import o from "ospec"
import {createUser, UserTypeRef} from "../../../../src/api/entities/sys/User"
import {createGroupMembership} from "../../../../src/api/entities/sys/GroupMembership"
import {DbTransaction} from "../../../../src/api/worker/search/DbFacade"
import {
    ENTITY_EVENT_BATCH_TTL_DAYS,
    GroupType,
    NOTHING_INDEXED_TIMESTAMP,
    OperationType,
} from "../../../../src/api/common/TutanotaConstants"
import {GroupDataOS, Indexer, Metadata, MetaDataOS} from "../../../../src/api/worker/search/Indexer"
import {createEntityEventBatch, EntityEventBatchTypeRef} from "../../../../src/api/entities/sys/EntityEventBatch"
import {NotAuthorizedError} from "../../../../src/api/common/error/RestError"
import {createEntityUpdate} from "../../../../src/api/entities/sys/EntityUpdate"
import {GroupInfoTypeRef} from "../../../../src/api/entities/sys/GroupInfo"
import {ContactTypeRef} from "../../../../src/api/entities/tutanota/Contact"
import {MailTypeRef} from "../../../../src/api/entities/tutanota/Mail"
import {OutOfSyncError} from "../../../../src/api/common/error/OutOfSyncError"
import {assertThrows, mock, spy} from "@tutao/tutanota-test-utils"
import {browserDataStub} from "../../TestUtils"
import type {QueuedBatch} from "../../../../src/api/worker/search/EventQueue"
import {EntityRestClient} from "../../../../src/api/worker/rest/EntityRestClient"
import {MembershipRemovedError} from "../../../../src/api/common/error/MembershipRemovedError"
import {WhitelabelChildTypeRef} from "../../../../src/api/entities/sys/WhitelabelChild"
import {
    GENERATED_MAX_ID,
    generatedIdToTimestamp,
    getElementId,
    timestampToGeneratedId,
} from "../../../../src/api/common/utils/EntityUtils"
import {daysToMillis, defer, downcast, TypeRef} from "@tutao/tutanota-utils"
import {
    aes128RandomKey,
    aes256Encrypt,
    aes256RandomKey,
    decrypt256Key,
    encrypt256Key,
    fixedIv,
    IV_BYTE_LENGTH,
    random,
} from "@tutao/tutanota-crypto"
const SERVER_TIME = new Date("1994-06-08").getTime()
const OUT_OF_DATE_SERVER_TIME = SERVER_TIME - daysToMillis(ENTITY_EVENT_BATCH_TTL_DAYS) - 1000 * 60 * 60 * 24
const restClientMock: EntityRestClient = downcast({
    getRestClient() {
        return {
            getServerTimestampMs() {
                return SERVER_TIME
            },
        }
    },
})
o.spec("Indexer test", () => {
    o("init new db", function (done) {
        let metadata = {}
        const expectedKeys = [Metadata.userEncDbKey, Metadata.lastEventIndexTimeMs]
        let transaction = {
            get: (os, key) => {
                o(os).equals(MetaDataOS)
                o(key).equals(expectedKeys.shift())
                return Promise.resolve(null)
            },
            getAll: os => {
                // So that we don't run into "no group ids' check
                return Promise.resolve([
                    {
                        key: "key",
                        value: "value",
                    },
                ])
            },
            put: (os, key, value) => {
                o(os).equals(MetaDataOS)
                metadata[key] = value
            },
            wait: () => Promise.resolve(),
        }
        let groupBatches = [
            {
                groupId: "user-group-id",
                groupData: {},
            },
        ]
        let persistentGroupData = [
            {
                persistentGroupData: "dummy",
            },
        ]
        const indexer = mock(
            new Indexer(
                restClientMock,
                {
                    sendIndexState: () => Promise.resolve(),
                } as any,
                browserDataStub,
                restClientMock,
            ),
            mock => {
                mock._loadGroupData = o.spy(() => Promise.resolve(groupBatches))
                mock._initGroupData = o.spy(batches => Promise.resolve())
                mock.db.dbFacade = {
                    open: o.spy(() => Promise.resolve()),
                    createTransaction: () => Promise.resolve(transaction),
                }
                mock._contact.indexFullContactList = o.spy(() => Promise.resolve())
                mock._groupInfo.indexAllUserAndTeamGroupInfosForAdmin = o.spy(() => Promise.resolve())
                mock._mail.indexMailboxes = o.spy(() => Promise.resolve())
                mock._whitelabelChildIndexer.indexAllWhitelabelChildrenForAdmin = o.spy(() => Promise.resolve())
                mock._loadPersistentGroupData = o.spy(() => Promise.resolve(persistentGroupData))
                mock._loadNewEntities = o.spy(async () => {})
            },
        )
        let user = createUser()
        user.userGroup = createGroupMembership()
        user.userGroup.group = "user-group-id"
        let userGroupKey = aes128RandomKey()
        indexer.init(user, userGroupKey).then(() => {
			// @ts-ignore
            o(indexer._loadGroupData.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._initGroupData.args[0]).deepEquals(groupBatches)
            o(metadata[Metadata.mailIndexingEnabled]).equals(false)
            o(decrypt256Key(userGroupKey, metadata[Metadata.userEncDbKey])).deepEquals(indexer.db.key)
	        // @ts-ignore
            o(indexer._contact.indexFullContactList.args).deepEquals([user.userGroup.group])
	        // @ts-ignore
            o(indexer._groupInfo.indexAllUserAndTeamGroupInfosForAdmin.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._whitelabelChildIndexer.indexAllWhitelabelChildrenForAdmin.callCount).equals(1)
	        // @ts-ignore
            o(indexer._mail.indexMailboxes.callCount).equals(1)
	        // @ts-ignore
            o(indexer._loadPersistentGroupData.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._loadNewEntities.args).deepEquals([persistentGroupData])
            done()
        })
    })
    o("init existing db", function (done) {
        let userGroupKey = aes128RandomKey()
        let dbKey = aes256RandomKey()
        let encDbIv = aes256Encrypt(dbKey, fixedIv, random.generateRandomData(IV_BYTE_LENGTH), true, false)
        let userEncDbKey = encrypt256Key(userGroupKey, dbKey)
        let transaction = {
            get: (os, key) => {
                if (os == MetaDataOS && key == Metadata.userEncDbKey) return Promise.resolve(userEncDbKey)
                if (os == MetaDataOS && key == Metadata.mailIndexingEnabled) return Promise.resolve(true)
                if (os == MetaDataOS && key == Metadata.excludedListIds) return Promise.resolve(["excluded-list-id"])
                if (os == MetaDataOS && key == Metadata.encDbIv) return Promise.resolve(encDbIv)
                return Promise.resolve(null)
            },
            getAll: os => {
                // So that we don't run into "no group ids' check
                return Promise.resolve([
                    {
                        key: "key",
                        value: "value",
                    },
                ])
            },
            wait: () => Promise.resolve(),
        }
        let persistentGroupData = [
            {
                persistentGroupData: "dummy",
            },
        ]
        let groupDiff = [
            {
                groupDiff: "dummy",
            },
        ]
        const indexer = mock(
            new Indexer(
                restClientMock,
                {
                    sendIndexState: () => Promise.resolve(),
                } as any,
                browserDataStub,
                restClientMock,
            ),
            mock => {
                mock.db.dbFacade = {
                    open: o.spy(() => Promise.resolve()),
                    createTransaction: () => Promise.resolve(transaction),
                }
                mock._loadGroupDiff = o.spy(() => Promise.resolve(groupDiff))
                mock._updateGroups = o.spy(() => Promise.resolve())
                mock._mail.updateCurrentIndexTimestamp = o.spy(() => Promise.resolve())
                mock._contact.indexFullContactList = o.spy(() => Promise.resolve())
                mock._contact.suggestionFacade.load = o.spy(() => Promise.resolve())
                mock._groupInfo.indexAllUserAndTeamGroupInfosForAdmin = o.spy(() => Promise.resolve())
                mock._groupInfo.suggestionFacade.load = o.spy(() => Promise.resolve())
                mock._whitelabelChildIndexer.suggestionFacade.load = o.spy(() => Promise.resolve())
                mock.indexAllWhitelabelChildrenForAdmin = o.spy(() => Promise.resolve())
                mock._loadPersistentGroupData = o.spy(() => Promise.resolve(persistentGroupData))
                mock._loadNewEntities = o.spy(async () => {})
            },
        )
        let user = createUser()
        user.userGroup = createGroupMembership()
        user.userGroup.group = "user-group-id"
        indexer.init(user, userGroupKey).then(() => {
            o(indexer.db.key).deepEquals(dbKey)
	        // @ts-ignore
            o(indexer._loadGroupDiff.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._updateGroups.args).deepEquals([user, groupDiff])
	        // @ts-ignore
            o(indexer._contact.indexFullContactList.args).deepEquals([user.userGroup.group])
	        // @ts-ignore
            o(indexer._groupInfo.indexAllUserAndTeamGroupInfosForAdmin.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._loadPersistentGroupData.args).deepEquals([user])
	        // @ts-ignore
            o(indexer._loadNewEntities.args).deepEquals([persistentGroupData])
	        // @ts-ignore
            o(indexer._contact.suggestionFacade.load.callCount).equals(1)
	        // @ts-ignore
            o(indexer._groupInfo.suggestionFacade.load.callCount).equals(1)
            done()
        })
    })
    o("init existing db out of sync", async () => {
        let userGroupKey = aes128RandomKey()
        let dbKey = aes256RandomKey()
        let userEncDbKey = encrypt256Key(userGroupKey, dbKey)
        let encDbIv = aes256Encrypt(dbKey, fixedIv, random.generateRandomData(IV_BYTE_LENGTH), true, false)
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.userEncDbKey) return userEncDbKey
                if (os == MetaDataOS && key == Metadata.mailIndexingEnabled) return true
                if (os == MetaDataOS && key == Metadata.excludedListIds) return ["excluded-list-id"]
                if (os == MetaDataOS && key == Metadata.encDbIv) return encDbIv
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            wait: () => Promise.resolve(),
            // So that we don't run into "no group ids' check
            getAll: () =>
                Promise.resolve([
                    {
                        key: "key",
                        value: "value",
                    },
                ]),
        }
        let groupDiff = [
            {
                groupDiff: "dummy",
            },
        ]
        let persistentGroupData = [
            {
                persistentGroupData: "dummy",
            },
        ]
        const indexer = mock(
            new Indexer(
                restClientMock,
                {
                    sendIndexState: () => Promise.resolve(),
                } as any,
                browserDataStub,
                restClientMock,
            ),
            mock => {
                mock.db.initialized = Promise.resolve()
                mock.db.dbFacade = {
                    open: o.spy(() => Promise.resolve()),
                    createTransaction: () => Promise.resolve(transaction),
                }
                mock._loadGroupDiff = o.spy(() => Promise.resolve(groupDiff))
                mock._updateGroups = o.spy(() => Promise.resolve())
                mock._mail.updateCurrentIndexTimestamp = o.spy(() => Promise.resolve())
                mock._contact.indexFullContactList = o.spy(() => Promise.resolve())
                mock._groupInfo.indexAllUserAndTeamGroupInfosForAdmin = o.spy(() => Promise.resolve())
                mock._loadPersistentGroupData = o.spy(() => Promise.resolve(persistentGroupData))
                mock._loadNewEntities = o.spy(() => Promise.reject(new OutOfSyncError("is out of sync ;-)")))
                mock.disableMailIndexing = o.spy()
            },
        )
        let user = createUser()
        user.userGroup = createGroupMembership()
        user.userGroup.group = "user-group-id"
        await indexer.init(user, userGroupKey)
        o(indexer.db.key).deepEquals(dbKey)
	    // @ts-ignore
        o(indexer._loadGroupDiff.args).deepEquals([user])
	    // @ts-ignore
        o(indexer._updateGroups.args).deepEquals([user, groupDiff])
	    // @ts-ignore
        o(indexer._contact.indexFullContactList.args).deepEquals([user.userGroup.group])
	    // @ts-ignore
        o(indexer._groupInfo.indexAllUserAndTeamGroupInfosForAdmin.args).deepEquals([user])
	    // @ts-ignore
        o(indexer._loadPersistentGroupData.args).deepEquals([user])
	    // @ts-ignore
        o(indexer._loadNewEntities.args).deepEquals([persistentGroupData])
    })
    o("_loadGroupDiff", function (done) {
        let user = createUser()
        user.memberships = [createGroupMembership(), createGroupMembership(), createGroupMembership()]
        user.memberships[0].groupType = GroupType.Mail
        user.memberships[0].group = "new-group-id"
        user.memberships[1].groupType = GroupType.Contact
        user.memberships[1].group = "constant-group-id"
        let deletedGroupId = "deleted-group-id"
        let groupData = {
            groupType: GroupType.MailingList,
        }
        let transaction = {
            getAll: os => {
                o(os).equals(GroupDataOS)
                return Promise.resolve([
                    {
                        key: deletedGroupId,
                        value: groupData,
                    },
                    {
                        key: user.memberships[1].group,
                        value: {},
                    },
                ])
            },
        }
        let indexer = new Indexer(restClientMock, null as any, browserDataStub, restClientMock)
        indexer.db.dbFacade = {
            createTransaction: () => Promise.resolve(transaction),
        } as any

        indexer._loadGroupDiff(user).then(result => {
            o(result).deepEquals({
                deletedGroups: [
                    {
                        id: "deleted-group-id",
                        type: GroupType.MailingList,
                    },
                ],
                newGroups: [
                    {
                        id: "new-group-id",
                        type: GroupType.Mail,
                    },
                ],
            })
            done()
        })
    })
    o("_updateGroups disable MailIndexing in case of a deleted mail group", async function () {
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.disableMailIndexing = o.spy(() => Promise.resolve())
        })
        let user = createUser()
        let groupDiff = {
            deletedGroups: [
                {
                    id: "groupId",
                    type: GroupType.Mail,
                },
            ],
            newGroups: [],
        }
        const e = await assertThrows(MembershipRemovedError, () => indexer._updateGroups(user, groupDiff))
    })
    o("_updateGroups disable MailIndexing in case of a deleted contact group", async function () {
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.disableMailIndexing = o.spy(() => Promise.resolve())
        })
        let user = createUser()
        let groupDiff = {
            deletedGroups: [
                {
                    id: "groupId",
                    type: GroupType.Contact,
                },
            ],
            newGroups: [],
        }
        const e = await assertThrows(MembershipRemovedError, () => indexer._updateGroups(user, groupDiff))
    })
    o("_updateGroups don't disable MailIndexing in case no mail or contact group has been deleted", function (done) {
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.disableMailIndexing = o.spy()
        })
        let user = createUser()
        let groupDiff = {
            deletedGroups: [
                {
                    id: "groupId",
                    type: GroupType.MailingList,
                },
            ],
            newGroups: [],
        }

        indexer._updateGroups(user, groupDiff).then(() => {
            done()
        })
    })
    o("_updateGroups do not index new mail groups", function (done) {
        let transaction = "transaction"
        let groupBatches = "groupBatches"
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._loadGroupData = o.spy(() => Promise.resolve(groupBatches))
            mock._initGroupData = o.spy(() => Promise.resolve())
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            } as any
            mock._mail.indexMailboxes = o.spy()
            mock._mail.currentIndexTimestamp = new Date().getTime()
        })
        let user = createUser()
        let groupDiff = {
            deletedGroups: [],
            newGroups: [
                {
                    id: "groupId",
                    type: GroupType.Mail,
                },
            ],
        }

        indexer._updateGroups(user, groupDiff).then(() => {
	        // @ts-ignore
            o(indexer._loadGroupData.callCount).equals(1)
	        // @ts-ignore
            o(indexer._loadGroupData.args[0]).equals(user)
	        // @ts-ignore
            o(indexer._initGroupData.callCount).equals(1)
	        // @ts-ignore
            o(indexer._initGroupData.args).deepEquals([groupBatches, transaction])
	        // @ts-ignore
            o(indexer._mail.indexMailboxes.callCount).equals(0)
            done()
        })
    })
    o("_updateGroups only init group data for non mail groups (do not index)", function (done) {
        let transaction = "transaction"
        let groupBatches = "groupBatches"
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._loadGroupData = o.spy(() => Promise.resolve(groupBatches))
            mock._initGroupData = o.spy(() => Promise.resolve())
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            } as any
            mock._mail.indexMailboxes = o.spy()
        })
        let user = createUser()
        let groupDiff = {
            deletedGroups: [],
            newGroups: [
                {
                    id: "groupId",
                    type: GroupType.Contact,
                },
            ],
        }

        indexer._updateGroups(user, groupDiff).then(() => {
	        // @ts-ignore
            o(indexer._loadGroupData.callCount).equals(1)
	        // @ts-ignore
            o(indexer._loadGroupData.args[0]).equals(user)
	        // @ts-ignore
            o(indexer._initGroupData.callCount).equals(1)
	        // @ts-ignore
            o(indexer._initGroupData.args).deepEquals([groupBatches, transaction])
	        // @ts-ignore
            o(indexer._mail.indexMailboxes.callCount).equals(0)
            done()
        })
    })
    o("_loadGroupData", function (done) {
        let user = createUser()
        user.memberships = [
            createGroupMembership(),
            createGroupMembership(),
            createGroupMembership(),
            createGroupMembership(),
        ]
        user.memberships[0].groupType = GroupType.Mail
        user.memberships[0].group = "group-mail"
        user.memberships[1].groupType = GroupType.MailingList
        user.memberships[1].group = "group-team"
        user.memberships[2].groupType = GroupType.Contact
        user.memberships[2].group = "group-contact"
        user.memberships[3].groupType = GroupType.Customer
        user.memberships[3].group = "group-customer"
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._entity = {
                loadRange: (type, listId, startId, count, reverse) => {
                    o(type).equals(EntityEventBatchTypeRef)
                    o(startId).equals(GENERATED_MAX_ID)
                    o(count).equals(1)
                    o(reverse).equals(true)
                    return Promise.resolve([
                        {
                            _id: [null, "event-batch-id"],
                        },
                    ])
                },
            }
        })

        indexer._loadGroupData(user).then(result => {
            o(result).deepEquals([
                {
                    groupId: "group-mail",
                    groupData: {
                        lastBatchIds: ["event-batch-id"],
                        indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
                        groupType: GroupType.Mail,
                    },
                },
                {
                    groupId: "group-contact",
                    groupData: {
                        lastBatchIds: ["event-batch-id"],
                        indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
                        groupType: GroupType.Contact,
                    },
                },
                {
                    groupId: "group-customer",
                    groupData: {
                        lastBatchIds: ["event-batch-id"],
                        indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
                        groupType: GroupType.Customer,
                    },
                },
            ])
            done()
        })
    })
    o("_loadGroupData not authorized", function (done) {
        let user = createUser()
        user.memberships = [createGroupMembership(), createGroupMembership()]
        user.memberships[0].groupType = GroupType.Mail
        user.memberships[0].group = "group-mail"
        user.memberships[1].groupType = GroupType.MailingList
        user.memberships[1].group = "group-team"
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            let count = 0
            mock._entity = {
                loadRange: (type, listId, startId, count, reverse) => {
                    if (count == 0) {
                        console.log("EEE")
                        count++
                        return Promise.reject(new NotAuthorizedError("test"))
                    } else {
                        return Promise.resolve([
                            {
                                _id: [null, "event-batch-id"],
                            },
                        ])
                    }
                },
            }
        })

        indexer._loadGroupData(user).then(result => {
            o(result).deepEquals([
                {
                    groupId: "group-mail",
                    groupData: {
                        lastBatchIds: ["event-batch-id"],
                        indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
                        groupType: GroupType.Mail,
                    },
                },
            ])
            done()
        })
    })
    o("_initGroupData", function (done) {
        let groupBatches = [
            {
                groupId: "groupId",
                groupData: {
                    groupType: GroupType.Mail,
                    lastBatchIds: [],
                    indexTimestamp: 1,
                },
            },
        ]
        let transaction: DbTransaction = downcast({
            put: (os, key, value) => {
                o(os).equals(GroupDataOS)
                o(key).equals(groupBatches[0].groupId)
                o(value).deepEquals(groupBatches[0].groupData)
                stored = true
                return Promise.resolve()
            },
            wait: () => Promise.resolve(),
        })
        let indexer = new Indexer(restClientMock, null as any, browserDataStub, restClientMock)
        let stored = false

        indexer._initGroupData(groupBatches, transaction).then(result => {
            o(stored).equals(true)
            done()
        })
    })
    o("_loadNewEntities", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        const groupId = "group-mail"
        let groupIdToEventBatches = [
            {
                groupId,
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch(), createEntityEventBatch()]
        batches[0]._id = ["group-mail", "L0JcCmw----1"] // bigger than last

        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        batches[1]._id = ["group-mail", oldestBatchId]
        batches[1].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
        })
        indexer._entity = {
            loadAll: (type, groupIdA, startId) => {
                o(type).deepEquals(EntityEventBatchTypeRef)
                o(groupIdA).equals(groupId)
                let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1)
                o(startId).equals(expectedStartId)
                return Promise.resolve(batches)
            },
        } as any
        downcast(indexer)._processEntityEvents = o.spy(() => Promise.resolve())
        const queue = indexer._core.queue
        downcast(queue).addBatches = spy()
        await indexer._loadNewEntities(groupIdToEventBatches)
        // two asserts, otherwise Node doesn't print deeply nested objects
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(1)
	    // @ts-ignore
        o(queue.addBatches.invocations[0]).deepEquals([
            [
                {
                    groupId,
                    batchId: getElementId(batches[0]),
                    events: batches[0].events,
                },
            ],
        ])
        o(transaction.put.args).deepEquals([MetaDataOS, Metadata.lastEventIndexTimeMs, SERVER_TIME])
    })
    o("load events and then receive latest again", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        const groupId = "group-mail"
        let groupIdToEventBatches = [
            {
                groupId,
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch(), createEntityEventBatch()]
        const loadedNewBatchId = "L0JcCmw----1"
        batches[0]._id = ["group-mail", loadedNewBatchId] // newer than oldest but older than newest

        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        batches[1]._id = ["group-mail", oldestBatchId]
        batches[1].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
        })
        indexer._entity = {
            loadAll: (type, groupIdA, startId) => Promise.resolve(batches),
        } as any
        downcast(indexer)._processEntityEvents = o.spy(() => Promise.resolve())
        const queue = indexer._core.queue
        downcast(queue).addBatches = spy()
        await indexer._loadNewEntities(groupIdToEventBatches)
        // Check that we actually added loaded batch
        // two asserts, otherwise Node doesn't print deeply nested objects
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(1)
	    // @ts-ignore
        o(queue.addBatches.invocations[0]).deepEquals([
            [
                {
                    groupId,
                    batchId: getElementId(batches[0]),
                    events: batches[0].events,
                },
            ],
        ])
        o(transaction.put.args).deepEquals([MetaDataOS, Metadata.lastEventIndexTimeMs, SERVER_TIME])
        // say we received the same batch via ws
        const realtimeEvents = [createEntityUpdate()]
        indexer.addBatchesToQueue([
            {
                groupId,
                events: realtimeEvents,
                batchId: loadedNewBatchId,
            },
        ])
        // Check that we filtered out batch which we already loaded and added
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(1)
    })
    o("load events and then receive older again", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        const groupId = "group-mail"
        let groupIdToEventBatches = [
            {
                groupId,
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch(), createEntityEventBatch()]
        const loadedNewBatchId = "L0JcCmy-----" // newer than newest

        batches[0]._id = ["group-mail", loadedNewBatchId]
        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        batches[1]._id = ["group-mail", oldestBatchId]
        batches[1].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
        })
        indexer._entity = {
            loadAll: (type, groupIdA, startId) => Promise.resolve(batches),
        } as any
        downcast(indexer)._processEntityEvents = o.spy(() => Promise.resolve())
        const queue = indexer._core.queue
        downcast(queue).addBatches = spy()
        await indexer._loadNewEntities(groupIdToEventBatches)
        // Check that we actually added loaded batch
        // two asserts, otherwise Node doesn't print deeply nested objects
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(1)
	    // @ts-ignore
        o(queue.addBatches.invocations[0]).deepEquals([
            [
                {
                    groupId,
                    batchId: getElementId(batches[0]),
                    events: batches[0].events,
                },
            ],
        ])
        o(transaction.put.args).deepEquals([MetaDataOS, Metadata.lastEventIndexTimeMs, SERVER_TIME])
        // say we received the older batch via ws
        indexer.addBatchesToQueue([
            {
                groupId,
                events: [],
                batchId: newestBatchId,
            },
        ])
        // Check that we filtered out batch which we already loaded and added
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(1)
    })
    o("receive realtime events before init finishes", async function () {
        const oldestBatchId = "L0JcCmw----0"
        const loadedNewBatchId = "L0JcCmw----1" // newer than oldest but older than realtime

        const realtimeBatchId = "L0JcCmx----0"
        const groupId = "group-mail"
        let groupIdToEventBatches = [
            {
                groupId,
                eventBatchIds: [oldestBatchId],
            },
        ]
        let loadedBatches = [
            createEntityEventBatch({
                _id: ["group-mail", loadedNewBatchId],
                events: [createEntityUpdate(), createEntityUpdate()],
            }),
            createEntityEventBatch({
                _id: ["group-mail", oldestBatchId],
            }),
        ]
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
        })
        const loadCompleted = defer()
        indexer._entity = {
            loadAll: (type, groupIdA, startId) => loadCompleted.promise,
        } as any
        downcast(indexer)._processEntityEvents = o.spy(() => Promise.resolve())
        const queue = indexer._core.queue
        downcast(queue).addBatches = spy()

        const loadPromise = indexer._loadNewEntities(groupIdToEventBatches)

        const realtimeUpdates = [
            createEntityUpdate({
                instanceId: "realtime",
            }),
        ]
        indexer.addBatchesToQueue([
            {
                groupId,
                events: realtimeUpdates,
                batchId: realtimeBatchId,
            },
        ])
        loadCompleted.resolve(loadedBatches)
        await loadPromise
        // Check that we filtered out batch which we already loaded and added
	    // @ts-ignore
        o(queue.addBatches.invocations.length).equals(2)
	    // @ts-ignore
        o(queue.addBatches.invocations[0]).deepEquals([
            [
                {
                    groupId,
                    batchId: getElementId(loadedBatches[0]),
                    events: loadedBatches[0].events,
                },
            ],
        ])
	    // @ts-ignore
        o(queue.addBatches.invocations[1]).deepEquals([
            [
                {
                    groupId,
                    batchId: realtimeBatchId,
                    events: realtimeUpdates,
                },
            ],
        ])
        o(transaction.put.args).deepEquals([MetaDataOS, Metadata.lastEventIndexTimeMs, SERVER_TIME])
    })
    o("_loadNewEntities batch already processed", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        let groupIdToEventBatches = [
            {
                groupId: "group-mail",
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch()]
        batches[0]._id = ["group-mail", oldestBatchId]
        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._entity = {
                loadAll: (type, groupId, startId) => {
                    o(type).deepEquals(EntityEventBatchTypeRef)
                    o(groupId).equals("group-mail")
                    let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1)
                    o(startId).equals(expectedStartId)
                    return Promise.resolve(batches)
                },
            }
            mock._processEntityEvents = o.spy()
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
            mock.db.initialized = Promise.resolve()
        })
        await indexer._loadNewEntities(groupIdToEventBatches)
	    // @ts-ignore
        o(indexer._processEntityEvents.callCount).equals(0)
        o(transaction.put.args).deepEquals([MetaDataOS, Metadata.lastEventIndexTimeMs, SERVER_TIME])
    })
    o("_loadNewEntities out of sync", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        let groupIdToEventBatches = [
            {
                groupId: "group-mail",
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch()]
        batches[0]._id = ["group-mail", "L0JcCmw----1"] // bigger than last

        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                return null
            },
            put: o.spy(async (os, key, value) => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._entity = {
                loadAll: (type, groupId, startId) => {
                    o(type).deepEquals(EntityEventBatchTypeRef)
                    o(groupId).equals("group-mail")
                    let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1)
                    o(startId).equals(expectedStartId)
                    return Promise.resolve(batches)
                },
            }
            mock._processEntityEvents = o.spy(() => Promise.resolve())
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
            mock.db.initialized = Promise.resolve()
        })
        await assertThrows(OutOfSyncError, () => indexer._loadNewEntities(groupIdToEventBatches))
	    // @ts-ignore
        o(indexer._processEntityEvents.callCount).equals(0)
        o(transaction.put.callCount).equals(0)
    })
    o("_loadNewEntities out of date", async function () {
        const newestBatchId = "L0JcCmx----0"
        const oldestBatchId = "L0JcCmw----0"
        let groupIdToEventBatches = [
            {
                groupId: "group-mail",
                eventBatchIds: [newestBatchId, oldestBatchId],
            },
        ]
        let batches = [createEntityEventBatch()]
        batches[0]._id = ["group-mail", "L0JcCmw----1"] // bigger than last

        batches[0].events = [createEntityUpdate(), createEntityUpdate()]
        let transaction = {
            get: async (os, key) => {
                if (os === MetaDataOS && key === Metadata.lastEventIndexTimeMs) return OUT_OF_DATE_SERVER_TIME
                return null
            },
            put: o.spy(async () => {}),
        }
        let indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock._processEntityEvents = o.spy(() => Promise.resolve())
            mock.db.dbFacade = {
                createTransaction: () => Promise.resolve(transaction),
            }
            mock.db.initialized = Promise.resolve()
        })
        await assertThrows(OutOfSyncError, () => indexer._loadNewEntities(groupIdToEventBatches))
	    // @ts-ignore
        o(indexer._processEntityEvents.callCount).equals(0)
        o(transaction.put.callCount).equals(0)
    })
    o("_loadPersistentGroupData", function (done) {
        let groupData = {
            lastBatchIds: ["last-batch-id"],
        }
        let transaction = {
            get: (os, groupId) => {
                o(os).equals(GroupDataOS)
                return Promise.resolve(groupData)
            },
        }
        let user = createUser()
        user.memberships = [
            createGroupMembership(),
            createGroupMembership(),
            createGroupMembership(),
            createGroupMembership(),
        ]
        user.memberships[0].groupType = GroupType.Mail
        user.memberships[0].group = "group-mail"
        user.memberships[1].groupType = GroupType.MailingList
        user.memberships[1].group = "group-team"
        user.memberships[2].groupType = GroupType.Contact
        user.memberships[2].group = "group-contact"
        user.memberships[3].groupType = GroupType.Customer
        user.memberships[3].group = "group-customer"
        let indexer = new Indexer(restClientMock, null as any, browserDataStub, restClientMock)
        indexer.db.dbFacade = {
            createTransaction: () => Promise.resolve(transaction),
        } as any

        indexer._loadPersistentGroupData(user).then(groupIdToEventBatches => {
            o(groupIdToEventBatches).deepEquals([
                {
                    groupId: "group-mail",
                    eventBatchIds: ["last-batch-id"],
                },
                {
                    groupId: "group-contact",
                    eventBatchIds: ["last-batch-id"],
                },
                {
                    groupId: "group-customer",
                    eventBatchIds: ["last-batch-id"],
                },
            ])
            done()
        })
    })
    o("_processEntityEvents_1", async function () {
        const groupId = "group-id"
        const batchId = "batch-id"
        let user = createUser()
        user.memberships = [createGroupMembership()]
        user.memberships[0].groupType = GroupType.Mail
        user.memberships[0].group = groupId
        const indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), indexerMock => {
            indexerMock.db.initialized = Promise.resolve()
            indexerMock._mail = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            indexerMock._contact = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            indexerMock._groupInfo = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            indexerMock._whitelabelChildIndexer = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            indexerMock._processUserEntityEvents = o.spy(() => Promise.resolve())
            indexerMock._initParams = {
                user: createUser(),
            }
            indexerMock._core.writeIndexUpdateWithBatchId = spy(() => Promise.resolve())
            indexerMock._initParams = {
                user,
            }
        })

        function newUpdate<T>(typeRef: TypeRef<T>) {
            let u = createEntityUpdate()
            u.application = typeRef.app
            u.type = typeRef.type
            return u
        }

        let events = [
            newUpdate(MailTypeRef),
            newUpdate(ContactTypeRef),
            newUpdate(GroupInfoTypeRef),
            newUpdate(UserTypeRef),
            newUpdate(WhitelabelChildTypeRef),
        ]
        indexer._indexedGroupIds = [groupId]
        const batch = {
            events,
            groupId,
            batchId,
        }
        await indexer._processEntityEvents(batch)
	    // @ts-ignore
        o(indexer._core.writeIndexUpdateWithBatchId.invocations.length).equals(4)
	    // @ts-ignore
        let indexUpdateMail = indexer._core.writeIndexUpdateWithBatchId.invocations[0][2]
	    // @ts-ignore
        o(indexer._mail.processEntityEvents.callCount).equals(1)
	    // @ts-ignore
        o(indexer._mail.processEntityEvents.args).deepEquals([[events[0]], groupId, batchId, indexUpdateMail])
	    // @ts-ignore
        let indexUpdateContact = indexer._core.writeIndexUpdateWithBatchId.invocations[1][2]
	    // @ts-ignore
        o(indexer._contact.processEntityEvents.callCount).equals(1)
	    // @ts-ignore
        o(indexer._contact.processEntityEvents.args).deepEquals([[events[1]], groupId, batchId, indexUpdateContact])
	    // @ts-ignore
        let indexUpdateGroupInfo = indexer._core.writeIndexUpdateWithBatchId.invocations[2][2]
	    // @ts-ignore
        o(indexer._groupInfo.processEntityEvents.callCount).equals(1)
	    // @ts-ignore
        o(indexer._groupInfo.processEntityEvents.args).deepEquals([
            [events[2]],
            groupId,
            batchId,
            indexUpdateGroupInfo,
            user,
        ])
        // no index update for user type
	    // @ts-ignore
        let indexUpdateWhitelabel = indexer._core.writeIndexUpdateWithBatchId.invocations[3][2]
	    // @ts-ignore
        o(indexer._whitelabelChildIndexer.processEntityEvents.callCount).equals(1)
	    // @ts-ignore
        o(indexer._whitelabelChildIndexer.processEntityEvents.args).deepEquals([
            [events[4]],
            groupId,
            batchId,
            indexUpdateWhitelabel,
            user,
        ])
    })
    o("processEntityEvents non indexed group", function (done) {
        let user = createUser()
        user.memberships = [createGroupMembership()]
        user.memberships[0].groupType = GroupType.MailingList
        user.memberships[0].group = "group-id"
        const indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock._mail = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._contact = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._groupInfo = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._processUserEntityEvents = o.spy(() => Promise.resolve())
            mock._initParams = {
                user: createUser(),
            }
            mock._core.writeIndexUpdate = o.spy(() => Promise.resolve())
            mock._initParams = {
                user,
            }
        })

        function update(typeRef: TypeRef<any>) {
            let u = createEntityUpdate()
            u.application = typeRef.app
            u.type = typeRef.type
            return u
        }

        let events = [update(MailTypeRef), update(ContactTypeRef), update(GroupInfoTypeRef), update(UserTypeRef)]
        const batch: QueuedBatch = {
            events,
            groupId: "group-id",
            batchId: "batch-id",
        }
        indexer._indexedGroupIds = ["group-id"]

        indexer._processEntityEvents(batch).then(() => {
	        // @ts-ignore
            o(indexer._core.writeIndexUpdate.callCount).equals(0)
	        // @ts-ignore
            o(indexer._mail.processEntityEvents.callCount).equals(0)
	        // @ts-ignore
            o(indexer._contact.processEntityEvents.callCount).equals(0)
	        // @ts-ignore
            o(indexer._groupInfo.processEntityEvents.callCount).equals(0)
	        // @ts-ignore
            o(indexer._processUserEntityEvents.callCount).equals(0)
            done()
        })
    })
    o("_processEntityEvents_2", async function () {
        const doneDeferred = defer()
        const indexer = mock(new Indexer(restClientMock, null as any, browserDataStub, restClientMock), mock => {
            mock.db.initialized = Promise.resolve()
            mock._mail = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._contact = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._groupInfo = {
                processEntityEvents: o.spy(() => Promise.resolve()),
            }
            mock._processUserEntityEvents = o.spy(() => Promise.resolve())
            mock._initParams = {
                user: createUser(),
            }
            mock._core.writeIndexUpdateWithBatchId = o.spy(() => Promise.resolve())
            let user = createUser()
            user.memberships = [createGroupMembership()]
            user.memberships[0].groupType = GroupType.Mail
            user.memberships[0].group = "group-id"
            mock._initParams = {
                user,
            }

            const _processNext = mock._core.queue._processNext.bind(mock._core.queue)

            mock._core.queue._processNext = spy(() => {
                if (mock._core.queue._eventQueue.length === 0) {
                    doneDeferred.resolve(null)
                }

                _processNext()
            })
        })
        const events1 = [
            createEntityUpdate({
                application: MailTypeRef.app,
                type: MailTypeRef.type,
                operation: OperationType.CREATE,
                instanceId: "id-1",
            }),
        ]
        indexer._indexedGroupIds = ["group-id"]
        const batch1: QueuedBatch = {
            events: events1,
            groupId: "group-id",
            batchId: "batch-id-1",
        }
        const events2 = [
            createEntityUpdate({
                application: MailTypeRef.app,
                type: MailTypeRef.type,
                operation: OperationType.CREATE,
                instanceId: "id-2",
            }),
        ]
        indexer._indexedGroupIds = ["group-id"]
        const batch2: QueuedBatch = {
            events: events2,
            groupId: "group-id",
            batchId: "batch-id-2",
        }
        indexer.addBatchesToQueue([batch1, batch2])

        indexer._realtimeEventQueue.resume()

        indexer.startProcessing()
        await doneDeferred.promise
	    // @ts-ignore
        o(indexer._core.writeIndexUpdateWithBatchId.callCount).equals(2)
	    // @ts-ignore
        o(indexer._mail.processEntityEvents.callCount).equals(2)
	    // @ts-ignore
        o(indexer._contact.processEntityEvents.callCount).equals(0)
	    // @ts-ignore
        o(indexer._groupInfo.processEntityEvents.callCount).equals(0)
    })
    o("_getStartIdForLoadingMissedEventBatches", function () {
        let indexer = new Indexer(restClientMock, null as any, browserDataStub, restClientMock)
        // one batch that is very young, so its id is returned minus 1 ms
        o(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1-----"])).equals("L0JcCm0-----") // - 1 ms

        // two batches that are very young, so the oldest id is returned minus 1 ms
        o(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm2-----", "L0JcCm1-----"])).equals("L0JcCm0-----") // - 1 ms

        // two batches of which the oldest is exactly one minute old, so the oldest id is returned minus 1 ms. this tests the inner limit
        let oneMinuteOld = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 1000 * 60)
        let oneMinuteOldMinusOneMS = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 1000 * 60 - 1) // - 1 ms

        o(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", oneMinuteOld])).equals(oneMinuteOldMinusOneMS)
        // two batches of which the oldest is exactly one minute and one ms old, so the newest id is returned minus 1 ms. this tests the outer limit
        let olderThanOneMinute = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 1000 * 60 - 1)
        let newestMinusOneMinute = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 1000 * 60)
        o(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", olderThanOneMinute])).equals(
            newestMinusOneMinute,
        )
        // two batches of which the oldest is very old, so the newest id is returned minus 1 ms.
        let veryOld = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 1000 * 60 * 10)
        o(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", veryOld])).equals(newestMinusOneMinute)
    })
})