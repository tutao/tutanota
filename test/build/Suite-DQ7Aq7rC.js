
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { __commonJS, __require, __toESM } from "./chunk-D_5_n1c4.js";
import { mithril_default } from "./mithril-Csg4iNnm.js";
import { DAY_IN_MILLIS, LazyLoaded, PromisableWrapper, TypeRef, arrayEquals, arrayOf, assertNotNull, base64ExtToBase64, base64ToUint8Array, byteArraysToBytes, byteLength, bytesToByteArrays, clamp, clone, concat, daysToMillis, debounceStart, deepEqual, defer, deferWithHandler, delay, difference, downcast, findAllAndRemove, freshVersioned, getDayShifted, getFromMap, getStartOfDay, getStartOfNextDay, groupBy, hexToUint8Array, identity, incrementDate, isSameTypeRef, last, lastThrow, lazyMemoized, neverNull, noOp, numberRange, ofClass, pMap, pad, remove, splitInChunks, stringToUtf8Uint8Array, uint8ArrayToBase64, uint8ArrayToHex, utf8Uint8ArrayToString } from "./dist-CJHwsXKY.js";
import { TutanotaError } from "./dist-Rk9U8Iqn.js";
import { ProgrammingError } from "./ProgrammingError-D8yJGVtm.js";
import { Mode, assertMainOrNode, isApp } from "./Env-D5xGlXfw.js";
import "./WhitelabelCustomizations-D1L5qbZi.js";
import { LanguageNames, getAvailableLanguageCode, getSubstitutedLanguageCode, lang, languageCodeToTag, languages } from "./LanguageViewModel-BNC5ekpO.js";
import { AlphaEnum, Animation, DefaultAnimationTime, TransformEnum, alpha, animations, ease, hexToHSL, hexToRgb, hslToHex, hslToRGB, isColorLight, isValidColorCode, normalizeHueAngle, rgbToHSL, rgbToHex, themes, transform, tutaDunkel, tutaRed } from "./HtmlUtils-C-ecR7U7.js";
import { AppType, BrowserType, DeviceType, client } from "./ClientDetector-D0v6Vqu6.js";
import { AccountType, ArchiveDataType, BlobAccessTokenKind, BucketPermissionType, CalendarAttendeeStatus, CalendarMethod, Const, ContactAddressType, ContactComparisonResult, ContactPhoneNumberType, ContactSocialType, ContactWebsiteType, ConversationType, CounterType, CryptoProtocolVersion, CustomDomainCheckResult, DEFAULT_KDF_TYPE, DnsRecordType, DnsRecordValidation, ENTITY_EVENT_BATCH_TTL_DAYS, EmailSignatureType, EncryptionAuthStatus, EndType, ExternalImageRule, FULL_INDEXED_TIMESTAMP, FeatureType, GroupKeyRotationType, GroupType, InboxRuleType, IndifferentContactComparisonResult, KdfType, MAX_BLOB_SIZE_BYTES, MailAuthenticationStatus, MailMethod, MailSetKind, MailState, NOTHING_INDEXED_TIMESTAMP, NewPaidPlans, OperationType, PermissionType, PlanType, PublicKeyIdentifierType, RepeatPeriod, ReportedMailFieldType, SecondFactorType, ShareCapability, asCryptoProtoocolVersion } from "./TutanotaConstants-3bwAESYA.js";
import "./Icon-BuqNK7vz.js";
import { Icons } from "./Icons-Dl3nFav5.js";
import "./KeyManager-B0OGXEyJ.js";
import "./WindowFacade-B9kSBKw7.js";
import "./Modal-g4c-b9IU.js";
import { Dialog, DialogType, getConfirmation, showDropdownAtPosition } from "./Dialog-B6-HFvZd.js";
import "./CountryList-DkVQtcTj.js";
import "./IconButton-DsU60HJ_.js";
import { AccessBlockedError, AccessDeactivatedError, AccessExpiredError, BadGatewayError, BadRequestError, ConnectionError, InternalServerError, InvalidDataError, InvalidSoftwareVersionError, LimitReachedError, LockedError, MethodNotAllowedError, NotAuthenticatedError, NotAuthorizedError, NotFoundError, PayloadTooLargeError, PreconditionFailedError, ResourceError, SessionExpiredError, TooManyRequestsError, handleRestError } from "./RestError-D17JEBMr.js";
import { SuspensionError } from "./SuspensionError-okvIjE4H.js";
import { LoginIncompleteError } from "./LoginIncompleteError-CpiW0a0l.js";
import { CryptoError } from "./CryptoError-PqdvQky4.js";
import "./error-DDmy0eAT.js";
import { CredentialAuthenticationError, SessionKeyNotFoundError, hasError } from "./ErrorUtils-o1-v67Dd.js";
import { RecipientsNotFoundError } from "./RecipientsNotFoundError-D8oGE7A_.js";
import "./OfflineDbClosedError-CAwHTI6J.js";
import { OutOfSyncError } from "./OutOfSyncError-Ck2yBBO8.js";
import "./DbError-CcwZaPG2.js";
import "./QuotaExceededError-nFM6SdTn.js";
import { CancelledError } from "./CancelledError-FjP5S_cR.js";
import "./FileOpenError-C1_8yoXr.js";
import "./DeviceStorageUnavailableError-m4Jk_0xN.js";
import "./MailBodyTooLargeError-C2i0rX_0.js";
import { ImportError } from "./ImportError-CIXw37Kv.js";
import "./PermissionError-BGDsHuAh.js";
import { KeyPermanentlyInvalidatedError } from "./KeyPermanentlyInvalidatedError-DJjt81rl.js";
import { ParserError, StringIterator, combineParsers, makeCharacterParser, makeEitherParser, makeNotOneOfCharactersParser, makeOneOrMoreParser, makeSeparatedByParser, makeZeroOrMoreParser, mapParser } from "./ParserCombinator-D38ofgFx.js";
import { ExportError, ExportErrorReason } from "./ExportError-DzgStBnl.js";
import { require_stream } from "./stream-u2PttBAC.js";
import { DateTime, Duration } from "./luxon-D6cgmg6Q.js";
import { CalendarEventWhenModel, Time, getDefaultEndCountValue } from "./CalendarEventWhenModel-DEedSoEH.js";
import { CUSTOM_MAX_ID, CUSTOM_MIN_ID, Cardinality, GENERATED_MAX_ID, GENERATED_MIN_ID, LEGACY_BCC_RECIPIENTS_ID, LEGACY_BODY_ID, LEGACY_CC_RECIPIENTS_ID, LEGACY_TO_RECIPIENTS_ID, LOAD_MULTIPLE_LIMIT, Type, ValueType, compareNewestFirst, compareOldestFirst, constructMailSetEntryId, create, deconstructMailSetEntryId, elementIdPart, firstBiggerThanSecond, generatedIdToTimestamp, getElementId, getEtId, getLetId, getListId, isSameId, listIdPart, removeTechnicalFields, sortCompareById, stringToCustomId, timestampToGeneratedId, timestampToHexGeneratedId } from "./EntityUtils-RQxXZlcV.js";
import { createEventElementId, findAttendeeInAddresses, generateEventElementId, getAllDayDateUTC, getEventWithDefaultTimes, isAllDayEvent, serializeAlarmInterval } from "./CommonCalendarUtils-DKaO7v1K.js";
import { formatDate, timeStringFromParts } from "./Formatter-zB15D6XI.js";
import { typeModels$3 as typeModels } from "./TypeModels-XIXYys8J.js";
import { BirthdayTypeRef, BodyTypeRef, CalendarEventAttendeeTypeRef, CalendarEventTypeRef, CalendarEventUpdateTypeRef, CalendarGroupRootTypeRef, CalendarRepeatRuleTypeRef, ContactAddressTypeRef, ContactListTypeRef, ContactMailAddressTypeRef, ContactPhoneNumberTypeRef, ContactSocialIdTypeRef, ContactTypeRef, ContactWebsiteTypeRef, ConversationEntryTypeRef, CustomerAccountCreateDataTypeRef, EmailTemplateContentTypeRef, EmailTemplateTypeRef, EncryptedMailAddressTypeRef, FileTypeRef, HeaderTypeRef, InboxRuleTypeRef, InternalRecipientKeyDataTypeRef, KnowledgeBaseEntryKeywordTypeRef, KnowledgeBaseEntryTypeRef, MailAddressPropertiesTypeRef, MailAddressTypeRef, MailBagTypeRef, MailBoxTypeRef, MailDetailsBlobTypeRef, MailDetailsTypeRef, MailFolderRefTypeRef, MailFolderTypeRef, MailSetEntryTypeRef, MailTypeRef, MailboxGroupRootTypeRef, MailboxPropertiesTypeRef, NewsIdTypeRef, NewsInTypeRef, NewsOutTypeRef, NotificationMailTypeRef, OutOfOfficeNotificationTypeRef, RecipientsTypeRef, ReportedMailFieldMarkerTypeRef, SecureExternalRecipientKeyDataTypeRef, SendDraftDataTypeRef, SymEncInternalRecipientKeyDataTypeRef, TemplateGroupRootTypeRef, TutanotaPropertiesTypeRef, UserSettingsGroupRootTypeRef, createCalendarRepeatRule, createContact, createMail, createMailAddress, createMailExportTokenServicePostOut, createMailSetEntry } from "./TypeRefs-CR3TLWn0.js";
import "./TypeModels-BktRFNDN.js";
import { AdminGroupKeyAuthenticationDataTypeRef, AdministratedGroupTypeRef, AdministratedGroupsRefTypeRef, AlarmInfoTypeRef, AlarmServicePostTypeRef, BlobReferenceTokenWrapperTypeRef, BlobTypeRef, BucketKeyTypeRef, BucketPermissionTypeRef, BucketTypeRef, CalendarEventRefTypeRef, ChallengeTypeRef, CreateSessionReturnTypeRef, CustomerAccountTerminationRequestTypeRef, CustomerInfoTypeRef, CustomerPropertiesTypeRef, CustomerServerPropertiesTypeRef, CustomerTypeRef, DateWrapperTypeRef, DnsRecordTypeRef, DomainInfoTypeRef, EntityEventBatchTypeRef, EntityUpdateTypeRef, ExternalUserReferenceTypeRef, GiftCardCreateDataTypeRef, GroupInfoTypeRef, GroupKeyRotationInfoGetOutTypeRef, GroupKeyTypeRef, GroupKeyUpdateTypeRef, GroupKeyUpdatesRefTypeRef, GroupKeysRefTypeRef, GroupMemberTypeRef, GroupMembershipTypeRef, GroupRootTypeRef, GroupTypeRef, InstanceSessionKeyTypeRef, InvoiceDataGetOutTypeRef, InvoiceDataItemTypeRef, KeyPairTypeRef, KeyRotationTypeRef, KeyRotationsRefTypeRef, MailAddressAliasTypeRef, MailAddressToGroupTypeRef, PermissionTypeRef, PlanConfigurationTypeRef, PlanPricesTypeRef, PubEncKeyDataTypeRef, PublicKeyGetOutTypeRef, PushIdentifierListTypeRef, PushIdentifierTypeRef, RepeatRuleTypeRef, RootInstanceTypeRef, SaltDataTypeRef, SaltReturnTypeRef, SentGroupInvitationTypeRef, TypeInfoTypeRef, U2fChallengeTypeRef, U2fKeyTypeRef, UserAlarmInfoListTypeTypeRef, UserAlarmInfoTypeRef, UserAuthenticationTypeRef, UserExternalAuthInfoTypeRef, UserGroupKeyDistributionTypeRef, UserGroupRootTypeRef, UserTypeRef, WebsocketCounterDataTypeRef, WebsocketCounterValueTypeRef, WebsocketEntityDataTypeRef, WebsocketLeaderStatusTypeRef, WhitelabelConfigTypeRef, createBucket, createBucketKey, createBucketPermission, createCustomDomainCheckGetIn, createGroup, createInstanceSessionKey, createKeyPair, createPermission, createPublicKeyGetIn, createPublicKeyGetOut, createSaltReturn, createSecondFactor, createTypeInfo } from "./TypeRefs-BP1jvX9p.js";
import { AlarmIntervalUnit, CalendarEventValidity, DefaultDateProvider, StandardAlarmInterval, addDaysForEventInstance, addDaysForRecurringEvent, areExcludedDatesEqual, areRepeatRulesEqual, calendarEventHasMoreThanOneOccurrencesLeft, checkEventValidity, createRepeatRuleWithValues, eventEndsBefore, eventStartsAfter, findNextAlarmOccurrence, getAllDayDateForTimezone, getAllDayDateUTCFromZone, getDiffIn24hIntervals, getDiffIn60mIntervals, getMonthRange, getStartOfDayWithZone, getStartOfNextDayWithZone, getStartOfWeek, getTimeZone, getWeekNumber, incrementByRepeatPeriod, isEventBetweenDays, parseAlarmInterval, prepareCalendarDescription } from "./CalendarUtils-C6jeYrj9.js";
import { NoopProgressMonitor, ProgressMonitor } from "./ProgressMonitor-HBfOF56H.js";
import "./Notifications-DLibQbV7.js";
import { HttpMethod, MediaType, ModelInfo_default as ModelInfo_default$1, ModelInfo_default$1 as ModelInfo_default, _verifyType, resolveTypeReference } from "./EntityFunctions-l6CncM5C.js";
import "./TypeModels-ZqCk-pGw.js";
import { ModelInfo_default$2 } from "./ModelInfo-DEa-Yxv2.js";
import { EntityClient } from "./EntityClient-B0RSdk2i.js";
import { SetupMultipleError } from "./SetupMultipleError-B6uY8P-x.js";
import { ENABLE_MAC, IV_BYTE_LENGTH, KEY_LENGTH_BYTES_AES_256, KeyLength, KeyPairType, TotpVerifier, aes256RandomKey, aesDecrypt, aesEncrypt, bitArrayToUint8Array, bytesToKyberPrivateKey, bytesToKyberPublicKey, createAuthVerifier, decapsulate, decryptKey, eccDecapsulate, eccEncapsulate, encapsulate, encryptEccKey, encryptKey, encryptRsaKey, fixedIv, generateEccKeyPair, generateIV, generateKeyFromPassphrase, generateKeyFromPassphrase$1, hexToRsaPrivateKey, hexToRsaPublicKey, hkdf, keyToBase64, kyberPrivateKeyToBytes, kyberPublicKeyToBytes, pqKeyPairsToPublicKeys, random, rsaDecrypt, rsaEncrypt, rsaPrivateKeyToHex, rsaPublicKeyToHex, sha256Hash, uint8ArrayToBitArray, unauthenticatedAesDecrypt } from "./dist-DcZ1Y4qd.js";
import { AdminGroupKeyRotationService, ChangeKdfService, CustomDomainCheckService, GroupKeyRotationInfoService, GroupKeyRotationService, LocalAdminRemovalService, PublicKeyService, SaltService, SessionService, UpdatePermissionKeyService, UpdateSessionKeysService, UpgradePriceService, UserGroupKeyRotationService } from "./Services-CZFE0084.js";
import { MailExportTokenService, NewsService } from "./Services-DCx-CeM7.js";
import { CalendarFacade, sortByRecurrenceId } from "./CalendarFacade-CaovxyFN.js";
import { CalendarModel } from "./CalendarModel-DK762b35.js";
import { containsEventOfType } from "./EntityUpdateUtils-B5iTKMk4.js";
import { hasCapabilityOnGroup } from "./GroupUtils-CpT2lvVS.js";
import { initCommonLocator, locator$1 as locator } from "./CommonLocator-Csg4iNnm.js";
import { EventImportRejectionReason, parseCalendarEvents, parseCalendarStringData, parseDuration, parseExDates, parseICalendar, parseProperty, parsePropertyKeyValue, parseRecurrenceId, parseTime, parseUntilRruleTime, propertySequenceParser, sortOutParsedEvents, triggerToAlarmInterval } from "./ImportExportUtils-B1MoOmZ0.js";
import { isDomainName, isMailAddress, isRegularExpression, isValidCreditCardNumber } from "./FormatValidator-2BBermUe.js";
import { UserError } from "./UserError-DfXlMLTl.js";
import { fullNameToFirstAndLastName, getCleanedMailAddress, mailAddressToFirstAndLastName, parseMailtoUrl, stringToNameAndMailAddress } from "./MailAddressParser-BgYy6oyp.js";
import "./GroupUtils-0ZkLIAeC.js";
import { createDataFile } from "./DataFile-CY7uuk9j.js";
import { deduplicateFilenames, sanitizeFilename } from "./FileUtils-W-u2-gZz.js";
import "./ProgressDialog-CJfJjh62.js";
import { createReferencingInstance } from "./BlobUtils-D5ADcckZ.js";
import { LINE_BREAK, RecipientField, createNewContact, isTutaMailAddress } from "./SharedMailUtils-AmFaSJP6.js";
import { _BAD_SEQUENCES, _getNbrOfSequenceChars, getPasswordStrength, isSecurePassword, scaleToVisualPasswordStrength } from "./PasswordUtils-C4jlV9GF.js";
import { RecipientType } from "./Recipient-BFxhfecW.js";
import { ParsingError, birthdayToIsoDate, isoDateToBirthday } from "./BirthdayUtils-BcCMglSq.js";
import { extractStructuredAddresses, extractStructuredMailAddresses, extractStructuredPhoneNumbers, formatBirthdayNumeric, getContactDisplayName } from "./ContactUtils-Bbon2oOk.js";
import { RecipientsModel, ResolveMode } from "./RecipientsModel-DxwXuUvL.js";
import { CalendarEventAlarmModel, CalendarEventWhoModel, CalendarOperation, EventSaveResult, EventType, eventHasChanged, getCalendarMonth, getDateFromMousePos, getEventType, getTimeFromMousePos, hasPlanWithInvites, makeCalendarEventModel } from "./CalendarGuiUtils-CkzhFM1K.js";
import { UpgradeRequiredError } from "./UpgradeRequiredError-CbZr7beN.js";
import "./ColorPickerModel-C1q3CWkL.js";
import "./BannerButton-BeplPQdI.js";
import "./SubscriptionDialogs-DAlWs68I.js";
import "./ExternalLink-rsCBSC7U.js";
import "./EventPreviewView-8_o5U-Qy.js";
import "./ToggleButton-DxuDa0rS.js";
import "./MailRecipientsTextField-BmI2qlpf.js";
import "./ColumnEmptyMessageBox-TSIJJX7z.js";
import { _getNumDaysInMonth, parseBirthday, parseDate } from "./DateParser-DIjdXKhX.js";
import "./ErrorHandler-DbW1lJbv.js";
import "./SnackBar-CoP3lSVs.js";
import { credentialsToUnencrypted } from "./Credentials-BM35X_na.js";
import "./NotificationOverlay-C-YNCUiT.js";
import "./Checkbox-WCw-l_7A.js";
import "./Expander-Bautb1_0.js";
import "./ClipboardUtils-mz40UK5S.js";
import { LOG_SIZE, Logger } from "./ErrorReporter-7sfLhWZg.js";
import { CounterValueTypeRef } from "./Services-CupYet_j.js";
import "./BubbleButton-DGGInJMg.js";
import { SessionType } from "./SessionType-rxSDsswH.js";
import "./PasswordField-CPKPoLq8.js";
import "./PasswordRequestDialog-B7ZIVTVw.js";
import "./ErrorHandlerImpl-DRpk8tE9.js";
import { DeviceConfig, ListAutoSelectBehavior, migrateConfigV2to3 } from "./DeviceConfig-payZM407.js";
import { RatingCheckResult, getRatingAllowed, isEventHappyMoment } from "./InAppRatingUtils-DwsFPPTC.js";
import { ListLoadingState, PageSize } from "./List-CdKNFQkI.js";
import "./SelectableRowContainer-CWm9GtOE.js";
import "./CalendarRow-DM7ryi94.js";
import { formatDateTimeUTC, serializeCalendar, serializeEvent, serializeExcludedDates, serializeRepeatRule, serializeTrigger } from "./CalendarExporter-BXenr-zb.js";
import "./CalendarImporter-DjgWaF1e.js";
import "./CustomerUtils-DmaZpb7Y.js";
import { CalendarInviteHandler, ReplyResult } from "./CalendarInvites-BycZJjjH.js";
import { CalendarNotificationSender } from "./CalendarNotificationSender-DBd9Ir3y.js";
import { CalendarViewModel } from "./CalendarViewModel-BxGaLvge.js";
import "./UserUtils-C4O25CeW.js";
import { EntityModificationType, EventQueue, batchMod } from "./EventQueue-c-5UmjJa.js";
import { CacheMode, ConnectMode, CustomCalendarEventCacheHandler, DefaultEntityRestCache, EXTEND_RANGE_MIN_CHUNK_SIZE, EntityRestClient, EventBusClient, OfflineStorage, WsConnectionState, customTypeDecoders, customTypeEncoders, decode, doBlobRequestWithRetry, encode, expandId, getIds, tryServers, typeRefToPath } from "./EntityRestClient--6dT7ZRF.js";
import "./MessageDispatcher-wJwFhXWv.js";
import "./SqlValue-CkGu32Qd.js";
import "./Sql-C9YhYNym.js";
import { urlify } from "./Urlifier-0Ec01nef.js";
import { RestClient, SuspensionBehavior } from "./RestClient-CmoHrId4.js";
import { BlobAccessTokenPostInTypeRef, BlobAccessTokenPostOutTypeRef, BlobAccessTokenService, BlobPostOutTypeRef, BlobReadDataTypeRef, BlobServerAccessInfoTypeRef, BlobServerUrlTypeRef, BlobWriteDataTypeRef, InstanceIdTypeRef } from "./Services-CtomUk-n.js";
import { encryptString } from "./CryptoWrapper-BTtEczdP.js";
import { BLOB_SERVICE_REST_PATH, BlobFacade, parseMultipleBlobsResponse } from "./BlobFacade-CJHwsXKY.js";
import { DbFacade, osName } from "./DbFacade-DYw6Nyfw.js";
import { ElementDataOS, GroupDataOS, MetaDataOS, Metadata, SearchIndexMetaDataOS, SearchIndexOS, SearchIndexWordsIndex, SearchTermSuggestionsOS } from "./IndexTables-C5S9WDY9.js";
import { ConfigurationDatabase, ConfigurationMetaDataOS, encryptItem, initializeDb, loadEncryptionMetadata, updateEncryptionMetadata } from "./ConfigurationDatabase-ClkJ3kmL.js";
import { ContactFacade } from "./ContactFacade-DvgVw5Lx.js";
import { formatNameAndAddress } from "./CommonFormatter-DiwVeRKZ.js";
import { GroupManagementFacade } from "./GroupManagementFacade-Dn8D-o9X.js";
import { MailAddressFacade } from "./MailAddressFacade-BOUAh3KL.js";
import { MAIL_EXPORT_TOKEN_HEADER, MailExportFacade } from "./MailExportFacade-BBIyF2WZ.js";
import { MailExportTokenFacade } from "./MailExportTokenFacade-KBHxS9-u.js";
import { _createNewIndexUpdate, appendBinaryBlocks, calculateNeededSpace, decodeBinaryBlock, decryptIndexKey, decryptMetaData, decryptSearchIndexEntry, encodeBinaryBlock, encodeNumberBlock, encryptIndexKeyBase64, encryptIndexKeyUint8Array, encryptMetaData, encryptSearchIndexEntry, filterIndexMemberships, filterMailMemberships, getIdFromEncSearchIndexEntry, htmlToText, iterateBinaryBlocks, numberOfBytes, removeBinaryBlockRanges, typeRefToTypeInfo, userIsGlobalAdmin } from "./IndexUtils-K27esrGs.js";
import { compress, uncompress } from "./Compression-CvN1IyGQ.js";
import { MailFacade, phishingMarkerValue, validateMimeTypesForAttachments } from "./MailFacade-Dv71IuiQ.js";
import { Deflater, PDF_DEFAULT_OBJECTS, PdfStreamEncoding } from "./Deflater-VR1UiLhC.js";
import { PdfInvoiceGenerator, areStringPartsOneByteLength } from "./PdfInvoiceGenerator-DretJohb.js";
import { InvoiceItemType, InvoiceType, PaymentMethod, VatType } from "./InvoiceUtils-3xBqh6rg.js";
import { XRechnungInvoiceGenerator, extractCityName, extractPostalCode } from "./XRechnungInvoiceGenerator-r5maK2cT.js";
import { PdfObject, PdfStreamObject, PdfWriter } from "./PdfWriter-D8FBjFbc.js";
import { AlarmScheduler } from "./AlarmScheduler-C-yXsv_f.js";
import { PREVENT_EXTERNAL_IMAGE_LOADING_ICON, htmlSanitizer } from "./HtmlSanitizer-CA1YjlPp.js";
import { CredentialEncryptionMode } from "./CredentialEncryptionMode-BR0DkQpJ.js";
import { DisplayMode, LoginState, LoginViewModel } from "./LoginViewModel-BX-8ry63.js";
import "./LoginButton-DzCRy0Yt.js";
import { formatActivateState, isNotificationCurrentlyActive, reminderCutoffDate, shouldShowUpgradeReminder } from "./PostLoginUtils-D4m5U8Kf.js";
import { CredentialType } from "./CredentialType-DXeA2MQH.js";
import { CredentialsProvider } from "./CredentialsProvider-HbB_U0ec.js";
import { ASSIGNMENT_UPDATE_INTERVAL_MS, EphemeralUsageTestStorage, Stage, StorageBehavior, UsageTest, UsageTestAssignmentInTypeRef, UsageTestAssignmentOutTypeRef, UsageTestAssignmentService, UsageTestAssignmentTypeRef, UsageTestModel, UsageTestParticipationInTypeRef, UsageTestParticipationService, createUsageTestMetricData } from "./UsageTestModel-CjGx3RZo.js";
import { BYTE_RANGE, PasswordGenerator, PasswordModel } from "./PasswordForm-f7LrLbA9.js";
import "./MoreInfoLink-CySwGi3Q.js";
import "./inlineImagesUtils-BekMwI7k.js";
import { SendMailModel, TOO_MANY_VISIBLE_RECIPIENTS } from "./SendMailModel-C8sfTf0o.js";
import { getDisplayedSender } from "./CommonMailUtils-DNufl6ib.js";
import { ReferralLinkNews } from "./ReferralLinkNews-DmxdtaMg.js";
import "./PermissionType-Bwii3hCe.js";
import { NativeFileApp } from "./ExportFacadeSendDispatcher-B0ubUu3N.js";
import { InterWindowEventFacadeSendDispatcher } from "./InterWindowEventFacadeSendDispatcher-BTmViZah.js";
import "./AttachmentBubble-CloIefNF.js";
import "./RouteChange-im6yOAT2.js";
import { createWizardDialog } from "./WizardDialog-DYBfLN1U.js";
import "./SearchUtils-Cu31OiTT.js";
import { getAvailableMatchingPlans } from "./SubscriptionUtils-D0qLWHbE.js";
import "./MailAddressesUtils-yYLKhrr9.js";
import { MailAddressTableModel } from "./MailAddressTableModel-DGB9dbCy.js";
import { PaymentInterval, PriceAndConfigProvider, UpgradePriceType, asPaymentInterval, formatMonthlyPrice } from "./PriceUtils-DA-dFW8L.js";
import { CardType, SimplifiedCreditCardViewModel, getCardTypeRange, inferExpirationDate, parseCaptchaInput } from "./Captcha-BgtCMZz1.js";
import { EntropyCollector, EventController, FileControllerBrowser, FileControllerNative, LoginController, MailModel, MailboxModel, NewsModel, SecondFactorHandler, ThemeController, WebauthnClient, _findMatchingRule, _matchesRegularExpression, routeMatchesPrefix, validateWebauthnDisplayName } from "./mailLocator-CrvEYt1k.js";
import "./PageContextLoginListener-dgY8O-YX.js";
import { NoZoneDateProvider, SET_TIMEOUT_LIMIT, SchedulerImpl } from "./Scheduler-B2H65_EO.js";
import "./MailUtils-ChhZAFAd.js";
import { FolderSystem } from "./FolderSystem-DLrUB8MO.js";
import "./MailChecks-PhVUoR7f.js";
import { require_qrcode } from "./qrcode-C0eFPi61.js";
import { _findMatches, _search, search, searchInTemplates } from "./TemplatePopupModel-Bv3eIGgN.js";
import { FaqModel } from "./FaqModel-BKSlOY96.js";
import { MailViewerViewModel, downloadMailBundle, getConfidentialIcon, isSystemNotification, isTutanotaTeamAddress, isTutanotaTeamMail, makeMailBundle } from "./MailViewerViewModel-D_nVDgz3.js";
import { appendEmailSignature, prependEmailSignature } from "./Signature-nc-d4UDo.js";
import { knowledgeBaseSearch } from "./KnowledgeBaseSearchFilter-D7VhMtlv.js";
import { _formatSmtpDateTime, mailToEml } from "./emlUtils-afBEUvhM.js";
import "./LoadingState-DqrMrOAm.js";
import { compareContacts } from "./ContactGuiUtils-BOj2qfyh.js";
import { vCardFileToVCards, vCardListToContacts } from "./VCardImporter-D9iigKrh.js";
import { ListModel } from "./ListModel-jYF3dysm.js";
import { ListElementListModel } from "./ListElementListModel-DYHUNydL.js";
import { ContactListEditorModel, _addressesToVCardAddresses, _areResidualContactFieldsEqual, _compareBirthdays, _compareContactsForMerge, _compareFullName, _compareMailAddresses, _comparePhoneNumbers, _contactToVCard, _getMergedAddresses, _getMergedEmailAddresses, _getMergedNameField, _getMergedOtherField, _getMergedPhoneNumbers, _getMergedSocialIds, _phoneNumbersToVCardPhoneNumbers, _socialIdsToVCardSocialUrls, _vCardFormatArrayToString, contactsToVCard, getMergeableContacts, mergeContacts } from "./ContactListEditor-5LX_1ENd.js";
import { ConversationViewModel } from "./ConversationViewModel-B29QLX0-.js";
import { LoginFacade, ResumeSessionErrorReason } from "./LoginFacade-zvyZiAr1.js";
import { MailListModel } from "./MailListModel-BwcGCBzp.js";
import { MailExportController } from "./MailExportController-OlydcYr6.js";
import "./SearchTypes-BQT7nl8f.js";
import { TemplateEditorModel } from "./TemplateEditorModel-BNzHRYEt.js";
import { de_default } from "./de-DcrbPWJZ.js";
import { de_sie_default } from "./de_sie-HnkD-UCP.js";
import { en_default } from "./en-BgRn5Lom.js";
import { BulkMailLoader } from "./BulkMailLoader-iol_KhLO.js";
import { ContactIndexer, Indexer, MembershipRemovedError, SuggestionFacade } from "./Indexer-BJlfvpHM.js";
import { IndexerCore } from "./IndexerCore-CrLYpsA5.js";
import { INITIAL_MAIL_INDEX_INTERVAL_DAYS, MailIndexer, _getCurrentIndexTimestamp } from "./MailIndexer-DcPkSBCs.js";
import { SearchFacade } from "./SearchFacade-BGVH_-od.js";
import { AesApp, AsymmetricCryptoFacade, BlobAccessTokenFacade, CHECK_INTERVAL, CryptoFacade, EphemeralCacheStorage, EventBusEventCoordinator, InstanceMapper, KeyCache, KeyLoaderFacade, KeyRotationFacade, LateInitializedCacheStorageImpl, LocalTimeDateProvider, OwnerEncSessionKeysUpdateQueue, PQFacade, SLEEP_INTERVAL, ServiceExecutor, SleepDetector, SuspensionHandler, UserFacade, WASMKyberFacade, convertToVersionedPublicKeys, decodePQMessage, decryptValue, encodePQMessage, encryptValue } from "./WorkerLocator-vHg_-eJs.js";
import "./StandardMigrations-7xZlHwBq.js";
import { OfflineStorageMigrator } from "./OfflineStorageMigrator-CQqO_-Qy.js";
import "./_wasm-loader_argon2-Be2iJ7_O.js";
import "./_wasm-loader_liboqs-CtTp3DnG.js";
import "./MailOfflineCleaner-BHMPStjr.js";
import { WorkerImpl } from "./WorkerImpl-DIBtyULv.js";
import { dist_default, otest_default } from "./dist-Ci1bEzYU.js";
import { require_testdouble } from "./testdouble-IbRSnrC0.js";
import { assertThrows, mapToObject, mock, mockAttribute, spy, unmockAttribute, verify } from "./dist-BY49f75m.js";
import { SchedulerMock, browserDataStub, createTestEntity, domainConfigStub, makeCore, textIncludes } from "./TestUtils-f_4UhLVE.js";
import { loadArgon2WASM, loadLibOQSWASM } from "./WASMTestUtils-CN9pkVyq.js";
import { addCapability, calendars, getDateInUTC, getDateInZone, makeAlarmScheduler, makeEvent, makeUserController, otherAddress, otherAddress2, otherRecipient, otherRecipient2, ownAddresses, ownerAddress, ownerAlias, ownerAliasRecipient, ownerId, ownerMailAddress, ownerRecipient, thirdAddress, thirdRecipient, zone } from "./CalendarTestUtils-I5CFxRuP.js";

//#region tests/misc/ListModelTest.ts
dist_default.spec("ListModel", function() {
	const listId = "listId";
	let fetchDefer;
	let listModel;
	const defaultListConfig = {
		fetch: () => fetchDefer.promise,
		sortCompare: sortCompareById,
		autoSelectBehavior: () => ListAutoSelectBehavior.OLDER,
		getItemId: getElementId,
		isSameId: (id1, id2) => id1 === id2
	};
	const itemA = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "a"],
		title: "a"
	});
	const itemB = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "b"],
		title: "b"
	});
	const itemC = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "c"],
		title: "c"
	});
	const itemD = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "d"],
		title: "d"
	});
	const items = [
		itemA,
		itemB,
		itemC,
		itemD
	];
	async function setItems(items$1) {
		fetchDefer.resolve({
			items: items$1,
			complete: true
		});
		await listModel.loadInitial();
	}
	dist_default.beforeEach(function() {
		fetchDefer = defer();
		listModel = new ListModel(defaultListConfig);
	});
	dist_default.spec("loading states", function() {
		dist_default("when loading initially it will set state to loading", async function() {
			const loading = listModel.loadInitial();
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Loading);
			fetchDefer.resolve({
				items: [],
				complete: false
			});
			await loading;
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Idle);
		});
		dist_default("when connection error occurs it wil set state to connectionLost", async function() {
			const loading = listModel.loadInitial();
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Loading);
			fetchDefer.reject(new ConnectionError("oops"));
			await loading;
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.ConnectionLost);
		});
		dist_default("when complete it wil set state to done", async function() {
			const loading = listModel.loadInitial();
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Loading);
			fetchDefer.resolve({
				items: [],
				complete: true
			});
			await loading;
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Done);
		});
		dist_default("when loadMore is called it will set state to loading and will fetch more", async function() {
			const initialLoading = listModel.loadInitial();
			fetchDefer.resolve({
				items: [],
				complete: false
			});
			await initialLoading;
			fetchDefer = defer();
			const moreLoading = listModel.loadMore();
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Loading);
			const knowledgeBaseEntry = createTestEntity(KnowledgeBaseEntryTypeRef, { _id: [listId, timestampToGeneratedId(10)] });
			fetchDefer.resolve({
				items: [knowledgeBaseEntry],
				complete: true
			});
			await moreLoading;
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Done);
			dist_default(listModel.state.items).deepEquals([knowledgeBaseEntry]);
		});
		dist_default("when called with retryLoading after connection error it will set state to loading and will load again", async function() {
			const initialLoading = listModel.loadInitial();
			fetchDefer.reject(new ConnectionError("oops"));
			await initialLoading;
			fetchDefer = defer();
			const retryLoading = listModel.retryLoading();
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Loading);
			fetchDefer.resolve({
				items: [],
				complete: true
			});
			await retryLoading;
			dist_default(listModel.state.loadingStatus).equals(ListLoadingState.Done);
		});
	});
	function getSortedSelection() {
		return listModel.getSelectedAsArray().sort(sortCompareById);
	}
	dist_default.spec("selection controls", function() {
		dist_default.spec("single", function() {
			dist_default("when selectNext and the list is empty nothing happens", async function() {
				await setItems([]);
				listModel.selectNext(false);
				dist_default(getSortedSelection()).deepEquals([]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(null);
			});
			dist_default("when selectNext and nothing is selected it select the first item", async function() {
				await setItems(items);
				listModel.selectNext(false);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when selectNext selects next item", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectNext(false);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when selectNext and last item is selected it stays", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemD);
				listModel.selectNext(false);
				dist_default(getSortedSelection()).deepEquals([itemD]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(3);
			});
			dist_default("when selectPrevious and nothing is selected it select the first item", async function() {
				await setItems(items);
				listModel.selectPrevious(false);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when selectPrevious and the first item is selected it stays", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.selectPrevious(false);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(0);
			});
		});
		dist_default.spec("selectPrevious/selectNext", function() {
			dist_default("when selectNext and the list is empty nothing happens", async function() {
				await setItems([]);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(null);
			});
			dist_default("when selectNext and nothing is selected it select the first item", async function() {
				await setItems(items);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when one item was selected selectNext adds to selection", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemB, itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when multiple items were selected selectNext below the selection start adds to selection", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectNext(true);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([
					itemB,
					itemC,
					itemD
				]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(3);
			});
			dist_default("when multiple items were selected selectNext above the selection start removes from selection", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectPrevious(true);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemB]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(1);
			});
			dist_default("when item below selection start is selected selectPrevious adds previous item to selection ", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemA, itemB]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when multiple items above selection start are selected selectPrevious adds previous item to selection ", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemC);
				listModel.selectPrevious(true);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([
					itemA,
					itemB,
					itemC
				]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when multiple items were selected selectPrevious above the selection start removes from selection", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.selectNext(true);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemB]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(1);
			});
			dist_default("when selectNext and last item is selected it stays", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemD);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemD]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(3);
			});
			dist_default("when selectPrevious and nothing is selected it select the first item", async function() {
				await setItems(items);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when selectPrevious and the first item is selected it stays", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when multiple items are selected and the active item is above the anchor and there's a gap selectPrevious will add item above the active one", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemD);
				listModel.onSingleInclusiveSelection(itemA);
				listModel.onSingleInclusiveSelection(itemC);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([
					itemA,
					itemB,
					itemC,
					itemD
				]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(1);
			});
			dist_default("when multiple items are selected and the active item is below the anchor and there's a gap select will add item above the active one", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.onSingleInclusiveSelection(itemD);
				listModel.onSingleInclusiveSelection(itemB);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([
					itemA,
					itemB,
					itemC,
					itemD
				]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when the active item is filtered out selectNext multiselect will still select next item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				listModel.setFilter((item) => item !== itemB);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(1);
			});
			dist_default("when the active item is filtered out selectPrevious multiselect will still select previous item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				listModel.setFilter((item) => item !== itemB);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
		});
		dist_default("selectRangeTowards towards item below", async function() {
			await setItems(items);
			listModel.onSingleSelection(itemA);
			listModel.selectRangeTowards(itemC);
			dist_default(getSortedSelection()).deepEquals([
				itemA,
				itemB,
				itemC
			]);
			dist_default(listModel.state.inMultiselect).equals(true);
			dist_default(listModel.state.activeIndex).equals(2);
		});
		dist_default("selectRangeTowards towards item above", async function() {
			await setItems(items);
			listModel.onSingleSelection(itemC);
			listModel.selectRangeTowards(itemA);
			dist_default(getSortedSelection()).deepEquals([
				itemA,
				itemB,
				itemC
			]);
			dist_default(listModel.state.inMultiselect).equals(true);
			dist_default(listModel.state.activeIndex).equals(0);
		});
		dist_default("selectRangeTowards towards item below with gap", async function() {
			await setItems(items);
			listModel.onSingleInclusiveSelection(itemC);
			listModel.onSingleInclusiveSelection(itemA);
			listModel.selectRangeTowards(itemD);
			dist_default(getSortedSelection()).deepEquals([
				itemA,
				itemC,
				itemD
			]);
			dist_default(listModel.state.inMultiselect).equals(true);
			dist_default(listModel.state.activeIndex).equals(3);
		});
		dist_default("selectRangeTowards towards item above with gap", async function() {
			await setItems(items);
			listModel.onSingleInclusiveSelection(itemB);
			listModel.onSingleInclusiveSelection(itemD);
			listModel.selectRangeTowards(itemA);
			dist_default(getSortedSelection()).deepEquals([
				itemA,
				itemB,
				itemD
			]);
			dist_default(listModel.state.inMultiselect).equals(true);
			dist_default(listModel.state.activeIndex).equals(0);
		});
		dist_default("onSingleSelection reset previous selection", async function() {
			await setItems(items);
			listModel.onSingleInclusiveSelection(itemA);
			listModel.onSingleSelection(itemC);
			dist_default(getSortedSelection()).deepEquals([itemC]);
			dist_default(listModel.state.inMultiselect).equals(false);
			dist_default(listModel.state.activeIndex).equals(2);
		});
		dist_default.spec("onSingleExclusiveSelection", function() {
			dist_default("when not in multiselect it will only select the newly selected item", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.onSingleExclusiveSelection(itemC);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when in multiselect it will add newly selected item to the selection", async function() {
				await setItems(items);
				listModel.onSingleExclusiveSelection(itemA);
				listModel.onSingleExclusiveSelection(itemC);
				dist_default(getSortedSelection()).deepEquals([itemA, itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
		});
		dist_default.spec("onSingleInclusiveSelection", function() {
			dist_default("when not in multiselect it will select both previous single selection and the newly selected item", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.onSingleInclusiveSelection(itemC);
				dist_default(getSortedSelection()).deepEquals([itemA, itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when not in multiselect it will not select both previous single selection and the newly selected item if in one column layout", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemA);
				listModel.onSingleInclusiveSelection(itemC, true);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
			});
			dist_default("when in multiselect it will add newly selected item to the selection", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemA);
				listModel.onSingleInclusiveSelection(itemC);
				dist_default(getSortedSelection()).deepEquals([itemA, itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(2);
			});
			dist_default("when entering multiselect on the same item as previously selected item, the item is selected", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.onSingleInclusiveSelection(itemB);
				dist_default(listModel.getSelectedAsArray()).deepEquals([itemB]);
				dist_default(listModel.state.inMultiselect).equals(true);
			});
			dist_default("when entering multiselect when having a single item selected, both items are selected", async function() {
				await setItems(items);
				listModel.onSingleSelection(itemB);
				listModel.onSingleInclusiveSelection(itemD);
				dist_default(getSortedSelection()).deepEquals([itemB, itemD]);
				dist_default(listModel.state.inMultiselect).equals(true);
			});
		});
	});
});

//#endregion
//#region tests/misc/ListElementListModelTest.ts
dist_default.spec("ListElementListModel", function() {
	const listId = "listId";
	let fetchDefer;
	let listModel;
	const defaultListConfig = {
		fetch: () => fetchDefer.promise,
		sortCompare: sortCompareById,
		loadSingle: () => {
			throw new Error("noop");
		},
		autoSelectBehavior: () => ListAutoSelectBehavior.OLDER
	};
	const itemA = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "a"],
		title: "a"
	});
	const itemB = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "b"],
		title: "b"
	});
	const itemC = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "c"],
		title: "c"
	});
	const itemD = createTestEntity(KnowledgeBaseEntryTypeRef, {
		_id: [listId, "d"],
		title: "d"
	});
	const items = [
		itemA,
		itemB,
		itemC,
		itemD
	];
	async function setItems(items$1) {
		fetchDefer.resolve({
			items: items$1,
			complete: true
		});
		await listModel.loadInitial();
	}
	dist_default.beforeEach(function() {
		fetchDefer = defer();
		listModel = new ListElementListModel(defaultListConfig);
	});
	function getSortedSelection() {
		return listModel.getSelectedAsArray().sort(sortCompareById);
	}
	dist_default.spec("selection controls", function() {
		dist_default.spec("selectPrevious/selectNext", function() {
			dist_default("when the active item is deleted selectPrevious single will still select previous item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
				listModel.selectPrevious(false);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when the active item is deleted selectPrevious multiselect will still select previous item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
				listModel.selectPrevious(true);
				dist_default(getSortedSelection()).deepEquals([itemA]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(0);
			});
			dist_default("when the active item is deleted selectNext single will still select next item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
				listModel.selectNext(false);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(false);
				dist_default(listModel.state.activeIndex).equals(1);
			});
			dist_default("when the active item is deleted selectNext multiselect will still select next item relative to it", async function() {
				await setItems(items);
				listModel.onSingleInclusiveSelection(itemB);
				await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
				listModel.selectNext(true);
				dist_default(getSortedSelection()).deepEquals([itemC]);
				dist_default(listModel.state.inMultiselect).equals(true);
				dist_default(listModel.state.activeIndex).equals(1);
			});
		});
	});
	dist_default.spec("Removing element in list ", function() {
		dist_default("in single select, the active element is next entity when active element gets deleted", async function() {
			await setItems(items);
			listModel.onSingleSelection(itemB);
			await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
			dist_default(listModel.state.activeIndex).equals(1);
		});
		dist_default("in single select, the active element is not changed when a different entity is deleted", async function() {
			await setItems(items);
			listModel.onSingleSelection(itemC);
			await listModel.entityEventReceived(getListId(itemA), getElementId(itemA), OperationType.DELETE);
			dist_default(listModel.state.activeIndex).equals(1);
		});
		dist_default("in multiselect, next element is not selected when element is removed", async function() {
			await setItems(items);
			listModel.onSingleInclusiveSelection(itemB);
			await listModel.entityEventReceived(getListId(itemB), getElementId(itemB), OperationType.DELETE);
			dist_default(listModel.state.inMultiselect).equals(true);
			dist_default(listModel.state.activeIndex).equals(null);
		});
	});
	dist_default.spec("Updating items", function() {
		function loadsElement(element) {
			return async (_listId, elementId) => {
				if (elementId === getElementId(element)) return element;
else throw new Error("noop");
			};
		}
		dist_default("update for item with id sorting updates item", async function() {
			const updatedItemD = createTestEntity(KnowledgeBaseEntryTypeRef, {
				...itemD,
				title: "AA"
			});
			const newConfig = {
				...defaultListConfig,
				loadSingle: loadsElement(updatedItemD)
			};
			listModel = new ListElementListModel(newConfig);
			await setItems(items);
			await listModel.entityEventReceived(getListId(itemD), getElementId(itemD), OperationType.UPDATE);
			dist_default(listModel.state.items).deepEquals([
				itemA,
				itemB,
				itemC,
				updatedItemD
			]);
		});
		dist_default("update for item with custom sorting changes position", async function() {
			const updatedItemD = createTestEntity(KnowledgeBaseEntryTypeRef, {
				...itemD,
				title: "AA"
			});
			const newConfig = {
				...defaultListConfig,
				loadSingle: loadsElement(updatedItemD),
				sortCompare: (e1, e2) => {
					return e1.title.localeCompare(e2.title);
				}
			};
			listModel = new ListElementListModel(newConfig);
			await setItems(items);
			await listModel.entityEventReceived(getListId(itemD), getElementId(itemD), OperationType.UPDATE);
			dist_default(listModel.state.items).deepEquals([
				itemA,
				updatedItemD,
				itemB,
				itemC
			]);
		});
		dist_default("create loading done", async function() {
			const itemE = createTestEntity(KnowledgeBaseEntryTypeRef, {
				_id: [listId, "e"],
				title: "e"
			});
			let somePromise = defer();
			const newConfig = {
				...defaultListConfig,
				fetch: () => {
					return somePromise.promise;
				},
				loadSingle: loadsElement(itemE)
			};
			listModel = new ListElementListModel(newConfig);
			listModel.loadInitial();
			const received = listModel.entityEventReceived(getListId(itemE), getElementId(itemE), OperationType.CREATE);
			somePromise.resolve({
				items: [],
				complete: true
			});
			await received;
			dist_default(listModel.state.items).deepEquals([itemE]);
		});
		dist_default("when receive create event while empty list and not loaded completely it will not insert the item", async function() {
			const itemE = createTestEntity(KnowledgeBaseEntryTypeRef, {
				_id: [listId, "e"],
				title: "e"
			});
			let somePromise = defer();
			const newConfig = {
				...defaultListConfig,
				fetch: () => {
					return somePromise.promise;
				},
				loadSingle: loadsElement(itemE)
			};
			listModel = new ListElementListModel(newConfig);
			listModel.loadInitial();
			const received = listModel.entityEventReceived(getListId(itemE), getElementId(itemE), OperationType.CREATE);
			somePromise.resolve({
				items: [],
				complete: false
			});
			await received;
			dist_default(listModel.state.items).deepEquals([]);
		});
		dist_default("when receive create event while empty list and error it does not insert", async function() {
			const itemE = createTestEntity(KnowledgeBaseEntryTypeRef, {
				_id: [listId, "e"],
				title: "e"
			});
			let somePromise = defer();
			const newConfig = {
				...defaultListConfig,
				fetch: () => {
					return somePromise.promise;
				},
				loadSingle: loadsElement(itemE)
			};
			listModel = new ListElementListModel(newConfig);
			listModel.loadInitial();
			const received = listModel.entityEventReceived(getListId(itemE), getElementId(itemE), OperationType.CREATE);
			somePromise.reject(new ConnectionError("test"));
			await received;
			dist_default(listModel.state.items).deepEquals([]);
		});
		dist_default("when receive create event and out of range", async function() {
			const itemE = createTestEntity(KnowledgeBaseEntryTypeRef, {
				_id: [listId, "e"],
				title: "e"
			});
			let somePromise = defer();
			const newConfig = {
				...defaultListConfig,
				fetch: () => {
					return somePromise.promise;
				},
				loadSingle: loadsElement(itemE)
			};
			listModel = new ListElementListModel(newConfig);
			listModel.loadInitial();
			const received = listModel.entityEventReceived(getListId(itemE), getElementId(itemE), OperationType.CREATE);
			somePromise.resolve({
				items: [
					itemA,
					itemB,
					itemC,
					itemD
				],
				complete: false
			});
			await received;
			dist_default(listModel.state.items).deepEquals([
				itemA,
				itemB,
				itemC,
				itemD
			]);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/LoginFacadeTest.ts
var import_testdouble$67 = __toESM(require_testdouble(), 1);
const { anything: anything$13, argThat: argThat$5 } = import_testdouble$67.matchers;
const PASSWORD_KEY = uint8ArrayToBitArray(new Uint8Array(Array(KEY_LENGTH_BYTES_AES_256).keys()));
function verify$30(demonstration, config) {
	function check(demonstration$1) {
		try {
			import_testdouble$67.default.verify(demonstration$1, config);
			return {
				pass: true,
				message: "Successful verification"
			};
		} catch (e) {
			return {
				pass: false,
				message: e.toString()
			};
		}
	}
	dist_default(demonstration).satisfies(check);
}
const SALT = new Uint8Array([
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15
]);
async function makeUser$1(userId$1, kdfVersion = DEFAULT_KDF_TYPE, userPassphraseKey = PASSWORD_KEY) {
	const groupKey = encryptKey(userPassphraseKey, [
		3229306880,
		2716953871,
		4072167920,
		3901332676
	]);
	return createTestEntity(UserTypeRef, {
		_id: userId$1,
		verifier: sha256Hash(createAuthVerifier(userPassphraseKey)),
		userGroup: createTestEntity(GroupMembershipTypeRef, {
			group: "groupId",
			symEncGKey: groupKey,
			groupInfo: ["groupInfoListId", "groupInfoElId"]
		}),
		kdfVersion,
		externalAuthInfo: createTestEntity(UserExternalAuthInfoTypeRef, { latestSaltHash: SALT })
	});
}
dist_default.spec("LoginFacadeTest", function() {
	let facade;
	let serviceExecutor;
	let restClientMock;
	let entityClientMock;
	let loginListener;
	let instanceMapperMock;
	let cryptoFacadeMock;
	let cacheStorageInitializerMock;
	let eventBusClientMock;
	let usingOfflineStorage;
	let userFacade;
	let entropyFacade;
	let blobAccessTokenFacade;
	let databaseKeyFactoryMock;
	let argon2idFacade;
	let cacheManagmentFacadeMock;
	const timeRangeDays = 42;
	const login = "born.slippy@tuta.io";
	dist_default.beforeEach(function() {
		serviceExecutor = (0, import_testdouble$67.object)();
		(0, import_testdouble$67.when)(serviceExecutor.get(SaltService, anything$13()), { ignoreExtraArgs: true }).thenResolve(createTestEntity(SaltReturnTypeRef, {
			salt: SALT,
			kdfVersion: DEFAULT_KDF_TYPE
		}));
		restClientMock = (0, import_testdouble$67.instance)(RestClient);
		entityClientMock = (0, import_testdouble$67.instance)(EntityClient);
		(0, import_testdouble$67.when)(entityClientMock.loadRoot(TutanotaPropertiesTypeRef, anything$13())).thenResolve(createTestEntity(TutanotaPropertiesTypeRef));
		loginListener = (0, import_testdouble$67.object)();
		instanceMapperMock = (0, import_testdouble$67.instance)(InstanceMapper);
		cryptoFacadeMock = (0, import_testdouble$67.object)();
		usingOfflineStorage = false;
		cacheStorageInitializerMock = (0, import_testdouble$67.object)();
		(0, import_testdouble$67.when)(cacheStorageInitializerMock.initialize({
			userId: anything$13(),
			databaseKey: anything$13(),
			timeRangeDays: anything$13(),
			forceNewDatabase: anything$13(),
			type: "offline"
		})).thenDo(async () => {
			return {
				isPersistent: usingOfflineStorage,
				isNewOfflineDb: false
			};
		});
		(0, import_testdouble$67.when)(cacheStorageInitializerMock.initialize({
			userId: anything$13(),
			type: "ephemeral"
		})).thenResolve({
			isPersistent: false,
			isNewOfflineDb: false
		});
		userFacade = (0, import_testdouble$67.object)();
		entropyFacade = (0, import_testdouble$67.object)();
		databaseKeyFactoryMock = (0, import_testdouble$67.object)();
		argon2idFacade = (0, import_testdouble$67.object)();
		(0, import_testdouble$67.when)(argon2idFacade.generateKeyFromPassphrase(anything$13(), anything$13())).thenResolve(PASSWORD_KEY);
		cacheManagmentFacadeMock = (0, import_testdouble$67.object)();
		facade = new LoginFacade(restClientMock, entityClientMock, loginListener, instanceMapperMock, cryptoFacadeMock, (0, import_testdouble$67.instance)(KeyRotationFacade), cacheStorageInitializerMock, serviceExecutor, userFacade, blobAccessTokenFacade, entropyFacade, databaseKeyFactoryMock, argon2idFacade, entityClientMock, async (error) => {}, async () => cacheManagmentFacadeMock);
		eventBusClientMock = (0, import_testdouble$67.instance)(EventBusClient);
		facade.init(eventBusClientMock);
	});
	dist_default.spec("Creating new sessions", function() {
		dist_default.spec("initializing cache storage", function() {
			const dbKey$1 = new Uint8Array([
				1,
				2,
				3,
				4,
				1,
				2,
				3,
				4
			]);
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessToken$1 = "accessToken";
			dist_default.beforeEach(async function() {
				(0, import_testdouble$67.when)(serviceExecutor.post(SessionService, anything$13()), { ignoreExtraArgs: true }).thenResolve(createTestEntity(CreateSessionReturnTypeRef, {
					user: userId$1,
					accessToken: accessToken$1,
					challenges: []
				}));
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(await makeUser$1(userId$1));
			});
			dist_default.test("When a database key is provided and session is persistent it is passed to the offline storage initializer", async function() {
				await facade.createSession(login, passphrase, "client", SessionType.Persistent, dbKey$1);
				verify$30(cacheStorageInitializerMock.initialize({
					type: "offline",
					databaseKey: dbKey$1,
					userId: userId$1,
					timeRangeDays: null,
					forceNewDatabase: false
				}));
				verify$30(databaseKeyFactoryMock.generateKey(), { times: 0 });
			});
			dist_default.test("When no database key is provided and session is persistent, a key is generated and we attempt offline db init", async function() {
				const databaseKey = Uint8Array.from([
					1,
					2,
					3,
					4
				]);
				(0, import_testdouble$67.when)(databaseKeyFactoryMock.generateKey()).thenResolve(databaseKey);
				await facade.createSession(login, passphrase, "client", SessionType.Persistent, null);
				verify$30(cacheStorageInitializerMock.initialize({
					type: "offline",
					userId: userId$1,
					databaseKey,
					timeRangeDays: null,
					forceNewDatabase: true
				}));
				verify$30(databaseKeyFactoryMock.generateKey(), { times: 1 });
			});
			dist_default.test("When no database key is provided and session is Login, nothing is passed to the offline storage initialzier", async function() {
				await facade.createSession(login, passphrase, "client", SessionType.Login, null);
				verify$30(cacheStorageInitializerMock.initialize({
					type: "ephemeral",
					userId: userId$1
				}));
				verify$30(databaseKeyFactoryMock.generateKey(), { times: 0 });
			});
			dist_default.test("When no database key is provided and session is persistent, valid credentials are returned", async () => {
				const result = await facade.createSession(login, passphrase, "client", SessionType.Persistent, null);
				const credentials = result.credentials;
				dist_default(credentials.encryptedPassphraseKey).notEquals(null);
				dist_default(credentials.login).equals(login);
				dist_default(credentials.userId).equals(userId$1);
				dist_default(credentials.encryptedPassword?.length).notEquals(null);
				dist_default(credentials.encryptedPassword).notEquals(null);
				dist_default(credentials.type).equals(CredentialType.Internal);
				dist_default(credentials.accessToken).equals(accessToken$1);
			});
		});
	});
	dist_default.spec("Resuming existing sessions", function() {
		dist_default.spec("initializing cache storage", function() {
			const dbKey$1 = new Uint8Array([
				1,
				2,
				3,
				4,
				1,
				2,
				3,
				4
			]);
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let credentials;
			let user;
			dist_default.beforeEach(async function() {
				user = await makeUser$1(userId$1);
				credentials = {
					login,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					encryptedPassphraseKey: null,
					accessToken: accessToken$1,
					userId: userId$1,
					type: CredentialType.Internal
				};
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.argThat((path) => typeof path === "string" && path.startsWith("/rest/sys/session/")), HttpMethod.GET, anything$13())).thenResolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				}));
			});
			dist_default.test("When resuming a session and there is a database key, it is passed to offline storage initialization", async function() {
				usingOfflineStorage = true;
				await facade.resumeSession(credentials, null, dbKey$1, timeRangeDays);
				verify$30(cacheStorageInitializerMock.initialize({
					type: "offline",
					databaseKey: dbKey$1,
					userId: userId$1,
					timeRangeDays,
					forceNewDatabase: false
				}));
			});
			dist_default.test("When resuming a session and there is no database key, nothing is passed to offline storage initialization", async function() {
				usingOfflineStorage = true;
				await facade.resumeSession(credentials, null, null, timeRangeDays);
				verify$30(cacheStorageInitializerMock.initialize({
					type: "ephemeral",
					userId: userId$1
				}));
			});
			dist_default.test("when resuming a session and the offline initialization has created a new database, we do synchronous login", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				(0, import_testdouble$67.when)(cacheStorageInitializerMock.initialize({
					type: "offline",
					databaseKey: dbKey$1,
					userId: userId$1,
					timeRangeDays,
					forceNewDatabase: false
				})).thenResolve({
					isPersistent: true,
					isNewOfflineDb: true
				});
				await facade.resumeSession(credentials, null, dbKey$1, timeRangeDays);
				dist_default(facade.asyncLoginState).deepEquals({ state: "idle" })("Synchronous login occured, so once resume returns we have already logged in");
			});
			dist_default.test("when resuming a session and the offline initialization has an existing database, we do async login", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				(0, import_testdouble$67.when)(cacheStorageInitializerMock.initialize({
					type: "offline",
					databaseKey: dbKey$1,
					userId: userId$1,
					timeRangeDays,
					forceNewDatabase: false
				})).thenResolve({
					isPersistent: true,
					isNewOfflineDb: false
				});
				await facade.resumeSession(credentials, null, dbKey$1, timeRangeDays);
				dist_default(facade.asyncLoginState).deepEquals({ state: "running" })("Async login occurred so it is still running");
			});
			dist_default.test("when resuming a session and a notauthenticatedError is thrown, the offline db is deleted", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.FREE;
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.argThat((path) => path.startsWith("/rest/sys/session/")), HttpMethod.GET, anything$13())).thenReject(new NotAuthenticatedError("not your cheese"));
				await dist_default(() => facade.resumeSession(credentials, {
					salt: SALT,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays)).asyncThrows(NotAuthenticatedError);
				verify$30(cacheStorageInitializerMock.deInitialize());
			});
			dist_default.test("when resuming a session with credentials that don't have encryptedPassphraseKey it is assigned", async () => {
				usingOfflineStorage = true;
				await facade.resumeSession(credentials, null, null, timeRangeDays);
				verify$30(loginListener.onFullLoginSuccess(SessionType.Persistent, anything$13(), argThat$5((credentials$1) => credentials$1.encryptedPassphraseKey != null)));
			});
		});
		dist_default.spec("account type combinations", function() {
			let credentials;
			const dbKey$1 = new Uint8Array([
				1,
				2,
				3,
				4,
				1,
				2,
				3,
				4
			]);
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let user;
			let calls;
			let fullLoginDeferred;
			dist_default.beforeEach(async function() {
				user = await makeUser$1(userId$1);
				credentials = {
					login,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					accessToken: accessToken$1,
					userId: userId$1,
					type: "internal"
				};
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				calls = [];
				(0, import_testdouble$67.when)(userFacade.setUser(anything$13())).thenDo(() => {
					calls.push("setUser");
				});
				(0, import_testdouble$67.when)(userFacade.isPartiallyLoggedIn()).thenDo(() => calls.includes("setUser"));
				fullLoginDeferred = defer();
				(0, import_testdouble$67.when)(loginListener.onFullLoginSuccess(import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything())).thenDo(() => fullLoginDeferred.resolve());
			});
			dist_default("When using offline as a free user and with stable connection, login sync", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.FREE;
				await testSuccessfulSyncLogin();
			});
			dist_default("When using offline as a free user with unstable connection, no offline for free users", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.FREE;
				(0, import_testdouble$67.when)(restClientMock.request(anything$13(), HttpMethod.GET, anything$13())).thenDo(async () => {
					calls.push("sessionService");
					throw new ConnectionError("Oopsie 1");
				});
				const result = await facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays).finally(() => {
					calls.push("return");
				});
				dist_default(result).deepEquals({
					type: "error",
					reason: ResumeSessionErrorReason.OfflineNotAvailableForFree
				});
				dist_default(calls).deepEquals(["sessionService", "return"]);
			});
			dist_default("When using offline as premium user with stable connection, async login", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				(0, import_testdouble$67.when)(restClientMock.request(anything$13(), HttpMethod.GET, anything$13())).thenDo(async () => {
					calls.push("sessionService");
					return JSON.stringify({
						user: userId$1,
						accessKey: keyToBase64(accessKey)
					});
				});
				const deferred = defer();
				(0, import_testdouble$67.when)(loginListener.onFullLoginSuccess(import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything())).thenDo(() => deferred.resolve(null));
				const result = await facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays);
				dist_default(result.type).equals("success");
				await deferred.promise;
				dist_default(calls).deepEquals([
					"setUser",
					"sessionService",
					"setUser"
				]);
				await fullLoginDeferred.promise;
			});
			dist_default("When using offline as premium user with unstable connection, async login with later retry", async function() {
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				const connectionError = new ConnectionError("Oopsie 2");
				(0, import_testdouble$67.when)(restClientMock.request(anything$13(), HttpMethod.GET, anything$13())).thenDo(async () => {
					calls.push("sessionService");
					throw connectionError;
				});
				const result = await facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays);
				await Promise.resolve();
				dist_default(result.type).equals("success");
				dist_default(calls).deepEquals(["setUser", "sessionService"]);
				verify$30(userFacade.unlockUserGroupKey(anything$13()), { times: 0 });
			});
			dist_default("When not using offline as free user with connection, sync login", async function() {
				usingOfflineStorage = false;
				user.accountType = AccountType.FREE;
				await testSuccessfulSyncLogin();
			});
			dist_default("When not using offline as free user with unstable connection, sync login with connection error", async function() {
				usingOfflineStorage = false;
				user.accountType = AccountType.FREE;
				await testConnectionFailingSyncLogin();
			});
			dist_default("When not using offline as premium user with stable connection, sync login", async function() {
				usingOfflineStorage = false;
				user.accountType = AccountType.PAID;
				await testSuccessfulSyncLogin();
			});
			dist_default("When not using offline as premium with unstable connection, sync login with connection error", async function() {
				usingOfflineStorage = false;
				user.accountType = AccountType.PAID;
				await testConnectionFailingSyncLogin();
			});
			async function testSuccessfulSyncLogin() {
				(0, import_testdouble$67.when)(restClientMock.request(anything$13(), HttpMethod.GET, anything$13())).thenDo(async () => {
					calls.push("sessionService");
					return JSON.stringify({
						user: userId$1,
						accessKey: keyToBase64(accessKey)
					});
				});
				await facade.resumeSession(credentials, user.salt == null ? null : {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays).finally(() => {
					calls.push("return");
				});
				dist_default(calls).deepEquals([
					"sessionService",
					"setUser",
					"return"
				]);
			}
			async function testConnectionFailingSyncLogin() {
				(0, import_testdouble$67.when)(restClientMock.request(anything$13(), HttpMethod.GET, anything$13())).thenDo(async () => {
					calls.push("sessionService");
					throw new ConnectionError("Oopsie 3");
				});
				await dist_default(() => facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays)).asyncThrows(ConnectionError);
				dist_default(calls).deepEquals(["sessionService"]);
			}
		});
		dist_default.spec("async login", function() {
			let credentials;
			const dbKey$1 = new Uint8Array([
				1,
				2,
				3,
				4,
				1,
				2,
				3,
				4
			]);
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let calls;
			let fullLoginDeferred;
			let user;
			dist_default.beforeEach(async function() {
				user = await makeUser$1(userId$1);
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				credentials = {
					login,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					accessToken: accessToken$1,
					userId: userId$1,
					type: "internal"
				};
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				calls = [];
				(0, import_testdouble$67.when)(userFacade.setUser(anything$13())).thenDo(() => {
					calls.push("setUser");
				});
				(0, import_testdouble$67.when)(userFacade.isPartiallyLoggedIn()).thenDo(() => calls.includes("setUser"));
				fullLoginDeferred = defer();
				(0, import_testdouble$67.when)(loginListener.onFullLoginSuccess(import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything())).thenDo(() => fullLoginDeferred.resolve());
			});
			dist_default("When successfully logged in, userFacade is initialised", async function() {
				const groupInfo = createTestEntity(GroupInfoTypeRef);
				(0, import_testdouble$67.when)(entityClientMock.load(GroupInfoTypeRef, user.userGroup.groupInfo)).thenResolve(groupInfo);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.GET, anything$13())).thenResolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				}));
				await facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays);
				await fullLoginDeferred.promise;
				verify$30(userFacade.setAccessToken("accessToken"));
				verify$30(userFacade.unlockUserGroupKey(import_testdouble$67.matchers.anything()));
				verify$30(eventBusClientMock.connect(ConnectMode.Initial));
			});
			dist_default("when retrying failed login, userFacade is initialized", async function() {
				const deferred = defer();
				(0, import_testdouble$67.when)(loginListener.onLoginFailure(import_testdouble$67.matchers.anything())).thenDo(() => deferred.resolve(null));
				const groupInfo = createTestEntity(GroupInfoTypeRef);
				(0, import_testdouble$67.when)(entityClientMock.load(GroupInfoTypeRef, user.userGroup.groupInfo)).thenResolve(groupInfo);
				const connectionError = new ConnectionError("test");
				(0, import_testdouble$67.when)(userFacade.isFullyLoggedIn()).thenReturn(false);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.GET, anything$13())).thenReturn(Promise.reject(connectionError), Promise.resolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				})));
				await facade.resumeSession(credentials, {
					salt: user.salt,
					kdfType: DEFAULT_KDF_TYPE
				}, dbKey$1, timeRangeDays);
				verify$30(userFacade.setAccessToken("accessToken"));
				verify$30(userFacade.unlockUserGroupKey(anything$13()), { times: 0 });
				verify$30(userFacade.unlockUserGroupKey(import_testdouble$67.matchers.anything()), { times: 0 });
				verify$30(eventBusClientMock.connect(ConnectMode.Initial), { times: 0 });
				await deferred.promise;
				await facade.retryAsyncLogin();
				await fullLoginDeferred.promise;
				verify$30(userFacade.setAccessToken("accessToken"));
				verify$30(userFacade.unlockUserGroupKey(import_testdouble$67.matchers.anything()));
				verify$30(eventBusClientMock.connect(ConnectMode.Initial));
			});
		});
		dist_default.spec("async login bcrypt", function() {
			let credentials;
			const dbKey$1 = new Uint8Array([
				1,
				2,
				3,
				4,
				1,
				2,
				3,
				4
			]);
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let calls;
			let fullLoginDeferred;
			let user;
			dist_default.beforeEach(async function() {
				const passphraseKeyData = {
					kdfType: KdfType.Bcrypt,
					passphrase,
					salt: SALT
				};
				const userPassphraseKey = await facade.deriveUserPassphraseKey(passphraseKeyData);
				user = await makeUser$1(userId$1, KdfType.Bcrypt, userPassphraseKey);
				user.salt = SALT;
				usingOfflineStorage = true;
				user.accountType = AccountType.PAID;
				credentials = {
					login,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					accessToken: accessToken$1,
					userId: userId$1,
					type: "internal"
				};
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				(0, import_testdouble$67.when)(serviceExecutor.get(SaltService, anything$13()), { ignoreExtraArgs: true }).thenResolve(createSaltReturn({
					salt: SALT,
					kdfVersion: KdfType.Bcrypt
				}));
				calls = [];
				(0, import_testdouble$67.when)(userFacade.setUser(anything$13())).thenDo(() => {
					calls.push("setUser");
				});
				(0, import_testdouble$67.when)(userFacade.isPartiallyLoggedIn()).thenDo(() => calls.includes("setUser"));
				fullLoginDeferred = defer();
				(0, import_testdouble$67.when)(loginListener.onFullLoginSuccess(import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything(), import_testdouble$67.matchers.anything())).thenDo(() => fullLoginDeferred.resolve());
			});
			dist_default("When successfully logged in, userFacade is initialised", async function() {
				const groupInfo = createTestEntity(GroupInfoTypeRef);
				(0, import_testdouble$67.when)(entityClientMock.load(GroupInfoTypeRef, user.userGroup.groupInfo)).thenResolve(groupInfo);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.GET, anything$13())).thenResolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				}));
				await facade.resumeSession(credentials, null, dbKey$1, timeRangeDays);
				await fullLoginDeferred.promise;
				verify$30(userFacade.setAccessToken("accessToken"));
				verify$30(userFacade.unlockUserGroupKey(import_testdouble$67.matchers.anything()));
				verify$30(eventBusClientMock.connect(ConnectMode.Initial));
			});
		});
		dist_default.spec("external sessions", function() {
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let user;
			let credentials;
			dist_default.beforeEach(async function() {
				credentials = {
					login: userId$1,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					accessToken: accessToken$1,
					userId: userId$1,
					type: "internal"
				};
				user = await makeUser$1(userId$1);
				user.externalAuthInfo = createTestEntity(UserExternalAuthInfoTypeRef, { latestSaltHash: sha256Hash(SALT) });
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.GET, anything$13())).thenResolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				}));
			});
			dist_default("when the salt is not outdated, login works", async function() {
				const result = await facade.resumeSession(credentials, {
					salt: SALT,
					kdfType: DEFAULT_KDF_TYPE
				}, null, timeRangeDays);
				dist_default(result.type).equals("success");
			});
			dist_default("when the salt is outdated, AccessExpiredError is thrown", async function() {
				user.externalAuthInfo.latestSaltHash = new Uint8Array([
					1,
					2,
					3
				]);
				await dist_default(() => facade.resumeSession(credentials, {
					salt: SALT,
					kdfType: DEFAULT_KDF_TYPE
				}, null, timeRangeDays)).asyncThrows(AccessExpiredError);
				verify$30(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.DELETE, anything$13()), { times: 0 });
			});
			dist_default("when the password is outdated, NotAuthenticatedError is thrown", async function() {
				user.verifier = new Uint8Array([
					1,
					2,
					3
				]);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.DELETE, anything$13())).thenResolve(null);
				await dist_default(() => facade.resumeSession(credentials, {
					salt: SALT,
					kdfType: DEFAULT_KDF_TYPE
				}, null, timeRangeDays)).asyncThrows(NotAuthenticatedError);
				verify$30(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.DELETE, anything$13()));
			});
		});
		dist_default.spec("external sessions bcrypt", function() {
			const passphrase = "hunter2";
			const userId$1 = "userId";
			const accessKey = [
				3229306880,
				2716953871,
				4072167920,
				3901332677
			];
			const accessToken$1 = "accessToken";
			let user;
			let credentials;
			dist_default.beforeEach(async function() {
				credentials = {
					login: userId$1,
					encryptedPassword: uint8ArrayToBase64(encryptString(accessKey, passphrase)),
					accessToken: accessToken$1,
					userId: userId$1,
					type: "internal"
				};
				const passphraseKeyData = {
					kdfType: KdfType.Bcrypt,
					passphrase,
					salt: SALT
				};
				const userPassphraseKey = await facade.deriveUserPassphraseKey(passphraseKeyData);
				user = await makeUser$1(userId$1, KdfType.Bcrypt, userPassphraseKey);
				user.externalAuthInfo = createTestEntity(UserExternalAuthInfoTypeRef, { latestSaltHash: sha256Hash(SALT) });
				(0, import_testdouble$67.when)(entityClientMock.load(UserTypeRef, userId$1)).thenResolve(user);
				(0, import_testdouble$67.when)(restClientMock.request(import_testdouble$67.matchers.contains("sys/session"), HttpMethod.GET, anything$13())).thenResolve(JSON.stringify({
					user: userId$1,
					accessKey: keyToBase64(accessKey)
				}));
			});
			dist_default("when the salt is not outdated, login works", async function() {
				const result = await facade.resumeSession(credentials, {
					salt: SALT,
					kdfType: KdfType.Bcrypt
				}, null, timeRangeDays);
				dist_default(result.type).equals("success");
			});
		});
	});
	dist_default.spec("Migrating the KDF", function() {
		dist_default("When the migration is enabled, a new key is derived from the same password with Argon2", async function() {
			const user = await makeUser$1("userId", KdfType.Bcrypt);
			user.salt = SALT;
			(0, import_testdouble$67.when)(userFacade.getCurrentUserGroupKey()).thenReturn({
				object: [
					1,
					2,
					3,
					4
				],
				version: 0
			});
			Const.EXECUTE_KDF_MIGRATION = true;
			await facade.migrateKdfType(KdfType.Argon2id, "hunter2", user);
			verify$30(argon2idFacade.generateKeyFromPassphrase("hunter2", argThat$5((arg) => {
				return arg !== SALT;
			})));
			verify$30(serviceExecutor.post(ChangeKdfService, argThat$5(({ kdfVersion, oldVerifier, pwEncUserGroupKey, salt, verifier }) => {
				return kdfVersion === KdfType.Argon2id;
			})));
			verify$30(cacheManagmentFacadeMock.reloadUser());
		});
		dist_default.afterEach(() => {
			Const.EXECUTE_KDF_MIGRATION = false;
		});
	});
});

//#endregion
//#region tests/api/common/utils/LoggerTest.ts
dist_default.spec("Loger test", function() {
	let dateProvider$1;
	let log;
	dist_default.beforeEach(function() {
		let dateCounter = 0;
		dateProvider$1 = () => new Date(dateCounter++);
		log = new Logger(dateProvider$1);
	});
	dist_default("log warn info error", function() {
		dist_default(log.getEntries()).deepEquals([]);
		log.logInfo("info");
		log.logWarn("warn");
		log.logError("error");
		dist_default(log.getEntries()).deepEquals([
			log.formatLogEntry(new Date(0), "I", "info"),
			log.formatLogEntry(new Date(1), "W", "warn"),
			log.formatLogEntry(new Date(2), "E", "error")
		]);
	});
	dist_default("log lots of entries", function() {
		for (let i = 0; i < LOG_SIZE + 2; i++) log.logInfo("info " + i);
		dist_default(log.getEntries().length).equals(LOG_SIZE);
		dist_default(log.getEntries()[0]).equals(log.formatLogEntry(new Date(2), "I", "info 2"));
		dist_default(lastThrow(log.getEntries())).equals(log.formatLogEntry(new Date(1001), "I", "info 1001"));
	});
});

//#endregion
//#region tests/api/common/utils/BirthdayUtilsTest.ts
dist_default.spec("BirthdayUtilsTest", function() {
	dist_default("birthdayToIsoDate", function() {
		const bday = createTestEntity(BirthdayTypeRef, {
			day: "12",
			month: "10",
			year: null
		});
		dist_default(birthdayToIsoDate(bday)).equals("--10-12");
		bday.year = "2009";
		dist_default(birthdayToIsoDate(bday)).equals("2009-10-12");
		bday.year = "100";
		dist_default(birthdayToIsoDate(bday)).equals("0100-10-12");
		bday.year = "2019";
		bday.month = "1";
		bday.day = "5";
		dist_default(birthdayToIsoDate(bday)).equals("2019-01-05");
	});
	dist_default("isoDateToBirthday", function() {
		dist_default(isoDateToBirthday("--10-12")).deepEquals(createTestEntity(BirthdayTypeRef, {
			day: "12",
			month: "10",
			year: null
		}));
		dist_default(isoDateToBirthday("2009-10-12")).deepEquals(createTestEntity(BirthdayTypeRef, {
			day: "12",
			month: "10",
			year: "2009"
		}));
		dist_default(isoDateToBirthday("2009-12-31")).deepEquals(createTestEntity(BirthdayTypeRef, {
			day: "31",
			month: "12",
			year: "2009"
		}));
		dist_default(isoDateToBirthday("2009-01-01")).deepEquals(createTestEntity(BirthdayTypeRef, {
			day: "01",
			month: "01",
			year: "2009"
		}));
	});
	dist_default("parsing error", function() {
		assertFail(() => isoDateToBirthday(""), new ParsingError("invalid birthday: "));
		assertFail(() => isoDateToBirthday("-"), new ParsingError("invalid birthday: -"));
		assertFail(() => isoDateToBirthday("31"), new ParsingError("invalid birthday: 31"));
		assertFail(() => isoDateToBirthday("31-wq."), new ParsingError("invalid birthday: 31-wq."));
		assertFail(() => isoDateToBirthday("--"), new ParsingError("invalid birthday without year: --"));
		assertFail(() => isoDateToBirthday("---10-12"), new ParsingError("invalid birthday without year: ---10-12"));
		assertFail(() => isoDateToBirthday("aaaa-bb-cc"), new ParsingError("Invalid birthday format: aaaa-bb-cc"));
		assertFail(() => isoDateToBirthday("aaaa-bb-01"), new ParsingError("Invalid birthday format: aaaa-bb-01"));
		assertFail(() => isoDateToBirthday("aaaa-01-01"), new ParsingError("Invalid birthday format: aaaa-01-01"));
		assertFail(() => isoDateToBirthday("0000-01-01"), new ParsingError("Invalid birthday format: 0000-01-01"));
		assertFail(() => isoDateToBirthday("2019-00-01"), new ParsingError("Invalid birthday format: 2019-00-01"));
		assertFail(() => isoDateToBirthday("2019-01-00"), new ParsingError("Invalid birthday format: 2019-01-00"));
		assertFail(() => isoDateToBirthday("2019-13-31"), new ParsingError("Invalid birthday format: 2019-13-31"));
		assertFail(() => isoDateToBirthday("2019-12-32"), new ParsingError("Invalid birthday format: 2019-12-32"));
	});
});
function assertFail(testFunction, expectedError) {
	try {
		testFunction();
		dist_default(false).equals("exception expected: " + expectedError.message);
	} catch (e) {
		assertTutanotaError(e, expectedError);
	}
}
function assertTutanotaError(actual, expectedError) {
	dist_default(actual.name).equals(expectedError.name);
	dist_default(actual.message).equals(expectedError.message);
}

//#endregion
//#region tests/api/worker/rest/EntityRestClientTest.ts
var import_testdouble$66 = __toESM(require_testdouble(), 1);
const { anything: anything$12, argThat: argThat$4 } = import_testdouble$66.matchers;
const accessToken = "My cool access token";
const authHeader = { accessToken };
function createArrayOf(count, factory) {
	return Array(count).fill().map((_, idx) => factory(idx));
}
const countFrom = (start, count) => createArrayOf(count, (idx) => String(idx + start));
function contacts(count) {
	const contactFactory = (idx) => createTestEntity(ContactTypeRef, { firstName: `Contact${idx}` });
	return createArrayOf(count, contactFactory);
}
dist_default.spec("EntityRestClient", function() {
	let entityRestClient;
	let restClient;
	let instanceMapperMock;
	let cryptoFacadeMock;
	let fullyLoggedIn;
	let blobAccessTokenFacade;
	let dateProvider$1;
	dist_default.beforeEach(function() {
		cryptoFacadeMock = (0, import_testdouble$66.object)();
		(0, import_testdouble$66.when)(cryptoFacadeMock.applyMigrations(anything$12(), anything$12())).thenDo(async (typeRef, data$1) => {
			return Promise.resolve({
				...data$1,
				migrated: true
			});
		});
		(0, import_testdouble$66.when)(cryptoFacadeMock.applyMigrationsForInstance(anything$12())).thenDo((decryptedInstance) => {
			return Promise.resolve({
				...decryptedInstance,
				migratedForInstance: true
			});
		});
		(0, import_testdouble$66.when)(cryptoFacadeMock.setNewOwnerEncSessionKey(anything$12(), anything$12())).thenResolve([]);
		(0, import_testdouble$66.when)(cryptoFacadeMock.encryptBucketKeyForInternalRecipient(anything$12(), anything$12(), anything$12(), anything$12())).thenResolve(createTestEntity(InternalRecipientKeyDataTypeRef));
		(0, import_testdouble$66.when)(cryptoFacadeMock.resolveSessionKey(anything$12(), anything$12())).thenResolve([]);
		instanceMapperMock = (0, import_testdouble$66.object)();
		(0, import_testdouble$66.when)(instanceMapperMock.encryptAndMapToLiteral(anything$12(), anything$12(), anything$12())).thenDo((typeModel, instance$14, sessionKey) => {
			return Promise.resolve({
				...instance$14,
				encrypted: true
			});
		});
		(0, import_testdouble$66.when)(instanceMapperMock.decryptAndMapToInstance(anything$12(), anything$12(), anything$12())).thenDo((typeModel, migratedEntity, sessionKey) => {
			return Promise.resolve({
				...migratedEntity,
				decrypted: true
			});
		});
		blobAccessTokenFacade = (0, import_testdouble$66.instance)(BlobAccessTokenFacade);
		restClient = (0, import_testdouble$66.object)();
		fullyLoggedIn = true;
		const authDataProvider$1 = {
			createAuthHeaders() {
				return authHeader;
			},
			isFullyLoggedIn() {
				return fullyLoggedIn;
			}
		};
		dateProvider$1 = (0, import_testdouble$66.instance)(DefaultDateProvider);
		entityRestClient = new EntityRestClient(authDataProvider$1, restClient, () => cryptoFacadeMock, instanceMapperMock, blobAccessTokenFacade);
	});
	function assertThatNoRequestsWereMade() {
		(0, import_testdouble$66.verify)(restClient.request(anything$12(), anything$12()), {
			ignoreExtraArgs: true,
			times: 0
		});
	}
	dist_default.spec("Load", function() {
		dist_default("loading a list element", async function() {
			const calendarListId = "calendarListId";
			const id1 = "id1";
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CalendarEventTypeRef)}/${calendarListId}/${id1}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default.version)
				},
				responseType: MediaType.Json,
				queryParams: undefined,
				baseUrl: undefined
			})).thenResolve(JSON.stringify({ instance: "calendar" }));
			const result = await entityRestClient.load(CalendarEventTypeRef, [calendarListId, id1]);
			dist_default(result).deepEquals({
				instance: "calendar",
				decrypted: true,
				migrated: true,
				migratedForInstance: true
			});
		});
		dist_default("loading an element ", async function() {
			const id1 = "id1";
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CustomerTypeRef)}/${id1}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				responseType: MediaType.Json,
				queryParams: undefined,
				baseUrl: undefined
			})).thenResolve(JSON.stringify({ instance: "customer" }));
			const result = await entityRestClient.load(CustomerTypeRef, id1);
			dist_default(result).deepEquals({
				instance: "customer",
				decrypted: true,
				migrated: true,
				migratedForInstance: true
			});
		});
		dist_default("query parameters and additional headers + access token and version are always passed to the rest client", async function() {
			const calendarListId = "calendarListId";
			const id1 = "id1";
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CalendarEventTypeRef)}/${calendarListId}/${id1}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default.version),
					baz: "quux"
				},
				responseType: MediaType.Json,
				queryParams: { foo: "bar" },
				baseUrl: undefined
			})).thenResolve(JSON.stringify({ instance: "calendar" }));
			await entityRestClient.load(CalendarEventTypeRef, [calendarListId, id1], {
				queryParams: { foo: "bar" },
				extraHeaders: { baz: "quux" }
			});
		});
		dist_default("when loading encrypted instance and not being logged in it throws an error", async function() {
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => entityRestClient.load(CalendarEventTypeRef, ["listId", "id"]));
			assertThatNoRequestsWereMade();
		});
		dist_default("when ownerKey is passed it is used instead for session key resolution", async function() {
			const calendarListId = "calendarListId";
			const id1 = "id1";
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CalendarEventTypeRef)}/${calendarListId}/${id1}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default.version)
				},
				responseType: MediaType.Json,
				queryParams: undefined,
				baseUrl: undefined
			})).thenResolve(JSON.stringify({ _ownerEncSessionKey: "some key" }));
			const ownerKey = [
				1,
				2,
				3
			];
			const sessionKey = [
				3,
				2,
				1
			];
			(0, import_testdouble$66.when)(cryptoFacadeMock.resolveSessionKeyWithOwnerKey(anything$12(), ownerKey)).thenReturn(sessionKey);
			const result = await entityRestClient.load(CalendarEventTypeRef, [calendarListId, id1], { ownerKeyProvider: async (_) => ownerKey });
			const typeModel = await resolveTypeReference(CalendarEventTypeRef);
			(0, import_testdouble$66.verify)(instanceMapperMock.decryptAndMapToInstance(typeModel, anything$12(), sessionKey));
			(0, import_testdouble$66.verify)(cryptoFacadeMock.resolveSessionKey(anything$12(), anything$12()), { times: 0 });
			dist_default(result).deepEquals({
				_ownerEncSessionKey: "some key",
				decrypted: true,
				migrated: true,
				migratedForInstance: true
			});
		});
	});
	dist_default.spec("Load Range", function() {
		dist_default("Loads a countFrom of entities in a single request", async function() {
			const startId = "42";
			const count = 5;
			const listId = "listId";
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CalendarEventTypeRef)}/${listId}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default.version)
				},
				queryParams: {
					start: startId,
					count: String(count),
					reverse: String(false)
				},
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			})).thenResolve(JSON.stringify([{ instance: 1 }, { instance: 2 }]));
			const result = await entityRestClient.loadRange(CalendarEventTypeRef, listId, startId, count, false);
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("when loading encrypted instance list and not being logged in it throws an error", async function() {
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => entityRestClient.loadRange(CalendarEventTypeRef, "listId", "startId", 40, false));
			assertThatNoRequestsWereMade();
		});
	});
	dist_default.spec("Load multiple", function() {
		dist_default("Less than 100 entities requested should result in a single rest request", async function() {
			const ids = countFrom(0, 5);
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CustomerTypeRef)}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: "0,1,2,3,4" },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			})).thenResolve(JSON.stringify([{ instance: 1 }, { instance: 2 }]));
			const result = await entityRestClient.loadMultiple(CustomerTypeRef, null, ids);
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("Exactly 100 entities requested should result in a single rest request", async function() {
			const ids = countFrom(0, 100);
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CustomerTypeRef)}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: ids.join(",") },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 1 }, { instance: 2 }]));
			const result = await entityRestClient.loadMultiple(CustomerTypeRef, null, ids);
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("More than 100 entities requested results in 2 rest requests", async function() {
			const ids = countFrom(0, 101);
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CustomerTypeRef)}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: countFrom(0, 100).join(",") },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 1 }]));
			(0, import_testdouble$66.when)(restClient.request(`${typeRefToPath(CustomerTypeRef)}`, HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: "100" },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 2 }]));
			const result = await entityRestClient.loadMultiple(CustomerTypeRef, null, ids);
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("More than 200 entities requested results in 3 rest requests", async function() {
			const ids = countFrom(0, 211);
			(0, import_testdouble$66.when)(restClient.request(typeRefToPath(CustomerTypeRef), HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: countFrom(0, 100).join(",") },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 1 }]));
			(0, import_testdouble$66.when)(restClient.request(typeRefToPath(CustomerTypeRef), HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: countFrom(100, 100).join(",") },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 2 }]));
			(0, import_testdouble$66.when)(restClient.request(typeRefToPath(CustomerTypeRef), HttpMethod.GET, {
				headers: {
					...authHeader,
					v: String(ModelInfo_default$2.version)
				},
				queryParams: { ids: countFrom(200, 11).join(",") },
				responseType: MediaType.Json,
				baseUrl: undefined,
				suspensionBehavior: undefined
			}), { times: 1 }).thenResolve(JSON.stringify([{ instance: 3 }]));
			const result = await entityRestClient.loadMultiple(CustomerTypeRef, null, ids);
			dist_default(result).deepEquals([
				{
					instance: 1,
					decrypted: true,
					migratedForInstance: true
				},
				{
					instance: 2,
					decrypted: true,
					migratedForInstance: true
				},
				{
					instance: 3,
					decrypted: true,
					migratedForInstance: true
				}
			]);
		});
		dist_default("when loading encrypted instance list and not being logged in it throws an error", async function() {
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => entityRestClient.loadMultiple(CalendarEventTypeRef, "listId", ["startId", "anotherId"]));
			assertThatNoRequestsWereMade();
		});
		dist_default("when loading blob elements a blob access token is requested and the correct headers and parameters are set", async function() {
			const ids = countFrom(0, 5);
			const archiveId = "archiveId";
			const firstServer = "firstServer";
			const blobAccessToken = "123";
			let blobServerAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken,
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: firstServer }), createTestEntity(BlobServerUrlTypeRef, { url: "otherServer" })]
			});
			(0, import_testdouble$66.when)(blobAccessTokenFacade.requestReadTokenArchive(archiveId)).thenResolve(blobServerAccessInfo);
			(0, import_testdouble$66.when)(blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, anything$12(), anything$12())).thenDo((blobServerAccessInfo$1, authHeaders) => {
				return Object.assign({ blobAccessToken: blobServerAccessInfo$1.blobAccessToken }, authHeaders);
			});
			(0, import_testdouble$66.when)(restClient.request(anything$12(), HttpMethod.GET, anything$12())).thenResolve(JSON.stringify([{ instance: 1 }, { instance: 2 }]));
			const result = await entityRestClient.loadMultiple(MailDetailsBlobTypeRef, archiveId, ids);
			let expectedOptions = {
				headers: {},
				queryParams: {
					ids: "0,1,2,3,4",
					...authHeader,
					blobAccessToken,
					v: String(ModelInfo_default.version)
				},
				responseType: MediaType.Json,
				noCORS: true,
				baseUrl: firstServer
			};
			(0, import_testdouble$66.verify)(restClient.request(`${typeRefToPath(MailDetailsBlobTypeRef)}/${archiveId}`, HttpMethod.GET, argThat$4((optionsArg) => {
				dist_default(optionsArg.headers).deepEquals(expectedOptions.headers)("headers");
				dist_default(optionsArg.responseType).equals(expectedOptions.responseType)("responseType");
				dist_default(optionsArg.baseUrl).equals(expectedOptions.baseUrl)("baseUrl");
				dist_default(optionsArg.noCORS).equals(expectedOptions.noCORS)("noCORS");
				dist_default(optionsArg.queryParams).deepEquals({
					blobAccessToken: "123",
					...authHeader,
					ids: "0,1,2,3,4",
					v: String(ModelInfo_default.version)
				});
				return true;
			})));
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("when loading blob elements request is retried with another server url if it failed", async function() {
			const ids = countFrom(0, 5);
			const archiveId = "archiveId";
			const firstServer = "firstServer";
			const blobAccessToken = "123";
			const otherServer = "otherServer";
			const blobServerAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken,
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: firstServer }), createTestEntity(BlobServerUrlTypeRef, { url: otherServer })]
			});
			(0, import_testdouble$66.when)(blobAccessTokenFacade.requestReadTokenArchive(archiveId)).thenResolve(blobServerAccessInfo);
			(0, import_testdouble$66.when)(blobAccessTokenFacade.createQueryParams(blobServerAccessInfo, anything$12(), anything$12())).thenDo((blobServerAccessInfo$1, authHeaders) => {
				return Object.assign({ blobAccessToken: blobServerAccessInfo$1.blobAccessToken }, authHeaders);
			});
			(0, import_testdouble$66.when)(restClient.request(anything$12(), HttpMethod.GET, {
				headers: {},
				queryParams: {
					ids: "0,1,2,3,4",
					...authHeader,
					blobAccessToken,
					v: String(ModelInfo_default.version)
				},
				responseType: MediaType.Json,
				noCORS: true,
				baseUrl: firstServer,
				suspensionBehavior: undefined
			})).thenReject(new ConnectionError("test connection error for retry"));
			(0, import_testdouble$66.when)(restClient.request(anything$12(), HttpMethod.GET, {
				headers: {},
				queryParams: {
					ids: "0,1,2,3,4",
					...authHeader,
					blobAccessToken,
					v: String(ModelInfo_default.version)
				},
				responseType: MediaType.Json,
				noCORS: true,
				baseUrl: otherServer,
				suspensionBehavior: undefined
			})).thenResolve(JSON.stringify([{ instance: 1 }, { instance: 2 }]));
			const result = await entityRestClient.loadMultiple(MailDetailsBlobTypeRef, archiveId, ids);
			(0, import_testdouble$66.verify)(restClient.request(`${typeRefToPath(MailDetailsBlobTypeRef)}/${archiveId}`, HttpMethod.GET, anything$12()), { times: 2 });
			dist_default(result).deepEquals([{
				instance: 1,
				decrypted: true,
				migratedForInstance: true
			}, {
				instance: 2,
				decrypted: true,
				migratedForInstance: true
			}]);
		});
		dist_default("when loading blob elements without an archiveId it throws", async function() {
			const ids = countFrom(0, 5);
			const archiveId = null;
			let result = null;
			try {
				result = await entityRestClient.loadMultiple(MailDetailsBlobTypeRef, archiveId, ids);
				dist_default(true).equals(false)("loadMultiple should have thrown an exception");
			} catch (e) {
				dist_default(e.message).equals("archiveId must be set to load BlobElementTypes");
			}
			(0, import_testdouble$66.verify)(restClient.request(anything$12(), anything$12(), anything$12()), { times: 0 });
			(0, import_testdouble$66.verify)(blobAccessTokenFacade.requestReadTokenArchive(anything$12()), { times: 0 });
			dist_default(result).equals(null);
		});
	});
	dist_default.spec("Setup", function() {
		dist_default("Setup list entity", async function() {
			const v = (await resolveTypeReference(ContactTypeRef)).version;
			const newContact = createTestEntity(ContactTypeRef);
			const resultId = "id";
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				baseUrl: undefined,
				headers: {
					...authHeader,
					v
				},
				queryParams: undefined,
				responseType: MediaType.Json,
				body: JSON.stringify({
					...newContact,
					encrypted: true
				})
			}), { times: 1 }).thenResolve(JSON.stringify({ generatedId: resultId }));
			const result = await entityRestClient.setup("listId", newContact);
			dist_default(result).equals(resultId);
		});
		dist_default("Setup list entity throws when no listid is passed", async function() {
			const newContact = createTestEntity(ContactTypeRef);
			const result = await assertThrows(Error, async () => await entityRestClient.setup(null, newContact));
			dist_default(result.message).equals("List id must be defined for LETs");
		});
		dist_default("Setup entity", async function() {
			const v = (await resolveTypeReference(CustomerTypeRef)).version;
			const newCustomer = createTestEntity(CustomerTypeRef);
			const resultId = "id";
			(0, import_testdouble$66.when)(restClient.request(`/rest/sys/customer`, HttpMethod.POST, {
				baseUrl: undefined,
				headers: {
					...authHeader,
					v
				},
				queryParams: undefined,
				responseType: MediaType.Json,
				body: JSON.stringify({
					...newCustomer,
					encrypted: true
				})
			}), { times: 1 }).thenResolve(JSON.stringify({ generatedId: resultId }));
			const result = await entityRestClient.setup(null, newCustomer);
			dist_default(result).equals(resultId);
		});
		dist_default("Setup entity throws when listid is passed", async function() {
			const newCustomer = createTestEntity(CustomerTypeRef);
			const result = await assertThrows(Error, async () => await entityRestClient.setup("listId", newCustomer));
			dist_default(result.message).equals("List id must not be defined for ETs");
		});
		dist_default("Base URL option is passed to the rest client", async function() {
			(0, import_testdouble$66.when)(restClient.request(anything$12(), anything$12(), anything$12()), { times: 1 }).thenResolve(JSON.stringify({ generatedId: null }));
			await entityRestClient.setup("listId", createTestEntity(ContactTypeRef), undefined, { baseUrl: "some url" });
			(0, import_testdouble$66.verify)(restClient.request(anything$12(), HttpMethod.POST, argThat$4((arg) => arg.baseUrl === "some url")));
		});
		dist_default("when ownerKey is passed it is used instead for session key resolution", async function() {
			const typeModel = await resolveTypeReference(CustomerServerPropertiesTypeRef);
			const v = typeModel.version;
			const newCustomerServerProperties = createTestEntity(CustomerServerPropertiesTypeRef, { _ownerEncSessionKey: new Uint8Array([
				4,
				5,
				6
			]) });
			const resultId = "id";
			(0, import_testdouble$66.when)(restClient.request(`/rest/sys/customerserverproperties`, HttpMethod.POST, {
				baseUrl: undefined,
				headers: {
					...authHeader,
					v
				},
				queryParams: undefined,
				responseType: MediaType.Json,
				body: JSON.stringify({
					...newCustomerServerProperties,
					encrypted: true
				})
			}), { times: 1 }).thenResolve(JSON.stringify({ generatedId: resultId }));
			const ownerKey = freshVersioned([
				1,
				2,
				3
			]);
			const sessionKey = [
				3,
				2,
				1
			];
			(0, import_testdouble$66.when)(cryptoFacadeMock.setNewOwnerEncSessionKey(typeModel, anything$12(), ownerKey)).thenResolve(sessionKey);
			const result = await entityRestClient.setup(null, newCustomerServerProperties, undefined, { ownerKey });
			(0, import_testdouble$66.verify)(instanceMapperMock.encryptAndMapToLiteral(anything$12(), anything$12(), sessionKey));
			(0, import_testdouble$66.verify)(cryptoFacadeMock.resolveSessionKey(anything$12(), anything$12()), { times: 0 });
			dist_default(result).equals(resultId);
		});
	});
	dist_default.spec("Setup multiple", function() {
		dist_default("Less than 100 entities created should result in a single rest request", async function() {
			const newContacts = contacts(1);
			const resultId = "id1";
			const { version: version$1 } = await resolveTypeReference(ContactTypeRef);
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "1" },
				responseType: MediaType.Json,
				body: JSON.stringify([{
					...newContacts[0],
					encrypted: true
				}])
			}), { times: 1 }).thenResolve(JSON.stringify([{ generatedId: resultId }]));
			const result = await entityRestClient.setupMultiple("listId", newContacts);
			dist_default(result).deepEquals([resultId]);
		});
		dist_default("Exactly 100 entities created should result in a single rest request", async function() {
			const newContacts = contacts(100);
			const resultIds = countFrom(0, 100).map(String);
			const { version: version$1 } = await resolveTypeReference(ContactTypeRef);
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "100" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.map((id) => {
				return { generatedId: id };
			})));
			const result = await entityRestClient.setupMultiple("listId", newContacts);
			dist_default(result).deepEquals(resultIds);
		});
		dist_default("More than 100 entities created should result in 2 rest requests", async function() {
			const newContacts = contacts(101);
			const resultIds = countFrom(0, 101).map(String);
			const { version: version$1 } = await resolveTypeReference(ContactTypeRef);
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "100" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.slice(0, 100).map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.slice(0, 100).map((id) => {
				return { generatedId: id };
			})));
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "1" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.slice(100).map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.slice(100).map((id) => {
				return { generatedId: id };
			})));
			const result = await entityRestClient.setupMultiple("listId", newContacts);
			dist_default(result).deepEquals(resultIds);
		});
		dist_default("More than 200 entities created should result in 3 rest requests", async function() {
			const newContacts = contacts(211);
			const resultIds = countFrom(0, 211).map(String);
			const { version: version$1 } = await resolveTypeReference(ContactTypeRef);
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "100" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.slice(0, 100).map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.slice(0, 100).map((id) => {
				return { generatedId: id };
			})));
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "100" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.slice(100, 200).map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.slice(100, 200).map((id) => {
				return { generatedId: id };
			})));
			(0, import_testdouble$66.when)(restClient.request(`/rest/tutanota/contact/listId`, HttpMethod.POST, {
				headers: {
					...authHeader,
					v: version$1
				},
				queryParams: { count: "11" },
				responseType: MediaType.Json,
				body: JSON.stringify(newContacts.slice(200).map((c) => {
					return {
						...c,
						encrypted: true
					};
				}))
			}), { times: 1 }).thenResolve(JSON.stringify(resultIds.slice(200).map((id) => {
				return { generatedId: id };
			})));
			const result = await entityRestClient.setupMultiple("listId", newContacts);
			dist_default(result).deepEquals(resultIds);
		});
		dist_default("A single request is made and an error occurs, all entities should be returned as failedInstances", async function() {
			(0, import_testdouble$66.when)(restClient.request(anything$12(), anything$12(), anything$12())).thenReject(new BadRequestError("canny do et"));
			const newContacts = contacts(100);
			const result = await assertThrows(SetupMultipleError, () => entityRestClient.setupMultiple("listId", newContacts));
			dist_default(result.failedInstances.length).equals(newContacts.length);
			dist_default(result.errors.length).equals(1);
			dist_default(result.errors[0] instanceof BadRequestError).equals(true);
			dist_default(result.failedInstances).deepEquals(newContacts);
		});
		dist_default("Post multiple: An error is encountered for part of the request, only failed entities are returned in the result", async function() {
			let requestCounter = 0;
			(0, import_testdouble$66.when)(restClient.request(anything$12(), anything$12(), anything$12())).thenDo(() => {
				requestCounter += 1;
				if (requestCounter % 2 === 0) return JSON.stringify(countFrom(0, 100).map((c) => {
					return { generatedId: c };
				}));
else throw new BadRequestError("It was a bad request");
			});
			const newContacts = contacts(400);
			const result = await assertThrows(SetupMultipleError, () => entityRestClient.setupMultiple("listId", newContacts));
			(0, import_testdouble$66.verify)(restClient.request(anything$12(), anything$12()), {
				times: 4,
				ignoreExtraArgs: true
			});
			dist_default(result.failedInstances).deepEquals(newContacts.slice(0, 100).concat(newContacts.slice(200, 300)));
			dist_default(result.errors.length).equals(2);
			dist_default(result.errors.every((e) => e instanceof BadRequestError)).equals(true);
		});
		dist_default("Post multiple: When a PayloadTooLarge error occurs individual instances are posted", async function() {
			const listId = "listId";
			const idArray = [
				"0",
				null,
				"2"
			];
			let instances = [];
			for (let i = 0; i < idArray.length; i++) instances.push(createTestEntity(ContactTypeRef));
			let step = 0;
			(0, import_testdouble$66.when)(restClient.request(anything$12(), anything$12(), anything$12())).thenDo((path, method, { body }) => {
				if (body && body.startsWith("[")) throw new PayloadTooLargeError("test");
else if (step === 1) {
					step += 1;
					throw new InternalServerError("might happen");
				} else return JSON.stringify(idArray[step++]);
			});
			const result = await assertThrows(SetupMultipleError, async () => {
				return await entityRestClient.setupMultiple(listId, instances);
			});
			(0, import_testdouble$66.verify)(restClient.request(anything$12(), anything$12()), {
				ignoreExtraArgs: true,
				times: 4
			});
			dist_default(result.failedInstances.length).equals(1);
			dist_default(result.errors.length).equals(1);
			dist_default(result.errors[0] instanceof InternalServerError).equals(true);
			dist_default(result.failedInstances).deepEquals([instances[1]]);
		});
	});
	dist_default.spec("Update", function() {
		dist_default("Update entity", async function() {
			const { version: version$1 } = await resolveTypeReference(CustomerTypeRef);
			const newCustomer = createTestEntity(CustomerTypeRef, { _id: "id" });
			(0, import_testdouble$66.when)(restClient.request("/rest/sys/customer/id", HttpMethod.PUT, {
				headers: {
					...authHeader,
					v: version$1
				},
				body: JSON.stringify({
					...newCustomer,
					encrypted: true
				})
			}));
			await entityRestClient.update(newCustomer);
		});
		dist_default("Update entity throws if entity does not have an id", async function() {
			const newCustomer = createTestEntity(CustomerTypeRef);
			const result = await assertThrows(Error, async () => await entityRestClient.update(newCustomer));
			dist_default(result.message).equals("Id must be defined");
		});
		dist_default("when ownerKey is passed it is used instead for session key resolution", async function() {
			const typeModel = await resolveTypeReference(CustomerServerPropertiesTypeRef);
			const version$1 = typeModel.version;
			const ownerKeyVersion = 2;
			const newCustomerServerProperties = createTestEntity(CustomerServerPropertiesTypeRef, {
				_id: "id",
				_ownerEncSessionKey: new Uint8Array([
					4,
					5,
					6
				]),
				_ownerKeyVersion: String(ownerKeyVersion)
			});
			(0, import_testdouble$66.when)(restClient.request("/rest/sys/customerserverproperties/id", HttpMethod.PUT, {
				headers: {
					...authHeader,
					v: version$1
				},
				body: JSON.stringify({
					...newCustomerServerProperties,
					encrypted: true
				})
			}));
			const ownerKey = freshVersioned([
				1,
				2,
				3
			]);
			const sessionKey = [
				3,
				2,
				1
			];
			(0, import_testdouble$66.when)(cryptoFacadeMock.resolveSessionKeyWithOwnerKey(anything$12(), ownerKey.object)).thenReturn(sessionKey);
			await entityRestClient.update(newCustomerServerProperties, { ownerKeyProvider: async (version$2) => {
				dist_default(version$2).equals(ownerKeyVersion);
				return ownerKey.object;
			} });
			(0, import_testdouble$66.verify)(instanceMapperMock.encryptAndMapToLiteral(anything$12(), anything$12(), sessionKey));
			(0, import_testdouble$66.verify)(cryptoFacadeMock.resolveSessionKey(anything$12(), anything$12()), { times: 0 });
		});
	});
	dist_default.spec("Delete", function() {
		dist_default("Delete entity", async function() {
			const { version: version$1 } = await resolveTypeReference(CustomerTypeRef);
			const id = "id";
			const newCustomer = createTestEntity(CustomerTypeRef, { _id: id });
			(0, import_testdouble$66.when)(restClient.request("/rest/sys/customer/id", HttpMethod.DELETE, { headers: {
				...authHeader,
				v: version$1
			} }));
			await entityRestClient.erase(newCustomer);
		});
	});
	dist_default.spec("tryServers", function() {
		dist_default("tryServers successful", async function() {
			let servers = [createTestEntity(BlobServerUrlTypeRef, { url: "w1" }), createTestEntity(BlobServerUrlTypeRef, { url: "w2" })];
			const mapperMock = (0, import_testdouble$66.func)();
			const expectedResult = { response: "response-from-server" };
			(0, import_testdouble$66.when)(mapperMock(anything$12(), anything$12())).thenResolve(expectedResult);
			const result = await tryServers(servers, mapperMock, "error");
			dist_default(result).equals(expectedResult);
			(0, import_testdouble$66.verify)(mapperMock("w1", 0), { times: 1 });
			(0, import_testdouble$66.verify)(mapperMock("w2", 1), { times: 0 });
		});
		dist_default("tryServers error", async function() {
			let servers = [createTestEntity(BlobServerUrlTypeRef, { url: "w1" }), createTestEntity(BlobServerUrlTypeRef, { url: "w2" })];
			const mapperMock = (0, import_testdouble$66.func)();
			(0, import_testdouble$66.when)(mapperMock("w1", 0)).thenReject(new ProgrammingError("test"));
			const e = await assertThrows(ProgrammingError, () => tryServers(servers, mapperMock, "error"));
			dist_default(e.message).equals("test");
			(0, import_testdouble$66.verify)(mapperMock(anything$12(), anything$12()), { times: 1 });
		});
		dist_default("tryServers ConnectionError and successful response", async function() {
			let servers = [createTestEntity(BlobServerUrlTypeRef, { url: "w1" }), createTestEntity(BlobServerUrlTypeRef, { url: "w2" })];
			const mapperMock = (0, import_testdouble$66.func)();
			const expectedResult = { response: "response-from-server" };
			(0, import_testdouble$66.when)(mapperMock("w1", 0)).thenReject(new ConnectionError("test"));
			(0, import_testdouble$66.when)(mapperMock("w2", 1)).thenResolve(expectedResult);
			const result = await tryServers(servers, mapperMock, "error");
			dist_default(result).deepEquals(expectedResult);
			(0, import_testdouble$66.verify)(mapperMock(anything$12(), anything$12()), { times: 2 });
		});
		dist_default("tryServers multiple ConnectionError", async function() {
			let servers = [createTestEntity(BlobServerUrlTypeRef, { url: "w1" }), createTestEntity(BlobServerUrlTypeRef, { url: "w2" })];
			const mapperMock = (0, import_testdouble$66.func)();
			(0, import_testdouble$66.when)(mapperMock("w1", 0)).thenReject(new ConnectionError("test"));
			(0, import_testdouble$66.when)(mapperMock("w2", 1)).thenReject(new ConnectionError("test"));
			const e = await assertThrows(ConnectionError, () => tryServers(servers, mapperMock, "error log msg"));
			dist_default(e.message).equals("test");
			(0, import_testdouble$66.verify)(mapperMock(anything$12(), anything$12()), { times: 2 });
		});
	});
	dist_default.spec("doBlobRequestWithRetry", function() {
		dist_default("retry once after NotAuthorizedError, then fails", async function() {
			let blobRequestCallCount = 0;
			let evictCacheCallCount = 0;
			let errorThrown = 0;
			const doBlobRequest = async () => {
				blobRequestCallCount += 1;
				throw new NotAuthorizedError("test error");
			};
			const evictCache = () => {
				evictCacheCallCount += 1;
			};
			await doBlobRequestWithRetry(doBlobRequest, evictCache).catch(ofClass(NotAuthorizedError, (e) => {
				errorThrown += 1;
			}));
			dist_default(errorThrown).equals(1);
			dist_default(blobRequestCallCount).equals(2);
			dist_default(evictCacheCallCount).equals(1);
		});
		dist_default("retry once after NotAuthorizedError, then succeeds", async function() {
			let blobRequestCallCount = 0;
			let evictCacheCallCount = 0;
			const doBlobRequest = async () => {
				if (blobRequestCallCount === 0) {
					blobRequestCallCount += 1;
					throw new NotAuthorizedError("test error");
				}
			};
			const evictCache = () => {
				evictCacheCallCount += 1;
			};
			await doBlobRequestWithRetry(doBlobRequest, evictCache);
			dist_default(blobRequestCallCount).equals(1);
			dist_default(evictCacheCallCount).equals(1);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/RsaPqPerformanceTest.ts
const privateKey = hexToRsaPrivateKey("02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf90200816022249104e1f94e289b6284b36d8f63ee1a31806852965be0d632fc25389ac02795e88eb254f4181bc2def00f7affa5627d6bf43e37e2a56c3cc20c4bbe058cf2d3e9fa759d1f78f3f5f797fd5195644e95fad1ecac235e51e72aa59476f374952b486e9db4b818157d362e3e638ee9edca329c4336df43fd3cd327f8542d1add9798af1d6a9e8cf8f54dd0b6a6f9ed9c3f5d803c220716757871e1442ef407ffe5df44c364bf57a60551b681173747b8df8e4138101f1d048cc1941a5d4c1fd3eda5bc96496eb1892477d811b845a7c9b3333e700989a1134e8f65edbf3a8332baa7195eb6aa33591b6ab41ec8215c6487979df5cf1b9736fd4fea73eee102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7a2e7a5cc651614fd17eb10765ef63462e5767745fc849e97095319d42f8cbb1485aba0f590b33208e666e949db0465e483a122467f771a986da6855abb148d0b5c1eefb08636d0aeb36b8ec161497cc9a64704f0976aceb33d09af5408ded1aec771b534f9a27fd9dc3303146ce98872915ed730ed9661eec46b8c0d6b6d37020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a632cb2e0a17ee6e363e3e056e5170480a3790023e342cb221431be37d63e692ce572390a379cf470c8a9fa4251a0af84d746b79ff91f6dcf168417137150d93049098ef747a601825982cbbd1ac1c20b3f3ee97b25e1739c31b43e78fc1cd53134dc4e82ebf98c720c34852fbd2288370421b848575f4d054e1d1e66b47f4f02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b09e8b48e56fd2859072135f4b129f62546228914b80fed239d1f756436f3a3c4faa98b2336bf0e6ded86771cc49beb1beab0b4b2a3bf8e20385e029e083b368d4579a9322a343da9ccadbe14edc527f5ef6754273fcd088e92c4a5d30934eeaccfcf05bbe17f66acc0055b92c72db229a50f3e2db40dda0b0c17e4b9cd3e3c30200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088861ee6e7e1a7f8c1287a40ce56b3ae159b79caf7f166057fd35fd1984aead1d313eb982942d897088d4a52b606bd13b9632d7400112b0bcdcf596b9693e42ccb982acdb43a35c0abe63fd5af1a54312604fdbb365d5f2afefaad2b798d6869d6a3aa15fb8c75170f5b5fae4f72ef7089462c136c55673f12ebeab0119e97dd02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8538fe6ebe9514412692fc985f8fd62b237c51c160c3d49aeeafffa057f2feff8f29040a205895b61dfa3f6188851021dc9e50152f3ea69746f5eb491af4a6dde21db9fa2c6fa61198ea02d6b600ed4267c3871af686c8db12e4bcbaaaa552e157e66fda90d34fce11cfd0f5eea6fbb236818070fb3a13751ad408e4231f499");
const publicKey = hexToRsaPublicKey("02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf9");
const RSA_TEST_KEYPAIR = {
	keyPairType: KeyPairType.RSA,
	privateKey,
	publicKey
};
dist_default.spec("RsaPqPerformanceTest", function() {
	dist_default.spec("perf", function() {
		const iterations = 1;
		function formatNumber(x) {
			return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".");
		}
		dist_default("pq", async function() {
			const kyberFacade$1 = new WASMKyberFacade(await loadLibOQSWASM());
			const pqFacade$1 = new PQFacade(kyberFacade$1);
			const bucketKey = bitArrayToUint8Array(aes256RandomKey());
			const senderIdentityKeyPair = generateEccKeyPair();
			const recipientKeys = await pqFacade$1.generateKeyPairs();
			let start = window.performance.now();
			let pubEncBucketKey;
			for (let i = 0; i < iterations; i++) {
				const ephemeralKeyPair = generateEccKeyPair();
				pubEncBucketKey = await pqFacade$1.encapsulateAndEncode(senderIdentityKeyPair, ephemeralKeyPair, pqKeyPairsToPublicKeys(recipientKeys), bucketKey);
			}
			let end = window.performance.now();
			console.log(formatNumber((end - start) / iterations) + "ms per pq encryption");
			let decryptedBucketKey;
			for (let i = 0; i < iterations; i++) decryptedBucketKey = (await pqFacade$1.decapsulateEncoded(pubEncBucketKey, recipientKeys)).decryptedSymKeyBytes;
			end = window.performance.now();
			console.log(formatNumber((end - start) / iterations) + "ms per pq decryption");
			dist_default(bucketKey).deepEquals(decryptedBucketKey);
		});
		dist_default("rsa", async function() {
			const bucketKey = bitArrayToUint8Array(aes256RandomKey());
			const keyPair = RSA_TEST_KEYPAIR;
			let seed = new Uint8Array(32);
			crypto.getRandomValues(seed);
			let start = window.performance.now();
			let pubEncBucketKey;
			for (let i = 0; i < iterations; i++) {
				const ephemeralKeyPair = generateEccKeyPair();
				pubEncBucketKey = rsaEncrypt(keyPair.publicKey, bucketKey, seed);
			}
			let end = window.performance.now();
			console.log(formatNumber((end - start) / iterations) + "ms per rsa encryption");
			let decryptedBucketKey;
			for (let i = 0; i < iterations; i++) decryptedBucketKey = rsaDecrypt(keyPair.privateKey, pubEncBucketKey);
			end = window.performance.now();
			console.log(formatNumber((end - start) / iterations) + "ms per rsa decryption");
			dist_default(bucketKey).deepEquals(decryptedBucketKey);
		});
	});
});

//#endregion
//#region tests/api/worker/crypto/CryptoFacadeTest.ts
var import_testdouble$65 = __toESM(require_testdouble(), 1);
const { captor: captor$3, anything: anything$11, argThat: argThat$3 } = import_testdouble$65.matchers;
const kyberFacade = new WASMKyberFacade(await loadLibOQSWASM());
const pqFacade = new PQFacade(kyberFacade);
let asymmetricCryptoFacade;
const senderAddress = "hello@tutao.de";
async function prepareBucketKeyInstance(bucketEncMailSessionKey, fileSessionKeys, bk, pubEncBucketKey, recipientUser, instanceMapper, mailLiteral, senderPubEccKey, recipientKeyVersion = "0", protocolVersion = CryptoProtocolVersion.TUTA_CRYPT) {
	const MailTypeModel = await resolveTypeReference(MailTypeRef);
	const mailInstanceSessionKey = createTestEntity(InstanceSessionKeyTypeRef, {
		typeInfo: createTestEntity(TypeInfoTypeRef, {
			application: MailTypeModel.app,
			typeId: String(MailTypeModel.id)
		}),
		symEncSessionKey: bucketEncMailSessionKey,
		instanceList: "mailListId",
		instanceId: "mailId"
	});
	const FileTypeModel = await resolveTypeReference(FileTypeRef);
	const bucketEncSessionKeys = fileSessionKeys.map((fileSessionKey, index) => {
		return createTestEntity(InstanceSessionKeyTypeRef, {
			typeInfo: createTestEntity(TypeInfoTypeRef, {
				application: FileTypeModel.app,
				typeId: String(FileTypeModel.id)
			}),
			symEncSessionKey: encryptKey(bk, fileSessionKey),
			instanceList: "fileListId",
			instanceId: "fileId" + (index + 1)
		});
	});
	bucketEncSessionKeys.push(mailInstanceSessionKey);
	const bucketKey = createTestEntity(BucketKeyTypeRef, {
		pubEncBucketKey,
		keyGroup: recipientUser.userGroup._id,
		bucketEncSessionKeys,
		recipientKeyVersion,
		senderKeyVersion: senderPubEccKey != null ? senderPubEccKey.version.toString() : "0",
		protocolVersion
	});
	(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketKey.keyGroup), Number(bucketKey.recipientKeyVersion), asCryptoProtoocolVersion(bucketKey.protocolVersion), pubEncBucketKey)).thenResolve({
		decryptedAesKey: bk,
		senderIdentityPubKey: senderPubEccKey?.object ?? null
	});
	const BucketKeyModel = await resolveTypeReference(BucketKeyTypeRef);
	const bucketKeyLiteral = await instanceMapper.encryptAndMapToLiteral(BucketKeyModel, bucketKey, null);
	Object.assign(mailLiteral, { bucketKey: bucketKeyLiteral });
	return {
		MailTypeModel,
		bucketKey
	};
}
dist_default.spec("CryptoFacadeTest", function() {
	let restClient;
	let instanceMapper = new InstanceMapper();
	let serviceExecutor;
	let entityClient$1;
	let ownerEncSessionKeysUpdateQueue;
	let crypto$1;
	let userFacade;
	let keyLoaderFacade;
	let cache;
	dist_default.before(function() {
		restClient = (0, import_testdouble$65.object)();
		(0, import_testdouble$65.when)(restClient.request(anything$11(), anything$11(), anything$11())).thenResolve(undefined);
		userFacade = (0, import_testdouble$65.object)();
		keyLoaderFacade = (0, import_testdouble$65.object)();
		cache = (0, import_testdouble$65.object)();
	});
	dist_default.beforeEach(function() {
		serviceExecutor = (0, import_testdouble$65.object)();
		entityClient$1 = (0, import_testdouble$65.object)();
		asymmetricCryptoFacade = (0, import_testdouble$65.object)();
		ownerEncSessionKeysUpdateQueue = (0, import_testdouble$65.object)();
		crypto$1 = new CryptoFacade(userFacade, entityClient$1, restClient, serviceExecutor, instanceMapper, ownerEncSessionKeysUpdateQueue, cache, keyLoaderFacade, asymmetricCryptoFacade);
	});
	dist_default("resolve session key: unencrypted instance", async function() {
		const dummyDate = new Date().getTime().toString();
		const customerAccountTerminationRequestLiteral = {
			_format: 0,
			terminationDate: dummyDate,
			terminationRequestDate: dummyDate,
			customer: "customerId"
		};
		const CustomerAccountTerminationTypeModel = await resolveTypeReference(CustomerAccountTerminationRequestTypeRef);
		dist_default(await crypto$1.resolveSessionKey(CustomerAccountTerminationTypeModel, customerAccountTerminationRequestLiteral)).equals(null);
	});
	dist_default("resolve session key: _ownerEncSessionKey instance.", async function() {
		const recipientUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientUser, userFacade, keyLoaderFacade);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const sk = aes256RandomKey();
		const mail = createMailLiteral(recipientUser.mailGroupKey, sk, subject, confidential, senderName, recipientUser.name, recipientUser.mailGroup._id);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	dist_default("resolve session key: _ownerEncSessionKey instance, fetches correct version.", async function() {
		const recipientUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientUser, userFacade, keyLoaderFacade);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const sk = aes256RandomKey();
		const groupKey_v1 = aes256RandomKey();
		(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(recipientUser.mailGroup._id, 1)).thenResolve(groupKey_v1);
		const mail = createMailLiteral(groupKey_v1, sk, subject, confidential, senderName, recipientUser.name, recipientUser.mailGroup._id);
		mail._ownerKeyVersion = "1";
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	const protocolVersion = CryptoProtocolVersion.TUTA_CRYPT;
	dist_default("resolve session key: rsa public key decryption of session key.", async function() {
		dist_default.timeout(500);
		const recipientUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientUser, userFacade, keyLoaderFacade);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		let privateKey$1 = RSA_TEST_KEYPAIR.privateKey;
		let publicKey$1 = RSA_TEST_KEYPAIR.publicKey;
		const keyPair = createTestEntity(KeyPairTypeRef, {
			_id: "keyPairId",
			symEncPrivRsaKey: encryptRsaKey(recipientUser.userGroupKey, privateKey$1),
			pubRsaKey: hexToUint8Array(rsaPublicKeyToHex(RSA_TEST_KEYPAIR.publicKey))
		});
		recipientUser.userGroup.currentKeys = keyPair;
		const mail = createMailLiteral(null, sk, subject, confidential, senderName, recipientUser.name, recipientUser.mailGroup._id);
		const bucket = createTestEntity(BucketTypeRef, { bucketPermissions: "bucketPermissionListId" });
		const permission = createTestEntity(PermissionTypeRef, {
			_id: ["permissionListId", "permissionId"],
			_ownerGroup: recipientUser.userGroup._id,
			bucketEncSessionKey: encryptKey(bk, sk),
			bucket,
			type: PermissionType.Public
		});
		const pubEncBucketKey = (0, import_testdouble$65.object)();
		const bucketPermission = createTestEntity(BucketPermissionTypeRef, {
			_id: ["bucketPermissionListId", "bucketPermissionId"],
			_ownerGroup: recipientUser.userGroup._id,
			type: BucketPermissionType.Public,
			group: recipientUser.userGroup._id,
			pubEncBucketKey,
			protocolVersion,
			pubKeyVersion: "0"
		});
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketPermission.group), Number(bucketPermission.pubKeyVersion), protocolVersion, pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: null
		});
		(0, import_testdouble$65.when)(entityClient$1.loadAll(BucketPermissionTypeRef, getListId(bucketPermission))).thenResolve([bucketPermission]);
		(0, import_testdouble$65.when)(entityClient$1.loadAll(PermissionTypeRef, getListId(permission))).thenResolve([permission]);
		(0, import_testdouble$65.when)(serviceExecutor.post(UpdatePermissionKeyService, argThat$3((p) => {
			return isSameId(p.permission, permission._id) && isSameId(p.bucketPermission, bucketPermission._id);
		}))).thenResolve(undefined);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	dist_default("resolve session key: pq public key decryption of session key.", async function() {
		dist_default.timeout(500);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const recipientTestUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientTestUser, userFacade, keyLoaderFacade);
		let pqKeyPairs = await pqFacade.generateKeyPairs();
		const senderIdentityKeyPair = generateEccKeyPair();
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		const mail = createMailLiteral(null, sk, subject, confidential, senderName, recipientTestUser.name, recipientTestUser.mailGroup._id);
		const bucket = createBucket({ bucketPermissions: "bucketPermissionListId" });
		const permission = createPermission({
			_format: "",
			listElementApplication: null,
			listElementTypeId: null,
			ops: null,
			symEncSessionKey: null,
			symKeyVersion: null,
			_id: ["permissionListId", "permissionId"],
			_ownerGroup: recipientTestUser.mailGroup._id,
			bucketEncSessionKey: encryptKey(bk, sk),
			bucket,
			type: PermissionType.Public,
			_ownerEncSessionKey: null,
			_ownerKeyVersion: null,
			_permissions: "p_id",
			group: null
		});
		const pubEncBucketKey = await pqFacade.encapsulateAndEncode(senderIdentityKeyPair, generateEccKeyPair(), pqKeyPairsToPublicKeys(pqKeyPairs), bitArrayToUint8Array(bk));
		const protocolVersion$1 = CryptoProtocolVersion.RSA;
		const bucketPermission = createBucketPermission({
			_id: ["bucketPermissionListId", "bucketPermissionId"],
			_format: "",
			_permissions: "",
			_ownerGroup: recipientTestUser.mailGroup._id,
			type: BucketPermissionType.Public,
			group: recipientTestUser.userGroup._id,
			pubEncBucketKey,
			senderKeyVersion: "0",
			ownerEncBucketKey: null,
			ownerKeyVersion: null,
			protocolVersion: protocolVersion$1,
			pubKeyVersion: "0",
			symEncBucketKey: null,
			symKeyVersion: null
		});
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketPermission.group), Number(bucketPermission.pubKeyVersion), protocolVersion$1, pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: senderIdentityKeyPair.publicKey
		});
		(0, import_testdouble$65.when)(userFacade.createAuthHeaders()).thenReturn({});
		(0, import_testdouble$65.when)(restClient.request(anything$11(), HttpMethod.PUT, anything$11())).thenResolve(undefined);
		(0, import_testdouble$65.when)(entityClient$1.loadAll(BucketPermissionTypeRef, getListId(bucketPermission))).thenResolve([bucketPermission]);
		(0, import_testdouble$65.when)(entityClient$1.loadAll(PermissionTypeRef, getListId(permission))).thenResolve([permission]);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	dist_default("resolve session key: pq public key decryption of session key, fetches correct recipient key version", async function() {
		dist_default.timeout(500);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const recipientTestUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientTestUser, userFacade, keyLoaderFacade);
		const pqKeyPairs_v1 = await pqFacade.generateKeyPairs();
		const senderIdentityKeyPair = generateEccKeyPair();
		const sk = aes256RandomKey();
		const bk = aes256RandomKey();
		const mail = createMailLiteral(null, sk, subject, confidential, senderName, recipientTestUser.name, recipientTestUser.mailGroup._id);
		const bucket = createBucket({ bucketPermissions: "bucketPermissionListId" });
		const permission = createPermission({
			_format: "",
			listElementApplication: null,
			listElementTypeId: null,
			ops: null,
			symEncSessionKey: null,
			symKeyVersion: null,
			_id: ["permissionListId", "permissionId"],
			_ownerGroup: recipientTestUser.mailGroup._id,
			bucketEncSessionKey: encryptKey(bk, sk),
			bucket,
			type: PermissionType.Public,
			_ownerEncSessionKey: null,
			_ownerKeyVersion: null,
			_permissions: "p_id",
			group: null
		});
		const pubEncBucketKey = await pqFacade.encapsulateAndEncode(senderIdentityKeyPair, generateEccKeyPair(), pqKeyPairsToPublicKeys(pqKeyPairs_v1), bitArrayToUint8Array(bk));
		const protocolVersion$1 = CryptoProtocolVersion.RSA;
		const bucketPermission = createBucketPermission({
			_id: ["bucketPermissionListId", "bucketPermissionId"],
			_format: "",
			_permissions: "",
			_ownerGroup: recipientTestUser.mailGroup._id,
			type: BucketPermissionType.Public,
			group: recipientTestUser.userGroup._id,
			pubEncBucketKey,
			senderKeyVersion: "0",
			ownerEncBucketKey: null,
			ownerKeyVersion: null,
			protocolVersion: "0",
			pubKeyVersion: "1",
			symEncBucketKey: null,
			symKeyVersion: null
		});
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketPermission.group), Number(bucketPermission.pubKeyVersion), protocolVersion$1, pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: senderIdentityKeyPair.publicKey
		});
		(0, import_testdouble$65.when)(userFacade.createAuthHeaders()).thenReturn({});
		(0, import_testdouble$65.when)(restClient.request(anything$11(), HttpMethod.PUT, anything$11())).thenResolve(undefined);
		(0, import_testdouble$65.when)(entityClient$1.loadAll(BucketPermissionTypeRef, getListId(bucketPermission))).thenResolve([bucketPermission]);
		(0, import_testdouble$65.when)(entityClient$1.loadAll(PermissionTypeRef, getListId(permission))).thenResolve([permission]);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	dist_default("resolve session key: pq public key decryption of session key using bucketKey", async function() {
		dist_default.timeout(500);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const recipientTestUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientTestUser, userFacade, keyLoaderFacade);
		const pqKeyPairs_v1 = await pqFacade.generateKeyPairs();
		const senderIdentityKeyPair = generateEccKeyPair();
		const sk = aes256RandomKey();
		const bk = aes256RandomKey();
		const mail = createMailLiteral(null, sk, subject, confidential, senderName, recipientTestUser.name, recipientTestUser.mailGroup._id);
		const bucketEncMailSessionKey = encryptKey(bk, sk);
		const pubEncBucketKey = await pqFacade.encapsulateAndEncode(senderIdentityKeyPair, generateEccKeyPair(), pqKeyPairsToPublicKeys(pqKeyPairs_v1), bitArrayToUint8Array(bk));
		Object.assign(mail, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const senderKeyVersion = 1;
		await prepareBucketKeyInstance(bucketEncMailSessionKey, [], bk, pubEncBucketKey, recipientTestUser, instanceMapper, mail, {
			object: senderIdentityKeyPair.publicKey,
			version: senderKeyVersion
		}, "1", protocolVersion);
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.decryptSymKeyWithKeyPair({
			keyPairType: pqKeyPairs_v1.keyPairType,
			eccKeyPair: pqKeyPairs_v1.eccKeyPair,
			kyberKeyPair: pqKeyPairs_v1.kyberKeyPair
		}, protocolVersion, pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: senderIdentityKeyPair.publicKey
		});
		(0, import_testdouble$65.when)(userFacade.createAuthHeaders()).thenReturn({});
		(0, import_testdouble$65.when)(restClient.request(anything$11(), HttpMethod.PUT, anything$11())).thenResolve(undefined);
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.authenticateSender({
			identifier: senderAddress,
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS
		}, senderIdentityKeyPair.publicKey, senderKeyVersion)).thenResolve(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(MailTypeModel, mail));
		dist_default(sessionKey).deepEquals(sk);
	});
	dist_default("enforceSessionKeyUpdateIfNeeded: _ownerEncSessionKey already defined", async function() {
		const files = [createTestEntity(FileTypeRef, { _ownerEncSessionKey: new Uint8Array() })];
		await crypto$1.enforceSessionKeyUpdateIfNeeded({}, files);
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.postUpdateSessionKeysService(anything$11()), { times: 0 });
		(0, import_testdouble$65.verify)(cache.deleteFromCacheIfExists(anything$11(), anything$11(), anything$11()), { times: 0 });
	});
	dist_default("enforceSessionKeyUpdateIfNeeded: _ownerEncSessionKey missing", async function() {
		dist_default.timeout(500);
		const files = [createTestEntity(FileTypeRef, {
			_id: ["listId", "1"],
			_ownerEncSessionKey: new Uint8Array()
		}), createTestEntity(FileTypeRef, {
			_id: ["listId", "2"],
			_ownerEncSessionKey: null
		})];
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const mail = createTestEntity(MailTypeRef, testData.mailLiteral);
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const updatedFiles = await crypto$1.enforceSessionKeyUpdateIfNeeded(mail, files);
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.postUpdateSessionKeysService(anything$11()), { times: 1 });
		(0, import_testdouble$65.verify)(cache.deleteFromCacheIfExists(FileTypeRef, "listId", "2"));
	});
	dist_default("encryptBucketKeyForInternalRecipient with existing PQKeys for sender and recipient", async () => {
		const cryptoFacadeTmp = new CryptoFacade(userFacade, entityClient$1, restClient, serviceExecutor, instanceMapper, ownerEncSessionKeysUpdateQueue, cache, keyLoaderFacade, asymmetricCryptoFacade);
		let senderMailAddress = "alice@tutanota.com";
		let recipientMailAddress = "bob@tutanota.com";
		let senderGroupKey = aes256RandomKey();
		let bk = aes256RandomKey();
		const recipientKeyPairs = await pqFacade.generateKeyPairs();
		const recipientKeyPair = createKeyPair({
			_id: "recipientKeyPairId",
			pubEccKey: recipientKeyPairs.eccKeyPair.publicKey,
			symEncPrivEccKey: null,
			pubKyberKey: kyberPublicKeyToBytes(recipientKeyPairs.kyberKeyPair.publicKey),
			symEncPrivKyberKey: null,
			pubRsaKey: null,
			symEncPrivRsaKey: null
		});
		const senderKeyPairs = await pqFacade.generateKeyPairs();
		const senderKeyPair = createKeyPair({
			_id: "senderKeyPairId",
			pubRsaKey: null,
			symEncPrivRsaKey: null,
			pubEccKey: senderKeyPairs.eccKeyPair.publicKey,
			symEncPrivEccKey: aesEncrypt(senderGroupKey, senderKeyPairs.eccKeyPair.privateKey),
			pubKyberKey: kyberPublicKeyToBytes(senderKeyPairs.kyberKeyPair.publicKey),
			symEncPrivKyberKey: aesEncrypt(senderGroupKey, kyberPrivateKeyToBytes(senderKeyPairs.kyberKeyPair.privateKey))
		});
		const senderUserGroup = createGroup({
			_format: "",
			_ownerGroup: "",
			_permissions: "",
			admin: "admin1",
			adminGroupEncGKey: null,
			adminGroupKeyVersion: null,
			administratedGroups: null,
			archives: [],
			customer: "customer1",
			enabled: false,
			external: false,
			groupInfo: ["", ""],
			invitations: "",
			members: "",
			storageCounter: "counter1",
			type: "",
			user: "user1",
			_id: "userGroupId",
			currentKeys: senderKeyPair,
			groupKeyVersion: "0",
			formerGroupKeys: null,
			pubAdminGroupEncGKey: null
		});
		(0, import_testdouble$65.when)(keyLoaderFacade.loadCurrentKeyPair(senderUserGroup._id)).thenResolve({
			version: 0,
			object: senderKeyPairs
		});
		const notFoundRecipients = [];
		const pqEncapsulation = {
			kyberCipherText: new Uint8Array([1]),
			kekEncBucketKey: new Uint8Array([2])
		};
		const encodedPqMessage = encodePQMessage({
			senderIdentityPubKey: senderKeyPair.pubEccKey,
			ephemeralPubKey: senderKeyPair.pubEccKey,
			encapsulation: pqEncapsulation
		});
		const recipientPublicKeyGetOut = createPublicKeyGetOut({
			pubKeyVersion: "0",
			pubEccKey: recipientKeyPair.pubEccKey,
			pubKyberKey: recipientKeyPair.pubKyberKey,
			pubRsaKey: null
		});
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, createPublicKeyGetIn({
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
			identifier: recipientMailAddress,
			version: null
		}))).thenResolve(recipientPublicKeyGetOut);
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, createPublicKeyGetIn({
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
			identifier: senderMailAddress,
			version: "0"
		}))).thenResolve(createPublicKeyGetOut({
			pubKeyVersion: "0",
			pubEccKey: senderKeyPair.pubEccKey,
			pubKyberKey: senderKeyPair.pubKyberKey,
			pubRsaKey: null
		}));
		(0, import_testdouble$65.when)(entityClient$1.load(GroupTypeRef, senderUserGroup._id)).thenResolve(senderUserGroup);
		(0, import_testdouble$65.when)(keyLoaderFacade.getCurrentSymGroupKey(senderUserGroup._id)).thenResolve({
			object: senderGroupKey,
			version: 0
		});
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.asymEncryptSymKey(bk, convertToVersionedPublicKeys(recipientPublicKeyGetOut), senderUserGroup._id)).thenResolve({
			recipientKeyVersion: Number(recipientPublicKeyGetOut.pubKeyVersion),
			senderKeyVersion: Number(senderUserGroup.groupKeyVersion),
			pubEncSymKeyBytes: encodedPqMessage,
			cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT
		});
		const internalRecipientKeyData = await cryptoFacadeTmp.encryptBucketKeyForInternalRecipient(senderUserGroup._id, bk, recipientMailAddress, notFoundRecipients);
		dist_default(internalRecipientKeyData.recipientKeyVersion).equals("0");
		dist_default(internalRecipientKeyData.protocolVersion).equals(CryptoProtocolVersion.TUTA_CRYPT);
		dist_default(internalRecipientKeyData.mailAddress).equals(recipientMailAddress);
		dist_default(internalRecipientKeyData.pubEncBucketKey).deepEquals(encodedPqMessage);
		(0, import_testdouble$65.verify)(serviceExecutor.put(PublicKeyService, anything$11()), { times: 0 });
	});
	dist_default("encryptBucketKeyForInternalRecipient with existing PQKeys for sender", async () => {
		const cryptoFacadeTmp = new CryptoFacade(userFacade, entityClient$1, restClient, serviceExecutor, instanceMapper, ownerEncSessionKeysUpdateQueue, cache, keyLoaderFacade, asymmetricCryptoFacade);
		let senderMailAddress = "alice@tutanota.com";
		let recipientMailAddress = "bob@tutanota.com";
		let senderGroupKey = aes256RandomKey();
		let bk = aes256RandomKey();
		const recipientKeyPairs = RSA_TEST_KEYPAIR;
		const recipientKeyPair = createKeyPair({
			_id: "recipientKeyPairId",
			pubRsaKey: hexToUint8Array(rsaPublicKeyToHex(recipientKeyPairs.publicKey)),
			symEncPrivRsaKey: aesEncrypt(senderGroupKey, hexToUint8Array(rsaPrivateKeyToHex(recipientKeyPairs.privateKey))),
			pubEccKey: null,
			pubKyberKey: null,
			symEncPrivEccKey: null,
			symEncPrivKyberKey: null
		});
		const senderKeyPairs = await pqFacade.generateKeyPairs();
		const senderKeyPair = createKeyPair({
			_id: "senderKeyPairId",
			pubEccKey: senderKeyPairs.eccKeyPair.publicKey,
			symEncPrivEccKey: aesEncrypt(senderGroupKey, senderKeyPairs.eccKeyPair.privateKey),
			pubKyberKey: kyberPublicKeyToBytes(senderKeyPairs.kyberKeyPair.publicKey),
			symEncPrivKyberKey: aesEncrypt(senderGroupKey, kyberPrivateKeyToBytes(senderKeyPairs.kyberKeyPair.privateKey)),
			pubRsaKey: null,
			symEncPrivRsaKey: null
		});
		const senderUserGroup = createGroup({
			_id: "userGroupId",
			currentKeys: senderKeyPair,
			groupKeyVersion: "0",
			_permissions: "",
			admin: null,
			adminGroupEncGKey: null,
			adminGroupKeyVersion: null,
			administratedGroups: null,
			archives: [],
			customer: null,
			enabled: false,
			external: false,
			groupInfo: ["", ""],
			invitations: "",
			members: "",
			storageCounter: null,
			type: "",
			user: null,
			formerGroupKeys: null,
			pubAdminGroupEncGKey: null
		});
		(0, import_testdouble$65.when)(keyLoaderFacade.loadCurrentKeyPair(senderUserGroup._id)).thenResolve({
			version: 0,
			object: senderKeyPairs
		});
		const notFoundRecipients = [];
		const recipientPublicKeyGetOut = createPublicKeyGetOut({
			pubKeyVersion: "0",
			pubRsaKey: recipientKeyPair.pubRsaKey,
			pubEccKey: null,
			pubKyberKey: null
		});
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, createPublicKeyGetIn({
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
			identifier: recipientMailAddress,
			version: null
		}))).thenResolve(recipientPublicKeyGetOut);
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, createPublicKeyGetIn({
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS,
			identifier: senderMailAddress,
			version: null
		}))).thenResolve(createPublicKeyGetOut({
			pubKeyVersion: "0",
			pubEccKey: senderKeyPair.pubEccKey,
			pubKyberKey: senderKeyPair.pubKyberKey,
			_ownerGroup: "",
			pubRsaKey: null
		}));
		(0, import_testdouble$65.when)(entityClient$1.load(GroupTypeRef, senderUserGroup._id)).thenResolve(senderUserGroup);
		(0, import_testdouble$65.when)(keyLoaderFacade.getCurrentSymGroupKey(senderUserGroup._id)).thenResolve({
			object: senderGroupKey,
			version: 0
		});
		const pubEncBucketKey = (0, import_testdouble$65.object)();
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.asymEncryptSymKey(bk, convertToVersionedPublicKeys(recipientPublicKeyGetOut), senderUserGroup._id)).thenResolve({
			recipientKeyVersion: Number(recipientPublicKeyGetOut.pubKeyVersion),
			senderKeyVersion: Number(senderUserGroup.groupKeyVersion),
			pubEncSymKeyBytes: pubEncBucketKey,
			cryptoProtocolVersion: CryptoProtocolVersion.RSA
		});
		const internalRecipientKeyData = await cryptoFacadeTmp.encryptBucketKeyForInternalRecipient(senderUserGroup._id, bk, recipientMailAddress, notFoundRecipients);
		dist_default(internalRecipientKeyData.recipientKeyVersion).equals("0");
		dist_default(internalRecipientKeyData.mailAddress).equals(recipientMailAddress);
		dist_default(internalRecipientKeyData.protocolVersion).equals(CryptoProtocolVersion.RSA);
		dist_default(internalRecipientKeyData.pubEncBucketKey).deepEquals(pubEncBucketKey);
		(0, import_testdouble$65.verify)(serviceExecutor.put(PublicKeyService, anything$11()), { times: 0 });
	});
	dist_default("authenticateSender | sender is authenticated for correct SenderIdentityKey", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const senderKeyVersion = "0";
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.authenticateSender({
			identifier: senderAddress,
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS
		}, testData.senderIdentityKeyPair.publicKey, Number(senderKeyVersion))).thenResolve(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()));
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
	});
	dist_default("authenticateSender | sender is authenticated for correct SenderIdentityKey from system@tutanota.de", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest([], false);
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const senderKeyVersion = "0";
		const senderIdentifier = "system@tutanota.de";
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.authenticateSender({
			identifier: senderIdentifier,
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS
		}, testData.senderIdentityKeyPair.publicKey, Number(senderKeyVersion))).thenResolve(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()));
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
	});
	dist_default("authenticateSender | sender is not authenticated for incorrect SenderIdentityKey", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const senderKeyVersion = "0";
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.authenticateSender({
			identifier: senderAddress,
			identifierType: PublicKeyIdentifierType.MAIL_ADDRESS
		}, testData.senderIdentityKeyPair.publicKey, Number(senderKeyVersion))).thenResolve(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()));
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED);
	});
	dist_default("authenticateSender | no authentication needed for sender with RSAKeypair", async function() {
		dist_default.timeout(500);
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()), { times: 1 });
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.RSA_NO_AUTHENTICATION);
	});
	dist_default("authenticateSender | no authentication needed for secure external recipient", async function() {
		dist_default.timeout(500);
		const file1SessionKey = aes256RandomKey();
		const file2SessionKey = aes256RandomKey();
		const testData = await prepareConfidentialMailToExternalRecipient([file1SessionKey, file2SessionKey]);
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()), { times: 1 });
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.AES_NO_AUTHENTICATION);
	});
	dist_default("authenticateSender | no authentication needed for secure external sender", async function() {
		const testData = await prepareConfidentialReplyFromExternalUser();
		const externalUser = testData.externalUser;
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
		const mailCaptor = import_testdouble$65.matchers.captor();
		const userCaptor = import_testdouble$65.matchers.captor();
		(0, import_testdouble$65.verify)(keyLoaderFacade.loadSymGroupKey(externalUser.userGroup._id, Number(externalUser.mailGroup.adminGroupKeyVersion), userCaptor.capture()));
		(0, import_testdouble$65.verify)(keyLoaderFacade.loadSymGroupKey(externalUser.mailGroup._id, testData.recipientKeyVersion, mailCaptor.capture()));
		dist_default(userCaptor.value.version).equals(Number(externalUser.userGroup.groupKeyVersion));
		dist_default(mailCaptor.value.version).equals(Number(externalUser.mailGroup.groupKeyVersion));
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()), { times: 1 });
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		const mailInstanceSessionKey = updatedInstanceSessionKeys.find((instanceSessionKey) => isSameId([instanceSessionKey.instanceList, instanceSessionKey.instanceId], testData.mailLiteral._id));
		const actualAutStatus = utf8Uint8ArrayToString(aesDecrypt(testData.sk, neverNull(mailInstanceSessionKey).encryptionAuthStatus));
		dist_default(actualAutStatus).deepEquals(EncryptionAuthStatus.AES_NO_AUTHENTICATION);
	});
	dist_default.spec("instance migrations", function() {
		dist_default.beforeEach(function() {
			(0, import_testdouble$65.when)(entityClient$1.update(anything$11())).thenResolve(undefined);
		});
		dist_default("contact migration without birthday", async function() {
			const contact = createTestEntity(ContactTypeRef);
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 0 });
		});
		dist_default("contact migration without existing birthday", async function() {
			const contact = createTestEntity(ContactTypeRef, { birthdayIso: "2019-05-01" });
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("2019-05-01");
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 0 });
		});
		dist_default("contact migration without existing birthday and oldBirthdayDate", async function() {
			const contact = createTestEntity(ContactTypeRef, {
				_id: ["listid", "id"],
				birthdayIso: "2019-05-01",
				oldBirthdayDate: new Date(2e3, 4, 1)
			});
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("2019-05-01");
			dist_default(migratedContact.oldBirthdayAggregate).equals(null);
			dist_default(migratedContact.oldBirthdayDate).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 1 });
		});
		dist_default("contact migration with existing birthday and oldBirthdayAggregate", async function() {
			const contact = createTestEntity(ContactTypeRef, {
				_id: ["listid", "id"],
				birthdayIso: "2019-05-01",
				oldBirthdayAggregate: createTestEntity(BirthdayTypeRef, {
					day: "01",
					month: "05",
					year: "2000"
				})
			});
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("2019-05-01");
			dist_default(migratedContact.oldBirthdayAggregate).equals(null);
			dist_default(migratedContact.oldBirthdayDate).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 1 });
		});
		dist_default("contact migration from oldBirthdayAggregate", async function() {
			const contact = createTestEntity(ContactTypeRef, {
				_id: ["listid", "id"],
				oldBirthdayDate: new Date(1800, 4, 1),
				oldBirthdayAggregate: createTestEntity(BirthdayTypeRef, {
					day: "01",
					month: "05",
					year: "2000"
				})
			});
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("2000-05-01");
			dist_default(migratedContact.oldBirthdayAggregate).equals(null);
			dist_default(migratedContact.oldBirthdayDate).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 1 });
		});
		dist_default("contact migration from oldBirthdayDate", async function() {
			const contact = createTestEntity(ContactTypeRef, {
				_id: ["listid", "id"],
				birthdayIso: null,
				oldBirthdayDate: new Date(1800, 4, 1),
				oldBirthdayAggregate: null
			});
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("1800-05-01");
			dist_default(migratedContact.oldBirthdayAggregate).equals(null);
			dist_default(migratedContact.oldBirthdayDate).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 1 });
		});
		dist_default("contact migration from oldBirthdayAggregate without year", async function() {
			const contact = createTestEntity(ContactTypeRef, {
				_id: ["listid", "id"],
				birthdayIso: null,
				oldBirthdayDate: null,
				oldBirthdayAggregate: createTestEntity(BirthdayTypeRef, {
					day: "01",
					month: "05",
					year: null
				})
			});
			const migratedContact = await crypto$1.applyMigrationsForInstance(contact);
			dist_default(migratedContact.birthdayIso).equals("--05-01");
			dist_default(migratedContact.oldBirthdayAggregate).equals(null);
			dist_default(migratedContact.oldBirthdayDate).equals(null);
			(0, import_testdouble$65.verify)(entityClient$1.update(anything$11()), { times: 1 });
		});
	});
	dist_default("resolve session key: rsa public key decryption of mail session key using BucketKey aggregated type - Mail referencing MailBody", async function() {
		dist_default.timeout(500);
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: rsa public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsDraft", async function() {
		dist_default.timeout(500);
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetailsDraft: ["draftDetailsListId", "draftDetailsId"] });
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: rsa public key decryption of mail session key using BucketKey aggregated type - already decoded/decrypted Mail referencing MailDetailsDraft", async function() {
		dist_default.timeout(500);
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetailsDraft: ["draftDetailsListId", "draftDetailsId"] });
		const mailInstance = await instanceMapper.decryptAndMapToInstance(testData.MailTypeModel, testData.mailLiteral, testData.sk);
		const decryptAndMapToInstance = instanceMapper.decryptAndMapToInstance = spy(instanceMapper.decryptAndMapToInstance);
		const convertBucketKeyToInstanceIfNecessary = crypto$1.convertBucketKeyToInstanceIfNecessary = spy(crypto$1.convertBucketKeyToInstanceIfNecessary);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, mailInstance));
		dist_default(decryptAndMapToInstance.invocations.length).equals(0);
		dist_default(convertBucketKeyToInstanceIfNecessary.invocations.length).equals(1);
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: rsa public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsBlob", async function() {
		dist_default.timeout(500);
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: rsa public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsBlob with attachments", async function() {
		dist_default.timeout(500);
		const file1SessionKey = aes256RandomKey();
		const file2SessionKey = aes256RandomKey();
		const testData = await prepareRsaPubEncBucketKeyResolveSessionKeyTest([file1SessionKey, file2SessionKey]);
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
		dist_default(testData.bucketKey.bucketEncSessionKeys.length).equals(3);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()));
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		for (const isk of testData.bucketKey.bucketEncSessionKeys) {
			const expectedSessionKey = decryptKey(testData.bk, isk.symEncSessionKey);
			dist_default(updatedInstanceSessionKeys.some((updatedKey) => {
				let updatedSessionKey = decryptKey(testData.mailGroupKey, updatedKey.symEncSessionKey);
				return updatedKey.instanceId === isk.instanceId && updatedKey.instanceList === isk.instanceList && updatedKey.typeInfo.application === isk.typeInfo.application && updatedKey.typeInfo.typeId === isk.typeInfo.typeId && arrayEquals(updatedSessionKey, expectedSessionKey);
			})).equals(true);
		}
	});
	dist_default("resolve session key: pq public key decryption of mail session key using BucketKey aggregated type - Mail referencing MailBody", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { body: "bodyId" });
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: pq public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsDraft", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetailsDraft: ["draftDetailsListId", "draftDetailsId"] });
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: pq public key decryption of mail session key using BucketKey aggregated type - already decoded/decrypted Mail referencing MailDetailsDraft", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetailsDraft: ["draftDetailsListId", "draftDetailsId"] });
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const mailInstance = await instanceMapper.decryptAndMapToInstance(testData.MailTypeModel, testData.mailLiteral, testData.sk);
		const decryptAndMapToInstance = instanceMapper.decryptAndMapToInstance = spy(instanceMapper.decryptAndMapToInstance);
		const convertBucketKeyToInstanceIfNecessary = crypto$1.convertBucketKeyToInstanceIfNecessary = spy(crypto$1.convertBucketKeyToInstanceIfNecessary);
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, mailInstance));
		dist_default(convertBucketKeyToInstanceIfNecessary.invocations.length).equals(1);
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: pq public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsBlob", async function() {
		dist_default.timeout(500);
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest();
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const sessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(sessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: pq public key decryption of session key using BucketKey aggregated type - Mail referencing MailDetailsBlob with attachments", async function() {
		dist_default.timeout(500);
		const file1SessionKey = aes256RandomKey();
		const file2SessionKey = aes256RandomKey();
		const testData = await preparePqPubEncBucketKeyResolveSessionKeyTest([file1SessionKey, file2SessionKey]);
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		(0, import_testdouble$65.when)(serviceExecutor.get(PublicKeyService, anything$11())).thenResolve(createPublicKeyGetOut({
			pubEccKey: testData.senderIdentityKeyPair.publicKey,
			pubKeyVersion: "0",
			pubKyberKey: null,
			pubRsaKey: null
		}));
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
		dist_default(testData.bucketKey.bucketEncSessionKeys.length).equals(3);
		const updatedInstanceSessionKeysCaptor = captor$3();
		(0, import_testdouble$65.verify)(ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatedInstanceSessionKeysCaptor.capture(), anything$11()));
		const updatedInstanceSessionKeys = updatedInstanceSessionKeysCaptor.value;
		dist_default(updatedInstanceSessionKeys.length).equals(testData.bucketKey.bucketEncSessionKeys.length);
		for (const isk of testData.bucketKey.bucketEncSessionKeys) {
			const expectedSessionKey = decryptKey(testData.bk, isk.symEncSessionKey);
			if (!updatedInstanceSessionKeys.some((updatedKey) => {
				const updatedSessionKey = decryptKey(testData.mailGroupKey, updatedKey.symEncSessionKey);
				return updatedKey.instanceId === isk.instanceId && updatedKey.instanceList === isk.instanceList && updatedKey.typeInfo.application === isk.typeInfo.application && updatedKey.typeInfo.typeId === isk.typeInfo.typeId && arrayEquals(updatedSessionKey, expectedSessionKey);
			})) {
				console.log("===============================");
				updatedInstanceSessionKeys.some((updatedKey) => {
					const updatedSessionKey = decryptKey(testData.mailGroupKey, updatedKey.symEncSessionKey);
					console.log(">>>>>>>>>>>>>>>>>>>>>>>");
					console.log("1 ", updatedKey.instanceId, isk.instanceId);
					console.log("2 ", updatedKey.instanceList, isk.instanceList);
					console.log("3 ", updatedKey.typeInfo.application, isk.typeInfo.application);
					console.log("4 ", updatedKey.typeInfo.typeId, isk.typeInfo.typeId);
					console.log("5 ", updatedSessionKey, expectedSessionKey);
				});
			}
			dist_default(updatedInstanceSessionKeys.some((updatedKey) => {
				const updatedSessionKey = decryptKey(testData.mailGroupKey, updatedKey.symEncSessionKey);
				return updatedKey.instanceId === isk.instanceId && updatedKey.instanceList === isk.instanceList && updatedKey.typeInfo.application === isk.typeInfo.application && updatedKey.typeInfo.typeId === isk.typeInfo.typeId && arrayEquals(updatedSessionKey, expectedSessionKey);
			})).equals(true);
		}
	});
	dist_default("resolve session key: external user key decryption of session key using BucketKey aggregated type encrypted with MailGroupKey - Mail referencing MailDetailsBlob with attachments", async function() {
		dist_default.timeout(500);
		const file1SessionKey = aes256RandomKey();
		const file2SessionKey = aes256RandomKey();
		const testData = await prepareConfidentialMailToExternalRecipient([file1SessionKey, file2SessionKey]);
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: external user key decryption of session key using BucketKey aggregated type encrypted with UserGroupKey - Mail referencing MailDetailsBlob with attachments", async function() {
		dist_default.timeout(500);
		const file1SessionKey = aes256RandomKey();
		const file2SessionKey = aes256RandomKey();
		const testData = await prepareConfidentialMailToExternalRecipient([file1SessionKey, file2SessionKey], true);
		Object.assign(testData.mailLiteral, { mailDetails: ["mailDetailsArchiveId", "mailDetailsId"] });
		const mailSessionKey = neverNull(await crypto$1.resolveSessionKey(testData.MailTypeModel, testData.mailLiteral));
		dist_default(mailSessionKey).deepEquals(testData.sk);
	});
	dist_default("resolve session key: MailDetailsBlob", async function() {
		const gk = aes256RandomKey();
		const sk = aes256RandomKey();
		const ownerGroup = "mailGroupId";
		(0, import_testdouble$65.when)(keyLoaderFacade.getCurrentSymGroupKey(ownerGroup)).thenResolve({
			object: gk,
			version: 0
		});
		(0, import_testdouble$65.when)(userFacade.hasGroup(ownerGroup)).thenReturn(true);
		(0, import_testdouble$65.when)(userFacade.isFullyLoggedIn()).thenReturn(true);
		const MailDetailsBlobTypeModel = await resolveTypeReference(MailDetailsBlobTypeRef);
		const mailDetailsBlobLiteral = {
			_id: ["mailDetailsArchiveId", "mailDetailsId"],
			_ownerGroup: ownerGroup,
			_ownerEncSessionKey: encryptKey(gk, sk)
		};
		(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(ownerGroup, 0)).thenResolve(gk);
		const mailDetailsBlobSessionKey = neverNull(await crypto$1.resolveSessionKey(MailDetailsBlobTypeModel, mailDetailsBlobLiteral));
		dist_default(mailDetailsBlobSessionKey).deepEquals(sk);
	});
	dist_default("resolve session key: MailDetailsBlob - session key not found", async function() {
		const MailDetailsBlobTypeModel = await resolveTypeReference(MailDetailsBlobTypeRef);
		const mailDetailsBlobLiteral = {
			_id: ["mailDetailsArchiveId", "mailDetailsId"],
			_permissions: "permissionListId"
		};
		(0, import_testdouble$65.when)(entityClient$1.loadAll(PermissionTypeRef, "permissionListId")).thenResolve([]);
		try {
			await crypto$1.resolveSessionKey(MailDetailsBlobTypeModel, mailDetailsBlobLiteral);
			dist_default(true).equals(false);
		} catch (error) {
			dist_default(error.constructor).equals(SessionKeyNotFoundError);
		}
	});
	/**
	* Prepares the environment to test receiving rsa asymmetric encrypted emails that have been sent with the simplified permission system.
	*  - Creates key pair for the recipient user
	*  - Creates group, bucket and session keys
	*  - Creates mail literal and encrypts all encrypted attributes of the mail
	*  - Create BucketKey object on the mail
	*
	* @param fileSessionKeys List of session keys for the attachments. When the list is empty there are no attachments
	*/
	async function prepareRsaPubEncBucketKeyResolveSessionKeyTest(fileSessionKeys = []) {
		const recipientUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientUser, userFacade, keyLoaderFacade);
		let privateKey$1 = RSA_TEST_KEYPAIR.privateKey;
		let publicKey$1 = RSA_TEST_KEYPAIR.publicKey;
		const keyPair = createTestEntity(KeyPairTypeRef, {
			_id: "keyPairId",
			symEncPrivRsaKey: encryptRsaKey(recipientUser.userGroupKey, privateKey$1),
			pubRsaKey: hexToUint8Array(rsaPublicKeyToHex(publicKey$1))
		});
		recipientUser.userGroup.currentKeys = keyPair;
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		const mailLiteral = createMailLiteral(null, sk, subject, confidential, senderName, recipientUser.name, recipientUser.mailGroup._id);
		const pubEncBucketKey = new Uint8Array([
			1,
			2,
			3,
			4
		]);
		const bucketEncMailSessionKey = encryptKey(bk, sk);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const mailInstanceSessionKey = createInstanceSessionKey({
			typeInfo: createTypeInfo({
				application: MailTypeModel.app,
				typeId: String(MailTypeModel.id)
			}),
			symEncSessionKey: bucketEncMailSessionKey,
			instanceList: "mailListId",
			instanceId: "mailId",
			encryptionAuthStatus: null,
			symKeyVersion: "0"
		});
		const FileTypeModel = await resolveTypeReference(FileTypeRef);
		const bucketEncSessionKeys = fileSessionKeys.map((fileSessionKey, index) => {
			return createInstanceSessionKey({
				typeInfo: createTypeInfo({
					application: FileTypeModel.app,
					typeId: String(FileTypeModel.id)
				}),
				symEncSessionKey: encryptKey(bk, fileSessionKey),
				symKeyVersion: "0",
				instanceList: "fileListId",
				instanceId: "fileId" + (index + 1),
				encryptionAuthStatus: null
			});
		});
		bucketEncSessionKeys.push(mailInstanceSessionKey);
		const protocolVersion$1 = CryptoProtocolVersion.RSA;
		const bucketKey = createBucketKey({
			pubEncBucketKey,
			keyGroup: recipientUser.userGroup._id,
			bucketEncSessionKeys,
			groupEncBucketKey: null,
			protocolVersion: protocolVersion$1,
			senderKeyVersion: null,
			recipientKeyVersion: "0"
		});
		const BucketKeyModel = await resolveTypeReference(BucketKeyTypeRef);
		const bucketKeyLiteral = await instanceMapper.encryptAndMapToLiteral(BucketKeyModel, bucketKey, null);
		Object.assign(mailLiteral, { bucketKey: bucketKeyLiteral });
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketKey.keyGroup), Number(bucketKey.recipientKeyVersion), asCryptoProtoocolVersion(bucketKey.protocolVersion), pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: null
		});
		return {
			mailLiteral,
			bucketKey,
			sk,
			bk,
			mailGroupKey: recipientUser.mailGroupKey,
			MailTypeModel
		};
	}
	/**
	* Prepares the environment to test receiving pq asymmetric encrypted emails that have been sent with the simplified permission system.
	*  - Creates key pair for the recipient user
	*  - Creates group, bucket and session keys
	*  - Creates mail literal and encrypts all encrypted attributes of the mail
	*  - Create BucketKey object on the mail
	*
	* @param fileSessionKeys List of session keys for the attachments. When the list is empty there are no attachments
	*/
	async function preparePqPubEncBucketKeyResolveSessionKeyTest(fileSessionKeys = [], confidential = true) {
		const recipientUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(recipientUser, userFacade, keyLoaderFacade);
		let pqKeyPairs = await pqFacade.generateKeyPairs();
		const recipientKeyPair = createKeyPair({
			_id: "keyPairId",
			pubEccKey: pqKeyPairs.eccKeyPair.publicKey,
			symEncPrivEccKey: aesEncrypt(recipientUser.userGroupKey, pqKeyPairs.eccKeyPair.privateKey),
			pubKyberKey: kyberPublicKeyToBytes(pqKeyPairs.kyberKeyPair.publicKey),
			symEncPrivKyberKey: aesEncrypt(recipientUser.userGroupKey, kyberPrivateKeyToBytes(pqKeyPairs.kyberKeyPair.privateKey)),
			pubRsaKey: null,
			symEncPrivRsaKey: null
		});
		recipientUser.userGroup.currentKeys = recipientKeyPair;
		const senderIdentityKeyPair = generateEccKeyPair();
		let subject = "this is our subject";
		let senderName = "TutanotaTeam";
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		const mailLiteral = createMailLiteral(recipientUser.mailGroupKey, sk, subject, confidential, senderName, recipientUser.name, recipientUser.mailGroup._id);
		mailLiteral._ownerEncSessionKey = null;
		const pubEncBucketKey = await pqFacade.encapsulateAndEncode(senderIdentityKeyPair, generateEccKeyPair(), pqKeyPairsToPublicKeys(pqKeyPairs), bitArrayToUint8Array(bk));
		const bucketEncMailSessionKey = encryptKey(bk, sk);
		const { MailTypeModel, bucketKey } = await prepareBucketKeyInstance(bucketEncMailSessionKey, fileSessionKeys, bk, pubEncBucketKey, recipientUser, instanceMapper, mailLiteral);
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.decryptSymKeyWithKeyPair({
			keyPairType: pqKeyPairs.keyPairType,
			eccKeyPair: pqKeyPairs.eccKeyPair,
			kyberKeyPair: pqKeyPairs.kyberKeyPair
		}, CryptoProtocolVersion.TUTA_CRYPT, pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: senderIdentityKeyPair.publicKey
		});
		(0, import_testdouble$65.when)(asymmetricCryptoFacade.loadKeyPairAndDecryptSymKey(assertNotNull(bucketKey.keyGroup), Number(bucketKey.recipientKeyVersion), asCryptoProtoocolVersion(bucketKey.protocolVersion), pubEncBucketKey)).thenResolve({
			decryptedAesKey: bk,
			senderIdentityPubKey: senderIdentityKeyPair.publicKey
		});
		return {
			mailLiteral,
			bucketKey,
			sk,
			bk,
			mailGroupKey: recipientUser.mailGroupKey,
			MailTypeModel,
			senderIdentityKeyPair
		};
	}
	/**
	* Prepares the environment to test receiving symmetric encrypted emails (mails sent from internal to external user) that have been sent with the simplified permission system.
	*  - Creates group, bucket and session keys
	*  - Creates mail literal and encrypts all encrypted attributes of the mail
	*  - Create BucketKey object on the mail
	*
	* @param fileSessionKeys List of session keys for the attachments. When the list is empty there are no attachments
	* @param externalUserGroupEncBucketKey for legacy external user group to encrypt bucket key
	*/
	async function prepareConfidentialMailToExternalRecipient(fileSessionKeys = [], externalUserGroupEncBucketKey = false) {
		const externalUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(externalUser, userFacade, keyLoaderFacade);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		const mailLiteral = createMailLiteral(null, sk, subject, confidential, senderName, externalUser.name, externalUser.mailGroup._id);
		const groupKeyToEncryptBucketKey = externalUserGroupEncBucketKey ? externalUser.userGroupKey : externalUser.mailGroupKey;
		const groupEncBucketKey = encryptKey(groupKeyToEncryptBucketKey, bk);
		const bucketEncMailSessionKey = encryptKey(bk, sk);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const mailInstanceSessionKey = createTestEntity(InstanceSessionKeyTypeRef, {
			typeInfo: createTestEntity(TypeInfoTypeRef, {
				application: MailTypeModel.app,
				typeId: String(MailTypeModel.id)
			}),
			symEncSessionKey: bucketEncMailSessionKey,
			instanceList: "mailListId",
			instanceId: "mailId"
		});
		const FileTypeModel = await resolveTypeReference(FileTypeRef);
		const bucketEncSessionKeys = fileSessionKeys.map((fileSessionKey, index) => {
			return createTestEntity(InstanceSessionKeyTypeRef, {
				typeInfo: createTestEntity(TypeInfoTypeRef, {
					application: FileTypeModel.app,
					typeId: String(FileTypeModel.id)
				}),
				symEncSessionKey: encryptKey(bk, fileSessionKey),
				instanceList: "fileListId",
				instanceId: "fileId" + (index + 1)
			});
		});
		bucketEncSessionKeys.push(mailInstanceSessionKey);
		const bucketKey = createTestEntity(BucketKeyTypeRef, {
			pubEncBucketKey: null,
			keyGroup: externalUserGroupEncBucketKey ? externalUser.userGroup._id : null,
			groupEncBucketKey,
			bucketEncSessionKeys
		});
		const BucketKeyModel = await resolveTypeReference(BucketKeyTypeRef);
		const bucketKeyLiteral = await instanceMapper.encryptAndMapToLiteral(BucketKeyModel, bucketKey, null);
		Object.assign(mailLiteral, { bucketKey: bucketKeyLiteral });
		return {
			mailLiteral,
			bucketKey,
			sk,
			bk,
			MailTypeModel
		};
	}
	/**
	* Prepares the environment to test receiving symmetric encrypted emails from an external sender(mails sent from external to internal user) that have been sent with the simplified permission system.
	*  - Creates group, bucket and session keys
	*  - Creates mail literal and encrypts all encrypted attributes of the mail
	*  - Create BucketKey object on the mail
	*
	* @param fileSessionKeys List of session keys for the attachments. When the list is empty there are no attachments
	*/
	async function prepareConfidentialReplyFromExternalUser() {
		const internalUser = createTestUser("Alice", entityClient$1);
		const externalUser = createTestUser("Bob", entityClient$1);
		externalUser.userGroup.admin = internalUser.userGroup._id;
		externalUser.userGroup.adminGroupEncGKey = encryptKey(internalUser.userGroupKey, externalUser.userGroupKey);
		externalUser.userGroup.adminGroupKeyVersion = "0";
		externalUser.mailGroup.admin = externalUser.userGroup._id;
		externalUser.mailGroup.adminGroupEncGKey = encryptKey(externalUser.userGroupKey, externalUser.mailGroupKey);
		externalUser.mailGroup.adminGroupKeyVersion = "4";
		const recipientKeyVersion = "5";
		externalUser.userGroup.groupKeyVersion = "7";
		externalUser.mailGroup.groupKeyVersion = "8";
		configureLoggedInUser(internalUser, userFacade, keyLoaderFacade);
		(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(externalUser.mailGroup._id, Number(recipientKeyVersion), anything$11())).thenResolve(externalUser.mailGroupKey);
		(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(externalUser.userGroup._id, Number(externalUser.mailGroup.adminGroupKeyVersion), anything$11())).thenResolve(externalUser.userGroupKey);
		let subject = "this is our subject";
		let confidential = true;
		let sk = aes256RandomKey();
		let bk = aes256RandomKey();
		const mailLiteral = createMailLiteral(null, sk, subject, confidential, externalUser.name, internalUser.name, internalUser.mailGroup._id);
		const keyGroup = externalUser.mailGroup._id;
		const groupEncBucketKey = encryptKey(externalUser.mailGroupKey, bk);
		const bucketEncMailSessionKey = encryptKey(bk, sk);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const mailInstanceSessionKey = createTestEntity(InstanceSessionKeyTypeRef, {
			typeInfo: createTestEntity(TypeInfoTypeRef, {
				application: MailTypeModel.app,
				typeId: String(MailTypeModel.id)
			}),
			symEncSessionKey: bucketEncMailSessionKey,
			instanceList: "mailListId",
			instanceId: "mailId"
		});
		const bucketEncSessionKeys = new Array();
		bucketEncSessionKeys.push(mailInstanceSessionKey);
		const bucketKey = createTestEntity(BucketKeyTypeRef, {
			pubEncBucketKey: null,
			keyGroup,
			groupEncBucketKey,
			recipientKeyVersion,
			bucketEncSessionKeys,
			protocolVersion: CryptoProtocolVersion.SYMMETRIC_ENCRYPTION,
			senderKeyVersion: null
		});
		const BucketKeyModel = await resolveTypeReference(BucketKeyTypeRef);
		const bucketKeyLiteral = await instanceMapper.encryptAndMapToLiteral(BucketKeyModel, bucketKey, null);
		Object.assign(mailLiteral, { bucketKey: bucketKeyLiteral });
		return {
			mailLiteral,
			bucketKey,
			sk,
			bk,
			MailTypeModel,
			internalUser,
			externalUser,
			recipientKeyVersion: Number(recipientKeyVersion)
		};
	}
});
function createMailLiteral(ownerGroupKey, sessionKey, subject, confidential, senderName, recipientName, ownerGroupId) {
	return {
		_format: "0",
		_area: "0",
		_owner: "ownerId",
		_ownerGroup: ownerGroupId,
		_ownerEncSessionKey: ownerGroupKey ? encryptKey(ownerGroupKey, sessionKey) : null,
		_id: ["mailListId", "mailId"],
		_permissions: "permissionListId",
		receivedDate: new Date(1470039025474).getTime().toString(),
		sentDate: new Date(1470039021474).getTime().toString(),
		state: "",
		trashed: false,
		unread: true,
		subject: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(subject), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC)),
		replyType: "",
		confidential: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(confidential ? "1" : "0"), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC)),
		sender: {
			_id: "senderId",
			address: senderAddress,
			name: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(senderName), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC))
		},
		bccRecipients: [],
		ccRecipients: [],
		toRecipients: [{
			_id: "recipientId",
			address: "support@yahoo.com",
			name: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(recipientName), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC))
		}],
		replyTos: [],
		bucketKey: null,
		attachmentCount: "0",
		authStatus: "0",
		listUnsubscribe: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(""), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC)),
		method: uint8ArrayToBase64(aesEncrypt(sessionKey, stringToUtf8Uint8Array(""), random.generateRandomData(IV_BYTE_LENGTH), true, ENABLE_MAC)),
		phishingStatus: "0",
		recipientCount: "0"
	};
}
function createTestUser(name, entityClient$1) {
	const userGroupKey = aes256RandomKey();
	const mailGroupKey = aes256RandomKey();
	const userGroup = createTestEntity(GroupTypeRef, {
		_id: "userGroup" + name,
		type: GroupType.User,
		currentKeys: null,
		groupKeyVersion: "0"
	});
	const mailGroup = createTestEntity(GroupTypeRef, {
		_id: "mailGroup" + name,
		type: GroupType.Mail,
		currentKeys: null,
		groupKeyVersion: "0"
	});
	const userGroupMembership = createTestEntity(GroupMembershipTypeRef, { group: userGroup._id });
	const mailGroupMembership = createTestEntity(GroupMembershipTypeRef, { group: mailGroup._id });
	const user = createTestEntity(UserTypeRef, {
		userGroup: userGroupMembership,
		memberships: [mailGroupMembership]
	});
	(0, import_testdouble$65.when)(entityClient$1.load(GroupTypeRef, userGroup._id)).thenResolve(userGroup);
	(0, import_testdouble$65.when)(entityClient$1.load(GroupTypeRef, mailGroup._id)).thenResolve(mailGroup);
	return {
		user,
		userGroup,
		mailGroup,
		userGroupKey,
		mailGroupKey,
		name
	};
}
function configureLoggedInUser(testUser, userFacade, keyLoaderFacade) {
	(0, import_testdouble$65.when)(userFacade.getLoggedInUser()).thenReturn(testUser.user);
	(0, import_testdouble$65.when)(keyLoaderFacade.getCurrentSymGroupKey(testUser.mailGroup._id)).thenResolve({
		object: testUser.mailGroupKey,
		version: 0
	});
	(0, import_testdouble$65.when)(keyLoaderFacade.getCurrentSymGroupKey(testUser.userGroup._id)).thenResolve({
		object: testUser.userGroupKey,
		version: 0
	});
	(0, import_testdouble$65.when)(userFacade.hasGroup(testUser.userGroup._id)).thenReturn(true);
	(0, import_testdouble$65.when)(userFacade.hasGroup(testUser.mailGroup._id)).thenReturn(true);
	(0, import_testdouble$65.when)(userFacade.getCurrentUserGroupKey()).thenReturn({
		object: testUser.userGroupKey,
		version: 0
	});
	(0, import_testdouble$65.when)(userFacade.isLeader()).thenReturn(true);
	(0, import_testdouble$65.when)(userFacade.isFullyLoggedIn()).thenReturn(true);
	(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(testUser.mailGroup._id, 0)).thenResolve(testUser.mailGroupKey);
	(0, import_testdouble$65.when)(keyLoaderFacade.loadSymGroupKey(testUser.userGroup._id, 0)).thenResolve(testUser.userGroupKey);
}

//#endregion
//#region tests/api/worker/crypto/AsymmetricCryptoFacadeTest.ts
var import_testdouble$64 = __toESM(require_testdouble(), 1);
otest_default.spec("AsymmetricCryptoFacadeTest", function() {
	let rsa;
	let pqFacade$1;
	let keyLoaderFacade;
	let cryptoWrapper;
	let serviceExecutor;
	let asymmetricCryptoFacade$1;
	otest_default.beforeEach(function() {
		rsa = (0, import_testdouble$64.object)();
		pqFacade$1 = (0, import_testdouble$64.object)();
		keyLoaderFacade = (0, import_testdouble$64.object)();
		cryptoWrapper = (0, import_testdouble$64.object)();
		serviceExecutor = (0, import_testdouble$64.object)();
		asymmetricCryptoFacade$1 = new AsymmetricCryptoFacade(rsa, pqFacade$1, keyLoaderFacade, cryptoWrapper, serviceExecutor);
	});
	otest_default.spec("authenticateSender", function() {
		let identifier;
		let identifierType;
		let senderIdentityPubKey;
		let senderKeyVersion;
		let keyData;
		otest_default.beforeEach(() => {
			identifier = (0, import_testdouble$64.object)();
			identifierType = (0, import_testdouble$64.object)();
			senderIdentityPubKey = new Uint8Array([
				1,
				2,
				3
			]);
			senderKeyVersion = 0;
			keyData = createPublicKeyGetIn({
				identifier,
				identifierType,
				version: senderKeyVersion.toString()
			});
		});
		otest_default("should return TUTACRYPT_AUTHENTICATION_SUCCEEDED if the key matches", async function() {
			(0, import_testdouble$64.when)(serviceExecutor.get(PublicKeyService, keyData)).thenResolve({ pubEccKey: senderIdentityPubKey });
			const result = await asymmetricCryptoFacade$1.authenticateSender({
				identifier,
				identifierType
			}, senderIdentityPubKey, senderKeyVersion);
			otest_default(result).equals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED);
		});
		otest_default("should return TUTACRYPT_AUTHENTICATION_FAILED if sender does not have an ecc identity key in the requested version", async function() {
			(0, import_testdouble$64.when)(serviceExecutor.get(PublicKeyService, keyData)).thenResolve({
				pubEccKey: null,
				pubRsaKey: new Uint8Array([
					4,
					5,
					6
				]),
				pubKyberKey: null
			});
			const result = await asymmetricCryptoFacade$1.authenticateSender({
				identifier,
				identifierType
			}, senderIdentityPubKey, senderKeyVersion);
			otest_default(result).equals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED);
		});
		otest_default("should return TUTACRYPT_AUTHENTICATION_FAILED if the key does not match", async function() {
			(0, import_testdouble$64.when)(serviceExecutor.get(PublicKeyService, keyData)).thenResolve({ pubEccKey: new Uint8Array([
				4,
				5,
				6
			]) });
			const result = await asymmetricCryptoFacade$1.authenticateSender({
				identifier,
				identifierType
			}, senderIdentityPubKey, senderKeyVersion);
			otest_default(result).equals(EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED);
		});
	});
	otest_default.spec("decryptSymKeyWithKeyPairAndAuthenticate", function() {
		otest_default("should throw CryptoError if authentication fails", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			const symKey = new Uint8Array([
				1,
				2,
				3,
				4
			]);
			const keyPair = (0, import_testdouble$64.object)();
			keyPair.keyPairType = KeyPairType.TUTA_CRYPT;
			const senderKeyVersion = "1";
			const senderIdentifier = (0, import_testdouble$64.object)();
			const senderIdentifierType = PublicKeyIdentifierType.GROUP_ID;
			const recipientIdentifier = (0, import_testdouble$64.object)();
			const recipientIdentifierType = PublicKeyIdentifierType.MAIL_ADDRESS;
			const pubEncKeyData = createTestEntity(PubEncKeyDataTypeRef, {
				pubEncSymKey,
				protocolVersion: CryptoProtocolVersion.TUTA_CRYPT,
				senderKeyVersion,
				recipientIdentifier,
				recipientIdentifierType
			});
			(0, import_testdouble$64.when)(pqFacade$1.decapsulateEncoded(pubEncSymKey, keyPair)).thenResolve({
				decryptedSymKeyBytes: symKey,
				senderIdentityPubKey: (0, import_testdouble$64.object)()
			});
			(0, import_testdouble$64.when)(serviceExecutor.get(PublicKeyService, createPublicKeyGetIn({
				version: senderKeyVersion,
				identifierType: senderIdentifierType,
				identifier: senderIdentifier
			}))).thenResolve({ pubEccKey: new Uint8Array([
				4,
				5,
				6
			]) });
			await assertThrows(CryptoError, () => asymmetricCryptoFacade$1.decryptSymKeyWithKeyPairAndAuthenticate(keyPair, pubEncKeyData, {
				identifier: senderIdentifier,
				identifierType: senderIdentifierType
			}));
		});
		otest_default("should not try authentication when protocol is not TutaCrypt", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			const pubEncKeyData = createTestEntity(PubEncKeyDataTypeRef, {
				pubEncSymKey,
				protocolVersion: CryptoProtocolVersion.RSA,
				senderKeyVersion: null
			});
			const senderIdentifier = (0, import_testdouble$64.object)();
			const senderIdentifierType = PublicKeyIdentifierType.GROUP_ID;
			const symKey = new Uint8Array([
				1,
				2,
				3,
				4
			]);
			(0, import_testdouble$64.when)(rsa.decrypt(RSA_TEST_KEYPAIR.privateKey, pubEncSymKey)).thenResolve(symKey);
			const result = await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPairAndAuthenticate(RSA_TEST_KEYPAIR, pubEncKeyData, {
				identifier: senderIdentifier,
				identifierType: senderIdentifierType
			});
			(0, import_testdouble$64.verify)(serviceExecutor.get(PublicKeyService, import_testdouble$64.matchers.anything()), { times: 0 });
			otest_default(result).deepEquals({
				senderIdentityPubKey: null,
				decryptedAesKey: uint8ArrayToBitArray(symKey)
			});
		});
	});
	otest_default.spec("decryptSymKeyWithKeyPair", function() {
		otest_default("should raise a CryptoError when the protocol version is unknown", async function() {
			await assertThrows(CryptoError, async function() {
				await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPair((0, import_testdouble$64.object)(), "unknown", (0, import_testdouble$64.object)());
			});
		});
		otest_default("should call RSA decryption when the protocol version is set to RSA", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			(0, import_testdouble$64.when)(rsa.decrypt(RSA_TEST_KEYPAIR.privateKey, pubEncSymKey)).thenResolve(new Uint8Array([
				1,
				2,
				3,
				4
			]));
			await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPair(RSA_TEST_KEYPAIR, CryptoProtocolVersion.RSA, pubEncSymKey);
			(0, import_testdouble$64.verify)(rsa.decrypt(RSA_TEST_KEYPAIR.privateKey, pubEncSymKey), { times: 1 });
		});
		otest_default("should raise a Crypto Error when trying to decypher a RSA that is not an RSA KeyPair", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			const keyPair = (0, import_testdouble$64.object)();
			keyPair.keyPairType = KeyPairType.TUTA_CRYPT;
			await assertThrows(CryptoError, async function() {
				await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPair(keyPair, CryptoProtocolVersion.RSA, pubEncSymKey);
			});
		});
		otest_default("should call tuta crypt decryption when the protocol version is set to TUTA_CRYPT", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			const keyPair = (0, import_testdouble$64.object)();
			keyPair.keyPairType = KeyPairType.TUTA_CRYPT;
			(0, import_testdouble$64.when)(pqFacade$1.decapsulateEncoded(pubEncSymKey, keyPair)).thenResolve({
				decryptedSymKeyBytes: new Uint8Array([
					1,
					2,
					3,
					4
				]),
				senderIdentityPubKey: (0, import_testdouble$64.object)()
			});
			await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPair(keyPair, CryptoProtocolVersion.TUTA_CRYPT, pubEncSymKey);
			(0, import_testdouble$64.verify)(pqFacade$1.decapsulateEncoded(pubEncSymKey, keyPair), { times: 1 });
		});
		otest_default("should raise a Crypto Error when trying to decypher a TutaCrypt that is not an TutaCrypt KeyPair", async function() {
			const pubEncSymKey = (0, import_testdouble$64.object)();
			const keyPair = (0, import_testdouble$64.object)();
			keyPair.keyPairType = KeyPairType.RSA;
			await assertThrows(CryptoError, async function() {
				await asymmetricCryptoFacade$1.decryptSymKeyWithKeyPair(keyPair, CryptoProtocolVersion.TUTA_CRYPT, pubEncSymKey);
			});
		});
	});
	otest_default.spec("encryptPubSymKey", function() {
		const recipientKeyVersion = 1;
		const senderKeyVersion = 2;
		const senderGroupId = "senderGroupId";
		let symKey;
		let pubEncSymKeyBytes;
		let recipientKyberPublicKey;
		let senderPqKeyPair;
		let ephemeralKeyPair;
		otest_default.beforeEach(function() {
			recipientKyberPublicKey = (0, import_testdouble$64.object)();
			symKey = [
				1,
				2,
				3,
				4
			];
			pubEncSymKeyBytes = (0, import_testdouble$64.object)();
			senderPqKeyPair = {
				object: {
					keyPairType: KeyPairType.TUTA_CRYPT,
					eccKeyPair: (0, import_testdouble$64.object)(),
					kyberKeyPair: (0, import_testdouble$64.object)()
				},
				version: senderKeyVersion
			};
			ephemeralKeyPair = (0, import_testdouble$64.object)();
			(0, import_testdouble$64.when)(cryptoWrapper.generateEccKeyPair()).thenReturn(ephemeralKeyPair);
			(0, import_testdouble$64.when)(keyLoaderFacade.loadCurrentKeyPair(senderGroupId)).thenResolve(senderPqKeyPair);
		});
		otest_default("should raise a CryptoError when the key pair type is unknown", async function() {
			await assertThrows(CryptoError, async function() {
				await asymmetricCryptoFacade$1.asymEncryptSymKey(symKey, (0, import_testdouble$64.object)(), senderGroupId);
			});
		});
		otest_default("should encrypt the sym key with the recipient PQ public key", async function() {
			const pubKyberKey = new Uint8Array([
				1,
				2,
				3,
				4
			]);
			const eccPublicKey = new Uint8Array([
				5,
				6,
				7,
				8
			]);
			const recipientPublicKeys = {
				object: {
					pubKyberKey,
					pubEccKey: eccPublicKey,
					pubRsaKey: null
				},
				version: recipientKeyVersion
			};
			(0, import_testdouble$64.when)(cryptoWrapper.bytesToKyberPublicKey(pubKyberKey)).thenReturn(recipientKyberPublicKey);
			(0, import_testdouble$64.when)(pqFacade$1.encapsulateAndEncode(senderPqKeyPair.object.eccKeyPair, ephemeralKeyPair, {
				eccPublicKey,
				kyberPublicKey: recipientKyberPublicKey,
				keyPairType: KeyPairType.TUTA_CRYPT
			}, import_testdouble$64.matchers.anything())).thenResolve(pubEncSymKeyBytes);
			const pubEncSymKey = await asymmetricCryptoFacade$1.asymEncryptSymKey(symKey, recipientPublicKeys, senderGroupId);
			otest_default(pubEncSymKey).deepEquals({
				pubEncSymKeyBytes,
				recipientKeyVersion,
				senderKeyVersion,
				cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT
			});
		});
		otest_default("should encrypt the sym key with the recipient PQ public key and generate new sender ecc identity key pair (sender has only RSA key pair)", async function() {
			const newIdentityEccPair = {
				publicKey: (0, import_testdouble$64.object)(),
				privateKey: (0, import_testdouble$64.object)()
			};
			(0, import_testdouble$64.when)(cryptoWrapper.generateEccKeyPair()).thenReturn(newIdentityEccPair, ephemeralKeyPair);
			const senderRsaKeyPair = {
				object: RSA_TEST_KEYPAIR,
				version: senderKeyVersion
			};
			(0, import_testdouble$64.when)(keyLoaderFacade.loadCurrentKeyPair(senderGroupId)).thenResolve(senderRsaKeyPair);
			const pubKyberKey = new Uint8Array([
				1,
				2,
				3,
				4
			]);
			const eccPublicKey = new Uint8Array([
				5,
				6,
				7,
				8
			]);
			const recipientPublicKeys = {
				object: {
					pubKyberKey,
					pubEccKey: eccPublicKey,
					pubRsaKey: null
				},
				version: recipientKeyVersion
			};
			(0, import_testdouble$64.when)(cryptoWrapper.bytesToKyberPublicKey(pubKyberKey)).thenReturn(recipientKyberPublicKey);
			(0, import_testdouble$64.when)(pqFacade$1.encapsulateAndEncode(newIdentityEccPair, ephemeralKeyPair, {
				eccPublicKey,
				kyberPublicKey: recipientKyberPublicKey,
				keyPairType: KeyPairType.TUTA_CRYPT
			}, import_testdouble$64.matchers.anything())).thenResolve(pubEncSymKeyBytes);
			const senderUserGroupKey = (0, import_testdouble$64.object)();
			(0, import_testdouble$64.when)(keyLoaderFacade.getCurrentSymGroupKey(senderGroupId)).thenResolve({
				object: senderUserGroupKey,
				version: senderKeyVersion
			});
			const encryptedEccSenderPrivateKey = (0, import_testdouble$64.object)();
			(0, import_testdouble$64.when)(cryptoWrapper.encryptEccKey(senderUserGroupKey, newIdentityEccPair.privateKey)).thenReturn(encryptedEccSenderPrivateKey);
			const pubEncSymKey = await asymmetricCryptoFacade$1.asymEncryptSymKey(symKey, recipientPublicKeys, senderGroupId);
			otest_default(pubEncSymKey).deepEquals({
				pubEncSymKeyBytes,
				recipientKeyVersion,
				senderKeyVersion,
				cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT
			});
			(0, import_testdouble$64.verify)(serviceExecutor.put(PublicKeyService, import_testdouble$64.matchers.argThat((arg) => {
				return arg.pubEccKey === newIdentityEccPair.publicKey && arg.symEncPrivEccKey === encryptedEccSenderPrivateKey && arg.keyGroup === senderGroupId;
			})));
		});
		otest_default("should encrypt the sym key with the recipient RSA public key", async function() {
			const recipientPublicKeys = {
				object: {
					pubKyberKey: null,
					pubEccKey: null,
					pubRsaKey: hexToUint8Array(rsaPublicKeyToHex(RSA_TEST_KEYPAIR.publicKey))
				},
				version: recipientKeyVersion
			};
			(0, import_testdouble$64.when)(rsa.encrypt(import_testdouble$64.matchers.argThat((arg) => arg.keyPairType === KeyPairType.RSA), bitArrayToUint8Array(symKey))).thenResolve(pubEncSymKeyBytes);
			const pubEncSymKey = await asymmetricCryptoFacade$1.asymEncryptSymKey(symKey, recipientPublicKeys, senderGroupId);
			otest_default(pubEncSymKey).deepEquals({
				pubEncSymKeyBytes,
				recipientKeyVersion,
				senderKeyVersion: null,
				cryptoProtocolVersion: CryptoProtocolVersion.RSA
			});
		});
		otest_default("raise a ProgrammingError when passing an RSA public key", async function() {
			await assertThrows(ProgrammingError, async function() {
				await asymmetricCryptoFacade$1.tutaCryptEncryptSymKey((0, import_testdouble$64.object)(), {
					object: {
						pubKyberKey: null,
						pubEccKey: null,
						pubRsaKey: hexToUint8Array(rsaPublicKeyToHex(RSA_TEST_KEYPAIR.publicKey))
					},
					version: 2
				}, (0, import_testdouble$64.object)());
			});
		});
	});
});

//#endregion
//#region tests/api/worker/crypto/InstanceMapperTest.ts
var import_testdouble$63 = __toESM(require_testdouble(), 1);
dist_default.spec("InstanceMapper", function() {
	let entityClient$1;
	let userFacade;
	let keyLoaderFacade;
	let instanceMapper;
	dist_default.beforeEach(() => {
		instanceMapper = new InstanceMapper();
		userFacade = (0, import_testdouble$63.object)();
		keyLoaderFacade = (0, import_testdouble$63.object)();
		entityClient$1 = (0, import_testdouble$63.object)();
	});
	function createValueType(type, encrypted, cardinality) {
		return {
			name: "test",
			id: 426,
			since: 6,
			type,
			cardinality,
			final: true,
			encrypted
		};
	}
	dist_default.spec("decrypt value", function() {
		dist_default("decrypt string / number value without mac", function() {
			let sk = aes256RandomKey();
			let value = "this is a string value";
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", createValueType(ValueType.String, true, Cardinality.One), encryptedValue, sk)).equals(value);
			value = "516546";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", createValueType(ValueType.String, true, Cardinality.One), encryptedValue, sk)).equals(value);
		});
		dist_default("decrypt string / number value with mac", function() {
			let sk = aes256RandomKey();
			let value = "this is a string value";
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", createValueType(ValueType.String, true, Cardinality.One), encryptedValue, sk)).equals(value);
			value = "516546";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", createValueType(ValueType.String, true, Cardinality.One), encryptedValue, sk)).equals(value);
		});
		dist_default("decrypt boolean value without mac", function() {
			let valueType = createValueType(ValueType.Boolean, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = "0";
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(false);
			value = "1";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(true);
			value = "32498";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(true);
		});
		dist_default("decrypt boolean value with mac", function() {
			let valueType = createValueType(ValueType.Boolean, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = "0";
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(false);
			value = "1";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(true);
			value = "32498";
			encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(true);
		});
		dist_default("decrypt date value without mac", function() {
			let valueType = createValueType(ValueType.Date, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = new Date().getTime().toString();
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).deepEquals(new Date(parseInt(value)));
		});
		dist_default("decrypt date value with mac", function() {
			let valueType = createValueType(ValueType.Date, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = new Date().getTime().toString();
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).deepEquals(new Date(parseInt(value)));
		});
		dist_default("decrypt bytes value without mac", function() {
			let valueType = createValueType(ValueType.Bytes, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = random.generateRandomData(5);
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, value, random.generateRandomData(IV_BYTE_LENGTH), true, true));
			let decryptedValue = decryptValue("test", valueType, encryptedValue, sk);
			dist_default(decryptedValue instanceof Uint8Array).equals(true);
			dist_default(Array.from(decryptedValue)).deepEquals(Array.from(value));
		});
		dist_default("decrypt bytes value with mac", function() {
			let valueType = createValueType(ValueType.Bytes, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = random.generateRandomData(5);
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, value, random.generateRandomData(IV_BYTE_LENGTH), true, true));
			let decryptedValue = decryptValue("test", valueType, encryptedValue, sk);
			dist_default(decryptedValue instanceof Uint8Array).equals(true);
			dist_default(Array.from(decryptedValue)).deepEquals(Array.from(value));
		});
		dist_default("decrypt compressedString", function() {
			let valueType = createValueType(ValueType.CompressedString, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = base64ToUint8Array("QHRlc3Q=");
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, value, random.generateRandomData(IV_BYTE_LENGTH), true, true));
			let decryptedValue = decryptValue("test", valueType, encryptedValue, sk);
			dist_default(typeof decryptedValue === "string").equals(true);
			dist_default(decryptedValue).equals("test");
		});
		dist_default("decrypt compressedString w resize", function() {
			let valueType = createValueType(ValueType.CompressedString, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = base64ToUint8Array("X3RleHQgBQD//1FQdGV4dCA=");
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, value, random.generateRandomData(IV_BYTE_LENGTH), true, true));
			let decryptedValue = decryptValue("test", valueType, encryptedValue, sk);
			dist_default(typeof decryptedValue === "string").equals(true);
			dist_default(decryptedValue).equals("text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text ");
		});
		dist_default("decrypt empty compressedString", function() {
			let valueType = createValueType(ValueType.CompressedString, true, Cardinality.One);
			let sk = aes256RandomKey();
			let encryptedValue = uint8ArrayToBase64(aesEncrypt(sk, new Uint8Array([]), random.generateRandomData(IV_BYTE_LENGTH), true, true));
			let decryptedValue = decryptValue("test", valueType, encryptedValue, sk);
			dist_default(typeof decryptedValue === "string").equals(true);
			dist_default(decryptedValue).equals("");
		});
		dist_default("do not decrypt null values", function() {
			let sk = aes256RandomKey();
			dist_default(decryptValue("test", createValueType(ValueType.String, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(decryptValue("test", createValueType(ValueType.Date, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(decryptValue("test", createValueType(ValueType.Bytes, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(decryptValue("test", createValueType(ValueType.Boolean, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(decryptValue("test", createValueType(ValueType.Number, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
		});
		dist_default("throw error on ONE null values (String)", makeTestForErrorOnNull(ValueType.String));
		dist_default("throw error on ONE null values (Date)", makeTestForErrorOnNull(ValueType.Date));
		dist_default("throw error on ONE null values (Bytes)", makeTestForErrorOnNull(ValueType.Bytes));
		dist_default("throw error on ONE null values (Boolean)", makeTestForErrorOnNull(ValueType.Boolean));
		dist_default("throw error on ONE null values (Number)", makeTestForErrorOnNull(ValueType.Number));
		function makeTestForErrorOnNull(type) {
			return async () => {
				let sk = aes256RandomKey();
				const e = await assertThrows(ProgrammingError, () => decryptValue("test", createValueType(type, true, Cardinality.One), null, sk));
				dist_default(e.message).equals("Value test with cardinality ONE can not be null");
			};
		}
		dist_default("convert unencrypted Date to JS type", function() {
			let value = new Date().getTime().toString();
			dist_default(decryptValue("test", createValueType(ValueType.Date, false, Cardinality.One), value, null)).deepEquals(new Date(parseInt(value)));
		});
		dist_default("convert unencrypted Bytes to JS type", function() {
			let valueBytes = random.generateRandomData(15);
			let value = uint8ArrayToBase64(valueBytes);
			dist_default(Array.from(decryptValue("test", createValueType(ValueType.Bytes, false, Cardinality.One), value, null))).deepEquals(Array.from(valueBytes));
		});
		dist_default("convert unencrypted Boolean to JS type", function() {
			let value = "0";
			dist_default(decryptValue("test", createValueType(ValueType.Boolean, false, Cardinality.One), value, null)).equals(false);
			value = "1";
			dist_default(decryptValue("test", createValueType(ValueType.Boolean, false, Cardinality.One), value, null)).equals(true);
		});
		dist_default("convert unencrypted Number to JS type", function() {
			let value = "";
			dist_default(decryptValue("test", createValueType(ValueType.Number, false, Cardinality.One), value, null)).equals("0");
			value = "0";
			dist_default(decryptValue("test", createValueType(ValueType.Number, false, Cardinality.One), value, null)).equals("0");
			value = "1";
			dist_default(decryptValue("test", createValueType(ValueType.Number, false, Cardinality.One), value, null)).equals("1");
		});
		dist_default("convert unencrypted compressedString to JS type", function() {
			let value = "";
			dist_default(decryptValue("test", createValueType(ValueType.CompressedString, false, Cardinality.One), value, null)).equals("");
			value = "QHRlc3Q=";
			dist_default(decryptValue("test", createValueType(ValueType.CompressedString, false, Cardinality.One), value, null)).equals("test");
		});
	});
	dist_default.spec("encryptValue", function() {
		dist_default("encrypt string / number value", function() {
			const valueType = createValueType(ValueType.String, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = "this is a string value";
			let encryptedValue = neverNull(encryptValue("test", valueType, value, sk));
			let expected = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value), base64ToUint8Array(encryptedValue).slice(ENABLE_MAC ? 1 : 0, ENABLE_MAC ? 17 : 16), true, ENABLE_MAC));
			dist_default(encryptedValue).equals(expected);
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(value);
		});
		dist_default("encrypt boolean value", function() {
			let valueType = createValueType(ValueType.Boolean, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = false;
			let encryptedValue = neverNull(encryptValue("test", valueType, value, sk));
			let expected = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value ? "1" : "0"), base64ToUint8Array(encryptedValue).slice(ENABLE_MAC ? 1 : 0, ENABLE_MAC ? 17 : 16), true, ENABLE_MAC));
			dist_default(encryptedValue).equals(expected);
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(false);
			value = true;
			encryptedValue = neverNull(encryptValue("test", valueType, value, sk));
			expected = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value ? "1" : "0"), base64ToUint8Array(encryptedValue).slice(ENABLE_MAC ? 1 : 0, ENABLE_MAC ? 17 : 16), true, ENABLE_MAC));
			dist_default(encryptedValue).equals(expected);
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).equals(true);
		});
		dist_default("encrypt date value", function() {
			let valueType = createValueType(ValueType.Date, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = new Date();
			let encryptedValue = neverNull(encryptValue("test", valueType, value, sk));
			let expected = uint8ArrayToBase64(aesEncrypt(sk, stringToUtf8Uint8Array(value.getTime().toString()), base64ToUint8Array(encryptedValue).slice(ENABLE_MAC ? 1 : 0, ENABLE_MAC ? 17 : 16), true, ENABLE_MAC));
			dist_default(encryptedValue).equals(expected);
			dist_default(decryptValue("test", valueType, encryptedValue, sk)).deepEquals(value);
		});
		dist_default("encrypt bytes value", function() {
			let valueType = createValueType(ValueType.Bytes, true, Cardinality.One);
			let sk = aes256RandomKey();
			let value = random.generateRandomData(5);
			let encryptedValue = neverNull(encryptValue("test", valueType, value, sk));
			let expected = uint8ArrayToBase64(aesEncrypt(sk, value, base64ToUint8Array(encryptedValue).slice(ENABLE_MAC ? 1 : 0, ENABLE_MAC ? 17 : 16), true, ENABLE_MAC));
			dist_default(encryptedValue).equals(expected);
			dist_default(Array.from(decryptValue("test", valueType, encryptedValue, sk))).deepEquals(Array.from(value));
		});
		dist_default("do not encrypt null values", function() {
			let sk = aes256RandomKey();
			dist_default(encryptValue("test", createValueType(ValueType.String, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(encryptValue("test", createValueType(ValueType.Date, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(encryptValue("test", createValueType(ValueType.Bytes, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(encryptValue("test", createValueType(ValueType.Boolean, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
			dist_default(encryptValue("test", createValueType(ValueType.Number, true, Cardinality.ZeroOrOne), null, sk)).equals(null);
		});
		dist_default("accept null _id and _permissions value during encryption", function() {
			let vt = {
				id: 426,
				type: ValueType.GeneratedId,
				cardinality: Cardinality.One,
				final: true,
				encrypted: false
			};
			dist_default(encryptValue("_id", vt, null, null)).equals(null);
			dist_default(encryptValue("_permissions", vt, null, null)).equals(null);
		});
		dist_default("throw error on ONE null values (enc String)", makeTestForErrorOnNull(ValueType.String));
		dist_default("throw error on ONE null values (enc Date)", makeTestForErrorOnNull(ValueType.Date));
		dist_default("throw error on ONE null values (enc Bytes)", makeTestForErrorOnNull(ValueType.Bytes));
		dist_default("throw error on ONE null values (enc Boolean)", makeTestForErrorOnNull(ValueType.Boolean));
		dist_default("throw error on ONE null values (enc Number)", makeTestForErrorOnNull(ValueType.Number));
		function makeTestForErrorOnNull(type) {
			return async () => {
				let sk = aes256RandomKey();
				const e = await assertThrows(ProgrammingError, async () => encryptValue("test", createValueType(type, true, Cardinality.One), null, sk));
				dist_default(e.message).equals("Value test with cardinality ONE can not be null");
			};
		}
		dist_default("convert unencrypted Date to DB type", function() {
			let value = new Date();
			dist_default(encryptValue("test", createValueType(ValueType.Date, false, Cardinality.One), value, null)).equals(value.getTime().toString());
		});
		dist_default("convert unencrypted Bytes to DB type", function() {
			let valueBytes = random.generateRandomData(15);
			dist_default(encryptValue("test", createValueType(ValueType.Bytes, false, Cardinality.One), valueBytes, null)).equals(uint8ArrayToBase64(valueBytes));
		});
		dist_default("convert unencrypted Boolean to DB type", function() {
			let value = false;
			dist_default(encryptValue("test", createValueType(ValueType.Boolean, false, Cardinality.One), value, null)).equals("0");
			value = true;
			dist_default(encryptValue("test", createValueType(ValueType.Boolean, false, Cardinality.One), value, null)).equals("1");
		});
		dist_default("convert unencrypted Number to DB type", function() {
			let value = "0";
			dist_default(encryptValue("test", createValueType(ValueType.Number, false, Cardinality.One), value, null)).equals("0");
			value = "1";
			dist_default(encryptValue("test", createValueType(ValueType.Number, false, Cardinality.One), value, null)).equals("1");
		});
	});
	dist_default("decrypt instance", async function() {
		dist_default.timeout(1e3);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		const user = createTestUser("Alice", entityClient$1);
		const sk = aes256RandomKey();
		let mail = createMailLiteral(user.mailGroupKey, sk, subject, confidential, senderName, user.name, user.mailGroup._id);
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		return instanceMapper.decryptAndMapToInstance(MailTypeModel, mail, sk).then((decrypted) => {
			dist_default(isSameTypeRef(decrypted._type, MailTypeRef)).equals(true);
			dist_default(decrypted.receivedDate.getTime()).equals(1470039025474);
			dist_default(decrypted.confidential).equals(confidential);
			dist_default(decrypted.subject).equals(subject);
			dist_default(decrypted.replyType).equals("0");
			dist_default(isSameTypeRef(decrypted.sender._type, MailAddressTypeRef)).equals(true);
			dist_default(decrypted.sender.name).equals(senderName);
			dist_default(decrypted.sender.address).equals("hello@tutao.de");
		});
	});
	dist_default.spec("encryptAndMapToLiteral", function() {
		dist_default.test("encrypt instance", async function() {
			let sk = aes256RandomKey();
			let address = createTestEntity(ContactAddressTypeRef);
			address.type = "0";
			address.address = "Entenhausen";
			address.customTypeName = "0";
			let contact = createTestEntity(ContactTypeRef);
			contact.title = "Dr.";
			contact.firstName = "Max";
			contact.lastName = "Meier";
			contact.comment = "what?";
			contact.company = "WIW";
			contact.addresses = [address];
			const ContactTypeModel = await resolveTypeReference(ContactTypeRef);
			const result = await instanceMapper.encryptAndMapToLiteral(ContactTypeModel, contact, sk);
			dist_default(result._format).equals("0");
			dist_default(result._ownerGroup).equals(null);
			dist_default(result._ownerEncSessionKey).equals(null);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.addresses[0].type)))).equals(contact.addresses[0].type);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.addresses[0].address)))).equals(contact.addresses[0].address);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.addresses[0].customTypeName)))).equals(contact.addresses[0].customTypeName);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.title)))).equals(contact.title);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.firstName)))).equals(contact.firstName);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.lastName)))).equals(contact.lastName);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.comment)))).equals(contact.comment);
			dist_default(utf8Uint8ArrayToString(aesDecrypt(sk, base64ToUint8Array(result.company)))).equals(contact.company);
		});
		dist_default.test("map unencrypted to DB literal", async function() {
			const dummyDate = new Date();
			const customerAccountTerminationRequest = createTestEntity(CustomerAccountTerminationRequestTypeRef);
			customerAccountTerminationRequest._format = "0";
			customerAccountTerminationRequest.terminationDate = dummyDate;
			customerAccountTerminationRequest.terminationRequestDate = dummyDate;
			customerAccountTerminationRequest.customer = "customerId";
			const customerAccountTerminationRequestLiteral = {
				_format: "0",
				_id: null,
				_ownerGroup: null,
				_permissions: null,
				terminationDate: dummyDate.getTime().toString(),
				terminationRequestDate: dummyDate.getTime().toString(),
				customer: "customerId"
			};
			const CustomerAccountTerminationRequestTypeModel = await resolveTypeReference(CustomerAccountTerminationRequestTypeRef);
			const result = await instanceMapper.encryptAndMapToLiteral(CustomerAccountTerminationRequestTypeModel, customerAccountTerminationRequest, null);
			dist_default(result).deepEquals(customerAccountTerminationRequestLiteral);
		});
		dist_default.test("when finalIvs has an entry it will reuse the IV", async function() {
			const sk = aes256RandomKey();
			const TypeModel = await resolveTypeReference(MailTypeRef);
			const mail = {
				...createTestEntity(MailTypeRef),
				subject: "some subject",
				sender: createTestEntity(MailAddressTypeRef)
			};
			const iv = new Uint8Array(IV_BYTE_LENGTH);
			iv[1] = 1;
			mail["_finalIvs"] = { subject: new Uint8Array(iv) };
			const result = await instanceMapper.encryptAndMapToLiteral(TypeModel, mail, sk);
			const encryptedSubject = base64ToUint8Array(result["subject"]);
			dist_default(encryptedSubject.slice(1, IV_BYTE_LENGTH + 1)).deepEquals(iv);
		});
		dist_default.test("when finalIvs has an empty entry and the value is default it will write default placeholder back", async function() {
			const sk = aes256RandomKey();
			const TypeModel = await resolveTypeReference(MailTypeRef);
			const mail = {
				...createTestEntity(MailTypeRef),
				subject: "",
				sender: createTestEntity(MailAddressTypeRef)
			};
			const iv = new Uint8Array([]);
			mail["_finalIvs"] = { subject: new Uint8Array(iv) };
			const result = await instanceMapper.encryptAndMapToLiteral(TypeModel, mail, sk);
			const encryptedSubject = result["subject"];
			dist_default(encryptedSubject).equals("");
		});
	});
	dist_default("map unencrypted to instance", async function() {
		const dummyDate = new Date();
		const customerAccountTerminationRequestLiteral = {
			_format: "0",
			terminationDate: dummyDate.getTime().toString(),
			terminationRequestDate: dummyDate.getTime().toString(),
			customer: "customerId"
		};
		const CustomerAccountTerminationTypeModel = await resolveTypeReference(CustomerAccountTerminationRequestTypeRef);
		const customerAccountTerminationRequest = await instanceMapper.decryptAndMapToInstance(CustomerAccountTerminationTypeModel, customerAccountTerminationRequestLiteral, null);
		dist_default(customerAccountTerminationRequest._format).equals("0");
		dist_default(customerAccountTerminationRequest.customer).equals("customerId");
		dist_default(customerAccountTerminationRequest.terminationDate).deepEquals(dummyDate);
		dist_default(customerAccountTerminationRequest.terminationRequestDate).deepEquals(dummyDate);
	});
	dist_default("decryption errors should be written to _errors field", async function() {
		const testUser = createTestUser("Bob", entityClient$1);
		configureLoggedInUser(testUser, userFacade, keyLoaderFacade);
		let subject = "this is our subject";
		let confidential = true;
		let senderName = "TutanotaTeam";
		let sk = aes256RandomKey();
		let mail = createMailLiteral(testUser.mailGroupKey, sk, subject, confidential, senderName, testUser.name, testUser.mailGroup._id);
		mail.subject = "asdf";
		const MailTypeModel = await resolveTypeReference(MailTypeRef);
		const instance$14 = await instanceMapper.decryptAndMapToInstance(MailTypeModel, mail, sk);
		dist_default(typeof instance$14._errors["subject"]).equals("string");
	});
});

//#endregion
//#region tests/api/worker/crypto/OwnerEncSessionKeysUpdateQueueTest.ts
var import_testdouble$62 = __toESM(require_testdouble(), 1);
const { anything: anything$10, captor: captor$2 } = import_testdouble$62.matchers;
dist_default.spec("OwnerEncSessionKeysUpdateQueueTest", function() {
	let serviceExecutor;
	let ownerEncSessionKeysUpdateQueue;
	let userFacade;
	let mailTypeModel;
	dist_default.beforeEach(async function() {
		mailTypeModel = await resolveTypeReference(MailTypeRef);
		userFacade = (0, import_testdouble$62.object)();
		(0, import_testdouble$62.when)(userFacade.isLeader()).thenReturn(true);
		serviceExecutor = (0, import_testdouble$62.object)();
		ownerEncSessionKeysUpdateQueue = new OwnerEncSessionKeysUpdateQueue(userFacade, serviceExecutor, 0);
	});
	dist_default.spec("updateInstanceSessionKeys", function() {
		dist_default("send updates from queue", async function() {
			const updatableInstanceSessionKeys = [createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "mailInstanceId",
				instanceList: "mailInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					1,
					2,
					3
				])
			}), createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "fileInstanceId",
				instanceList: "fileInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					4,
					5,
					6
				])
			})];
			await await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatableInstanceSessionKeys, mailTypeModel);
			await delay(0);
			const updatedPostCaptor = captor$2();
			(0, import_testdouble$62.verify)(serviceExecutor.post(UpdateSessionKeysService, updatedPostCaptor.capture()));
			dist_default(updatedPostCaptor.value.ownerEncSessionKeys).deepEquals(updatableInstanceSessionKeys);
		});
		dist_default("no updates sent if not leader", async function() {
			(0, import_testdouble$62.when)(userFacade.isLeader()).thenReturn(false);
			const updatableInstanceSessionKeys = [createTestEntity(InstanceSessionKeyTypeRef)];
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatableInstanceSessionKeys, mailTypeModel);
			await delay(0);
			(0, import_testdouble$62.verify)(serviceExecutor.post(anything$10(), anything$10()), { times: 0 });
		});
		dist_default("no updates sent for GroupKeyUpdate type", async function() {
			const groupKeyUpdateTypeModel = await resolveTypeReference(GroupKeyUpdateTypeRef);
			const updatableInstanceSessionKeys = [createTestEntity(InstanceSessionKeyTypeRef)];
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatableInstanceSessionKeys, groupKeyUpdateTypeModel);
			await delay(0);
			(0, import_testdouble$62.verify)(serviceExecutor.post(anything$10(), anything$10()), { times: 0 });
		});
		dist_default("retry after LockedError", async function() {
			let throwError = true;
			(0, import_testdouble$62.when)(serviceExecutor.post(UpdateSessionKeysService, anything$10())).thenDo(() => {
				if (throwError) return Promise.reject(new LockedError("test lock"));
else return undefined;
			});
			const updatableInstanceSessionKeys = [createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "mailInstanceId",
				instanceList: "mailInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					1,
					2,
					3
				])
			}), createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "fileInstanceId",
				instanceList: "fileInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					4,
					5,
					6
				])
			})];
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys(updatableInstanceSessionKeys, mailTypeModel);
			await delay(0);
			throwError = false;
			(0, import_testdouble$62.when)(serviceExecutor.post(UpdateSessionKeysService, anything$10())).thenResolve(undefined);
			await delay(0);
			const updatedPostCaptor = captor$2();
			(0, import_testdouble$62.verify)(serviceExecutor.post(UpdateSessionKeysService, updatedPostCaptor.capture()), { times: 2 });
			dist_default(updatedPostCaptor.value.ownerEncSessionKeys).deepEquals(updatableInstanceSessionKeys);
			if (!updatedPostCaptor.values) throw new Error("should have been invoked twice");
			dist_default(updatedPostCaptor.values[0]).deepEquals(updatedPostCaptor.values[1]);
		});
		dist_default("debounced request sends entire queue", async function() {
			const updatableInstanceSessionKeys = [createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "mailInstanceId",
				instanceList: "mailInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					1,
					2,
					3
				])
			}), createTestEntity(InstanceSessionKeyTypeRef, {
				instanceId: "fileInstanceId",
				instanceList: "fileInstanceList",
				typeInfo: createTestEntity(TypeInfoTypeRef),
				symEncSessionKey: new Uint8Array([
					4,
					5,
					6
				])
			})];
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys([updatableInstanceSessionKeys[0]], mailTypeModel);
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys([updatableInstanceSessionKeys[1]], mailTypeModel);
			await delay(0);
			const updatedPostCaptor = captor$2();
			(0, import_testdouble$62.verify)(serviceExecutor.post(UpdateSessionKeysService, updatedPostCaptor.capture()));
			dist_default(updatedPostCaptor.value.ownerEncSessionKeys).deepEquals(updatableInstanceSessionKeys);
		});
		dist_default("empty inputs do not trigger a call to the service", async function() {
			await ownerEncSessionKeysUpdateQueue.updateInstanceSessionKeys([], mailTypeModel);
			await delay(0);
			(0, import_testdouble$62.verify)(serviceExecutor.post(UpdateSessionKeysService, anything$10()), { times: 0 });
		});
	});
});

//#endregion
//#region tests/api/worker/crypto/CompatibilityTestData.json
var rsaEncryptionTests = [{
	"publicKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf9",
	"privateKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf90200816022249104e1f94e289b6284b36d8f63ee1a31806852965be0d632fc25389ac02795e88eb254f4181bc2def00f7affa5627d6bf43e37e2a56c3cc20c4bbe058cf2d3e9fa759d1f78f3f5f797fd5195644e95fad1ecac235e51e72aa59476f374952b486e9db4b818157d362e3e638ee9edca329c4336df43fd3cd327f8542d1add9798af1d6a9e8cf8f54dd0b6a6f9ed9c3f5d803c220716757871e1442ef407ffe5df44c364bf57a60551b681173747b8df8e4138101f1d048cc1941a5d4c1fd3eda5bc96496eb1892477d811b845a7c9b3333e700989a1134e8f65edbf3a8332baa7195eb6aa33591b6ab41ec8215c6487979df5cf1b9736fd4fea73eee102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7a2e7a5cc651614fd17eb10765ef63462e5767745fc849e97095319d42f8cbb1485aba0f590b33208e666e949db0465e483a122467f771a986da6855abb148d0b5c1eefb08636d0aeb36b8ec161497cc9a64704f0976aceb33d09af5408ded1aec771b534f9a27fd9dc3303146ce98872915ed730ed9661eec46b8c0d6b6d37020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a632cb2e0a17ee6e363e3e056e5170480a3790023e342cb221431be37d63e692ce572390a379cf470c8a9fa4251a0af84d746b79ff91f6dcf168417137150d93049098ef747a601825982cbbd1ac1c20b3f3ee97b25e1739c31b43e78fc1cd53134dc4e82ebf98c720c34852fbd2288370421b848575f4d054e1d1e66b47f4f02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b09e8b48e56fd2859072135f4b129f62546228914b80fed239d1f756436f3a3c4faa98b2336bf0e6ded86771cc49beb1beab0b4b2a3bf8e20385e029e083b368d4579a9322a343da9ccadbe14edc527f5ef6754273fcd088e92c4a5d30934eeaccfcf05bbe17f66acc0055b92c72db229a50f3e2db40dda0b0c17e4b9cd3e3c30200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088861ee6e7e1a7f8c1287a40ce56b3ae159b79caf7f166057fd35fd1984aead1d313eb982942d897088d4a52b606bd13b9632d7400112b0bcdcf596b9693e42ccb982acdb43a35c0abe63fd5af1a54312604fdbb365d5f2afefaad2b798d6869d6a3aa15fb8c75170f5b5fae4f72ef7089462c136c55673f12ebeab0119e97dd02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8538fe6ebe9514412692fc985f8fd62b237c51c160c3d49aeeafffa057f2feff8f29040a205895b61dfa3f6188851021dc9e50152f3ea69746f5eb491af4a6dde21db9fa2c6fa61198ea02d6b600ed4267c3871af686c8db12e4bcbaaaa552e157e66fda90d34fce11cfd0f5eea6fbb236818070fb3a13751ad408e4231f499",
	"input": "83197c134aeeff44c5ea6f4fae4ebda3",
	"seed": "a82f703e3faae5490ca64a2b100c2d4c093ce3549a2bfbbc88615b29824fab59",
	"result": "843ce9168930b862f26ed512e641f395f6fd8e8ee350892208985c478a742713d18a36ce8a64b62a36ecf92585890a2f89cf5effc7182968436b35a61f56f0f26e86bb373e85554ab621e29da169a38bbc84e5725e4ea1e5d42c6df74f0874f0fe65b0563c7b95bf97d697ca3a2f8c2d8259f210320d5dbec1987aa0c4d828a0bbc5d60ddc07f2b07759b35f4cf08618383b6912f2cd2eaff81b8b1083146ccc6d90b6a171939a94b455239af034995a367bb081b4edc9028adbcc21a34331064e4a6160ce982a6386f03e4837593339e062338fdbcb1d6400b4dff089a20e67b13f0f4a2c2acaa3bc7ea16e68c9407d73b42d7a63c0d6612e44d5de72ea00fc"
}, {
	"publicKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf9",
	"privateKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf90200816022249104e1f94e289b6284b36d8f63ee1a31806852965be0d632fc25389ac02795e88eb254f4181bc2def00f7affa5627d6bf43e37e2a56c3cc20c4bbe058cf2d3e9fa759d1f78f3f5f797fd5195644e95fad1ecac235e51e72aa59476f374952b486e9db4b818157d362e3e638ee9edca329c4336df43fd3cd327f8542d1add9798af1d6a9e8cf8f54dd0b6a6f9ed9c3f5d803c220716757871e1442ef407ffe5df44c364bf57a60551b681173747b8df8e4138101f1d048cc1941a5d4c1fd3eda5bc96496eb1892477d811b845a7c9b3333e700989a1134e8f65edbf3a8332baa7195eb6aa33591b6ab41ec8215c6487979df5cf1b9736fd4fea73eee102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7a2e7a5cc651614fd17eb10765ef63462e5767745fc849e97095319d42f8cbb1485aba0f590b33208e666e949db0465e483a122467f771a986da6855abb148d0b5c1eefb08636d0aeb36b8ec161497cc9a64704f0976aceb33d09af5408ded1aec771b534f9a27fd9dc3303146ce98872915ed730ed9661eec46b8c0d6b6d37020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a632cb2e0a17ee6e363e3e056e5170480a3790023e342cb221431be37d63e692ce572390a379cf470c8a9fa4251a0af84d746b79ff91f6dcf168417137150d93049098ef747a601825982cbbd1ac1c20b3f3ee97b25e1739c31b43e78fc1cd53134dc4e82ebf98c720c34852fbd2288370421b848575f4d054e1d1e66b47f4f02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b09e8b48e56fd2859072135f4b129f62546228914b80fed239d1f756436f3a3c4faa98b2336bf0e6ded86771cc49beb1beab0b4b2a3bf8e20385e029e083b368d4579a9322a343da9ccadbe14edc527f5ef6754273fcd088e92c4a5d30934eeaccfcf05bbe17f66acc0055b92c72db229a50f3e2db40dda0b0c17e4b9cd3e3c30200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088861ee6e7e1a7f8c1287a40ce56b3ae159b79caf7f166057fd35fd1984aead1d313eb982942d897088d4a52b606bd13b9632d7400112b0bcdcf596b9693e42ccb982acdb43a35c0abe63fd5af1a54312604fdbb365d5f2afefaad2b798d6869d6a3aa15fb8c75170f5b5fae4f72ef7089462c136c55673f12ebeab0119e97dd02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8538fe6ebe9514412692fc985f8fd62b237c51c160c3d49aeeafffa057f2feff8f29040a205895b61dfa3f6188851021dc9e50152f3ea69746f5eb491af4a6dde21db9fa2c6fa61198ea02d6b600ed4267c3871af686c8db12e4bcbaaaa552e157e66fda90d34fce11cfd0f5eea6fbb236818070fb3a13751ad408e4231f499",
	"input": "2d2ab0a40010a202457ef6c973c9d5740058b18bed7e648d2d7e7310df8d1675",
	"seed": "a82f703e3faae5490ca64a2b100c2d4c093ce3549a2bfbbc88615b29824fab59",
	"result": "8317b2db99dc191c333226a5f83b0f8a0125ccf298424a43450dc9b4cc72c037a9e8f16b633e591ef3e16e7649c7f7a746c9b65ac9d2b4888367f7ebc5235dd2aedb712ed085205ce6847ded9f05f9defa7af419b43d56b8a3e40822e4fc0aaa9305bc0b23c96382a541149300a9c216abf70e97b782db7a0e5939d8f023d8d3637187fa45ed63dc4f2a355bfacc77bd7dc0d7c193717d2e0e382ef0fe7ffe8f9169eb2ec3e7e8b08119a9913d3318b1d5aceadb86a7072d57fb1df7eeff9438a87c35f77d521123aaed949a2b3d9aacdd1d913a0b64db5a2ec2147f1fdb1a203bfd92e26d49d9ab0784b3da55cb892596b7670b4425b9c278d18c3bacf4a672"
}];
var kyberEncryptionTests = [{
	"publicKey": "06001ca3c52629b5161c0ed6f100efe9650f7983652865a2e00049c7c840741238022170a89b7e4a001f014a62223e29d6693712428e415520487155078be8a78c6b92c628d667241174f7f2acc333bfe7db667063ce5d45b69afcc9f16b64d9a2ad48784b133963268a1ab2c9a8f76638de4280b3733c1752a09929203fb237a5dac0d5b37387181edcf3500755bb34f37b5cf7bb31266a7c49853276c95bb179595ca5833b25d4726b9014affafb2b074338885abdbe8c7915a12576565370c181f24b31cbb66ae4ca69c0452b9db632f0bc4179972922fb932c0364cc8763f6d7bbcf7531b7981442f583904937ab33bbd528754fc425e422b22eb66f45e16208ec49cdb0472829361e30af5dd24bccdca6cca7811bac40c0095fa128c60b202eda22435692aa67177f0e02c381f220249059e79b75aba5b04d39055b6cc9324641fef2bb978abe09ec9960b35bc8a94a1cd4445b702bca11a4336c261ed4738af0a7588c748bc1590f335757c8a4fc0a58ffe15c84691551f2c9f1202548e595c39b73d0c422557b34161813d93b4463a020db27c490aa6095f43cdab0b2d21b4bea66c09c9a5e56d2a79b8c7e958712b56996a67631514b7e97d849cc3a81b7a1bd4579930310a56b43a8654c7606d8c28acb8f2ac3b93b5857a43712f9193f65d2cf76fc422deb4ff85c6f4775a4b49cab655c3a5c5916707bc37525c43a914bbe22ae1c7b96143bab620189bcd98e52137950539526f5818a0a7a3919040e9790710b1eb5f73ed3359dfd1790491b492d38212c43a1ec30cdca66c46d98a80f957e9823084c6697219027a54b98d37811cc0a20bcac336eb85c3b3a2b31a26a28f6cabad7a13fa73887364d2993c2753a8dcfc0a769e2cb03025db349607e3c1a6f54861b79823943cbf091070fc3895d775a68441b41ea3d584c360546808cd3252a7b2baf7808930a7cf003718a30854d57450595a9f374236eb3a0d358396b972f05fc9ea9164abc3aa4e6b3a70679c4224479a5d84a4777041238278a4b657163b013667d7be35081c645e0fb4a07a20173f54dd92a6b64469f21f146530723c62503d2b331a7262b60540f50775eb5e06f1a0401e48072b3a736af250fea149a32f421cf560000fc7ed2e50bb6d096c2aa4f1fcc7680513699bcbedc59c8bfeabe05a9626b904fe9ac9cba19cd9704bf92c82380134f010322f90b78b23ca858215cb07b6bbdd434cd440af015844ef27b58297922a24d3d531de35734cbf552aed02963f1076785949301457035a5c51874a1b4ca2805cb0b07bd44f77a59a7c48e0a1dd7e69d4baa4f07472be82c58ee5b4fff093cdbbc6bfdd37aa8c5cb79dcbfda589cae8c8f6d3490386c531b98b83d008f440388418308211c6e48fc1153493d56f915e85aabd0052ed01b210a143c073cbef96192aa04a544330c87c5a344521f7d44835cba1b3ae1303fc215bcd99a20fa00395bc9edf74502981766f56e7b97398185915edb7c95dcc4859b9798d25f1eb5cfad85c698bcafe0b11744f1283c536188757c3ad505f05650320c2021667f4f978fb120635c036b4a34732f67a7017aa740ba7b7f269fa0e940c7d51bbe6b0cf7d4370dd4872831b3258b803a64cff331b6b880925fc260ba63930e3164d153285c5a45db620efad208104087653852e667af48aa5884a1660ce8519533851340c8286372b2eaaf7d5c20c2b84ae0b33acdf827960a73bdfa68c28bb2c8a6475998673f2c2c3ae4bf2740c925d556fdd259d2eab5b2204faac71109ec9e261a9825dc49c03c2b10b5a72b9ca003e02f948acc00393d51282e92c61f991a606a88438ddcb6be73b4341b1ada180dc1620390b033a5bc536e8b96ce9a89a7d5276913c19de78bd0c393a74c6c2bdbb0bd307d2ff5ad608bc0424230706915d563009f05422f595a0d51083b17253b12470f503e84058b32a290ded39d14d1136f0570fa43c174acb726293940f848186b85a2fc22d7cb103a08cbed438537a42cb495841b457c2901b179530105563288d6578ed81ec4d988a5b9b8c10898bef7bdef4300e694801fa3c8e9e90b7ae30eec349d6934668a4ba843203b86bb4745d5281870b9ee83547309268c9740e02001560409fcf4cb54c67bafb417be366d810c7854f9750020bd58d5134911f959fe588af8e73aefa60ed00a55e8acc8451f837be565e2e719",
	"privateKey": "06004c04453f7506f72038b5c2a4f8f92c130a8e5bdc95f8f324a618ad66c65e8071014b62176957309aea5a921c5b09567b65c62231994da401306886126c25037f50a635360758217f7c6b1de0e65af134b88bf400ee9401c38382649a9c8790910ac679521a68a1f0958db310c9190120fa925a4c69de2b2772e10a01208e2276af79b82ddf7a8f46592ee9357be2661ca189742645aafbb507de439a3ae6c6030b872c2a96dbf38643338bc1f61ac797ac09aabcd1d6bc0830956668afc90ac3457401cf2a2cf129981cb5248a163393ea12cbd0b7ebda1aa1560cb2463111ecb9e7d88460c049d0084807e8128a361da69481063287c08a857f8c5553400c67e40724a8a2e54807c8bac508434cc6ccc70fe90ddff007f27647b3799a4aac5c8b5090d368c5bb3294cb67c3a636128d0c1e38a196bf446a12c6459cb2a5dc752394fc7f20942915f4b99758a969d356e551156292897db34be6565ce843bbe0b055b1970c06836523d6b2e447454b513e87564238d8984468482952a4154968a2f2cb5e43c1490a3b9ee91157ab6cdb64064e3cabab299a6b19614437c399589452889869ea7b5ed68eb82056b4a54789b034c8612615a2597f539348255c859b9d144bc4c9889b06579abc6b19b2968b962a08bf093ad5b7325f665ea6d58a60349d94a52149f198b20295b497173949929436a81ee46af5125db56183706aa576224947b804143658c196a1b62a6530814618743af7c02a06e03993b74bd98635ede3642a2c216688002aa90872f40395190a3c3a7efdfaa2b3b326d4806f55039cabb5166b3c8b88dbc963a90812298ae2307e134449e848c481b568a0064db2aa7c9c16cb8464acfd538e84bb494de5b99bf8b48fdb65e8c78f3797adcf1b9f72516ab391ce69306289f5af93647177573c8f1877c9601613823f97c025b35bc6bccc57d9f40f3e0113854694317b9a5a7766cd9ca6552b7be82caa3f284fb228c906164addc486b5670772906a152a580ea73fe6b6060c8627e7690232467c3c17cd430b077216089d1b630278948718c65e608f66979d90c28dad1398866732b5437b5646c6f251c63f152046305a227b5abf91a0aab1b9ef191a97cb5929c00a92495ec3b42771f958b450797a95476e9c5331b715274b894f073d671b553d699de84c361ae253aa69caa4677f63920fbfccc195fc5ae4529b353668c04c120295a937c2129ad0a0894175f004b88081a9b4a73848b13f18502f3ba5a0c78b05e7c85cf70450cf30345721701ba5cafc94885c4449987118501973ffaa6f6a73236945600027a4b7500734e03fb2d5b0fd03a3907a0ba37a65cdc6ccf44277a046c8e4f27b2bac3b576965aeb3100cb94a3c19168a666b153c1d2e74cc25e42db45079aa1c099ae397edb2235224ab1cc852a547b29d500e7a182b945b267fabb84d941a1888a627621042814a929141637873e309c04ef92c90501e0486cfe4353959072912723996609442c1a66b2045810994227aa2c263c13fba221a987a662c7d299808b29543bc678880700971b9a9412822a27b2156ca64d305a15af882d668705ca76490687ab979815ac70ecda47f394319c54487716405c2c99d4aa30ce988686bf510d16a9790b2425be12b26b2cb92aa3de6f59ebc0497b46764771a52663225c75670e551ae8a42250f396a990bc849f07a33239eb0ecc5a3ca06268bc39237a995443a45a62f4b27ca41e336ea044469a69f0a8a77f7a9bc669730f2b150c17a2ed949798c259a49e4715f906ac8c35dc5040e7c8089fc448c9e87b37a16601fc37b4c94b5cfc2ce6a12ce0a074e29449271ab9f801a5879b2c9e7c051ef42050ad08ced647f30263c85e4ca9a6cc5bcd6afd9eb32887707711c06dfc8a2e57963db2b30b1a718299186932a7d89207c7c6a030fabb738215b939358791496d7a72008c280c9867971f73823d6a72a635ab422183b04bd85602ed935085232cd7726bde1f78b6c7221a0e9cbd4e24a51c36d6c1634983a5d004a3a91fbc395c7b2c1142a2d49763fe3b4d7940ee4ba98a5b4c71ff63151975e87003a1752257c2a4b0d1b5612155abf064b1c20755c877625a8c176cbab3aeb96142658a01794db17a513b48bbcb747005602161a480b78430d6b1800206a0057312f5dc38c04a0b0190fee88c7f6f96f5f453e3bbf5a98ada10b64145600206bb0b827e28469737931032a75d8219ea09889824ef61cd69097e9f7eb9fd43306001ca3c52629b5161c0ed6f100efe9650f7983652865a2e00049c7c840741238022170a89b7e4a001f014a62223e29d6693712428e415520487155078be8a78c6b92c628d667241174f7f2acc333bfe7db667063ce5d45b69afcc9f16b64d9a2ad48784b133963268a1ab2c9a8f76638de4280b3733c1752a09929203fb237a5dac0d5b37387181edcf3500755bb34f37b5cf7bb31266a7c49853276c95bb179595ca5833b25d4726b9014affafb2b074338885abdbe8c7915a12576565370c181f24b31cbb66ae4ca69c0452b9db632f0bc4179972922fb932c0364cc8763f6d7bbcf7531b7981442f583904937ab33bbd528754fc425e422b22eb66f45e16208ec49cdb0472829361e30af5dd24bccdca6cca7811bac40c0095fa128c60b202eda22435692aa67177f0e02c381f220249059e79b75aba5b04d39055b6cc9324641fef2bb978abe09ec9960b35bc8a94a1cd4445b702bca11a4336c261ed4738af0a7588c748bc1590f335757c8a4fc0a58ffe15c84691551f2c9f1202548e595c39b73d0c422557b34161813d93b4463a020db27c490aa6095f43cdab0b2d21b4bea66c09c9a5e56d2a79b8c7e958712b56996a67631514b7e97d849cc3a81b7a1bd4579930310a56b43a8654c7606d8c28acb8f2ac3b93b5857a43712f9193f65d2cf76fc422deb4ff85c6f4775a4b49cab655c3a5c5916707bc37525c43a914bbe22ae1c7b96143bab620189bcd98e52137950539526f5818a0a7a3919040e9790710b1eb5f73ed3359dfd1790491b492d38212c43a1ec30cdca66c46d98a80f957e9823084c6697219027a54b98d37811cc0a20bcac336eb85c3b3a2b31a26a28f6cabad7a13fa73887364d2993c2753a8dcfc0a769e2cb03025db349607e3c1a6f54861b79823943cbf091070fc3895d775a68441b41ea3d584c360546808cd3252a7b2baf7808930a7cf003718a30854d57450595a9f374236eb3a0d358396b972f05fc9ea9164abc3aa4e6b3a70679c4224479a5d84a4777041238278a4b657163b013667d7be35081c645e0fb4a07a20173f54dd92a6b64469f21f146530723c62503d2b331a7262b60540f50775eb5e06f1a0401e48072b3a736af250fea149a32f421cf560000fc7ed2e50bb6d096c2aa4f1fcc7680513699bcbedc59c8bfeabe05a9626b904fe9ac9cba19cd9704bf92c82380134f010322f90b78b23ca858215cb07b6bbdd434cd440af015844ef27b58297922a24d3d531de35734cbf552aed02963f1076785949301457035a5c51874a1b4ca2805cb0b07bd44f77a59a7c48e0a1dd7e69d4baa4f07472be82c58ee5b4fff093cdbbc6bfdd37aa8c5cb79dcbfda589cae8c8f6d3490386c531b98b83d008f440388418308211c6e48fc1153493d56f915e85aabd0052ed01b210a143c073cbef96192aa04a544330c87c5a344521f7d44835cba1b3ae1303fc215bcd99a20fa00395bc9edf74502981766f56e7b97398185915edb7c95dcc4859b9798d25f1eb5cfad85c698bcafe0b11744f1283c536188757c3ad505f05650320c2021667f4f978fb120635c036b4a34732f67a7017aa740ba7b7f269fa0e940c7d51bbe6b0cf7d4370dd4872831b3258b803a64cff331b6b880925fc260ba63930e3164d153285c5a45db620efad208104087653852e667af48aa5884a1660ce8519533851340c8286372b2eaaf7d5c20c2b84ae0b33acdf827960a73bdfa68c28bb2c8a6475998673f2c2c3ae4bf2740c925d556fdd259d2eab5b2204faac71109ec9e261a9825dc49c03c2b10b5a72b9ca003e02f948acc00393d51282e92c61f991a606a88438ddcb6be73b4341b1ada180dc1620390b033a5bc536e8b96ce9a89a7d5276913c19de78bd0c393a74c6c2bdbb0bd307d2ff5ad608bc0424230706915d563009f05422f595a0d51083b17253b12470f503e84058b32a290ded39d14d1136f0570fa43c174acb726293940f848186b85a2fc22d7cb103a08cbed438537a42cb495841b457c2901b179530105563288d6578ed81ec4d988a5b9b8c10898bef7bdef4300e694801fa3c8e9e90b7ae30eec349d6934668a4ba843203b86bb4745d5281870b9ee83547309268c9740e02001560409fcf4cb54c67bafb417be366d810c7854f9750020bd58d5134911f959fe588af8e73aefa60ed00a55e8acc8451f837be565e2e719",
	"seed": "6bb0b827e28469737931032a75d8219ea09889824ef61cd69097e9f7eb9fd433",
	"cipherText": "a807b3fa2af05596610d6300572a703fdc0a935d264e1d62c4948389598e17e96e54b0d949743cc96119d5b506e6773de362d443eff95a1f1f6380537b12c73bd839565d32c037118f4a6c7188b1414f04a44221299aec7f619939e332f1940ef54c88bec633d6235fde8f8baac2f645e720c568e9ef739a85ad3dcae4684e5ffa938b43ef419a9c92afb486be061edc8543e71c1ff10170f80c9bf3601144330352a3c44a9563c3c155f968a790d9babb9311e564069911ccbb41fbfb5bbad3049a6368202791abc6bf12d9bf8505dccc3e1ee477c8edce232b2cd6b7e7a7506efdc5e9c22e042752e8d99f3d0948a010b6b31005d325721e3093a04d583e3d6d469d14d3739dda856c9622e652368cbdc9b3f05f9ee8f05107710a842c4875d3e7b87b17588da9547de972f861cd974d222639e8f3ae850ff344cd2b979e24d4a39da1456fe280721b516d2e306a845d79ddd887bf1074111edddc4be53e1aa561ccf177c5dcbc69fe2b4e5c1e52a55a33872a9c320d0d2d19e70d3658ca4c24c6d8f3cb24a2875ab6c40fbfbfdfc6c25411b801a13f4539e7b8fcf43615c71edba747e97a7b477edcc067c3d146ea26dc4bd4c03f84362c303d1a5a2dc8be80ecf4ab7b7a6cce93a59059fbf4f009e556fd2bbc7e1615fd8c2f6ec0d085ee84d5c8f1f14f8277ba5b23ebabc13b4a4a478b3819e1772826d7b5633b5097493d3f5458687d66846e29f2ecf12b2ae25532e64915c29204703ebb6c6f3d0a88a2b4e851fea5164cdaf2c6889b64dfac0e0a0cc843d60695a4fd24ce6b8596284e50091e6df5f6fc0901c1b16d46aed3bb9946fcfeb45555297cfef0dba87ef0268db6f067f52378f3c5aef4e472f95ddaff9aeea051df08949bcc3f8cfa356f30980186b0ece604c8c22844c316dfef15eeba67a643b6cda956c64e70bb4f2e19304f546f7d6897524a79b13e5fdccd050af8f0130a782a5ce30d5edcb0f9e9c706af08ab461eb8b9939638c2eb1c5b199f160c3ddd1cae7657bbc92900a2d0e8bdcd6e08836f8b168599702993c0f7426dc3ea83b9adf5a0686ac12549866f3efa03559a68703c7dd94f4200a1368bf66a129ff245be9eee5d06c08851210d0a98f0fe965e58192bca25b32fe225f2af2c3ebd3d6ce6e9269865a5e4c6f789ed2a8c961ac0d2adbba4379e71573349d55f221a489c2dbc2998a7cce78454b24ae78a767825bb3489ff4f4433d7638d34c29db02635c8a10b3a0620b79006565d3126b1068fe5e856c0dfd665cd7c493052119627a1f4aa4be47667672688e0cd695c72bd7e7681a0cca31357844b6b62cd21ed4619bf19873f7c49a21d1db717f40359cb25c45d1d61adcccdba2cb1ac5689c80f9cb454e689b98cf02c57e19209a7c1dd9f4bc1422f472c35a580de725956e6b96595194fcea6deb50ce44fb84da51be9dd0880d34aab5265c104908ca4340bb0472d158624b0f7aac9412eac1aa8cdd0ecfe7a469eb61b62bda1aa66c07392bc146e66b844b7b8d989de26c803795c77d23cfa6bbeaac4104d31234e4094d327fea131618b260ed74ac843cdba9fce67b5460bca65293fbf16100e4cc8dc281d0967a27626edae23dd4fe32bd0be30df9cbc9e4363ce795b530ffebbe497b9837286b72b3e9d2090f2d05a2c0a086b19ae99613f5d1b3f2ba31f84160c46bacc14be992ab6aa0eebbbf77b77eb47e73dadbe2d029361f715010549a209c9e1352fbe4dd1c3b3cedb3c8f81cf1238e4d6889ff8b7fb243ba8cfe817e6a4e4d4f6e090e1e2ef2cd1f58c94fef4787bf5564d81a512bd99f81c481220864021e53e811d2db8da1eba0bcae9a55032f977d1e7c4f6d706a698a9de7dec55ece9e7780d973e9bdd99d64670300bc7cc59208ad5d898f771167f6820d6987e3d9fd34e09aa3be61ca78c8edd4db66c295c2838d0fa24ea4ae99e04763454156b2741ba68149c4ae6822a59d4c0a80784d35046eeb9e0d40f66406e38662067e5d6525b7384cf390ff96832d3c006c361a6fb6e8df6ff388ff5300ca951acc02d28d0d11254228de3166484803285e0ff3d67ade6c7d20a311959cbec840d1325e78fa86b64ee2fd53df71408041e96897b3cc1e12cac81022488c33b356017d4f51865d1bca561c71403663cf91c46e78c2fd14b504d63cc8b46250be57c49fa85cd837152b8ac63326a1df93d2f",
	"sharedSecret": "dd2f644699213517ffdc1623d9da69aa9a1a17111232b4c70003f22ac45851b6"
}, {
	"publicKey": "0600ac54c08819b700bb49ad72138dc1145cf443e29c150f4cbec89b4846e12ff2846245d3385755519feb0c0ab82753e485a099ceaf112fecd4b1d9916832f902bc530574960381d66b455883c5fa8959cb4a57a8adc15c09c6c0b5775b24aa9540d0d50f7a72c1cbe19234636799e049fe7378e919656e7a9e9c1b072387985e1083345a3f85189801b545b480139e206bb569ba0b2a451f9b287ed105de87b4708754f7f02793d901402bb441ca7578038504020ad04b71eee23b308698dea73caa9900d5bc276f267066abcc3665c48b2967d4274f85bac00c1a69ce32458c09c2f3b8773f9b0996ca91811432ae65954de74ce39741cd74a340806e843199bdb94b88dbaab1b6cea71867d8ac4fb82bccb6eb7dd901ad7e4a6342e4a641d9cffc32b6142a118ad89a8e965917e6417eb3be32d9a856464c18806d15aaa8617b0b37897b4a9760a134a0d196b813134a1ea3b262602d2c6066d0c133aa322fdd63bd49a830e0006b74235bcb921592dc5be0a38151024d884415370cabe2096a6dec71da9523527791e635833d0561e3d55a680b2586dac5a2a549c4e14261bc36d37b9988b1b48d832e9c1891992108f946206c032ca8d596c2bca500d11acb5794fb1729bec15f396b2f7907505608a83fb7cf73351022f36a56b02cb77ba78a02b9f18cb427e583a4d33e9806087ab40ac93b9e551132b4039ea8817a5c5957ed8a0ec6341a7b875995a40e7f407bccc39d5300608d67a50fc7024737264aa1079c7a7252375f08194d0042a11fd2a548966813bc5c81ec6e3364a30a558ae22420098aca5b4639504cc9c4348eda9393abf08b16687952a61051038ad92504eae7112ea3a0eb41604d742e2af222d075c55601b775b16964624d4f7631e3b34324867e8c73700c3aab79f88a4255c2dad953d0053400b13ad6031ab80660be956fa2a915efa6b9b9d8132427790c5a0b31cbcc437798420b7e1047b33364516b5253e2fc8c9c58b0d9eb2bad1646af79a13ca12824b52f4b3075039782b53c01b395a755c55a98ec2f29a614ffa79c7e1b7c77f8a97f5a07540165ed2a66e6118ec2c227bc0c76a6974b0ad975be3059005542da95b44436713c712c157b78e7a55bb1e7be4e8b336b646b4ed09085f647e6b0352335a97e492c8713b27be34857e31b74fc75df959131352439c23f15611db0a76ca077788df505e6b5b8b432907c415b28113fdc24549465c3fd8383974b345fd94e87a9710be84b56e30028eb8b64e71fc3270438b2722a8207c27aafdc23686958453051c0b9e3028196a7c800be5b070137fa7aa5e6620cb42a84bb53d4ba5abaccbb44a391229ab502a3435ca66aa7991872c2b8d7368bd8742e743b029ca63d0cbba53ea57011b7636b654e3a4146b9c18ed3f41176c602b25105a8964b4b77b5a9577d69b2c62883364bf553f2448f20e75665480f56a6359c361a7df9a205da525adb88e4201f3c9688c4b71631f4123b5b86fbc11f65a5cb4db5432bf4c76203b19eb33310f8b5641a00659614a84a1db0ab322a8333d8d29b678977d20545d63bcbb95098cf83c71470b2ae335ebeab6f4af393c959c70c1c8cb3cbb7a9e36a6275cc3824ac8e0587cf40121504c1be6b460b8a4cb97797d15c8a6e15a0fcc6af384366bd02627c869aea84624b0476957463a3a24979e34e7f9c8583f80f1b844ef68cc3be78bfe9e867bbe3704a5bca250720f6fca0c6f32882bc1473322f73051054986c2d95a78ceb7971b234168547da833f8c60c0be717f710c48fb62cd14981f3218819618c8e32531bbe5b37815563fa1bf0b014e939cc61bfcb2de182fae851110a6ba7b04b6befab7e5c660a4753ed07000a4d59b2e250c52324019024c9f843b6b703a6fb6533017c0d0d5895e40114d044042a04b48713827624eaaf6677dc485c9b139ca815ff7550f8fa26a1ce9826b717ebbd22013d8c735b8a828215cb88c941e129fe5cabde0091cc6d8264169a186b2b654f870d25c0ab1412d7efa32ef440cfde318ab9a9501884bd05978eb06bf9a9c5a2e288e2b182996698fbb7967cf4079fe012e3e505901bc836f755e616b602fb10d3a9ba327ba204da5b6cd570e0d431465b13b0d0b0525929207dac52859bb1e45ca438b1af1a285ab131f00206a4789f6d81b9283a90142b47c63a0f4133950ca5c6b52eef8b3ebc256b9a428",
	"privateKey": "060061b6785ee020a290bdd857b73a14130cc6792f5977f70539f9045925023b2e94b5354bb5db72c6edf598570bb09e078d76097f2a10609614544d6647ba9783d432afbe715268100f5bd8c416b10c15a610dd03ceb038004d7bab0792b344d3229568cd8bc7b294d51a64f20d03c8c05ff41aad5970528c4dc865319ac69e3a0a4d73daa300423515f5baa8000907b506d27447861b930e33b1751946efbaa245bb8d6d8062b1f5552213ad4b026cee80c180b16a770408dcb138fdb113f2047dac935299148d08d397a9fb36fe4b253de2a8f3e6076d354ca591643674aedddcb5d9fb136888b351f24026c668307c2776b0225eb0c33e67964b4744422cca9dd14d48d053963b88d3b85727a74ec8ba1c2773be595301fa52bb02407cd74501d51596c1b9bf40b693e676684eba27482965bb781275a4ca96630b01247da7fa27abd493e99b8f52861039b888214196ebba973ab96151368e75a15da893496cb77207790e0a989d21fb02934c27e3481e9b30b482f554edf431bc5cca946ccb34d9789ab555ff077bee330d8cab07cb917a9fb26b20680f1c694819e66b065471d799980c41ced8bb284d0106a5f9bd51f3970f4284274100b2dc865b4425d00394e3e623114cc44dd27f0938256e791f8ae094e745335234a941ca82fef16c659094b9ec2a3356cfc60bb233101ecdcc7019e0be33453fc3337187a6850061688d953174a75d7a2573d2fb0683b04f2510c32e34a4fea495291238ccb53362e9b70660c2122a06e71067b806b507b45cbbe11163d6c272fa285c4813d5773852c94a519b38f60230fe1cc648502e3fc8c4555539a725a413576e648796c33b340d6632097c4afffc7c6d5b33a1a92361e01beae843ef30551c0a04bd405009c95cc5b42e26ac8d83c96ced29516ac3664bb53fbfcb3be4b521a2820a3ab11f6a09685d0959caf0c02b3974b4c23cd9c358a5610ff14aa95d55a6d0319f15634eeb36b467a6a64260c8a9952780d4bc9324aab6f1b789447382886e056407f9992e4dc40081035521822174d429693177af547a2918c418e523b356287ee0851b1c2745fa41961739f54794431bc24517322158b6b8d3571abc2e8ea997f43801ab3a8556a16f13865d232bc31534a9380921c258a299eb85e8c487e2fa742809705c6221182b04aaf2760fd4abedc5b562f54ee0fa0d26070fe5f282b928778f730c556a90e253106bbc036103b8439b7ab0277dea8710bcc427454b054599ca2e8b4dad224fc9474ece8c24e35209d6ea9de3e594342a3f13c27ad9101d1248867d900cc25abc79141f8a49318da3001e506c8e4221b7c61ad84a5b09c48cec35af965ca5064aa9cf856f120a11aa7795edf18a63cc2b8cf34b600bbf89d51ced1baf9777896f4334c8e6263b6998b87a0f9639c4db54228ae86010eb3905664c67a1ad653ab652639f62422ba2617b34e56f1f877a72296380946036748737a8cf95025a7e7a187274c5bf4995c5e8ce1097c5ae846394e4176742079dc947f6708d767471993b965a4238be7abddcd26839ac832d67425042cf3ff34e7da7636950cf3c5c837d79961b8250af4599b814144ca66a5204211bc2ced27b5543f611d2f79b1b765210a61faa87501ffc05c0b02414176a10248c87a6b6d7a74c6c6837f1f79616c907559bb8e17941e11c0e7d2a653babcf5fb863778b4fb3f45104592fd28c7609337ade664e4a61b44eca3aa25c18e36a2e8b5cbd32d007d887404b521b76756a631a363bba2e5fc77488c71b8b640a35a39356154bf4ea4ad8a9c0f5624fb9930d9db4894a601fbd6285b6d931e0b6a743fb7a1c96ae660564da4150fc48232379152b2ab316949485626990fcb40738575a223d1a3cc0b00b4691060e8829b7c7a92203361ed5504b15341095c10e021a0d9698093a0aa807336550697c3fd354a6b48bb2549b01cb7622ebb4ff612c67168c354bcd1dd07a76a9376f5ccf91214826a79bf3f45090d2910098814af4484999b61835376d303cad957652a9a820e85bdc562d824aa05424a63ec298f63691b98a9d649b63b0a25ee9d9c1bb0a9a7e78183ab605603a5d44c14bec547b0d63365750a112ca8faaf49ada3c627ff763b1c4a950334f0d166aafc143f5e426be07c3954778002036d39f931cec9fb7db37ca9144261fb6fb3b9663e8df007267cb711677959c5e00200ab5906375d947cb945f1bacba9438831fbb71a2353b4bac7afe990d11f6fd980600ac54c08819b700bb49ad72138dc1145cf443e29c150f4cbec89b4846e12ff2846245d3385755519feb0c0ab82753e485a099ceaf112fecd4b1d9916832f902bc530574960381d66b455883c5fa8959cb4a57a8adc15c09c6c0b5775b24aa9540d0d50f7a72c1cbe19234636799e049fe7378e919656e7a9e9c1b072387985e1083345a3f85189801b545b480139e206bb569ba0b2a451f9b287ed105de87b4708754f7f02793d901402bb441ca7578038504020ad04b71eee23b308698dea73caa9900d5bc276f267066abcc3665c48b2967d4274f85bac00c1a69ce32458c09c2f3b8773f9b0996ca91811432ae65954de74ce39741cd74a340806e843199bdb94b88dbaab1b6cea71867d8ac4fb82bccb6eb7dd901ad7e4a6342e4a641d9cffc32b6142a118ad89a8e965917e6417eb3be32d9a856464c18806d15aaa8617b0b37897b4a9760a134a0d196b813134a1ea3b262602d2c6066d0c133aa322fdd63bd49a830e0006b74235bcb921592dc5be0a38151024d884415370cabe2096a6dec71da9523527791e635833d0561e3d55a680b2586dac5a2a549c4e14261bc36d37b9988b1b48d832e9c1891992108f946206c032ca8d596c2bca500d11acb5794fb1729bec15f396b2f7907505608a83fb7cf73351022f36a56b02cb77ba78a02b9f18cb427e583a4d33e9806087ab40ac93b9e551132b4039ea8817a5c5957ed8a0ec6341a7b875995a40e7f407bccc39d5300608d67a50fc7024737264aa1079c7a7252375f08194d0042a11fd2a548966813bc5c81ec6e3364a30a558ae22420098aca5b4639504cc9c4348eda9393abf08b16687952a61051038ad92504eae7112ea3a0eb41604d742e2af222d075c55601b775b16964624d4f7631e3b34324867e8c73700c3aab79f88a4255c2dad953d0053400b13ad6031ab80660be956fa2a915efa6b9b9d8132427790c5a0b31cbcc437798420b7e1047b33364516b5253e2fc8c9c58b0d9eb2bad1646af79a13ca12824b52f4b3075039782b53c01b395a755c55a98ec2f29a614ffa79c7e1b7c77f8a97f5a07540165ed2a66e6118ec2c227bc0c76a6974b0ad975be3059005542da95b44436713c712c157b78e7a55bb1e7be4e8b336b646b4ed09085f647e6b0352335a97e492c8713b27be34857e31b74fc75df959131352439c23f15611db0a76ca077788df505e6b5b8b432907c415b28113fdc24549465c3fd8383974b345fd94e87a9710be84b56e30028eb8b64e71fc3270438b2722a8207c27aafdc23686958453051c0b9e3028196a7c800be5b070137fa7aa5e6620cb42a84bb53d4ba5abaccbb44a391229ab502a3435ca66aa7991872c2b8d7368bd8742e743b029ca63d0cbba53ea57011b7636b654e3a4146b9c18ed3f41176c602b25105a8964b4b77b5a9577d69b2c62883364bf553f2448f20e75665480f56a6359c361a7df9a205da525adb88e4201f3c9688c4b71631f4123b5b86fbc11f65a5cb4db5432bf4c76203b19eb33310f8b5641a00659614a84a1db0ab322a8333d8d29b678977d20545d63bcbb95098cf83c71470b2ae335ebeab6f4af393c959c70c1c8cb3cbb7a9e36a6275cc3824ac8e0587cf40121504c1be6b460b8a4cb97797d15c8a6e15a0fcc6af384366bd02627c869aea84624b0476957463a3a24979e34e7f9c8583f80f1b844ef68cc3be78bfe9e867bbe3704a5bca250720f6fca0c6f32882bc1473322f73051054986c2d95a78ceb7971b234168547da833f8c60c0be717f710c48fb62cd14981f3218819618c8e32531bbe5b37815563fa1bf0b014e939cc61bfcb2de182fae851110a6ba7b04b6befab7e5c660a4753ed07000a4d59b2e250c52324019024c9f843b6b703a6fb6533017c0d0d5895e40114d044042a04b48713827624eaaf6677dc485c9b139ca815ff7550f8fa26a1ce9826b717ebbd22013d8c735b8a828215cb88c941e129fe5cabde0091cc6d8264169a186b2b654f870d25c0ab1412d7efa32ef440cfde318ab9a9501884bd05978eb06bf9a9c5a2e288e2b182996698fbb7967cf4079fe012e3e505901bc836f755e616b602fb10d3a9ba327ba204da5b6cd570e0d431465b13b0d0b0525929207dac52859bb1e45ca438b1af1a285ab131f00206a4789f6d81b9283a90142b47c63a0f4133950ca5c6b52eef8b3ebc256b9a428",
	"seed": "0ab5906375d947cb945f1bacba9438831fbb71a2353b4bac7afe990d11f6fd98",
	"cipherText": "3d8483216bf80957be786260759a3e3cf953bad1510c0f7b58b0e36a5f5efc635df962f80ae362986315a3864b1586e02897e7c7c46c438a2e407b96f7c0c29f4f55722a2dbe225c4526363cd2ed33297a2836f558ff3c4cbec3e9ca3821ae85d3d68f9c6b4e52b85218d498431e51ea6e3b0a40570f5bb211436cd1dca7bb87d287038ed2819b1aed4a8de27df0310fd36f4de638a59a5520cd9c1fb9a6676ebcebcaad41c059db587bd8fcdf1236e3c2610358bfb6707c41de7403f6e332ad208ef94e272c7cff396332fcc9c12aa87a9086ac7a3ea8c3a8a30fed04e7f21e77d294865ddf1c388210aed22a1ed29b6f60d6e758388851b7ad2e42473a117a688b0f8c8de9f0365f99f996b69e88d82fbf3a58ae95d7bd4ab9c18aae3e205718e9235ed3691f3fea7e73e0bd1d1e711a38bdce014b744682bfc6054b7686ee935def1bdc1236c5d2ea7b3d74c4691a794211b80dae68e3693e181df4441e5896bc0c837f5867946f1f65db6ab9dd596bd028d7a21b3b6417e23d60e89a702401e72a2afe005bcafb1fa287ff3c12701809aa29899727b0f94b3a4a637a0d3f83cac0f23a13463b50b30ffb208a0949708920c5b65ff923da209d3c1587e5de2680c844b6c60b06bc496e6cacabb562f0c3b508e8b1c9b571348aa829a5c458ccb0fdf8cf3767583e64467f067ad3a2eb7aedb28b502ea557648299b045e7074905482a1c4b114d9edfaf6fc19fe7e4ed41d3befde49df3bfa28ade6746130219ffeb1e39e6f457cd2fd62a9c968cb0a3046a857dee272af07ab34467d147d08be9e9bbe8cf197467194f2d299a5191db7ff552878a0e2dfc550a492731b9fd8332e0724e41ac7ee568313d65e643adf4980847a888adafbe3e2f7b76d43f86d59159ce0523dd432887ada00fa8339394991474e690d25376410f1168b86e2b773c7b513b96999db1396dcafcbf0b3865342d98c983d65ef45fdea3cac46753426f81db433eb4f3fecbf3413d308bbe032d3c7e07199eabcd9bc2195579fd70c25200cbb05ec5476efcec0c00d2cfbe8726f23f69bf0448a0f262566e22017021e8ef2f41a979eb6ca862796630e607308372f9dea9d59606c2f128524be0d0bfcb694f584b4a0580f06ceb2c1e2c43705609d6d77cb1a064b8e44c6f8a954f1666dbb472f172f20f513e2b1b93327cde42a564034fe035d1ec1764c762b1e761e02d90aa94f828eda73ec9aeaa9e577741567fc4f89650d70476de4eb7ec9b1612a4158518331f7959f80fb147f189cf06130bba80ca801d573490d25815d54db6547cbfa2952203ff3833f024197f417f6a8bd9e6d3a0741d66f1db2c84e6ca5b0855ec7dc5b22c5f4abcbd473ed7bd02ac7bade4c411f31db63c6f73e395517b4be4ca7e8bc326a3a4c7a85d79a7c8c61a690381ed787f5dce4cc494815fd59973118f479c7409cbfa0bc0dd4677af4a9684ce13a85c987f55b49f1fc14872d83458c0a7b0451362d203c65c589ca7f804b894a359fb60c80ef381acb48b48cfa8a592b7fa040a0e62e37134c23d0184c4d4a264e03f02925b3f84e6c1339957652950e421531ca3aebf5df7c89c938990c41c20f85cfc3bdaba65da1504f4342468ac1245696619ec811acd86cebc4b11e5cf59892ae7ecf6a74def31ef0f6b6bf2b564a7d4192b2869d59a1e7f91dec379d04583da0c812bb4dc411ebddd4fd86ac9c8a34b4875985428705f7ab725880770097cf21a64847e52c341e1d3ecb50e9a9009753e9908ee6abe90431440ed8dbe4ebb14f267e9e477632c141d3cf292a051f2dac4127dc8eb7a91f9e308e3656ac10c5c6c8831e95c766a4bf77aaabb514853285cb33f6042cb58936a70aaa155e28302de29ebd399974f2035348cae9f1e5bbb18a2f19fbf51f00f4b94b39b9421f54e606fbf38ef49c943144b3bf14ffa969fc06f2838418db6f925cf623a6af67b8f96089e66b7f8d88c9a4486fbc4bfaee21eacf7f7caec4ec56cd294b4ee1cda8131b62a762e475ce18e61b8395080337ec0d5888bd571deef4e24bd2e565fd4f170dcf08178977fe15381a622bbfb8ba6ab4ea4b5a7fb8e4ce204654da24a083de1cf3d0873204e052e6b426c97766f380d49cddbc12be173da33e9e27f0c40c13dbf63166053793f2209f34b8cccb9800c51ce77943fbb0a1d56ddc29ea52a229a25ed3cacd0e040",
	"sharedSecret": "c6793e91187d9298f0ba08179a11d91c8801bd1aadbf72b92c16ae57fd328e6d"
}];
var rsaSignatureTests = [{
	"publicKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf9",
	"privateKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf90200816022249104e1f94e289b6284b36d8f63ee1a31806852965be0d632fc25389ac02795e88eb254f4181bc2def00f7affa5627d6bf43e37e2a56c3cc20c4bbe058cf2d3e9fa759d1f78f3f5f797fd5195644e95fad1ecac235e51e72aa59476f374952b486e9db4b818157d362e3e638ee9edca329c4336df43fd3cd327f8542d1add9798af1d6a9e8cf8f54dd0b6a6f9ed9c3f5d803c220716757871e1442ef407ffe5df44c364bf57a60551b681173747b8df8e4138101f1d048cc1941a5d4c1fd3eda5bc96496eb1892477d811b845a7c9b3333e700989a1134e8f65edbf3a8332baa7195eb6aa33591b6ab41ec8215c6487979df5cf1b9736fd4fea73eee102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7a2e7a5cc651614fd17eb10765ef63462e5767745fc849e97095319d42f8cbb1485aba0f590b33208e666e949db0465e483a122467f771a986da6855abb148d0b5c1eefb08636d0aeb36b8ec161497cc9a64704f0976aceb33d09af5408ded1aec771b534f9a27fd9dc3303146ce98872915ed730ed9661eec46b8c0d6b6d37020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a632cb2e0a17ee6e363e3e056e5170480a3790023e342cb221431be37d63e692ce572390a379cf470c8a9fa4251a0af84d746b79ff91f6dcf168417137150d93049098ef747a601825982cbbd1ac1c20b3f3ee97b25e1739c31b43e78fc1cd53134dc4e82ebf98c720c34852fbd2288370421b848575f4d054e1d1e66b47f4f02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b09e8b48e56fd2859072135f4b129f62546228914b80fed239d1f756436f3a3c4faa98b2336bf0e6ded86771cc49beb1beab0b4b2a3bf8e20385e029e083b368d4579a9322a343da9ccadbe14edc527f5ef6754273fcd088e92c4a5d30934eeaccfcf05bbe17f66acc0055b92c72db229a50f3e2db40dda0b0c17e4b9cd3e3c30200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088861ee6e7e1a7f8c1287a40ce56b3ae159b79caf7f166057fd35fd1984aead1d313eb982942d897088d4a52b606bd13b9632d7400112b0bcdcf596b9693e42ccb982acdb43a35c0abe63fd5af1a54312604fdbb365d5f2afefaad2b798d6869d6a3aa15fb8c75170f5b5fae4f72ef7089462c136c55673f12ebeab0119e97dd02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8538fe6ebe9514412692fc985f8fd62b237c51c160c3d49aeeafffa057f2feff8f29040a205895b61dfa3f6188851021dc9e50152f3ea69746f5eb491af4a6dde21db9fa2c6fa61198ea02d6b600ed4267c3871af686c8db12e4bcbaaaa552e157e66fda90d34fce11cfd0f5eea6fbb236818070fb3a13751ad408e4231f499",
	"input": "e255f0e68147e62fd740f96071fb91e4",
	"seed": "05f10d85d4ce01f36500193e1c2a34d966f4539e94a9ea847bc29411d5e610b9",
	"result": "1d7256b9e3b864bd4659ca7073446fff5c276d1751f31953ba2143c35084c9f42df204e735634efea941911fe47de08ace8803b22d6db47294d4150b118ac193c2e0502d83da4074f6c63a627268051aac42eb294058d002138387c36361deb5ba0e0b0430768583dd4fd90eef90d3335f541f6b976d9550c0d0e1cb0b2b646e9073408b20497a796e5d8b1e976dd192d949326384a169a7b3a404911c5fc9499d74588436c1d599bf494efddab281ea28ad9b98a29f8b38f7e534b736e10e7204a10d7142f5fbb1620eb8d2ff5a6dd99b4baa577b9d6ffacaa9c053118c9c177d427204213c8be6818db34e0eba118dfa179521e3c7e9253963da4e56b12717"
}, {
	"publicKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf9",
	"privateKey": "02008bb1bbcb2c6915c182b0c7cc93e1d8210181ffee4be4ae81f7a98fdba2d6e37cea72e2124ebb6b05d330ab1ddfbc6d85c9d1c90fc3b65bd9634c3b722fe77ab98f33cc28af975d51609e1c308324501d615cbb82836c33c2a240e00826ddf09460cee7a975c0607579d4f7b707e19287a1c754ba485e04aab664e44cae8fcab770b9bb5c95a271786aa79d6fa11dd21bdb3a08b679bd5f29fc95ab573a3dabcbd8e70aaec0cc2a817eefbc886d3eafea96abd0d5e364b83ccf74f4d18b3546b014fa24b90134179ed952209971211c623a2743da0c3236abd512499920a75651482b43b27c18d477e8735935425933d8f09a12fbf1950cf8a381ef5f2400fcf90200816022249104e1f94e289b6284b36d8f63ee1a31806852965be0d632fc25389ac02795e88eb254f4181bc2def00f7affa5627d6bf43e37e2a56c3cc20c4bbe058cf2d3e9fa759d1f78f3f5f797fd5195644e95fad1ecac235e51e72aa59476f374952b486e9db4b818157d362e3e638ee9edca329c4336df43fd3cd327f8542d1add9798af1d6a9e8cf8f54dd0b6a6f9ed9c3f5d803c220716757871e1442ef407ffe5df44c364bf57a60551b681173747b8df8e4138101f1d048cc1941a5d4c1fd3eda5bc96496eb1892477d811b845a7c9b3333e700989a1134e8f65edbf3a8332baa7195eb6aa33591b6ab41ec8215c6487979df5cf1b9736fd4fea73eee102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7a2e7a5cc651614fd17eb10765ef63462e5767745fc849e97095319d42f8cbb1485aba0f590b33208e666e949db0465e483a122467f771a986da6855abb148d0b5c1eefb08636d0aeb36b8ec161497cc9a64704f0976aceb33d09af5408ded1aec771b534f9a27fd9dc3303146ce98872915ed730ed9661eec46b8c0d6b6d37020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009a632cb2e0a17ee6e363e3e056e5170480a3790023e342cb221431be37d63e692ce572390a379cf470c8a9fa4251a0af84d746b79ff91f6dcf168417137150d93049098ef747a601825982cbbd1ac1c20b3f3ee97b25e1739c31b43e78fc1cd53134dc4e82ebf98c720c34852fbd2288370421b848575f4d054e1d1e66b47f4f02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b09e8b48e56fd2859072135f4b129f62546228914b80fed239d1f756436f3a3c4faa98b2336bf0e6ded86771cc49beb1beab0b4b2a3bf8e20385e029e083b368d4579a9322a343da9ccadbe14edc527f5ef6754273fcd088e92c4a5d30934eeaccfcf05bbe17f66acc0055b92c72db229a50f3e2db40dda0b0c17e4b9cd3e3c30200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088861ee6e7e1a7f8c1287a40ce56b3ae159b79caf7f166057fd35fd1984aead1d313eb982942d897088d4a52b606bd13b9632d7400112b0bcdcf596b9693e42ccb982acdb43a35c0abe63fd5af1a54312604fdbb365d5f2afefaad2b798d6869d6a3aa15fb8c75170f5b5fae4f72ef7089462c136c55673f12ebeab0119e97dd02000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d8538fe6ebe9514412692fc985f8fd62b237c51c160c3d49aeeafffa057f2feff8f29040a205895b61dfa3f6188851021dc9e50152f3ea69746f5eb491af4a6dde21db9fa2c6fa61198ea02d6b600ed4267c3871af686c8db12e4bcbaaaa552e157e66fda90d34fce11cfd0f5eea6fbb236818070fb3a13751ad408e4231f499",
	"input": "c7193d0896f98f57c9b201af869480e3",
	"seed": "05f10d85d4ce01f36500193e1c2a34d966f4539e94a9ea847bc29411d5e610b9",
	"result": "53dd60af925f11d7923a79a62e7126fe15b1cfae4c6c422830e934ddbcfa70728b1e0256efa34623ac1f28f707e5a26d0a812cf9834ab05064cc0f2c5d858fd5ee58ca82e8d2e83d9d07ed19c21be04f4a7939dd559f95cbb30f882ee57105f4c08541948500a691a85b193329b9a62fb48101f165f360c4a6d1a909cff5850710ac32c365c492bb18abd3e7bb7df6bb665a906c7e13c306640be3257e1f0a11d09461924fcf2329fb1949cf9e2c5216558bae2d941c6aafe55f2d87d0c8033de3733c107471a856031212f50492b67cf1c3b70ef1489ed6d66ee26ff1cbb219a62c56459f9c40a01df0dc2332e12fe0b1cb4cdcf303506124408e32568130af"
}];
var aes256Tests = [
	{
		"plainTextBase64": "",
		"ivBase64": "fj9oCCQjyXWdqw9E9uGzkg==",
		"cipherTextBase64": "AX4/aAgkI8l1nasPRPbhs5K1v3ZrnLORHwT181LrcFmPztC0x+YJYFB/o+eVfoyW/IQwJl5nNTRowia/ZLbhzjw=",
		"hexKey": "4776d1a0aa814f2daf9fb710361ddfac7f018b4cc4ba689ab9c67967e84ca9d9",
		"keyToEncrypt256": "d116b21f4a47dc29cf061dcc57befebeb84160315100887eb4be68f8a0cbfd23",
		"keyToEncrypt128": "4c403bd7da91a15b1acdef29975ebe62",
		"encryptedKey256": "AX4/aAgkI8l1nasPRPbhs5L/EMNrOcGqCKhuQblhqa6Dk7tedKQBIMSqCvUP8xM6DveXwySH78afbD/tBsM25+EazEPayJpiHzc1hz1PSpCf",
		"encryptedKey128": "AX4/aAgkI8l1nasPRPbhs5KrA+OR4/3LLJIOL5grWi5hscGcy62A7cOO/GHp6Uu6+IWR3Yfe20TeSuEWX8SovmI="
	},
	{
		"plainTextBase64": "vQ==",
		"ivBase64": "ThwJYaATPDfmNkRRSlSIFA==",
		"cipherTextBase64": "AU4cCWGgEzw35jZEUUpUiBR7gg/rnRpb1DXX3rKuX0qdZWj81lG4toybqfyPOCRz5jQTFgFmOn+C4mSKfX3YXlI=",
		"hexKey": "73a52c661f3e39068916449ba9eff90f9ec39b16411d2f950b552a25f08f46a9",
		"keyToEncrypt256": "a89d53fa91bcb06dede817a40e6f7b17a263c6ab51b9973b9d36eac1409df0da",
		"keyToEncrypt128": "479eb7fef664827fb3b0aea4bad45550",
		"encryptedKey256": "AU4cCWGgEzw35jZEUUpUiBRFKift9fceUjUwRWROF+t07PKXzhb6ZM4EPFDlgKTNON0rFTb+H3Q1XhLiB9wDj0zQT2qkczlQ1rijq74+tFZp",
		"encryptedKey128": "AU4cCWGgEzw35jZEUUpUiBRncSPr8me3twdNIbdMA5McIIwnOSHQaJEb0bynStFSxOhpeKKdzOETTTnsXniHjjo="
	},
	{
		"plainTextBase64": "zvE=",
		"ivBase64": "H6GSen11EEjDwoVbWuN2Ig==",
		"cipherTextBase64": "AR+hknp9dRBIw8KFW1rjdiIx+Ia/bfo8ju8KtPqztOu6JV9APVUbISz0CBpuk5HMFDvEAliiSwvEOErKwu76P2M=",
		"hexKey": "4d18fbcb55e5af5f7d659687a9d53eacb482edb8b2accce5e89f85ac2106c6dd",
		"keyToEncrypt256": "2f4e2e52c2626e5f36171d84d9f021436522d5c491a55a892de4e8e5d4eb4a71",
		"keyToEncrypt128": "574e9cec3825946c3d2f232ebccf469d",
		"encryptedKey256": "AR+hknp9dRBIw8KFW1rjdiIcMr6P1pPzyU+QKiAQ+oIGnSPvwYMqOtN8Agh6JCuFaS9Dr2TxMx/TpRh2mwBQoHDYVHWm0bKHGZFAzCBmI5y2",
		"encryptedKey128": "AR+hknp9dRBIw8KFW1rjdiKJBpZuh4u/oM8pxdyCq9XCxa7sw4AdnM2VXN1zso4Zcr4Y+DiP/plIUWqbNiExLDg="
	},
	{
		"plainTextBase64": "k5L+",
		"ivBase64": "Qwq2EEbUN+MdnTVmfCYCeQ==",
		"cipherTextBase64": "AUMKthBG1DfjHZ01ZnwmAnka/iKGKs2i0JCn75gPWTZDKbJl7y4xOPUViFM7x7IJN6KDB1ObZE+fWEHPg9+bTSg=",
		"hexKey": "711e8930a9d03844303293b9998358002b19de0f16fc32c9e001c7c6d5a246f0",
		"keyToEncrypt256": "24ad03ed93a52394da93d14af4f5797c411e58a35b617b5ea5c56655f2689e48",
		"keyToEncrypt128": "806200924949abf0fccd84bf48a6338a",
		"encryptedKey256": "AUMKthBG1DfjHZ01ZnwmAnnW2gC8L3zhZvZhYXhsuZIokn7Px5cwSOE/5f800w/2prl2DoHsWy3bE1jP4p7fDEr3vFSFSQjE2qUnQLwYtUV+",
		"encryptedKey128": "AUMKthBG1DfjHZ01ZnwmAnk915vlRfYwHrmnMhdgERFZt+ETjE5F96Fw0+XmMP5cAh2On3TKl+R99b6yaYfl+Ec="
	},
	{
		"plainTextBase64": "2csQAA==",
		"ivBase64": "ucHGKLZXVk9Nabw03YmdmQ==",
		"cipherTextBase64": "AbnBxii2V1ZPTWm8NN2JnZmK6X7ueiZcmZofGTQkgSOEuxW96+38oqU87bFRIPnHlDIOXbgrE4CsXOrdGwnmGr8=",
		"hexKey": "7ddfb103f848b42a9661151f317573a1e16afd461d56a2976dffbef62c8928f5",
		"keyToEncrypt256": "28c982eb3c5b209b3e5f40c821de4c13cda34f244565c8304e05cd2ab2842896",
		"keyToEncrypt128": "38e8ae53082f5c0bbe67e901adbf8017",
		"encryptedKey256": "AbnBxii2V1ZPTWm8NN2JnZnMCChTUb/RwQKoV2JCXJuJYpJuchDSk/ZuAysAGwwjtgpepOAtSXQ47IBjeOc1EhVg+U7f9WBmGzPlRvDbavw4",
		"encryptedKey128": "AbnBxii2V1ZPTWm8NN2JnZnEkBVOq+sqz0CDEgqEYdwtRjqgYhvvttv9x0o6dgkPjP/HEIQI8/pTboGOKw1/p8Y="
	},
	{
		"plainTextBase64": "j1leGJE=",
		"ivBase64": "Tz9YjEzvdi7WT+JQmNIwOw==",
		"cipherTextBase64": "AU8/WIxM73Yu1k/iUJjSMDvuBFdj8hDShGz7qZi7lK7lIw0goQsDw9r0U57R6QncHDpEV2/9wYwknkwivDLoTas=",
		"hexKey": "e47bb578d532672c76acc785a1db903e3f633eceecb4ad60b887c85c2996750b",
		"keyToEncrypt256": "bca8c8c5dfbbbce51ba3d210436bc16dc00f05cdd3f99b5691b1dab35cb23c5e",
		"keyToEncrypt128": "c7b605468ee418916cd89dd1bfb94563",
		"encryptedKey256": "AU8/WIxM73Yu1k/iUJjSMDsAXDuvkBO5gg/nMp7zYMQgJDHKZTG9YUPesKyMTWRPe9uOsnpmRupvvEWhwUOeOVOH9flTe0bTk+aYI46KOWmY",
		"encryptedKey128": "AU8/WIxM73Yu1k/iUJjSMDsmIpHXjM75foN/q/5mg8AZiytVG3GKQaSb6CbBL9prweWe2JrnWtJXXroRJGxHuCA="
	},
	{
		"plainTextBase64": "xBBE08Ym",
		"ivBase64": "Te9456nlDVwLrA31rwqW4Q==",
		"cipherTextBase64": "AU3veOep5Q1cC6wN9a8KluHp9MU0Gg3jDZgbJ6AqiiUsz9gwMW+kkybNt0kmKgjYC+lvYS0XwYhkL5jNnVCA5ZQ=",
		"hexKey": "b9da36df3f03d6e9dfcabfda4b83674987ec3f84acea3590182292acf9872afa",
		"keyToEncrypt256": "6e8dd6031e4f3bbaec3d3960efbc9bd195aef5c1b16b9cdcf946ef5e4f1b6e4d",
		"keyToEncrypt128": "56f3ff81adcb3a59cede4c753072ea1d",
		"encryptedKey256": "AU3veOep5Q1cC6wN9a8KluEvhEBVd4FGBsKgYEXBcoHiKhqJ9JDMiPI07wpoXs9DGFKFaWapIBBpImTcoInft+8PJXtxm6xTHDBUSZz6LqUg",
		"encryptedKey128": "AU3veOep5Q1cC6wN9a8KluE0dtqabLSdmBcHEl1m2vY0rkdr0xzfN8pGTCwrjZ6XQUkXVlAWAR2a6ZktZyj97YM="
	},
	{
		"plainTextBase64": "lVIr7qIGKQ==",
		"ivBase64": "Rlh4+FoTpGJuVZ5lr6uSXQ==",
		"cipherTextBase64": "AUZYePhaE6RiblWeZa+rkl0GWvyw14Pec1T5RNkmXDCrwFscjWbHnaABY4aznoF8ZANwrQ3NKezvC6STBvnvLkk=",
		"hexKey": "e60ded9728bbae31146c1ff92db03dea1f47b47c000f6444197e9577596d5916",
		"keyToEncrypt256": "df348231ee07b0f402b9caa5ef9af617ab26115794f7e2db6eb3c87344f0836c",
		"keyToEncrypt128": "31043fcb416127b27cb0098ea1f09ffd",
		"encryptedKey256": "AUZYePhaE6RiblWeZa+rkl0uwdjiGHMTogy0H1cGYxTQfBI0rHP51rPHvPQtPqBc8rxMj0MF9wwxPqgEqa0mOwnhTCo/NgBYW9+KpV17o/4/",
		"encryptedKey128": "AUZYePhaE6RiblWeZa+rkl0KZaQWZckcMHzsCCcocgKjkO8Lks0crzz/xLFA9Nbc03CzIy36BaUwSZdXX8mPeso="
	},
	{
		"plainTextBase64": "Ewpqmm9X9jc=",
		"ivBase64": "QZX5diZe1FAmfAV0VdQ+cw==",
		"cipherTextBase64": "AUGV+XYmXtRQJnwFdFXUPnPXOlKToi+jXqyuUpN4xxYItkuqYRH4tiJfynKbof9fgLYEtqL5mgoebd+VqTjMOlQ=",
		"hexKey": "2bbddf5fb81bda956616ac39a7c59b506c812f5e6dd21a4b94567da28e3b8f7d",
		"keyToEncrypt256": "f37024155f1fc3edfa0889d1669999ca612f75b4f31e219a4459a472e9c2224b",
		"keyToEncrypt128": "63097f413e2dfe390d49d908971ddbe3",
		"encryptedKey256": "AUGV+XYmXtRQJnwFdFXUPnOn5z1QjeFZIZE4nGNCyvsREgeRAnKtVJ9oYJdSOV7jSdkzFQdfdKI2EWHeAoABisWre4yiFRM6V2Lyj/RuieFl",
		"encryptedKey128": "AUGV+XYmXtRQJnwFdFXUPnOR6ja5Od/3SWSMO3/m5mcy16vGR/lHjFObkeKMNtNLXZCgE/7KFhnajwfGiPiyvhI="
	},
	{
		"plainTextBase64": "hojmRjzpORSF",
		"ivBase64": "KeXcFNSJdb6XIHtpJkHoSA==",
		"cipherTextBase64": "ASnl3BTUiXW+lyB7aSZB6Eil90ch0X1o2QXCfETnvP66Z6AiZJjJ0Py5Nc4CcG1dDZoNV9L0Jaw9GZoh+PZOoaI=",
		"hexKey": "3b8681ad10e101b9b0fed20f7091ce3e1b955f1c3abc2bfbe54cf2094bdacd99",
		"keyToEncrypt256": "3953a715d4596bf9b38996be3ae96367113bef91b5ab30d2befef4a596287062",
		"keyToEncrypt128": "6d2a61be301a50a5ae8baacd00a7576e",
		"encryptedKey256": "ASnl3BTUiXW+lyB7aSZB6Eil53BCYQnKV6TLH2/WwOt4wzbJcYUhZheAAacPIO65JM4i9c0xdUwKPCo/4ipUv4U02g7CbV/lNAKRhRP8+2DR",
		"encryptedKey128": "ASnl3BTUiXW+lyB7aSZB6EjHqu6DUkx8fLCquDG86lVsTk/1M4wLgOjiRmQ0m8ewSWlAwxWy36DLljCY2TCgRps="
	},
	{
		"plainTextBase64": "25W+ya607I+yZw==",
		"ivBase64": "SO9CsAyXQ+g/8c67VYWvTw==",
		"cipherTextBase64": "AUjvQrAMl0PoP/HOu1WFr0+0xHyzAIF2hCn6VSEW5geIq+QbuDJqvlDfNgUxfCpWfULqXQ61xyfJm1u8zZffY4s=",
		"hexKey": "edb022605593c2f1044c64cc03fa7d3e9f77389a0ca03ca9690cce06f7cfa55e",
		"keyToEncrypt256": "0a2e032bb76ce8a6a57140d3255ec0a86019db820c95d5f8417ebd3556af9308",
		"keyToEncrypt128": "2d500e9ab4b10526a6620b914da6087e",
		"encryptedKey256": "AUjvQrAMl0PoP/HOu1WFr08gpEJZ1MKXUVpFPkHRryZmyzY2tkgFsWW7gg66SebHYRrflo2reBDDomx+VPovfQy1GNXmEzTODNaua57icHqw",
		"encryptedKey128": "AUjvQrAMl0PoP/HOu1WFr0/qk52LBBm/sRGOuKxZdgN6kbpSSexwTVCXUFlD9wCCaSvIXruxBQ0X44qHC0TewEQ="
	},
	{
		"plainTextBase64": "SJc2ubLMPbBq2lQ=",
		"ivBase64": "Jx5u0aV8LDtu8jY5rQke9w==",
		"cipherTextBase64": "AScebtGlfCw7bvI2Oa0JHvetHTKxDpxA/2HpknZyc7tpcQCYDCBB9NOpl8n4T345rjjKim0PjvQf2BDnsC2kOJw=",
		"hexKey": "6be6f6360ecb51a7ef266ecac0a3b676ff600291f5a255690ba2b708e547e9e1",
		"keyToEncrypt256": "b1ac241eada34c95771be2bf3fca41c56a5653d23e051876b071ad201630b398",
		"keyToEncrypt128": "434f6f118ff6f7d486a5e716b8336ca4",
		"encryptedKey256": "AScebtGlfCw7bvI2Oa0JHvePcyYH6XxP2wf56yqQquukwoWo883Oi/lFpxvA5I/Yu33fcSnVWROi9XXe73iD6ieIjmqSESat6GiHoni0EUHT",
		"encryptedKey128": "AScebtGlfCw7bvI2Oa0JHvdvMKUbxfCcQy0CIvYE41nkl/MA2BWRttZ5TvEdUuN5pywCKis1N2EKS+3Wd1fiuiw="
	},
	{
		"plainTextBase64": "VK++FveN0aSm/9p5",
		"ivBase64": "IrLSmPyNW0kySh2JPCjmhg==",
		"cipherTextBase64": "ASKy0pj8jVtJMkodiTwo5oYl5/grgxVQjw/pv59Lv7mCXlnlPliWVqjgL0CVzP06AWBLphX6vMuY+BjRDp4SeqY=",
		"hexKey": "81745cf6ff5495101846bf3fe7de01948d84dc378f2492a15e33a20ab55b8d24",
		"keyToEncrypt256": "06802625f88c62b5406efb3c739854b2dacfbf7c58b214d263971f5b3691b5ab",
		"keyToEncrypt128": "13e532e5118a706c990239533d3d718f",
		"encryptedKey256": "ASKy0pj8jVtJMkodiTwo5oYLsyBP+4Vdla71askF5aiSkLI5ow4RI3ABB74AbeXa3tWIBDBJcKJVbcZzeG7Odjmv+GyzJmcFjrRG9M8sU2Ni",
		"encryptedKey128": "ASKy0pj8jVtJMkodiTwo5oaGzmchtLQoRTZQ70490Jryfsi4uJL4/PY7qy/5ktq9B3YxuWUObxw2qLsseKARcr4="
	},
	{
		"plainTextBase64": "YtJO1GQcuTHahkMPyQ==",
		"ivBase64": "vJ0iED4s4Un+X6+yLfq0qA==",
		"cipherTextBase64": "AbydIhA+LOFJ/l+vsi36tKgZK6QaZlHAVzpNBmKYmpWVjTBIKxizHCqnrPHO1YrciSdn4loKLC5S6Vi5ZTS8fWU=",
		"hexKey": "80b1ed897ae1e96f22f8a8cdb3da28992aa4a34585b8e6607475932965f04c8b",
		"keyToEncrypt256": "478702828c7302f8870306adadf0bb47e1de500dc99117af74cdaed59648d11e",
		"keyToEncrypt128": "caad900e41c923ff242ed506c3676d3c",
		"encryptedKey256": "AbydIhA+LOFJ/l+vsi36tKg9LUx+2ItOaVFMsuEMx1wGk3XU/z1dFm3a58QFgMSZbei5h0gstpfJ+q7r2l3lCwGqeTru2pJVeL2ua1dyg6Fq",
		"encryptedKey128": "AbydIhA+LOFJ/l+vsi36tKj3RiQ+JBXGGtXBJ6JB3iuZ/pK+Aw2Pz7XR49HnnqwPFtMBQPeIa7hSgsoJl/OV7+U="
	},
	{
		"plainTextBase64": "GcSxe8JZQqsugUf6NdM=",
		"ivBase64": "U7aW9nHOA+HvJxfyI7NK2w==",
		"cipherTextBase64": "AVO2lvZxzgPh7ycX8iOzStss8HJKYQ2eC2qEKYjLD1cgGQrTd4rPRqDAqbu1Nyz/dS+eSQ7WKDdPa0SECLWwNZE=",
		"hexKey": "d2ade024bf8cf51b9824abea56f8e5ed7aa9c3f9719c7ac47146919476219d90",
		"keyToEncrypt256": "6bbe83b2e0292997738741010de051c975c136b57de7576e06edbefa24218568",
		"keyToEncrypt128": "15783500bb212ff19caa6fda6518214e",
		"encryptedKey256": "AVO2lvZxzgPh7ycX8iOzSttHab/UsuqAmtPXjBcIXHHd+lSkCkmrk75mWOmmNl6yqGkFY3FhLGAAcoMIrwqSMYWJH/D6CAmMBcSOwaqLdtcc",
		"encryptedKey128": "AVO2lvZxzgPh7ycX8iOzStvgXWdr1pejp/DOEXukvFWexr44JXqJC4VX3rHPAUcHut5aXCM07Pzct2E2K3zZ8zM="
	},
	{
		"plainTextBase64": "NnS0+GL8GFSeJb7ERZ/I",
		"ivBase64": "4XA79tFuaRmJptDFF/2IFQ==",
		"cipherTextBase64": "AeFwO/bRbmkZiabQxRf9iBVGedUcLG7JNEevSeoIT71IEKxDcCcqfkm4OYl7L09wxmOjA4KeB7BuNvenGEvdUiI=",
		"hexKey": "96dc451c1a710b9a6135021545c7497e84720363d676f40bb5bccbe1fa5619a9",
		"keyToEncrypt256": "8e90e7132ccdacb961ef8b505c3f6780f5d8f0764ac433e31ca7ad8aee95607c",
		"keyToEncrypt128": "0ab312e141cc09c07a9c8aa02c8d1868",
		"encryptedKey256": "AeFwO/bRbmkZiabQxRf9iBUgroH64tBjEOVj2tQo2CW8VklYR1WpuS/BrB/GNcdzuG2OSLYU1DSePojSGamuw46ng5kscHWSJx9Xoa2LGgOW",
		"encryptedKey128": "AeFwO/bRbmkZiabQxRf9iBWXLRLUGVgTwlQAyDd5KKNV3lG92kVK0ncDE5s+s5aW8Erwb4aJgV0oBRO9GkIqbtQ="
	},
	{
		"plainTextBase64": "Q5S80c+7nJjeNpCIz53XwQ==",
		"ivBase64": "l4UPMa2gzVu/GXBWv/M1kg==",
		"cipherTextBase64": "AZeFDzGtoM1bvxlwVr/zNZJ3jIktwL50AdO72rRYJkoFBluP62L3n0jQ0oPR7YWz+0YbE86Os1rD70eXruKYi1MMbhw6eT/HrEj2XMDHkAdh",
		"hexKey": "b11f3ece204d1792527f3eb5d2884e5137b21677d5274d5ff7f8e77f6ee5b508",
		"keyToEncrypt256": "cace8514cbcfb9b845c641f03180765b8e9760b22e38a0bb071b63ccfbaec787",
		"keyToEncrypt128": "c48967a0f03fcece4f23a44d10509a48",
		"encryptedKey256": "AZeFDzGtoM1bvxlwVr/zNZJR41uD2kPk/g2uUF5AlGRzuYdTa937G+UaQyichd0HL21PtJ9GN7L/Dpi5jdS8UPmH+1WfGM5zRbcHj0NFheij",
		"encryptedKey128": "AZeFDzGtoM1bvxlwVr/zNZKmWSTKu9/2EBdrLCv1rajR0RfQqtBngj0PevDl25eyGy3CHmey/1grRu49ksM8dNQ="
	},
	{
		"plainTextBase64": "Q1WAHf0xNpP5Xw8Yor0QQb4=",
		"ivBase64": "ZM27lXyKAHjSJJKtF4dksg==",
		"cipherTextBase64": "AWTNu5V8igB40iSSrReHZLILDi5by5wOFxsMt2BR+CHl2dV21A1XkiZA/XtxXIxMn5EWUwCAYsIlRdrYy6xrp7voqL0bPT62Cf42bIcTPFHD",
		"hexKey": "9c2bf28ac558047002691bd8dafc870637e0b57a167371a1bd4f00aaa13e9920",
		"keyToEncrypt256": "86f96a826837404aeb1c66c0bdf2b3bba4687606ec5a4ae65ef397f9a52c65f4",
		"keyToEncrypt128": "3492dd558a7293249800ee04e7ddfc32",
		"encryptedKey256": "AWTNu5V8igB40iSSrReHZLJSAjd2tEa6M/ba2f1fUMUt1h383FagFYl/v1368ioCDme63iw8XmD6mRufJlwhJpKHS31ywN9JclXetLTv/0Vh",
		"encryptedKey128": "AWTNu5V8igB40iSSrReHZLLlv7IvPyoJzAOWfZDbTDWbQGvWdpXzcRLAj1WTtnpQJNycHOd7rwUMs20OXb4reo4="
	},
	{
		"plainTextBase64": "/sOfaOKn8KodXT2if13q6jnT",
		"ivBase64": "F35as+uWLEin7po9pbf4jw==",
		"cipherTextBase64": "ARd+WrPrlixIp+6aPaW3+I/zhAQSA4dqEPW0I8zT+IKHGDb7Lqvnf28rrzM6z3hI7FznP5Wt1nVmXhho1FlGnsVZA8+xyBjXuszzxRpSWKOf",
		"hexKey": "53ca6016aba6c33e366b6a9a0700fcee5dc8396fb2327b0255a07a090bba9e57",
		"keyToEncrypt256": "808c9505f3244656285fa9476d193bc4c904019d50c6dfb4cd2e5747e329e94f",
		"keyToEncrypt128": "9bc7a476999641fdef39b6baf272291c",
		"encryptedKey256": "ARd+WrPrlixIp+6aPaW3+I/3rp4qqPKmPyoW0ugFEYIR2yw0moWSqtdN0vFNm1AgH3A/uTds+NRAxxw6vnjsCCIelwVFw1Rt4CxOaVM0fHRS",
		"encryptedKey128": "ARd+WrPrlixIp+6aPaW3+I+X4WySCukeiJ6VecPUJoNPdjMIt+F1t4EznwVtHpwbzSsKZ26DLbaRIU+ymxbzZ44="
	},
	{
		"plainTextBase64": "B9tDpwmcOgpwcyz0151Ix0wckg==",
		"ivBase64": "dpQRxquFYxR9IJnqtbdR0Q==",
		"cipherTextBase64": "AXaUEcarhWMUfSCZ6rW3UdF9+fKvPqe+ISZSJIgn82UOozyctBI8el9iUMbqNo+d8wPO/p/wNjWMHTZJVq/bdK/SUhm/yUNg1iyg3wbDlLen",
		"hexKey": "753ed47c0a55953421812ec5a2a907c55acb0bdf23b2aa9e1e15210693e93dd7",
		"keyToEncrypt256": "832a770a3e22e69977b89f6d6bff1ba22335e34e91c4adba7bc5175bdf77160e",
		"keyToEncrypt128": "97666d7e3503aaad48d912e9cb22f81b",
		"encryptedKey256": "AXaUEcarhWMUfSCZ6rW3UdHnHRp+mGq1PrgdMlVIRqecGAcRLww9tog4r77NiNab8L9S9VEnwYew4yto73p0PUN8eDbYg1sY7LfmQjSK/NyQ",
		"encryptedKey128": "AXaUEcarhWMUfSCZ6rW3UdEmZKeUkBEDfcQBu8rZIMjPyVhREvSIy3t7Zl0bJ7gfq6ClF9PVp26EI1WINcjFR2A="
	},
	{
		"plainTextBase64": "BN9COlS2a4RaMVupyfTkk9wo9sM=",
		"ivBase64": "Pn7yKUp72NCYu9GRMZdWlQ==",
		"cipherTextBase64": "AT5+8ilKe9jQmLvRkTGXVpXeR5OdGi0O8+Zw42Y8riMIII5mf+5qRx2ZeqFbEPKe60XzUsMfFmgeml6iMxD0Ad9oHQDDt3un55W7EiL8y2TO",
		"hexKey": "ef66c07b44bd3ee0e9954863e6125d1f0bf06c650d380d3840c687a7b0b51eb6",
		"keyToEncrypt256": "14f7f7e56015e4a265123f848c1f011c98a581d4c4f6bde34979dfb61d207386",
		"keyToEncrypt128": "e4cfae465a3f3c77ff0fbaa30ad9ed0f",
		"encryptedKey256": "AT5+8ilKe9jQmLvRkTGXVpUnxIJC3OpUasJNIoqj5spVwp4/JC3AzAxwbshUvQS0jw++YdIxiX6l9ivtcTaFZ8QYeWiSzLhcU4h3gh53ipVJ",
		"encryptedKey128": "AT5+8ilKe9jQmLvRkTGXVpVzhrlp3Ap/+6cr9nc7+sutneyU2o0YBIHwq3ntT2GN4qTjPoFvj4vLrYHM4G9G7XQ="
	},
	{
		"plainTextBase64": "BXcpT77XsFyzmzYYQb2k6PHQ0fsF",
		"ivBase64": "wv6dOMaCIYxprRH8R1375Q==",
		"cipherTextBase64": "AcL+nTjGgiGMaa0R/Edd++XargGSga6RMdlMeZtoJX5df1r3H5ceBAmoIhA8X8Zb82FlPMbGkA3DoywflrVxoMvqzzb1AhTWeMrdJAwqHhG7",
		"hexKey": "36b0ba9c741376740b6650f6bd1adba8dc9c91d75fb9af2e7b4fa315f4a31435",
		"keyToEncrypt256": "f59b90371c18c7eb3b84cc408eeae703d135237c3e75008d579f1038091a2d12",
		"keyToEncrypt128": "9b8ce8117ada2a519417ff0565f52408",
		"encryptedKey256": "AcL+nTjGgiGMaa0R/Edd++UZgty7UXCkRUuCJYRdJ/aSutylp/n3dw7VZSnbueVXLdCKCgEGYnwTgMi/YVZUIkC6ZT4z1IO3JlZJSorZYVlL",
		"encryptedKey128": "AcL+nTjGgiGMaa0R/Edd++XedszbDa/duwlKbrlBaXHHq9j58MKlEpwMHdU+AU5YxgckZM36f7TeEx9DJPF3NUQ="
	},
	{
		"plainTextBase64": "pz1RfTWZzs3Ya91y5GG6DdsViPx/sQ==",
		"ivBase64": "xglJhT8QIUACd4Ry1wF5+w==",
		"cipherTextBase64": "AcYJSYU/ECFAAneEctcBefv/a1UnPqweqhEHPI2imeUXKClNGIIlJ0Pis+7+EXacUw/RVo3IV7/PqJO3LABsZnf+tS3RqWLbslR/lCKBEtNe",
		"hexKey": "5a7c64c35f53fb8b4c59a4de6a6511a26ef22ba740736bb0b76d03bc1ac55ebf",
		"keyToEncrypt256": "ff10011534c4928f5affcae7b292d27d63b146b199fd212f371b31553dc2c40a",
		"keyToEncrypt128": "19a648e5427f7bee21618accda195c62",
		"encryptedKey256": "AcYJSYU/ECFAAneEctcBefve5ma7r9QkvvBy/vF8XsjjxYth/0JybNs8aP/9G0HJvoKtkf4rG99V4DCiSRFCoi15/fI2F2uNMX842JAxX1Lb",
		"encryptedKey128": "AcYJSYU/ECFAAneEctcBeft89yR5U62kTCBQ5gnsyF+1NqAH7G3R9V3Atbs8bbWIaZtwjI8WkT/sFtgxh/4v4es="
	},
	{
		"plainTextBase64": "2amswpiKm6+0mv7OTHI4u7CI3aTZAmE=",
		"ivBase64": "h7443v1X2C/E7OPNpIrA8g==",
		"cipherTextBase64": "AYe+ON79V9gvxOzjzaSKwPLG5/Em2Ti7d77iLhv7SQFmQVqP/NWVp9rl+ULAbpLSHLheaJgo9Vg7XV9l3oVFst16HC5rbEIEg2eNX1BOUS+w",
		"hexKey": "efe41d16e736a5f5cdf7efa7c63f1acdd05559d2c88b20301c79a5d1684de158",
		"keyToEncrypt256": "d85432f7026a9c29f294b91efcff1f10d845d85ac1e2e40f66588cb351ee6f69",
		"keyToEncrypt128": "13c35377c47b9b7da47b3bcae3699060",
		"encryptedKey256": "AYe+ON79V9gvxOzjzaSKwPIjhqJSSJof2QckorfPu8Qr86mHpRsvM2shuCeM7Y4AfegMNOQA2l3vMySXw4rwOakQbfzw4f1bwWzahi4Xkj8H",
		"encryptedKey128": "AYe+ON79V9gvxOzjzaSKwPJPj3aleVtMRz0yCIBbFF0Ua1CQZjYEJ0qpQy7HVhZ1YpKRRmNMnRo7nNVjNvVsEII="
	},
	{
		"plainTextBase64": "g7t2/NwpbolmzA5LMhYpX1MIQs2p+IAj",
		"ivBase64": "phqqwIRkPyS9YarhopioAQ==",
		"cipherTextBase64": "AaYaqsCEZD8kvWGq4aKYqAFqlHRsGGRGs2Rl+sc3RzBcqqANS/3IILklK0X6l4JHSi7/ch4BF0g2E08oDQvEXC9XEyIx1WieQ9Ys9zXH8yfD",
		"hexKey": "84a511ffe0b98e8c07b5f4b883f616c70a92d712f370afa677de73f476470b2f",
		"keyToEncrypt256": "b04a2c68aa8cd9eeb9bd1efaf2277564e325f231d3ddc5bb8556e54970f26bef",
		"keyToEncrypt128": "c25a2d420294a160b46d60a01c9cdbcf",
		"encryptedKey256": "AaYaqsCEZD8kvWGq4aKYqAGK/GKfq9GzIrXDzFLhuwtSiE/6pmhMakSkgxJRnkwT45AKZqsGGCfiqbFa3UlxsQRc00gqPzvKKY6UJb6NMb34",
		"encryptedKey128": "AaYaqsCEZD8kvWGq4aKYqAGDZhOs1jLB5lCYAoSRT30jmneCPdQYYS2ew795FyFA8Xv/S3tYcHgoM0w6W7qBYqM="
	},
	{
		"plainTextBase64": "k5cstGPanKkhhX038KI3o3Uu5bkoA6Lk+g==",
		"ivBase64": "qFNf0e0kQ42A+JdzTshyeg==",
		"cipherTextBase64": "AahTX9HtJEONgPiXc07Icnr619gdUHHawfOUJvxpl97z/vyr+bGzz2TjXC2YnsYvvel90Q46sE0SsRKR5pvL9zg0Q2zH9BJzgOtHfHBbeYaG",
		"hexKey": "d36c74a28046f9204c46bbbe5f324ec80b22aa0c16bd4dc119725ccc57dfafbd",
		"keyToEncrypt256": "85e7baea516dc5193345ec827a26baf6f2b5112947d1624f9dbaaceed7bde9e8",
		"keyToEncrypt128": "3b376091f644b4876f19c4947e6a6299",
		"encryptedKey256": "AahTX9HtJEONgPiXc07IcnpcxY04sWu8aZ17pzgmCJ2JOQ0b6SSIaz4DukHOHDqM91D/BStCRweEhYlt+I0ZGsY8kKj2TDvK8zlZqJ9UI8p6",
		"encryptedKey128": "AahTX9HtJEONgPiXc07IcnpoMUJLBhrRGlREttfARuY9rmyGeHdLKnxuMDUyk/QPKXeDI2DM53AuUhxtbapNkT0="
	},
	{
		"plainTextBase64": "HjEm0gX6oIlgFKyccpntlZneIjqGKwD7f5A=",
		"ivBase64": "xyT5ypBLQtRrWoxA8gx4Rg==",
		"cipherTextBase64": "Acck+cqQS0LUa1qMQPIMeEYgMExkH8efjTEpldpJMINc4lDMV/yTMUmIDdoQJlV9Ydbqw9hhFVqqpznRqj64YbQAg/mRQVgf42qqCdwRMW0X",
		"hexKey": "c1bbc3d50d72dc55035311c1bacca19c0f45051b06fb9deb7b211abd059ec7b4",
		"keyToEncrypt256": "81d87f0e726bb16ba5d8f309e4f19dca943b3ecf295ff6ce5b72a7c7634c4e84",
		"keyToEncrypt128": "39def12487a1bd13a248e12d8e66e282",
		"encryptedKey256": "Acck+cqQS0LUa1qMQPIMeEbw0hdV2jhA5AUnxguzsfp/E0mQZch2dq/rHYGiuRhIikCy2Y0Y0OnGBS1I019ak32L47XRsFxkrtjVTzRmE9pD",
		"encryptedKey128": "Acck+cqQS0LUa1qMQPIMeEaI72ZuoYlcPEGDqgqhlX+rV4twvATMnt2DNp+47oOVbhBun+/l3I2ySxy/02j6XIc="
	},
	{
		"plainTextBase64": "zKyb8vGSeQtc9MYd+eh5T0TIhkB+3msN0QwK",
		"ivBase64": "u9RkykLjM8kewpMj9aUYew==",
		"cipherTextBase64": "AbvUZMpC4zPJHsKTI/WlGHsKnl6xyqZIoxjuB5WMb6oNtlCpHai9POcIVei5jXf+ewt8BE8IFpXFGx9GPDAu5z9TZdQ4ZEplqA2wIscToiX3",
		"hexKey": "1a675b49c58dede30a3b0e9493a9d1e58e4d836818bc997a70d2c19b6399f1ca",
		"keyToEncrypt256": "faf6631a5658dd1c8b14523ee76d9083a32ce6925451f5dd08d7f4a593df45ca",
		"keyToEncrypt128": "47abfbf76f5e7579464f4debc1791acc",
		"encryptedKey256": "AbvUZMpC4zPJHsKTI/WlGHsKSFAmBFTOnyY2Y2iAFaaDlXojjWhhk74nnNop49xrICmoZU3Un/Prt/geQ/Pnq4Sxak0dxO3dCwPE7EVN0lN6",
		"encryptedKey128": "AbvUZMpC4zPJHsKTI/WlGHskWG2I2mzq8R536ALcJZMd5pC4yX/DvrKXtep7BBcT/7XvKcuYIO5I7cT77EmHsQE="
	},
	{
		"plainTextBase64": "V1X7t/SUELLXFLO7gw/twLVn9UNOx39pfKm/UA==",
		"ivBase64": "VfSW4hO/O++mRHZplu70dA==",
		"cipherTextBase64": "AVX0luITvzvvpkR2aZbu9HROFPh55tlMfuVq6Assp/x/hQj+N3P2ZBuurc1WUskGujqEN6NfwOFreETWAe7UgxJdm4qqUCsT5MbFi+cDvn0T",
		"hexKey": "730a5d4febd800337eb91ea1c847d6ebf8e3e7e821e5f3118126c6456bff6d6a",
		"keyToEncrypt256": "e893fd573462834a7c99f53848aa05d23347d34f94116fd5153c7d18cf634f31",
		"keyToEncrypt128": "b4c413c7da029a99d9868140b84b1b6d",
		"encryptedKey256": "AVX0luITvzvvpkR2aZbu9HS1YiTHj3PaK87tPtJsG/iE7Bdx+atOeu9dz+RT0E1h9MZZ7nzZV3Ff4lcbDrKYwNEnFN82cVFr2b4nEkExu2Gp",
		"encryptedKey128": "AVX0luITvzvvpkR2aZbu9HQYixsLSK7a9ERGgwyi7ky9FA2cfdXBY8o6z6uZmJDaz0kWWvI2Z6NRf9nln3VeN3U="
	},
	{
		"plainTextBase64": "9wbCuMVFjsBLDqT0qabkskF+k3wMqjqh2CdKQNo=",
		"ivBase64": "3ES3p7B83TA3Yvc9ninLmQ==",
		"cipherTextBase64": "AdxEt6ewfN0wN2L3PZ4py5lKNE+V9FhsWSs2ZmgO6qdqWI6PKl3CdwvsaBt38wBlmOyf1k7ZWOXQhBhyaOl57SllkzZZxN67y81xpaP+vshs",
		"hexKey": "a4ea92cd1e9c0f8539a62f3b46e54078bfd32c88c124846e16a6b1376f7dec4c",
		"keyToEncrypt256": "404f9f5de0df8262f3c63faa867f2d0c9717069d4f53b651f9267b442f1441b9",
		"keyToEncrypt128": "b627371ee14f5e1eec6195ccf1adafd6",
		"encryptedKey256": "AdxEt6ewfN0wN2L3PZ4py5kGLSAYYS9czQEuhvhKS1wLIFytAde1XEpZeZKTJSQHnYd3gKnUMZaOfS2EeHKxbB9nnFdRgIJoWbVLXOUuSJCa",
		"encryptedKey128": "AdxEt6ewfN0wN2L3PZ4py5lXXMRgKsFndboo4lKOcomgUu98AmhoOgAXpscBhgxibTBErTeL5WtH6jv8Wb1Tkns="
	},
	{
		"plainTextBase64": "4R+eB5ysW4gfUS42KbFndw0RmwIMuZUS2BLTPB28",
		"ivBase64": "kKFVge1ejdquh42sgV6lpQ==",
		"cipherTextBase64": "AZChVYHtXo3aroeNrIFepaW89EyHgpCXhhz9BfBpbItifturSPUaK3RTg66o+LDRX7+l8dddX9s2UUrJjYmmtRfkSfif1IYEK6VNAxUCxtrJ",
		"hexKey": "2e1a4690eda60001b364b21019abee4698477e22a3c5b12d319f84aa7bbc4de8",
		"keyToEncrypt256": "e3d1744c4adc1868c48489ab26240b9903196d6d40b38c1ffb5d4a2116be565c",
		"keyToEncrypt128": "126b0d568f9e37739f3ba1a359b14150",
		"encryptedKey256": "AZChVYHtXo3aroeNrIFepaUfaAPuEX+GU++Xgf7IqOAJwLIvyKPGlNlne1u11ra6FuKjkP9yI4/gz11xNIiWNUKHXSgAbl5E+r2BGjazk1Mj",
		"encryptedKey128": "AZChVYHtXo3aroeNrIFepaX1NFoWb/fAeemfIWb5kxtsqiyKu6TuoTjhd5ydBMlu4gcYiKGbJcVNc2K75smx3no="
	},
	{
		"plainTextBase64": "o8EipB1kNDEzB8oRNg/9qytfQlKv+xF2Csd5e5LFgA==",
		"ivBase64": "sltOqXHY9LCbhdbsuIgO3A==",
		"cipherTextBase64": "AbJbTqlx2PSwm4XW7LiIDtw4WhBjlm63C7h9uFErUDkyQztX8QC41ZM7JpWdM50p8kYV025FtqUp3w1PyranP8YRcf47lBTWyPuN2HL0f3M3",
		"hexKey": "1fe849b9f50e260cfadb7deb67ad76c63e65d27a80ebe960c0520bbe2bd66317",
		"keyToEncrypt256": "6a0698cd69a82f1ef925033eb2b853d3c80e1cc1e4b924d02b736e41e29c89d2",
		"keyToEncrypt128": "79c45fd0181fe7d8af92209d96f88de7",
		"encryptedKey256": "AbJbTqlx2PSwm4XW7LiIDtzVISVP9NKy9A3/thB9gdS6KY2eu8T7sPZX/p7JAdyVfzUogJm/IbndY6+eokzBv0cTNPyfAhmkskKaGgING8hd",
		"encryptedKey128": "AbJbTqlx2PSwm4XW7LiIDtxZOrDCOxD6jO4zs7uHCMwrQyAIsHm/9ug4pG7CukdAGYR4/FRza2O3DVCeJ43qMuo="
	},
	{
		"plainTextBase64": "yXjvlJOoeR87ZIYAwOd8Sah4LJbj6HvlrNDn0yFkZ+Y=",
		"ivBase64": "C0h+Sk/ZYzxf96mCJ/zYhg==",
		"cipherTextBase64": "AQtIfkpP2WM8X/epgif82IZ8wt2M3Us8qM9s84uWVmERgjFAI31f6p9+7WbjpY8OxQ6XGE2vQkhnoqI9Tee4K47OOXxRn2iiz4X3psb3tsr+wccLLG36MShfF86z1nOKiA==",
		"hexKey": "cfeaba501b248598a3915951787d671c279265c4522efd16f15c37f9707172f4",
		"keyToEncrypt256": "52757efdd8edf4af6b82f846732f6efa0a5c51d60e5e8e078aa1d3151ea43d5b",
		"keyToEncrypt128": "ffe6a05cfca0ca45405a471581606ec9",
		"encryptedKey256": "AQtIfkpP2WM8X/epgif82IYMG77bFJiTRij/vyEAYg+UvcAODTr2yvIrItQWFU7qy7J07QjHntQitzfcYD1EFGE4wGF/BlW6pzruvEWAldwv",
		"encryptedKey128": "AQtIfkpP2WM8X/epgif82IYoeSLRx3paanZTDE5PJuBQ18MaWfp/V+P3hLsLrqKECEikfuARgWAl+IktzfZcnnU="
	},
	{
		"plainTextBase64": "VxwubvAbs4/Vo/K8mqVBLxnhK7JkC80szZzShrA0uXwd",
		"ivBase64": "jZdZipPyAi23BB1II4mylg==",
		"cipherTextBase64": "AY2XWYqT8gIttwQdSCOJspZAyDC4kYAa2d3BGPEuspN4MOfUnrxGzdo3bXSahAs9RsYI1aJ88t9RMA++ts2VFre4PVDBNhFAvCCcUT9r1Tt1Yf/wWxg62XL8+SwS7/MmPA==",
		"hexKey": "e545b98162ac383cd6543d903aee57676ef5e6571fae567107081bb54459d6a2",
		"keyToEncrypt256": "883b0a2d7ed3431371c2bcf5b1eb67d3db0abe6be5904130d37df6acafe8324c",
		"keyToEncrypt128": "48d13db74af3054fc37809935dba3457",
		"encryptedKey256": "AY2XWYqT8gIttwQdSCOJspY0ovaiZDj38MVuX0gktLndKvn7hPO8W1sRpfmjPBtDMvOq77RDW20+Ivn77yusACwkxc3UCVgU+XfzzOteL1CV",
		"encryptedKey128": "AY2XWYqT8gIttwQdSCOJspYwskEMnUO2q7OnoP9pj0R0MsVGjpPYZu8OhTC5YcxygR8vxj7PxEHwmBjapxZf6JE="
	},
	{
		"plainTextBase64": "uFUh13aC/Rku6vOc21AyvNVH4lnwW2Lh+rdZXi8hKLHtfg==",
		"ivBase64": "f0GqjA1ZkFVdUHd2lQyZ5g==",
		"cipherTextBase64": "AX9BqowNWZBVXVB3dpUMmeZNoSpuPjV9KJt3vcGwgVh+cPmqA1JZ/Bfjx8X5PeKy9OsZhAg8snx6uHbxol27Xv4xvimNDP8xoiOSQOMUjlzdHYW2LppaTGF40+iRC2sfXQ==",
		"hexKey": "f8ab4e2946150a82736366a8f895b5461af09ea86c17c1968e7cdb517925b0e1",
		"keyToEncrypt256": "1b876cdc33c765226b76cc3dc5f4b650cbe4335ba90342f57ee23f3c9a370f1c",
		"keyToEncrypt128": "d2905fc759f993ff5c2051acfdc9c1e6",
		"encryptedKey256": "AX9BqowNWZBVXVB3dpUMmeawxdqUQwN4p8vt5MSpGbJV6lWYRCNQjfQnfp3d56jjv/fs7eChjXYJGgyL5wIvj/2EuNZ/fcMIkExazzzczAJU",
		"encryptedKey128": "AX9BqowNWZBVXVB3dpUMmebR+eyAth7QcH0Nn1KHScxzrxK76r9BJcN1+rXthnHSTC0URHyl6nPyzQ3FDV/Vzrw="
	},
	{
		"plainTextBase64": "syFKottS8giGK/kfbddaZ5PkCg6oz5sAU7zWR97kqn9pPl8=",
		"ivBase64": "m/Q13iB9xTHssaHPoKDL0w==",
		"cipherTextBase64": "AZv0Nd4gfcUx7LGhz6Cgy9NfoF2h6j7fv0CpxF1wzbHnYTY6p2gK1RWfrmZm96qCT1oduEoc5ymQyyTTmdHdnlZskphS2hI9injDexyzAQwH9P1qe1ooSRtSYqimx07VJQ==",
		"hexKey": "a6aa9c8e8636f6ac4d3651d72ba5732d7edaca02ac177b26980ab9a25694d0b5",
		"keyToEncrypt256": "7cc649da1c279f999e79b125382509173ef8ec48a53073a6ca2dc561362e7227",
		"keyToEncrypt128": "7fc79e517c8f2698e6d4bd55da696e9a",
		"encryptedKey256": "AZv0Nd4gfcUx7LGhz6Cgy9OBYSiktwhP02UtJD0KlzHHwgmx8ki6e5qDx12T1LCD63sln+Sc2TZ2o6I8BOcy6C4wUKbKHzbQCS5U9K7X6HF/",
		"encryptedKey128": "AZv0Nd4gfcUx7LGhz6Cgy9Nbafs7AznzwX6lfAaTEjLgxL8iEOwoh5VuZHgu63NKT9Y6HLwuU8gIaf1W0j4csPo="
	},
	{
		"plainTextBase64": "ln1hBG93Bqo5F6kTAhzJLvbQ4OL5D8Vby0JTVKqrUpptRWhO",
		"ivBase64": "/iSsliux9vHtVVgHqVt8aw==",
		"cipherTextBase64": "Af4krJYrsfbx7VVYB6lbfGtXHhitoXFrUAqGGgQsaRF/r7FqupWzEqycpkNIOd00SxxJmU99udburylSOSzZBoAXhvY48+9jP1/MupqdRNvowOAix+jHvFkzmdAFkllrnA==",
		"hexKey": "af2c22c550d54c03490ef5be9fb580c1dd1d6598bce8fbf316e93a598dfc571b",
		"keyToEncrypt256": "70394da55393926af9c6bce7b243555071dc3b7f867d156391242c7aa538e9cc",
		"keyToEncrypt128": "3cc78bb2c8e6209bd648105e9c9774ae",
		"encryptedKey256": "Af4krJYrsfbx7VVYB6lbfGvad89WP/7QvQ6HGOzqDStFneIdRdnVCsHCJedp7MLbamoxWvQc5oi1Xh2ypKPKz/ww2WhHc9ZzYuqSkxVzFY+/",
		"encryptedKey128": "Af4krJYrsfbx7VVYB6lbfGtz29UOwub5Q4+xuPMlGAtBZHJCUcmqxJ4PeteIHLIXGelJLrXlZkyDpKYHPJGceJ8="
	},
	{
		"plainTextBase64": "kV52TQ04JX4AvqmeJKmHub5NKTY1gUIiwCeYK8YRrn08GrisBg==",
		"ivBase64": "eo4IUEZfQSoErASUFk66Sg==",
		"cipherTextBase64": "AXqOCFBGX0EqBKwElBZOukqWYl6ptabVgnc2PBqzzqVr7EXwusL93JQ84d7QmNwN1rRVk1rqNPLvv9jsHjW/Lq0JFzokuLTpBfSgXJl0lldi0UxyZmdKsokAD/j2dwu+LQ==",
		"hexKey": "370eae688bf33db8f82dccdf70082de5808afc00e2f94130b3d23cb6b19312bf",
		"keyToEncrypt256": "d6f64f246d60026963b911f5c99255b7ee4443b2914b20e7102169b6c8202e4f",
		"keyToEncrypt128": "9f999655a305d2df9807938ba871a4ac",
		"encryptedKey256": "AXqOCFBGX0EqBKwElBZOukp82RMH1rSJCM82nXGtjLWZBED6r4T6FTQXt1WcPw7jFkyCuXOiiUnSvSf0zx6Sr7DPUdBSul7Iej6kGAgGQrCv",
		"encryptedKey128": "AXqOCFBGX0EqBKwElBZOukomato9e+/lkT+rzP0hYEH7cBw6HT5QvrI5seDN5fKGkf+keiNKDnGJYki0FB76bmg="
	},
	{
		"plainTextBase64": "qeZyzOt+UNKLZqBiyt4CJG+wvjE1/e8Q6MI248qt9NhQZOS4y10=",
		"ivBase64": "UtxN1o+ICkhNM5lMo9arng==",
		"cipherTextBase64": "AVLcTdaPiApITTOZTKPWq57f8aQ4LKtSyazrFQ5EOzg4skYTMN40pDhB/xK7mmWcyt/qJJ4843HcmzkxkNcED/9W45j7W60pKSpXN3FMJsizOmYNWhdmL2gqIwuGr5rpBA==",
		"hexKey": "7212d1f44fd66c2842b1412363fe1352c2319cac8658cd7bbfcf6666b48e1d8c",
		"keyToEncrypt256": "975659f560fcb909d017f4f4ae22c7b9d80ab426cd3395bdfce7b1447bc28d99",
		"keyToEncrypt128": "cbf846b6084d4891a4a2e2b7829542e7",
		"encryptedKey256": "AVLcTdaPiApITTOZTKPWq56333CQDfgP5q2cD7PdELqmnk16PrmQcYcGxr2fA0nxUp5sLKUkadzU7DDDUHLX/hMQQYDWMN/eC7DCo4SraaKW",
		"encryptedKey128": "AVLcTdaPiApITTOZTKPWq54qc3Jj82GFRmrAIKhB2vzrWZJlXS40q32BQ5zRNR9DzDsDri2sMZwSbUh5YwReIro="
	},
	{
		"plainTextBase64": "dMUklvpbU+yPx+SvJpR7/hwN4uiBKv3K7xedbeWQ/nVA7oQsoisX",
		"ivBase64": "Yrl95BtAR3xuPx1l57xhLQ==",
		"cipherTextBase64": "AWK5feQbQEd8bj8dZee8YS0NYTqXHReh+LSbo8+EG13FmX1V0g2tHmZIzyZQEp5CK23bGV4xhVzkUaXn/b40qu5oPtwTu6zQjZwOndvVRmbH3F4vAtboxnDVM2ruo5IMwQ==",
		"hexKey": "5b3cd721808321673330353fa214840bc4908fbcbe81c7f2f4b9908ce5c86393",
		"keyToEncrypt256": "6b051d424ac7a094bbc3135281e845065f8401703ddf0a52b42a81dbf6036c3c",
		"keyToEncrypt128": "ca0155ddadbe6d48dc60c615b7cf11f7",
		"encryptedKey256": "AWK5feQbQEd8bj8dZee8YS2+IgQAPix2qwrZ24sjsXMnRghHU9ewbIiewJ556FXIFkmhJvdbwMiT9Q9d6ciTMHbJIw40prDycnlctnM4PWR+",
		"encryptedKey128": "AWK5feQbQEd8bj8dZee8YS2TOSkys7Mr2VvBRezEkZFJ1gtO9Uh8ogigZWypmEgo/rsVcAGKPaLC69ak1SEg0PA="
	},
	{
		"plainTextBase64": "fj6JVfXMYNTIKpRauH6uKUN9A0Lb33afSfZJav+5TT4vmQizu/XqcA==",
		"ivBase64": "Aw4D9ahiOt78IdE0nF4plQ==",
		"cipherTextBase64": "AQMOA/WoYjre/CHRNJxeKZVEjb4JBVHsN/Ta8jXUsEcZJIzfEOae1eUB3FiQtB0TUT06izn2cZtPYsKHPiCuLBuQSLSEDz+q7SyEq2noHM+YnSpyBWUa6azEtK+Kc/f4Ig==",
		"hexKey": "35ee06d3afaad3b1491d232bd4e786518b2cd9fb34eda356f98ba8f1c90398f1",
		"keyToEncrypt256": "d6d0382e88ba40d00113dd6e789476c6b31501babbe3c580a8d690950f8d906e",
		"keyToEncrypt128": "49b9468b5f2ea730fa9db2b3fe97e94d",
		"encryptedKey256": "AQMOA/WoYjre/CHRNJxeKZUhmw4RLUpV34GWeFB/AHxdDa4TIZkQGnLnCkE2lEBYf45P3qFB3qoeG5ju0CRwa+kPdQlBss4HoSsmM7AgCXE0",
		"encryptedKey128": "AQMOA/WoYjre/CHRNJxeKZUx0c08Yf5L5O96baxHqV8UkIOaVF8ILHXUIRuwfIcREUXH6VxHJpMY9DFZtGbah0c="
	},
	{
		"plainTextBase64": "lfeTVApTD117SKI1hhr9jjEsB8yxtFu+mCtDhstcmztLNFEuGFo9ObQ=",
		"ivBase64": "VI2Klm+RcsTeMp7qupFOdQ==",
		"cipherTextBase64": "AVSNipZvkXLE3jKe6rqRTnV7UlggNfEhkh57Y2Zu6my+9J/l5BmOa3HtVYz47+7I79J8swuWTHyfdap9KLzZiIa+W8jgRGrcyezZLmAjKvOZGLhdSA8XJKJifwV0d2+nwA==",
		"hexKey": "f1c461e7169c07c4d5120276bc826a2e303c9ce5d78e319e8c8376926b0ff591",
		"keyToEncrypt256": "55c50a33426887e3b173bedf81ced84cbdf000d9ef55e66416732a6e75a4b97d",
		"keyToEncrypt128": "4805cc4f45f497a8ea60d7bacf80aa14",
		"encryptedKey256": "AVSNipZvkXLE3jKe6rqRTnWfREg+8v/Gd3LXBJugpsmuNngdt5b0WAC3c1WNAei5Vye/JdgVmeeqtGW2FBdu4wd019wDcmCR2QPC2+7Xz9K0",
		"encryptedKey128": "AVSNipZvkXLE3jKe6rqRTnWPTz1A0eXJmgmJx6n+no/BoUZ1Zza2JeO63hRqGDdx7geLGgEg1zRaQGk3OkvYoZk="
	},
	{
		"plainTextBase64": "wAzpgXuD7hlX6avvsXxsHJcPS9oPbYNaC/SN6JcBHfpT/sqLhM3se47l",
		"ivBase64": "oGt9/BkS2Ptwl81nUxg4CA==",
		"cipherTextBase64": "AaBrffwZEtj7cJfNZ1MYOAgNu98IHhnKJikUVxc7Q1QFfrUjgALVIxYf2kOuopIm0JXpOOw3QeFBLxdoA/he934pI8DFAvKcCgInks+DfVIU3FA/m5M4HYr5yF7MVbarrQ==",
		"hexKey": "200904c5e0e48800f6ce4d6c63125ad08299599472784f2c38b438c37270dee7",
		"keyToEncrypt256": "e51af749aa2c2168a7727a13b6fbc937c4cea278c4a868906a78a5f3676147cc",
		"keyToEncrypt128": "4d764fabaeb29b08f2da7e861b15fdac",
		"encryptedKey256": "AaBrffwZEtj7cJfNZ1MYOAhhBe6BpaPcw8ssZ3BXgboGHUtQE0ewHjOJzENJ7d1u904eFjN8Uo+8B55lylYjge/WHRV/Beu8X/eiOV/C9tkF",
		"encryptedKey128": "AaBrffwZEtj7cJfNZ1MYOAhQjTZeKtjrPxxRtFNATHrZydJ7wHJh92GFB5JD+BdCx9qMIykJDrhrOT+u6XWYjfc="
	},
	{
		"plainTextBase64": "GP8EDVL888oNIJKj19gEPYPwYsWjVOSy+8eR3cajmgqFgAeKRKBdSUUoPQ==",
		"ivBase64": "Hp7hMkFZyqRIhkUpGgp58A==",
		"cipherTextBase64": "AR6e4TJBWcqkSIZFKRoKefCiSuf9R1LPxxabQbUBb78RkA4XDHE3nw3h+/33Pt20CupSvkNSgwFndKhhiNXOxDQ1y7qR2s9hyFvcrJg5NZcnRgceEdIhkVtVJd/TjTwO8w==",
		"hexKey": "09216105c7fdecab135b49fcf75fcdbc0efaf9e81227a8dc25039ddc6a3684e6",
		"keyToEncrypt256": "05f59809aaff9b3bb040c9289bd79c856fd58f17ff01d4f275192f55139706bd",
		"keyToEncrypt128": "8c7ce96cfef15e68f1b2466630ac4118",
		"encryptedKey256": "AR6e4TJBWcqkSIZFKRoKefAm+xhIQwt/M2+AJbznSaGttRtcS9neuRgBiMQbB2tflCy9uJFMQuqSbsw7C4Vq9Q6yGGHAAsc0rv6hwU+i0f9S",
		"encryptedKey128": "AR6e4TJBWcqkSIZFKRoKefDnbWA6qLwQdNpnYEvAJqkl8XWapHmq/6h5nkmTY9zaz3prJEFDtGfX4SJmV1aea54="
	},
	{
		"plainTextBase64": "xy/lNo8C+1yjTC6D6FCyXxAIKjSgTXYturIm1RHz8ODgUUOlL4RTnql+DmY=",
		"ivBase64": "Fr7OgbC9O8YAECfly3Dhxg==",
		"cipherTextBase64": "ARa+zoGwvTvGABAn5ctw4cY1rBtvWGCj7rNNzauSKWXYwBDq8vpYslw7bOcfHmtNwRUc1m5MlmT9hqlVYFmQDAnbTcnN6CkEmuwzPAru/SWlTheJu3b2A9GaWYvmQnwtAg==",
		"hexKey": "f92df783515268404d0b87255da6a3d0eeee1b76f13aa647cb18d1c8c6b33bb1",
		"keyToEncrypt256": "23e51c707729cc78b4d56316cf76cb23f9ee242f43e8ab5d0c681efee191c7b6",
		"keyToEncrypt128": "07df21389345aeb00afaf8ed456b9c30",
		"encryptedKey256": "ARa+zoGwvTvGABAn5ctw4cbCOLFGWh+E4p41cv3tYR24jWqli1q75+8AM92nu0UcgQJsNkJ6QaLTpBovHaTajN7meR4HvPlA8MC2VVlWamx6",
		"encryptedKey128": "ARa+zoGwvTvGABAn5ctw4cY+4vZ6Nm9HotfQTjAwdh5z3vh/ABtGMIpgJ3RTxxd4dUcbxq/MgVP0Pt2jXkICXG8="
	},
	{
		"plainTextBase64": "Qo5bxngXtJmJhIlPGL81VsH9NJzucTnzxvolJmqufCLO4tW9cvPxSOcEkz9/",
		"ivBase64": "IrJWZM0JTBdnFsznnTrW+A==",
		"cipherTextBase64": "ASKyVmTNCUwXZxbM55061vi6jOp+Xh8QDyU5J++2MciPgw2PGC6BeYn8IMh0ttlEqT7HhlnzkQQsXmzG5gtUQTbSocfrt31zbHFGvU1CwZ77N6MTxle77zH/vWbVfAtk6Q==",
		"hexKey": "6a3a68c400ec66f993115cabc71aedbdd71b6fac1ed6beab78aaad732a369314",
		"keyToEncrypt256": "93d313c31d9443e47dafcd12bdb7bb11df9bb5fd34c2e7b6135a003cbfcd028e",
		"keyToEncrypt128": "1e9ea5ed421d592c05e383aacfc77363",
		"encryptedKey256": "ASKyVmTNCUwXZxbM55061vjbkyCqwMcvVM4YeVnEHYwBqDUd7/RO3Ls1MlkTXp0qGgwmlqeq+OPseN1aG8cw3XQgMZrbOfr2Ck8CRCaxnJau",
		"encryptedKey128": "ASKyVmTNCUwXZxbM55061vhqBCtu1MjN3YVdNLr4+OXmiWOqvo5p/aAVSVQEEsE6HFRGfjpgDID6HwDrUl0D0Lw="
	},
	{
		"plainTextBase64": "kwMtzMkNDKUcrEIn9iWMw9wzIdyi9JeGO9YQ/LNflxLxrJBmGsWfaFSDXkwaew==",
		"ivBase64": "Eyr/nZSwYyFUivIi7xTFtw==",
		"cipherTextBase64": "ARMq/52UsGMhVIryIu8Uxbc3F1BuLAkYAvAHucpuCt5wL6q9Oz55EHbulHsF9xjA6WxLur2t1xkD7R+MWe0lsCeqEsst46G+UHleJIBZKhU6kkh4Z/vXsQVPq0oPEtIG/g==",
		"hexKey": "99bbe5359e2c313104286230fb403ffdd673d48c5734f47aaf8a85811d9588c6",
		"keyToEncrypt256": "a3d25190e1a591023b24b9e6e4ad567aa50f58f91dbace519a731af3b7e3fd08",
		"keyToEncrypt128": "7dc60105788c769932e96ad82f9460ef",
		"encryptedKey256": "ARMq/52UsGMhVIryIu8UxbcbQNnLETtlrd6qr7Xg70V7hDfN0HOlYNQODAEq1KyF9wxqkNPpLR4A+66Px+HP0fYG/zaO3Ip9j3lCKR1dPNfL",
		"encryptedKey128": "ARMq/52UsGMhVIryIu8Uxbe17CtmcgFPD8x8X9V4ya89OkheVTqykd7IvsShdip6y7vk+xdyHuItk6sM2THPFvM="
	},
	{
		"plainTextBase64": "8OhDkF8TRjuJgHEhV0wWt8dnC7h7ui3pO4D7Qimbv+AprU4+WrynGGLFfhShABo=",
		"ivBase64": "thPdb6O5FqDlPGBOwSMpqQ==",
		"cipherTextBase64": "AbYT3W+juRag5TxgTsEjKalt1Lo47SBoaf9XHIIgzS3Dg5PGYp8+idF12+xANlh+49K7FJo89THk2XOMm+SDG6HTdhKFx+cfNxgwTjtQAsg8jG6F4r0quy+KNw0+HfAOEg==",
		"hexKey": "dc40fc24786d662ebd692d92f408298fd2486f3a36b477a25653b32416b8459c",
		"keyToEncrypt256": "9319931345c50cf8c2806ca06ea162a24594ec72d81414e40ab36a26b88eb53f",
		"keyToEncrypt128": "0296325a2b3ac0cbb227d57a71695e20",
		"encryptedKey256": "AbYT3W+juRag5TxgTsEjKakmLzMJw1Pz/aycvkY9Lrf+ZkE4RHWSnV01z7PQmCc6kCSibXf3EoXvaqbm92fIr6FGW7/o/RogHC9YwMGr2orJ",
		"encryptedKey128": "AbYT3W+juRag5TxgTsEjKanwfKZn9SN34Z9WDfozkGztKxGwz7jEutzzPStxUjMm+pgne+ZqZroJMRadj3ssqaM="
	},
	{
		"plainTextBase64": "oWr0k/LCVxalHJhz6T1o6Q04ENAnVFx5W5P2eHRaiCHw1LIVbW3pWFf2eIcS2bht",
		"ivBase64": "wheLmasmrsUW16C/8Zk6ow==",
		"cipherTextBase64": "AcIXi5mrJq7FFtegv/GZOqP30KgUNIKTz3ekiR+7mbx0feXhDAoN/tQmJkff4O5j1xBzhOQ9w4WwbqriItsN0JCiord0y46wjh+433WOZwkaMfvPBA12FtMkSlyvM0YPGZndWDAArh7TZgYOIN2jdoU=",
		"hexKey": "f5643e4f0bfdf5b38f043d9f6a68bfc94eb371dff5e527a99a18d41c7ae35f16",
		"keyToEncrypt256": "f9a1d6aafb73be9b726a57b60f6ebf9c1b4ef42f5bc579592038c0d6dc08b88f",
		"keyToEncrypt128": "6ea3217c1ef73041c1579c4aae36c8c0",
		"encryptedKey256": "AcIXi5mrJq7FFtegv/GZOqOvLaH0r31Q4LYQttdSLp9/Bxk4dOHNyKW7ipXJWatOy7CJ3wnKB8Y69r88xv0ddodi02xZkx3ukeuIrZm3gjUO",
		"encryptedKey128": "AcIXi5mrJq7FFtegv/GZOqOe2WN2Tq5NHdfAyOa8iqMV1Y4KL0SIBODOmEKep5UWJHfY+gDdUngzbxaeUiM9oyA="
	},
	{
		"plainTextBase64": "XPcFcJ7DgQjnasGkx959T//gEoXZUSbHaFMAiE8HQV6vCIBm0w3WNKyWA73Uv8QTwA==",
		"ivBase64": "KzvynTHx7UuESkBxWIm+4A==",
		"cipherTextBase64": "ASs78p0x8e1LhEpAcViJvuDR57c0sn03J0AukipT3Zyr+3lVLRCRXNSiIy50E7gO8bSU1//mnwdfqrClF2oiDbySb6tGYu4+n8CGaMdS0i5wvZU4My5MrV8slJq59NIdAMwO6PuMxL2yZAN6z90jpn0=",
		"hexKey": "84ace5a505b563aed9baddaa517f3384feafbd06f2359fddc87ef0f3b35cdca9",
		"keyToEncrypt256": "83ce506bbbe3fe80081daf85e3607099d0a39a72b966bc796d1b79b6c8dfb6b8",
		"keyToEncrypt128": "d59b9ad5281067e43bb57ad696206242",
		"encryptedKey256": "ASs78p0x8e1LhEpAcViJvuAkDAsfiggwwMOFQOacdUdPP2OkcsCgT1L40T7eUtyBqJ96PnBsJxqkPLbCqREpLukJmWjZGR9cYbuVRUuM8Byo",
		"encryptedKey128": "ASs78p0x8e1LhEpAcViJvuBdyInk9G/lc07yWovP4GV+Vrj2GQ4EPzNZ5xr8rk3pSdG/4CsLCiD97QDXRF7GU0E="
	},
	{
		"plainTextBase64": "BB0bEOUCn101XrnJBrC8mAi8a3yDda/e4x10XlHv+ACe413iXiTlM/WN7x3uJl6+/Mo=",
		"ivBase64": "8YaVlWclP/8SySLWULDqBA==",
		"cipherTextBase64": "AfGGlZVnJT//Eski1lCw6gQM+Cv3jOlCWap55F5PdVwMi1r4ZUeq2r+HEbP+oyptUIGx9bdu7yY5d+CL61AaMW9cMBHeS1dbMjZx8SVHKDaXdqMhZNG7wf2zSmkpYs8NZBpHJzQ0g47shk2trx1Ao+Y=",
		"hexKey": "a4cfa131ed1df30e3efd604589128a92baf10cbb57695bb6056ee99fbc4bf114",
		"keyToEncrypt256": "049ebbb23eeea5fe76479e80dc2e62359c88ec10fbb4dacb73605afba9d764f6",
		"keyToEncrypt128": "7056fb782594cb33a05d0479b7245129",
		"encryptedKey256": "AfGGlZVnJT//Eski1lCw6gTIvCkdcrwBrer0cjN5nB2AcPlUYjGV3dJqZRigG24HeE+gp5kcEViEGWghpUBqMW+bPgzmQlXf1XDnyFvmiKZD",
		"encryptedKey128": "AfGGlZVnJT//Eski1lCw6gQ4RvMFEwwqq18nQ9MjjRnkjuTNbdq2VTi30cTwodpfYdTdbeRjlqwgjVQNwsFiyH4="
	},
	{
		"plainTextBase64": "7ceSendnQJI6JG/irumHKH0lA5EA8mMOdH6g/iKCA1eEhkPVkaP43j8hhbFXzuJH6QLJ",
		"ivBase64": "rj2sm6jdNPSzB0jD9kx5TA==",
		"cipherTextBase64": "Aa49rJuo3TT0swdIw/ZMeUwXa1mDqCsjKhsxwLP7NSN6bLBXiI2cKeACqFwehKbAeI0VKWU50h9bE/yZZJgmCT6kr+pLMBUt8lB4Ju9XaGMX2whgRzbUrmHLmnDu5tsouMq6Goxu+25SPWDZIlHBOIc=",
		"hexKey": "46971ea216d2d68ff019ccc86291ae1d4de7e972d8b1a70f8178eab40b04e364",
		"keyToEncrypt256": "56b0e56b9a22b9aaf9c30ea763571e6b21107dead4c359f05a11c5fa7a94ea22",
		"keyToEncrypt128": "96c3f71db5428732774342a3c14ee9a7",
		"encryptedKey256": "Aa49rJuo3TT0swdIw/ZMeUxl13RuUqqmG3LcyhApTNG6AQlzMwh909Lz1m9eqJdp6R0yBQSkFxi9xemqFLiqmtwOfcCK4JCoyy/h3fNERp3w",
		"encryptedKey128": "Aa49rJuo3TT0swdIw/ZMeUwVsgGzPoF/nYQZgMSclGUrYzETztxZo6dDYzNOsbKIi1nxl9upuF6ZcZRvOvTUZrM="
	},
	{
		"plainTextBase64": "ppWFKuAwDObRUepIu6ad7VwMUTuSuAbYxhMtLGIchipIps9rvQd737FUwC48nrQxHTPM1A==",
		"ivBase64": "QQPnYNcW4/ajsrU9UxlCMw==",
		"cipherTextBase64": "AUED52DXFuP2o7K1PVMZQjOn8gUqzsI5A9a1E35HeL/CGcvgTTcTReeJTpE6jn9UZGu3rNqX6UaBLyQjRxwWwvBGowhgHJzSk1Qw7qdl05zVaZs2e1qRAZ2ss/3nwiw/vBT0EWu/3v51sNZzDHegun0=",
		"hexKey": "129a394449d12c9738df93bede97bcf7e5ffabc9eb38d780fb5c87f5c26302be",
		"keyToEncrypt256": "70f27a07691e6f7b493f7fec2395bcf692f0ce46826c684be545fb8a62def465",
		"keyToEncrypt128": "a9923be559567c84b5b852034f738acc",
		"encryptedKey256": "AUED52DXFuP2o7K1PVMZQjPFzwzT3Ksdk3CeFWO68GSE+rfwa2tvNbvnydZCdZKfnajD4XEp9+PEllGlr8InATw+ShbtDpV0D1OxuEM/3u+R",
		"encryptedKey128": "AUED52DXFuP2o7K1PVMZQjPAsJUdA+iYnMqlVZG63lO2MGZGrR0c0r9mKlBWopTkOhCFVIE0b/vPC37H5cNB600="
	},
	{
		"plainTextBase64": "r2X+DEDO+YzMums9UuwAoJGF6qq1nf7ForoeMu8UgTM/VKbymkkeZbDdLg1NdS+7OrwFSbE=",
		"ivBase64": "H8ifzt1DrLXR8ziiPh24yg==",
		"cipherTextBase64": "AR/In87dQ6y10fM4oj4duMqqjpNwaYhFMIPfmyshPIMMmG6QOlCRitksNo5MQgnUwQrmqsDdjxEXytt+dB2rBf3BUI1XrmjUwvN+5bVsZzNb46v57W25jGTiRPKfaDPeTNGqNfbQS2SqgMXR2fNaA+I=",
		"hexKey": "5c602c5b30884de10e901f7fcb8f139f0bce2476f68030f81f04964885fa8b7b",
		"keyToEncrypt256": "61bff358843938f53616e83b389e29bf01b6e7b59d634a56b12b7d5131a1c498",
		"keyToEncrypt128": "d04356d40e3b056955a5074e240105b2",
		"encryptedKey256": "AR/In87dQ6y10fM4oj4duMoEAtZCjQ+75FNnuuoCUGlFDi89XWRSUkpNBCudPvmzeiYh6DLTOCJpWplTLPAmxNj5frbtPHk1WCdLmg2JuGwH",
		"encryptedKey128": "AR/In87dQ6y10fM4oj4duMrqha2jgxjTabPr56gS8/1m1c+7zKyjb4buDy8zsiV/F7HlN7B0wMIvhGdcqcIHdD8="
	},
	{
		"plainTextBase64": "0nR298cRDEc0pqgu5E+Ih2pGI/6tVTNffi6KfGhjzEI5qfaavQqLS44t4mcKfkobxeJPkjUE",
		"ivBase64": "mKZ45Awqgde9v0fdRhx8Rg==",
		"cipherTextBase64": "AZimeOQMKoHXvb9H3UYcfEaMRO2/ropC7s1nXEcF7xEDdtep40P8mkcUsFFChVeavnxRaAZenMU7ZcmEdOeIhTrrSpL+soA26qTrsY4NhohVN1OHCoHM3R8Qq2ybvhJlcO3gzr01lI6JMmINvWOX1Qw=",
		"hexKey": "6ac77e8c6b68afad21357395d4a46b4ecf96da9c47377aab3e62e73f9d626dbc",
		"keyToEncrypt256": "a55a34fb96f927ac25dbe032c4236919cc33259035ad8ac0cb013915dc823051",
		"keyToEncrypt128": "d94e2056f162ce50b8ab3cae6f8a2f96",
		"encryptedKey256": "AZimeOQMKoHXvb9H3UYcfEZ86ywL3eMJbwg9G1yKs/LKkuHgvVsYPWAh2K6TZcn7zsRc37SwNkQBvbBgoXOFO2IE24KHithEsVcQRztsLWsH",
		"encryptedKey128": "AZimeOQMKoHXvb9H3UYcfEYG77pT5MCI5p9WKXReBNO/bgiQOfVMrfnt9ByC0x8fKvK4u6Gnbl1nRbbT/WWu4kY="
	},
	{
		"plainTextBase64": "sH+QnlE/WSO4CWgJdYS8hCce0v+0LdeksyVrb92kcsX/5N5KrwcSyrMxLUQQ0jjgOXrdbRO2Og==",
		"ivBase64": "javc1kWEstZ+Ci1gscVOfA==",
		"cipherTextBase64": "AY2r3NZFhLLWfgotYLHFTnzAo7yRsat57rcWI8TZJkSP/+MhOEmonNCiIb+UjFCa8jC5+Zo3s3dR5uiKbkOZ6+9TdJ5Hs5eOBqH82quoKHVWLWU+D3gBD7hAKehcyF7toNTXJUfMrRHoitcYhVzteek=",
		"hexKey": "f1f188159f8cbf89a82bbae62a249af6911e507a160a5aac3567ea7bf5586ac5",
		"keyToEncrypt256": "2646182af8267100e7ddc409d3751b914dfcce78be0ddaf0f2f2a295b7c4590c",
		"keyToEncrypt128": "a88f3ae3bb8e14950069172ccc217702",
		"encryptedKey256": "AY2r3NZFhLLWfgotYLHFTnw4x6c9FXzJIGiiRqp+k2KZHi3K5mAYfihQkN7h3CRJxDD7BF2zAPIlWQMfMUcaHStShOjJgEnKZA8StDkruDhN",
		"encryptedKey128": "AY2r3NZFhLLWfgotYLHFTnxtsvcXIknF42JULl6mlH3CJBO77BT/yO36bZUHq0Kl31s8hnsNHKAdU5Y3MTKxQr0="
	},
	{
		"plainTextBase64": "Ignc8/y+bq6ddr7gu72wr2VmML34fZNzmHZ9d+tTAgaGZrbK8KwUEVXWHy4NbmgJ4KvHH5kB0C8=",
		"ivBase64": "FpmvnQx8DepmemDZ/n3MMw==",
		"cipherTextBase64": "ARaZr50MfA3qZnpg2f59zDM5vw16zOj1m6LfFA7otBzhuMubNibviwRbjl4EZtdB3P9SvLsNyIMHlYYuZ1169d5sGJmRGti8AZST43zFhPxuh5fHagZs5qTzBN/iBebSHE+mdqG73wqWOu+8FQiXn5Y=",
		"hexKey": "7f2e983b1ff9170d733d9d31ebadc509550248549cbdd1a7e644efc860b65f9e",
		"keyToEncrypt256": "07567145b18de751df97086cdf86980a52579b4623c8b27685325cd021eae1b2",
		"keyToEncrypt128": "0d75b9e2537b850533b72d5b454d8d14",
		"encryptedKey256": "ARaZr50MfA3qZnpg2f59zDNnGyLjhyVk0d493DTnfIBbV6bk4v4qJ0LBSbRYYm/8T91Ygu0PTp10Q8Wv7xWGr4l5yFfjlajLwb7HLjbW/OFK",
		"encryptedKey128": "ARaZr50MfA3qZnpg2f59zDMNZyXOombAAtUt3u95V8NmFiEaPw5hONGwl7qBGzJ6qzg8lAEvwyzvGdUpSY4NQQs="
	},
	{
		"plainTextBase64": "qKO9UQSt+jMG/JK8EkHWdAooNJ4GMOgdrfFM2JGd16NCk5w9kPvIaUSjGcLOQHF3/NW3oG3J8amc",
		"ivBase64": "lenGDiSTmd2iwX1Goozjpg==",
		"cipherTextBase64": "AZXpxg4kk5ndosF9RqKM46arKMPaqGFCioCJY6XjZby4FnM7qOuTmpaAwWqFTAO3zt9jb0RHQlmAqlWV3NQ0npxKwOpQqO7htg/bLvYraC/AX4tf7AJne8LBWJ03CwtTg5dULnpWWCrtVqvx/LVtsiI=",
		"hexKey": "414f4372dbeea4697ce28b4bcbb1797a6e137a6722dea1e9383fe769ee9bb2ac",
		"keyToEncrypt256": "512a59379f8018ce73620d0301e7a4bf7f419dcd664578dd47a93fe38c9e456c",
		"keyToEncrypt128": "cd8f8b5066cfba93df5ac395cc6d9720",
		"encryptedKey256": "AZXpxg4kk5ndosF9RqKM46brSa0XKgBv2U6eInME1zFj+5ZiCbW9dxfNDUKC4yIzJnRynTcQ3NX52bu9BsR7boyD4+sJYFZmwJVi5DLa3JwM",
		"encryptedKey128": "AZXpxg4kk5ndosF9RqKM46aQu9xUKVjR1oxTgQMNwQAAIuPOKeRLVTkHyWId052RZq000O/xezp4RmIRkv1U370="
	},
	{
		"plainTextBase64": "6CHYr33CrrdZ1bAru2+6RptbELor0tab+p3aoH0CGftngabDq0dNq8dVd+pNq7K5m7pbXhH4+9cJDQ==",
		"ivBase64": "s2TZ+PmZREY7YZAE5bB0Qw==",
		"cipherTextBase64": "AbNk2fj5mURGO2GQBOWwdENUaooIddgfmqBJb3oXHjQiOnRKPIJjcTxTGf6H6AD0vpUnDNFOYpuwpmsJqueqCI4bmcdFXYAmrKg/F8RHtKfh6w6IaDkvnCzw61NGfRcTJuUMSQMOOZKBg8VJHNSw2Bw=",
		"hexKey": "0374c794223028ed1f8fa7779c7b10deba4a90fad0e6dbbf53fd8010d7bf492a",
		"keyToEncrypt256": "acd274243634eb976388a36c3acebf32216427c7ac14a67f79524c5f7d096a07",
		"keyToEncrypt128": "2e20cb29e016429c465b95c2609ce673",
		"encryptedKey256": "AbNk2fj5mURGO2GQBOWwdEMxOll8ekbh6mwgwRWK3MJOASJrEt15HYSWREqlNTrzuecodKvJZVXBibKSTFmIaFtmpPiDJRRIQ1w/0LO9eA1S",
		"encryptedKey128": "AbNk2fj5mURGO2GQBOWwdEOf4X7KAKNJM0N/Vfcv4mWiXzPSCBVE+YkChxvUDjVKH/L7PtG2xgnZonXoLrkjtUk="
	},
	{
		"plainTextBase64": "BGxqVaf0knrNjv6+S3sfSLtUcwWRbRQFbDudJtSslo4EHSgbvCxJNIbjS2w+9hJvOJUWMNUVud3qD2g=",
		"ivBase64": "l2suKwEM8hZKsEoh24ug/A==",
		"cipherTextBase64": "AZdrLisBDPIWSrBKIduLoPzNqy4ByT2cQI08bDEl6cGs5wi6QaUnX3TE9vWF16MefyFuiW/tS69MB4dJCwIQgAFqts6w27rSFsZfPYloUhe/qWe61J6dbG5iKsGltN5fEOqR7R4juXR4XvYrhX9c6xw=",
		"hexKey": "c840c5dbb598e5b0d234b25e7498a8e4856418d45657b144cb15fc1595135a28",
		"keyToEncrypt256": "8df23d96c65b158ca322f8f913bb02865d1be358cb9f72222848ee8328d97915",
		"keyToEncrypt128": "53f3216d7720682ab898b9beddfdb30e",
		"encryptedKey256": "AZdrLisBDPIWSrBKIduLoPwAqPoAjfdmB81yBDDZ65mmzS3rIaHQvQhsPj6X6LwMDhuWoBHWokgqX+7YEYVHD38Clr/87RUhmf+hotsu0B4/",
		"encryptedKey128": "AZdrLisBDPIWSrBKIduLoPwYMN7s3xrfprsMd+mHNw66vV401QzfZoNyiBgU33CAOz+1d/uyXq1hRisAbzgoF48="
	},
	{
		"plainTextBase64": "SObxeX1K3a3zm6PJcqgM0w6yQPOvvPY/pf5CTVZlXIqeo2givXFEaKNCzJlVz3T4o6ELM+XflV17kKSl",
		"ivBase64": "0tdA3cCFHZFzaPE/KjrKTw==",
		"cipherTextBase64": "AdLXQN3AhR2Rc2jxPyo6yk9s48OL5iyxzRXROS9Bh05OoYfHPlDoBBk0ToBWVy5rUnUA8YU/Ef5gpQHIqsFyDqPN2fpd5JEXP/3WsG6wEXQp3K2F3opiJsZdRJo+nG9Mq+x1Tufv99x03vIKtQqCgPU=",
		"hexKey": "3e8dfb61272c6c4a76bddadc5c03cbfd3f36b7e0de8f71a22735b857cb310e5e",
		"keyToEncrypt256": "3257c44a9c4be50f799df1b6d0bb53e48a411856cd9349ab27e0639a88554867",
		"keyToEncrypt128": "f691a8c97614421c83e904dd5cf61e71",
		"encryptedKey256": "AdLXQN3AhR2Rc2jxPyo6yk83DRuZRGyMhcbJQid1Vbm2YSr8+RhXywTN0fii3lgYi3/7JaVFnWSMTBDBm8FEGcuddL04G7N0Y0/EVNWScMz7",
		"encryptedKey128": "AdLXQN3AhR2Rc2jxPyo6yk+//TXjN+QJXKgRcX0yxbeyn7HcPB1Ko05D3sHGYQmd3qLQLJextEaaCc92KfZvCaw="
	},
	{
		"plainTextBase64": "3KMwaKj9CS+pES+mGIzzsFvPjSd2KvsW+AZWwoBYiPRULSjFTzmTSUrm2TGcmdbdpljzDGqAXLAsmR5nmA==",
		"ivBase64": "c7gjGNzibGxdBDoylZSTtQ==",
		"cipherTextBase64": "AXO4Ixjc4mxsXQQ6MpWUk7WDYe9zKADhmrTXloC85TvEgg51nSqcznFAeGD8ya0jvw2dBZkdJdY+qHqz6jUn8Rb6UUAyZpLlr3JR05ZpezaL0NeRZS6X3kkC6wwHPzkepq3glkCXP/BhgVCx+BdEQYs=",
		"hexKey": "994088a080635ac70785f3cb3023ee5aef655c7fa9484bfd7e067aaf08cb813a",
		"keyToEncrypt256": "ad6c5fe2d21abca23fa72ce92cb67da833ce0f3956f0ab89f25fe325171165d9",
		"keyToEncrypt128": "2cd8bfbb22a7e1243ec0801260a5d044",
		"encryptedKey256": "AXO4Ixjc4mxsXQQ6MpWUk7V2jtdDEuRaHiauCUednwkTGtGVBqGanlRCZrDK10NSLmZWxJcRwPl4dmkgCy4rkQNDqmpAN2QtKYw/faNukxpn",
		"encryptedKey128": "AXO4Ixjc4mxsXQQ6MpWUk7Vo0q8Z5mLMdGfjwJrdKoiBKwjxWMdsA89TinAe4g0JAn5yeYdFlRGbQ43JeKzqhhI="
	},
	{
		"plainTextBase64": "8ZVQfBm5ElAFWjnCJy8tUHKFcnrr1AJ/IA0WsoNI5lGJzICQG7UB5c9UQwYiaD3o6IAqAwCZxaRKr9197lw=",
		"ivBase64": "I4sMWcLSv/CiyQxy/Ia/jA==",
		"cipherTextBase64": "ASOLDFnC0r/woskMcvyGv4zYa4uhkj6YYf6qN33tZiub3MEkIi9eNqVH6x3Oc/r6l4zD9qDZ2NrtwpFka0pcSs0UMZFsI65N7lFTZm8jnofw5Oj/wAS1ipAuj75lPPU6Rtod+1SqhBHsYgPGc+4tBzs=",
		"hexKey": "d678dbdfc01b6dab1c25755b4a3ed039a60feeb8d903854cd02bba1bc801b4c3",
		"keyToEncrypt256": "ecff1e7a5b9eb017131105e94f6018506db298f9efb17d39a289eb69a45b7c1a",
		"keyToEncrypt128": "f4c975d5984174fe16d37b4d17297713",
		"encryptedKey256": "ASOLDFnC0r/woskMcvyGv4yx2xegq4PbBV46HmeUntnat/64gBAIQWMADh850nD0CmxYZ8uZePUEvB2wWjKTBixdgwq9GxB4sET1GAQYpO2c",
		"encryptedKey128": "ASOLDFnC0r/woskMcvyGv4xVLojLIAVwU6PYvnqpg/ou2sZdLWbhOtKl3YNkPDwLeu091+MUWseaIBYmEL65SYs="
	},
	{
		"plainTextBase64": "wcTixf0qyxJRsVJnu8wY1+GlwRdPVXTFXLuuEtBTPAHep5ktPmg37+HpcPrevV4JFo8TBCmtNiVS5mXm5x1H",
		"ivBase64": "n0xKT9MIIun9JQMBzGckUw==",
		"cipherTextBase64": "AZ9MSk/TCCLp/SUDAcxnJFMA296FcQphBw6n7PlnaCi7YMy5rcy+aMX/FegX0TJlAF12vGT3qLisvlXmQXb1t9oqIu88Z3h+ULzOklEaEAevxp0ql19JleO1NXu+BfNs9+4fSbdP9ibmWQuMw5ZZV4w=",
		"hexKey": "43e0d70e900c71cabf757800340ea73a5396b45c30597013d44c5626d03ed76c",
		"keyToEncrypt256": "86ccd79045ccf9e59ffe9e134e128d22e7c45a82c70345959dc1d9d807c0c169",
		"keyToEncrypt128": "68a73aa49b83cc1583f5e9552a81e5c7",
		"encryptedKey256": "AZ9MSk/TCCLp/SUDAcxnJFN5HUXm0t1MznmgtumL6KVw2DJV4VmeJ1wC9axL/8+wN8GaEJzyIem3IX9JgqU1AxH6OefcnPs8Mpc3LUotHhvX",
		"encryptedKey128": "AZ9MSk/TCCLp/SUDAcxnJFP/zH49aKyZ4CCnq/oQLWjQAB44yDjvlUXyrPm8LmZc+7E1b7pRI3ZCoh84YqzGZRA="
	},
	{
		"plainTextBase64": "OkiyrIRCSqrc/75GwO7qsxI17fFNn/YyLh0QIqR/f9zWMC43H1ZWvGD6CX3HhHzfKhYFR2MjjIGo1rmqw9ekdg==",
		"ivBase64": "To3l7QN5du9MElIaRTBhsA==",
		"cipherTextBase64": "AU6N5e0DeXbvTBJSGkUwYbBCiwrnsdJ3NXnTo3/hDpWGigZ6izBwPxS8m1wJvdZgzf7bHNniYZeqwilnSlrp7Rbr5AMnvwvocNy5Wh6hMDvfQFlk/9Ph2izh7gN9ETKZ6lmvs73jADudnQ+gRUd4ULVfNt3o4QJgd1+MfJCREMh4",
		"hexKey": "7575c15f4f158059f5e80451ba80f3b89735370357b74f31c0fb873a03dc20f7",
		"keyToEncrypt256": "0174ac4c72977237d55d5c02788c5920b9ee1a1129d2314d85b2011bdce8113f",
		"keyToEncrypt128": "6fe236eeefacda2e99776e34f7adf5e5",
		"encryptedKey256": "AU6N5e0DeXbvTBJSGkUwYbDH+qUP0386O2qe7KmxOR2IvKnK3g4a6ZcSOOixjAv/e5YhpoAegpfeogmS2wpKW/Ka9Jy8/+hCZlMwWEM3W5v0",
		"encryptedKey128": "AU6N5e0DeXbvTBJSGkUwYbAFquxGjjHDJKtR9oAKLs1u0Wbs4VnMTveh/eR+ubEywaRT4WzZ8U4qrN5uueBxbJQ="
	},
	{
		"plainTextBase64": "Ky7Xg18be5+77zPhxy2lkINxEAZ82znNkSb/hiLAVDwJwPM/ONMypvTeYDSzQ9d1WXp3gTQGfQhHduf2uJ9FPvI=",
		"ivBase64": "OFnYCYqi+jundgsC9mII4Q==",
		"cipherTextBase64": "AThZ2AmKovo7p3YLAvZiCOF2G+TsB37Fzy6MGT7ZmTMaxQ+wb+L6OWU8mIVh2QQkktINTtWDqlL29eTfhsfnxQLnkKIPOYN7Tkz7A7Xlh+LqJicNFHiMfRSKshkfcUW6tLLg5FZQ2sq33H2ImOnwPGWJTUZ82fvSFRV9+dm7o1aV",
		"hexKey": "3fd32d5d00f77a04510f7e582a9afaea6c4ec118a8f547133e6448300fbac8f9",
		"keyToEncrypt256": "c1f5948b07daad3138f58e0e372cc48f4783aac2f2ba3310bd4203569b62c0d9",
		"keyToEncrypt128": "03acbb80de0ba0fe06570cf4dbc94e4d",
		"encryptedKey256": "AThZ2AmKovo7p3YLAvZiCOFGZoI8iyssxDRCG4KwHLOzCs3x2NTLChCnkic8NyvR8G8MPeCylFJNOv76HUjUljp/6X1OKTAwqLpeGx788FF+",
		"encryptedKey128": "AThZ2AmKovo7p3YLAvZiCOGDH51TqEkC/BbemWVAW+8yWvWuQaCez3Cey8+u7MjhozUftIy8TwjCtrf9HVv1Ut8="
	},
	{
		"plainTextBase64": "CK8N5+biFxn120OA/jKcUMROF2yoDk/rXuspfpuv7I/StEH3rX41xiW9OjvXOAsGYQ4UZm6YHAhZwa2mHxnaac8H",
		"ivBase64": "sK2rf66TT7g9yX+EG5RFQg==",
		"cipherTextBase64": "AbCtq3+uk0+4Pcl/hBuURUK6LkT7R5W3kbgVS/cw+RKDIJ40rQMwny/SXl69uyUcbQm4b7pfLAsXWPZY0LO6H4PunlwaAzwf2YkpJVa6daYgx47rhrmnXBeixZFblPGEUw+hTLLZBKiK15V/h0ttrYo8qhmu4hIhvp17GpaWNKQ0",
		"hexKey": "d359fa67db54ac8628a6bbbd27fccad359ea5cbac03e3d6eb342e3cc12451f2f",
		"keyToEncrypt256": "8d17b32457b8579fba075a251178bce4ce8abc0f8e58801e708f69bbf43d0f37",
		"keyToEncrypt128": "ad88a94d11b58ea2b87e05bece98f4cf",
		"encryptedKey256": "AbCtq3+uk0+4Pcl/hBuURUJdSkjdZ/a/KGT4zGzyjNGCkO6O/aSbl/wO677WQpO1hAk683RklVBT3bK8YpMWlXRnpc1DhOSa++YjlBZDBD/P",
		"encryptedKey128": "AbCtq3+uk0+4Pcl/hBuURUJs3wF3NfkVukhW41n+dfjxxH3GfbCVkHz+moLK8dFhEnoA6eSsrEmKXl/JoY0tYXI="
	},
	{
		"plainTextBase64": "6Xp2b4rx7tw5URa9n+pCjNcl28OverJkKP+KcrbbGR8OitCseOZx7iUisR4nUtc5NAutdLyVt2VFrC5hiUzuQjkIEg==",
		"ivBase64": "07vsjjwiIQzyJOFf+fQepQ==",
		"cipherTextBase64": "AdO77I48IiEM8iThX/n0HqVbORs2BMOOi3BhKNZCCs8kHaX7fhLfPK7jQvwFbYPcI17FGW+4qwdIk/a+Q1eO+XOvgqt619J/O6WPetMOinUTbIoy0sz5lKkZqjSc0ZEgDlpoDoNOPjNFbflHnE+3lZWIcvWNNW73WOfy28GWjbSl",
		"hexKey": "872bdd74ae27fe1a8e75fb3396e837d3aec7eb6c30381a518e19e3823088bd31",
		"keyToEncrypt256": "c017af3916330dd5f2fe0806c6a8c181227b815e52559f62533075a1594bde68",
		"keyToEncrypt128": "e122e1c44ef779208c8d31913405229c",
		"encryptedKey256": "AdO77I48IiEM8iThX/n0HqWQ8g3iCj4mWMCpfC27UguMW/WuTXoGTxLXRw/q2+jFufwgAQumLn35hrnbCTEcBc7tUGTf7ID+ZH3cKUOTf0KN",
		"encryptedKey128": "AdO77I48IiEM8iThX/n0HqUcx5H5kFgr20SD+B9pEK0+q/H7OyU/plCrgtxJ2RNZDtnqUhZkW5zcxogPXI48xjM="
	},
	{
		"plainTextBase64": "JwCYxPzCzWKuw9Pxlxy1hU9XiCZs8gyD0y2iuB85lyNm1B97BAA//m170uD3fR7Sdx8I3grM66LTEPxFpiXfg2ydg30=",
		"ivBase64": "RXdqhv+WlSqnCy/RQ8XJ9Q==",
		"cipherTextBase64": "AUV3aob/lpUqpwsv0UPFyfUSt/EeJzx82+8gMCEXwkNEJa3uVmC4dMZJojKIJ9L35/v00QgkdXUa9gLDdjVzC89q7zPYorf/LjiXUCwmjh/INqRsiXG8LAG8rwZRFbbaqluFgUXIrnwromuyD797OpXy5LGf2tS6BzteyTX9s/fh",
		"hexKey": "71a5b8d64b56ad56f6b0cca43720b32d2b50eb4de2208d875272c45756802b9e",
		"keyToEncrypt256": "8bd08c9c7cf55b82f2947de554d2f6f7d05d5e24de6ea1fb60ac6dd454eab11c",
		"keyToEncrypt128": "76b754bc6ed852bff7df72ae8420f8ea",
		"encryptedKey256": "AUV3aob/lpUqpwsv0UPFyfVdmGXRO6SXoDsOtV1xqEOoPU2HNZtDM7FdFupSLd3d4Mt+F1+TBu1wB8j4jJeNQbtwuII7c+kW6EUm4EB0Tpsb",
		"encryptedKey128": "AUV3aob/lpUqpwsv0UPFyfWXwht0/GrkSoTZ/9eHgChG3dkZKM/QQtuIy1hQXieFrpXti4dek68UyD3xQd4TRmk="
	},
	{
		"plainTextBase64": "65Z/EfQfZNRvafj3la4z1L/W8v6bLaVPJKQGkdeMwRWf00CxsGNafBp6TbMWP7Q7RW9QWeNHTDafbHIZRSUQPoiyrZxL",
		"ivBase64": "P3zL4jpBhGQGga6+FAvAKA==",
		"cipherTextBase64": "AT98y+I6QYRkBoGuvhQLwChFMmyvzQUr8KT3vlPMQLeAY2mrThG0nf9ZWsHauydWs/68pwINcwjwEwl0TdAmXHiu2LM6esxa3Ql+Q4qYw7hR5zkBfd6b1q0gkhmhD5SC4nT3MEjInvu5H241/2oPOSu0FUYEyY0AcqggjoS1hMk5",
		"hexKey": "5893a032f8c406962e18ac6159fa7ce9dbb984622ba7fefc13c0c5ed928ff674",
		"keyToEncrypt256": "d34772847992ca7604c8239f7bc4f9ed0f06e03e68236d961d5bdbd0f6d95296",
		"keyToEncrypt128": "482ad33ef3775d131f75344bc3f42a8c",
		"encryptedKey256": "AT98y+I6QYRkBoGuvhQLwCiGfyo1h3PvGcyVFkFnEPIxmnvcg3XfhLfMvfkkHY9wNVMjdkZnmlwVRzox4goxaqmzSVr3qQgQAw0PBtlyoi9s",
		"encryptedKey128": "AT98y+I6QYRkBoGuvhQLwCj1+ZoQgxo2Bwz8BPCsFkGgPN6ifaX7u9vtJbTauDjl1p8o5mB0K1Mjh/OkQraw6bQ="
	},
	{
		"plainTextBase64": "PJ3qjXRfzLCfMfsdha7/dml4AmoJxhPzSmo4MS92imV3wrCVLMLzI1roX1QHWj0En0SnCOIgtKSJTlUv3CPLhJ3iQC2tvQ==",
		"ivBase64": "OHMQjqmcS3PldJpSSJwrRQ==",
		"cipherTextBase64": "AThzEI6pnEtz5XSaUkicK0VN/QGdtKAZFhaf80dRsT4KzYlm/ASp2mZgG0Mvrs8cWTYU9l3sXtwnW0+FCWP3v2qfXIVeyv461E92IPxMJYLINGGBaWiz7hj4p1LW6PIOjloJq4qrVPT0D69eRhLBHj3vNCANzIrXP7fxh7MemPD8",
		"hexKey": "7aa27113de71d3faaba1e17513a62566622189e05c993947223765c8d2b03290",
		"keyToEncrypt256": "5990ae16897a418612b3cae5f62226f21ae3e5004c421541fc10ac7c87dc6918",
		"keyToEncrypt128": "9b7ec052daf8f0833f073fcd69f905d4",
		"encryptedKey256": "AThzEI6pnEtz5XSaUkicK0U8W1YLc0yAQEqLCYCAIarbz0MH4q0waokcV8opxw+ZzA9pXID4unJy4lVj0Or+8EELkSxyBDfSvB7ggEF8F3ls",
		"encryptedKey128": "AThzEI6pnEtz5XSaUkicK0XhwzWOyDx6MygGu7hP/mNPyCG167PenqhVFKNmGRZVnpW+KpKviODiKiZ90RrpgtY="
	},
	{
		"plainTextBase64": "8joinASSnbYbNPNNgD99lrO+pcwJTbObHEQKsY++mOgNEIG5DGGa5VL3qu4RdgD5zrFpxT/4LfrAzkvO8ZXLCLCRwrqLujI=",
		"ivBase64": "y5H29B5tMDMgQqxmWMwR7w==",
		"cipherTextBase64": "AcuR9vQebTAzIEKsZljMEe8NxRkRAyny7hjvG9U8yx7+99KSyBJOuw+oosbG2bh0YrysyO002BnyP7hHGPHvX+cik39Bfn2b9/0AslLl0URI5u/sL2CTmZ4AHZJlB/Vb9hI8YuvoY57lPf/VafsManRHv3Mzj4gpS219/JoJL2gr",
		"hexKey": "e4879b6cf267f243b6393f435300ede3958726049b5adf7f8d4ce76ff4d59e53",
		"keyToEncrypt256": "fdb850e29491917681ddc434212451800cce65a2bde629324ae070ee9f132333",
		"keyToEncrypt128": "752d3061f5432130032df0eec3b66f70",
		"encryptedKey256": "AcuR9vQebTAzIEKsZljMEe86Kx5ZeZkUQ/6blTgRQdR/e3d4Gt+PXVlTA/2z5UQAlzrjGmuUnoT6sbeTKv982sopBgx27ZQSZ4rtPHQXETEj",
		"encryptedKey128": "AcuR9vQebTAzIEKsZljMEe/CaS9A8F5D9oRtr/77UmjEhX+G/b01/OkU6aXM/nzN+L3tfGCkU/SDJe2NuzBRt+0="
	},
	{
		"plainTextBase64": "vYUZwLcKT/rOmJSrduLolZnYhbljQJ1FMlY8Hc85zurvuhKjHYN/ZY99DqE9sgiaYf39WPM0W00lsCUmw2QQU34QHDF3funq",
		"ivBase64": "/2iyJAuVDd+ecwbTfQP+Fg==",
		"cipherTextBase64": "Af9osiQLlQ3fnnMG030D/hafQaEm8Gso5WINEE+FlFsH8j2TExNMovOWcTfmGJA/Tvcr/y4XhfP0FdAVAMRz0jXhDAUcXFPrzMwhn9Z1knMgNgfKvEnylVe7BDqJeYOU1JEWmvRdjQLxRlC4YyWQhtvDt+GLVwa+j8HLr8lBb85/",
		"hexKey": "1d2b092b92997da35f95bc33f9bec7b07ed87f694cf4fd5bd10140509f3ef8f5",
		"keyToEncrypt256": "b1f33978861feee901df8308158ab7217d2a6486a12f2f1f628856c3e1c62745",
		"keyToEncrypt128": "24706afa1e843497388bc185e360973e",
		"encryptedKey256": "Af9osiQLlQ3fnnMG030D/ha8flQdESvzjUr/aSfkEJBTOzb/wgTzob+aSCLOKXp7Y79emBNAZEGRhSxtjsp73YEByUfvM53aH4hQ/FiVpop/",
		"encryptedKey128": "Af9osiQLlQ3fnnMG030D/hYXOFRR5B/9jCusc2UWZBjdEX/xFNFcsF2/N6s87y258B4N2SBexcUT/wUVtTGm3cI="
	},
	{
		"plainTextBase64": "JwxyZ5xWpShVFSrvdAorz+kNN3YkHX73YryD9TCq/WWzgSXQhqbTeWNu02mlYLMIrwW5maipL5SDOzegQF1Kq3+IP2zeQRxocw==",
		"ivBase64": "hLkRaxd3/MbpsEF+PuNseA==",
		"cipherTextBase64": "AYS5EWsXd/zG6bBBfj7jbHigv8mrQKWryKYkfm/nttyF7EkoT0MzxmU7CSDkdBE0OEgH9u5kj+M8gZvHg33YQvjFEl59uu75USpE+Dm+uV73+aGRPfqnFLfBq+KeuBtpF5CcSpmTUNW2HGBkg/Lh1AdKHaRdE+FO1pBfeU4r2whD",
		"hexKey": "fa774040e3e0e834d169b2841582925daac1df138e76b0ceac9d9cd844cdd210",
		"keyToEncrypt256": "955a954bc36324873c3e577c018386d9bc53b25af0eb89c0667de1827fa8cffb",
		"keyToEncrypt128": "6d18033f98eb4f6388ac66407327e823",
		"encryptedKey256": "AYS5EWsXd/zG6bBBfj7jbHhO2tX8/yomv8wzqe5jfZcNu8VRw+gbys3IfJK1Hj3TGjysx12ygpLhRtnPQxMLaIUgvhrVziMhIulZmiefmpjW",
		"encryptedKey128": "AYS5EWsXd/zG6bBBfj7jbHgaY3L8iji0KqYNDcy9daMxB/EP3MpU7uw6Q3jiRS4rawQCEpIlzuHVKNh8f7ut1Ps="
	},
	{
		"plainTextBase64": "FUdto1ikZu5dDDzUMxmM29Cex+HcXoxFS2vcQ1lmCrJvST/B9rCtwTOxleC7HpjuOKngg9PfGai2D1kRyCJ+IhBJ1p7CxluFZYk=",
		"ivBase64": "f402tTpGmcxLufakDho8hw==",
		"cipherTextBase64": "AX+NNrU6RpnMS7n2pA4aPIdSNqS3xgc6iPoeD5QmOKG8WFLfFxJJVonPxd2O4kM6uiEBb0gzgY7T2vHu1vYopJoAxclzPstUbG7X6aG5VfM7qRpNfQtthAz6iAi5npQgqGRh5kkpfaN3b3EFnS+1WjFeqGpTx8uYRIZsp/mbOebB",
		"hexKey": "b477eb79e8e6fea4b5ba935809d4c011880081d225e7fc094d0834d5e13be765",
		"keyToEncrypt256": "0f4caac1782af46d54b0b5df1cb211f2bd277f386c45195f9f7bd4d4fc6af5b8",
		"keyToEncrypt128": "e7aa08588f454fc8dfdc586ad043d2c5",
		"encryptedKey256": "AX+NNrU6RpnMS7n2pA4aPIci5wWZq+qX7Jzkg0bICQNaqTuywO1Ak0MlfsL6YQbPy2YjdKEv/wzlcknnnhnln3ZTNvhAZs/kC5Z1X2A0/opI",
		"encryptedKey128": "AX+NNrU6RpnMS7n2pA4aPIclNmbmRtGIF+guXyKxCGX9BiEA+2EnXIuDtPvsuOPdUp2UbsYjvlQ5Ifd9sB78Wr4="
	},
	{
		"plainTextBase64": "EuBGVsFypCJ+Bx7mKPgBqIGuW7ECa9XSP3injk65OldEKU+Yk0DzQssywJUXK3txZQhmEUnjOz8yyBUgphxGhQ75dkSMgiaBSmQs",
		"ivBase64": "MihQAFXTS4uYoKUPRAAQOQ==",
		"cipherTextBase64": "ATIoUABV00uLmKClD0QAEDntkdEBCslaSrHpGu6hlkHiK5RtxdA9LKdlw9Uaiv00vD/0moLtSH7lbqQb5gKu7UvQoFAbPuENwXe3FIZhgPEOFX3xJ4yrWvTVrsU/bRHcUD6N6By1BWg9+2MiE4EfflrKSXEBdcUdn6ehT3YzmEQr",
		"hexKey": "21243ecf98edef480de7c0d99004ea6f98151905e346881bcc671fa0c81eb90c",
		"keyToEncrypt256": "b5c9fc85bf08ec4c810b1ed7ed7ed6c73bae2ae259fa496efa4ba2c079b25d1f",
		"keyToEncrypt128": "803aa5a90da220e23fb8aac2b84249af",
		"encryptedKey256": "ATIoUABV00uLmKClD0QAEDktPNJQd3YDHjgJl3qnfaatlgbtjBrm0C3AaA9JMWrWfZGADyTfGkFuCoELHTVIepFN28t0xVDbhKy35uFFEVun",
		"encryptedKey128": "ATIoUABV00uLmKClD0QAEDlzNDZBiFaHW/8vs1Ui3uvUmZ/vs3ml3degM8CPXm7ZkQBeACbi130IuIR8AvSj+Bk="
	},
	{
		"plainTextBase64": "+dEejUPTYpTJD+L4qvcTX//rCJojD1h0UNchHKrKjr8cExEEtuRY8xDqTtAheQNdVXATJCtMRUSQPnKKKatngmTwaZyGxyRLOWJptA==",
		"ivBase64": "fLRembyx4FcaSWbqGgfPaQ==",
		"cipherTextBase64": "AXy0Xpm8seBXGklm6hoHz2mGwe+Ac/ySHFnYgfEMz2gWfGy4YqYEyRmMWvxMiZuUfmOJvKkzIo8ojXqs9tPR50WQEqFQWt5sOXoaFDvzwus+inF5dzAjNDskB3LMfClyxWiIPSUE/Q1dNVYoMY5aYs+DW/f7UlFXX2ABsuPw+b5u",
		"hexKey": "8132284a962c3c97887f1d919fa97ff49266ccaac58bca1133dd54fb91a1f120",
		"keyToEncrypt256": "7ecddf2bf20223a6b3590e09c1a05b5e5f90a0fc77b5b889d9c92e3eb85d4d64",
		"keyToEncrypt128": "49985c055df453f2372df2dcf73bb131",
		"encryptedKey256": "AXy0Xpm8seBXGklm6hoHz2mmxphPxHFA4+2o559H8GyA8Sy3e/oq1ECuJQML/XEJTF+Des7Ie769pSOGG4/QNJIMrZDY7kYUC3ETlxSsoRS+",
		"encryptedKey128": "AXy0Xpm8seBXGklm6hoHz2nCfJxowLJQqNrRhCE4IEthZH5j/U1isZrEe7TlJkTHqBRdIV4o5x1ygNpESTbFGCs="
	},
	{
		"plainTextBase64": "F6m9S2v38F4DIRmcQFwoLqZX6C4uk6vFNNAmqVxE3hQYGHfqZpiGMkBsLJXPFXxRzP35ZKRHuq7nv6kxQTcUe7nTTOE/4VUjpvS9ouo=",
		"ivBase64": "QHOYYPP9kkIViGXtvEPXZw==",
		"cipherTextBase64": "AUBzmGDz/ZJCFYhl7bxD12cEvLh25TJbPKCKTDUmei5Z42xWykQK/fq9B1bjqG1/Z3y9JaaKNXKOdtEveGClX4ZwRZ/QGQRmwPK0LzHL9F1d28jvS7jqSpRvMGa5OSBcr7ZJrj0moUsZ/rbk0zE5bv+ZOlNGt0tex1vYXP/YQgZt",
		"hexKey": "8d7a13cd05afce1611225ec5cd76982267f8006874de3e5dce8b9e59209cf364",
		"keyToEncrypt256": "c1de9966a678db449279a3d6401818fda200cf68c5b8e5e663de259b4f3c2f01",
		"keyToEncrypt128": "6b1b44bef04d90a1b0bbf0484dfa3c5d",
		"encryptedKey256": "AUBzmGDz/ZJCFYhl7bxD12fwf0+lJh7cl4kzir7fEUodAP7ma/ijAg8nDkRTkT7OuA6/5QtEcXISuG3LBLsZD14SQqYgJuw/iJu9dBOcAT6A",
		"encryptedKey128": "AUBzmGDz/ZJCFYhl7bxD12eBbfrbNW1d2GjXJxRtITeLzkQ+AfW61dtEQDvzgna3EYGb0T0Lp1PnPl5PXfzMC3I="
	},
	{
		"plainTextBase64": "RqN2ZY1wNtu5WouTUukwjI23ZMl/V1v9PhC3bB4YvcW9dlem+UDjLX3nHFMNXWglXIhVybYG6TCbgB++0/7WpGxiHMWq99fPz1l5FEk4",
		"ivBase64": "llOzRV6oIGKIxP2Qp4nlOA==",
		"cipherTextBase64": "AZZTs0VeqCBiiMT9kKeJ5TiYyxhAcAxgZxqNfhidkeFv8Y/SD8DjVdNHi5JDplODbscsQ2s6yvEfVQ6FuudHygeAOuFrRbVN26gcHisqNfrNC0ZNT02xFMOPJQlpvgXTAmBmVsD11WC2yChwPqu5sB4saIvcIxHuto3yX5SaZZus",
		"hexKey": "eec6d532a8d0798600704a4a31b6e0d3a07dc61fde514d0da0538a9c0fab5d3f",
		"keyToEncrypt256": "8f0f72550b37adbaff47e506eff26750fc27d1c760d448d45af00e2a4e476b5d",
		"keyToEncrypt128": "e2115b8b0bdcade4a79348f8d8f8f646",
		"encryptedKey256": "AZZTs0VeqCBiiMT9kKeJ5TjCkP7WtBYxUyouptUVxhGOljDeS+TWlxGhbbIHoSUhaSMJ+0jr81nsPoXJAMSS3mPIZol84rMLaWmokARDIFYs",
		"encryptedKey128": "AZZTs0VeqCBiiMT9kKeJ5TjxqScQEkdrW4g4pfvqG3NjrWEpT+VyIV1ixjOi3fEnebC29WxsoehUD72L5scHXJ0="
	},
	{
		"plainTextBase64": "peDObTeYorCirkmaG4CuR4er3JfUyENt6rOegBpxfzGJb7q97GndbIOGI+gqTmjLAODjeCyamb7mmsmBHNnSi6CDcc8q84YoEETvHerBhA==",
		"ivBase64": "dhPVbmJD0+xWk41q1uKRtg==",
		"cipherTextBase64": "AXYT1W5iQ9PsVpONatbikbb0JzpLtW1O65F3pMPodElgYxte7NH45SECNhToAwtb4G91yHIEVhHqlAjqV9fB9V3c1Re5+PIi9EjDp71R/gHtB6LDw2MhDgSzQrcVgB7ZcRP+u2gxiPitt5Qb8C7Nf6x6MGiYj1zF5tb9OZp/TBVQ",
		"hexKey": "c0fc00ce44407be998f4a098cc80596f2ec7bcf2e741ef2b5b81f9f685b232e0",
		"keyToEncrypt256": "9e0372ab8d05381267b0d6bda8682f715f2c17caa173cffb52df8bc964ef8ba2",
		"keyToEncrypt128": "3e655295590dc46b02df826f5a6d243f",
		"encryptedKey256": "AXYT1W5iQ9PsVpONatbikbZ4Sv8GnyQDIhyPb0/DQ1jc5VNaAfCJuCLF6DmcAXdXZVYnWsLnWMoTdeNWNUl8o/J58tAjncNY5P/K35Fb86+c",
		"encryptedKey128": "AXYT1W5iQ9PsVpONatbikbaywJhxi5ETki+0btCvw+SggNADwJR2bYwyapGELdfkhUtZORVrJJdhOpc7zaq+TqI="
	},
	{
		"plainTextBase64": "ijt8mEVnXfJ+QnOqmcru4lqtPNzJkuam/zNjCfrH7z4Na3KFC5v6fDQi9tQWaCrPCT7Ux6wImsbPWwtAa94usxKpOSDVIPYSC5t6HJY5wo8=",
		"ivBase64": "n0e+AD8ZxyOoKUaTSgchxQ==",
		"cipherTextBase64": "AZ9HvgA/GccjqClGk0oHIcUcvyhYTGyx9ySqT5aAaoraC5A3Nd3Hv7z6lnnEl2jjzF4c70uFz2EQ62daplS0hx1rb5sAzdwLXZb1DicUt58pS1Hwt0XZxi3QAjanIgYzikEQ6DDAN8/LJVhpu1UMt4drdAXA8yv43c8yNOuqzSJTP0aeEadLEeiZCcA+DFOE4w==",
		"hexKey": "4a4d2208977a31332a823bc034ed01316e138d9cbace3fdb7aa93a73d2b48938",
		"keyToEncrypt256": "748914ba03039be68c7ea9d6162e6943d1b23f28331be335e797d479eaf17cab",
		"keyToEncrypt128": "21781cb0b49b82125e7e0e8ba8e7802a",
		"encryptedKey256": "AZ9HvgA/GccjqClGk0oHIcW7lEMhmnGwNA0NBtMw1ma1OQUkP2dXswUDRvfDl5sWioDXJn5aKFTZLoJ7+w+a9RW1ydtLu1DJYLq3dOP9wy8Q",
		"encryptedKey128": "AZ9HvgA/GccjqClGk0oHIcUmt67mk1HjcFUd6S7mHYFrOAey0HWqfodqgEvwgaVsHi9jgy4U/ItASPKHZoSTQGk="
	},
	{
		"plainTextBase64": "IHeDeadMBM0N4wv85CkYT27s2HkWUoExyTET2YnIw3NNKLCMntDmHOCoEqf958p8Ny8wM1qDzDUJlutt7G979KUZWfv/1ETtc/ErTFVAZ4gl",
		"ivBase64": "Zpk0UW9ah4QQu5m/mbp+5w==",
		"cipherTextBase64": "AWaZNFFvWoeEELuZv5m6fufHnBAgk47YsjrE25RymsLEJ8EXkGwzkUxmCBUBH+7sTaxil5APU8g588HVnHQnP0AP1AZE9+At58PouG0F1IJ3asbXYRQ/rIhtBar0OmMKdce0bnZW4PUgOTewzUfI0hGeNOZgGMIdvQwAOer5E0NdGdVds3lMqmkkF6NHclDckQ==",
		"hexKey": "27acbc23456b44dff348b79994d7c5fee2af67eae4116a81571ee6a4a3567236",
		"keyToEncrypt256": "6a70b3f706d9c87c13d8542716505f40c2f5c2423f5574d331bbec261aee948c",
		"keyToEncrypt128": "ae2ff32ebb5fc4591026debf2ef54183",
		"encryptedKey256": "AWaZNFFvWoeEELuZv5m6fucv9DN3Nf1OdLU3Svyxj2yui5J11T6HzFw4y2uVKcd8T4gxIAb0H+J3cobCQ5w/S5hd7x3LaqtsjtizewBeDdxf",
		"encryptedKey128": "AWaZNFFvWoeEELuZv5m6fudj89UiPPu04RtZT//1NplDSnts8MZQ4lbzgoRReQHuHNM8m9lsx0fhonG7MdaqMJk="
	},
	{
		"plainTextBase64": "64W4NDWa2q2u3QZGIRXDMJ27eM29EuqNjnZ9sDPf2T/BSapqlA/ymMtNpOxxghSqXz4D76ksD2g0JHZRuulSu2wnmmYryGefL0RZeN2VJo52og==",
		"ivBase64": "aCwsZdqGgaRpSc8O39uyQg==",
		"cipherTextBase64": "AWgsLGXahoGkaUnPDt/bskLNCo69OhWtCzphdzMNpV5s4udrj1vyNRA+0LgR+22l3+t9T78QJa1FdCZTlhnevXQT/0vZFnfUMXgt7a65z0QXfNFNjgglF5bEc8Ty2aQkgVYsnKFMyXNgJs+7ohgqVz2OUixWMEQgriyDTOzlgwaCIYPHy2R3TfZleKOfi2VPuA==",
		"hexKey": "b115ccee3c763a3b0c9768ef2d60ad0da4edf84bf818446ea1d89c659df181dc",
		"keyToEncrypt256": "0b987cd8e1764985a824d0c97dab260b9746d6ceb8c2e5c4a57f86b8b4ce098b",
		"keyToEncrypt128": "f260bd24c3a06a06d23ddc548706fb35",
		"encryptedKey256": "AWgsLGXahoGkaUnPDt/bskLu7H67WtNYUHhHUnxfieam4Rfx7VJwAb4luUh2h+MkbG9c7slXdHBDqTo8gCuxh0QnJvgU+ckSc3kMpHTgirOz",
		"encryptedKey128": "AWgsLGXahoGkaUnPDt/bskLzo02J77DuHS7e4r5HkgQr4mKmW7sjjQHLVOobZV14GZG3CzfFO8c30zlNJwzr5bQ="
	},
	{
		"plainTextBase64": "vb5Pg8HGI6yEmTZMBSjxSv3l3yl0xc/L1o1QaBdZs2T50hGSL0cDTqnrEl8b1BHsXOAm8B+uToMk0vH+6BExa5YUVg/pAAXFfMSxywJu+B7OwH4=",
		"ivBase64": "4HhBGaQL5LtzG+Si0+Vndg==",
		"cipherTextBase64": "AeB4QRmkC+S7cxvkotPlZ3bR+fkF4n3yHMTIn9PYAlDSsLQnGsBw/wucXjp1+cmxUr0/L8t7AL0dIBDIfrLzcORTwuieuMvVH9nFqMICl3Ng9MbD64Y56igcRpGFIoTbMRoG5sVr1kUFSjLxfHn7Obs/pYruqJ2buD7AZyXxCBdJIDx2W6IhBLu/5a+xe8iztQ==",
		"hexKey": "56bc59610b838592d38a54cb48c5bd6ef67221a08da75332932ec75750234003",
		"keyToEncrypt256": "99e44ec6662d1dbb94ac8cbd9ddd38ad883bf946e4aea946dceb133d0f37d2a1",
		"keyToEncrypt128": "4de52d158fe8d4da698cbdfe2debc483",
		"encryptedKey256": "AeB4QRmkC+S7cxvkotPlZ3Za5LduiCR2pNQkfJiSPdktRKYvYM1gwJ3YHcBhtf4rGeL1p5+ZcSEQfnYJpcdA+L/DoJzbiIieJ9kCnsH+CHQm",
		"encryptedKey128": "AeB4QRmkC+S7cxvkotPlZ3aKPlMiBvXy2yTRXJqg1e7Us85l9oDazkn8iTM1D3DgKyCvE771t85i3xHraw/L5Oo="
	},
	{
		"plainTextBase64": "B/xXQYKzMSkmzw0p840IIt7CUkFHURuTjdv1K9GmySqZJAmvapZY6JzB+Pu2zF7yROj+WrqfAL04ItS+Im7KImJwk8/GDXAybD8ZhVZDv81XQ31e",
		"ivBase64": "qS9DdzFHHtMHwfBeW1V1Fw==",
		"cipherTextBase64": "AakvQ3cxRx7TB8HwXltVdRcnt2skniNmG1NKfE1IwprVyn+fcglNg3FOSmdycurguwurfXD4eX15WA97ZcnEQgOgtHAWHVpDidMalO3J6Of5zX6XbXdVYg2FH0ZKCeVZSjMAOHSOOQoEIZPoLuoI8icbvSopiti3rG2IlQ5b+egj4c/kP90kEogsbqgEb02ODA==",
		"hexKey": "fe5d966cfc4accf6216c6de8695068fbd63516c0548110e293309981b77dbf2e",
		"keyToEncrypt256": "b124ad9f581aa236d005c28546f018653ce8bf8a631f6fea3dae5e335c1b7676",
		"keyToEncrypt128": "bb4522cfd09b80a6e872b27de4347468",
		"encryptedKey256": "AakvQ3cxRx7TB8HwXltVdRfD7ikm7pfbf3e2idu+H9aqrVNwuNkDfvRdjSZ20Ve1bpyJ8sYZ2ZVRB5w1M6R/cjgD2JaOFW8GiifGiW2Nfv9b",
		"encryptedKey128": "AakvQ3cxRx7TB8HwXltVdReP8F1ULcU22HOFfvpHeT2+kcyUUo71Pyvj66SdisYN4BisIOHlrJuuDsMn/JkhG9w="
	},
	{
		"plainTextBase64": "M556Y3igULzjFQpWP/y/C6RFJuWTYt2yCT/bo7QOmOOvMqXO15Er32hpdhsG3Qc+bV/dwuUmk0WB+bnia7Y5aQwLEom5FYl+jMQR7JMejTYBtDizKg==",
		"ivBase64": "l2yXdtFQxuLUkJ+Q6MbRnQ==",
		"cipherTextBase64": "AZdsl3bRUMbi1JCfkOjG0Z0uVib6Nt9VV+eCmybwQYukYkWP8vCABc9ddNAgqVmUYUA4VnNaezjNJuBymAuOA7tHeCGtsQmIsYtIL89gNk6usUXZV4trM+yRSffTA08DveccqMv3l7qmN58Lvj/+2S4p8Qlp2w0W9Rr+RErcNQGdES8AO57aaAEvH4NdB75VEA==",
		"hexKey": "3072ac715830e0ffdce12c9a7aba2cff8eb4ce8a5568b4aa2d0f59cb55036959",
		"keyToEncrypt256": "551be2d061205f3ee6df4538e3a2fa96a97d22f0ef86c2283d8569df4d6aabeb",
		"keyToEncrypt128": "b7e0a95484ead7958c6b280bfc583663",
		"encryptedKey256": "AZdsl3bRUMbi1JCfkOjG0Z2uEXfUVSbv44Dl1sg6pBk9Wy3/AZ0iOEnsKVkGvaP62OTdr4z7Rpe/g0WVphH0vGfjMLIlbs8ODUgws2Qh+ysJ",
		"encryptedKey128": "AZdsl3bRUMbi1JCfkOjG0Z0Dvv+T60ns51Dowu+2nMvCy3J7lvczyeYbcBEC3d0jKuaD5wjaOxyaRNHQljN1BR8="
	},
	{
		"plainTextBase64": "+YDxGG5DTjn3hvtCCmHBo9kbuQIJoV8dAVBzElfPV4SEGKU5cBcc8zQ1DuLmI/a8Bn/w2NGeW8Z0oye93DPGD7qOGgv9kEQ/GCOizBH4345s7G1J410=",
		"ivBase64": "5vr2Y6xPZBNxdKtHc/27+A==",
		"cipherTextBase64": "Aeb69mOsT2QTcXSrR3P9u/jrRzLuLU14flXNkRPVS3JWSLKFJaHZNAx4MwNNC7BlJbCv/Wj8KwaTryCKOR2l9+hhjLVay0BWclLyXedPS9fj1Imn1XgJf0REqr5Rvx9vooc2v2UL9Cv5Uf0XIMMeUV6+hjgpdk1iojlWs4Uv/lpytbsqdZ+zFUeHDurM+wRO0Q==",
		"hexKey": "7b750ed842ec32ff3e4c6c5f3e8aaccc9a3bf2a1f02d214e7715d63215f2228c",
		"keyToEncrypt256": "babdae3d66cd85103a443471728541beccc46e6055567d5e65cf324e7741c120",
		"keyToEncrypt128": "70c6c9ac35b969cb3ac21f3379772fa3",
		"encryptedKey256": "Aeb69mOsT2QTcXSrR3P9u/hmuPhehC5/aS3WLTXwunww3sGL/6nXgezsvycNRVMGISBprMD1JDulO9Cxq9WLGtOPhQJ3h4WaOQpdwJPDxpEa",
		"encryptedKey128": "Aeb69mOsT2QTcXSrR3P9u/iQrgVjUV0dGUDOwZVaZc8zxF+LfmBwiZQXz21Z/eSN6Yxd8sh0XfXoYbTE9A5Otg0="
	},
	{
		"plainTextBase64": "lHDT43hjWymfxCKWqVzSHSOAbyukKtnsjwzuE1q/54VBz+NtAMe0LEieZ2lYyEDFSwxEO4ms0hPmzi9L7SRctxa4DNSKZRMkgPgeEykoPv6dnj2oMwFz",
		"ivBase64": "hMzPr6blLb+rDqxTk20dSA==",
		"cipherTextBase64": "AYTMz6+m5S2/qw6sU5NtHUiw/4h1cqsHxBjwKZPheGKN//eCcm/bQfbVXYaexafeQg+ykTCFgkpAoBCp6dvePqNH7YzuDqogPVAWxiobAyHJRpjMx56gTMHcZFxHfhTq/qJZXFF5GURBXgC5Xtz8BeVdBc7epYi65hGJm3SkC9RjVl93bCr/izRTb1edwnyW3g==",
		"hexKey": "51aca3ab21272e06491e417ec13c236126f8bde90b40b1ddd2367dea2b446f62",
		"keyToEncrypt256": "6f21774b146c4755a0c02a1afcad30de2fea8bc662d01eed30e9e396581e7957",
		"keyToEncrypt128": "2276b41d19d6ffb5484a59aa06a75039",
		"encryptedKey256": "AYTMz6+m5S2/qw6sU5NtHUjH2yZ0NNk3ou1ejlVe6eQZLQyji+Fi6L2EcVJ4QK4XsNs+lVI2wSBJYI6aVq1sVYo64HUi+ov5qc3nT2uvo5KM",
		"encryptedKey128": "AYTMz6+m5S2/qw6sU5NtHUhA9vqzktcA0zxG6sAPQDPoYdnm+hCxLBQODrRHtA7S9U6jxAJmFSzSfoGaubH2VJc="
	},
	{
		"plainTextBase64": "bzCbfPLZasd9erfZWhcMtm8eMNnvrDjBtaUGNssSkgEFFCT8Fv9TL30B36+iG7vxFB+MbnfRhE2iLh8g0X55rUC4ChlbYH/N4iTdzqf+um5K71uGQ/STyg==",
		"ivBase64": "e+s1KEv3/Qhl9Tx3mIMobw==",
		"cipherTextBase64": "AXvrNShL9/0IZfU8d5iDKG/RXmuB1+FWQ4vkAUCMuWWBqIo5BvGe5s/Ess92SlucZZaXRTmuJWVPIkjapfGwUU9H0z++STSxmcWnaf8umZfHHWUqkDXZ9q8GglHKIWzGXRQim5i60X0CD4+McEcGF3TdtLe0l4eB1eiYvQp7XekhTKtsqkS5EK3KDNT7f6cgrA==",
		"hexKey": "4cb82a557695e8cf7f092a3801bee7325ae700d3579c2d08dc96706d9226e3de",
		"keyToEncrypt256": "790aca75ccd033bcdeec4817342597cc94bd0e4c407b812e5119bf366d3f3350",
		"keyToEncrypt128": "515de7c36e834fbfed4fbba0c29bd291",
		"encryptedKey256": "AXvrNShL9/0IZfU8d5iDKG/sbaBM56l7QEML+qaZZBnSaIVbVAjdL+fF77a6lx4+xMXtfX2iQ/jX76PH7M4MoAddX2N7CBJCpsLJVoUjzKLB",
		"encryptedKey128": "AXvrNShL9/0IZfU8d5iDKG9NjXTBMyBwdlyTZNy0yG9ceKJZyLCje5Z+PvVAMaeMxfJjDGpd5LZMbxYEHhIUXFY="
	},
	{
		"plainTextBase64": "zxv+GdRfwP+RKyEuIEqz/Qw4S4333PO4MetVaVIwS5ptgmbMLgfZdEgP8HPnyWZ5f6dA0iKIjvrTMUALk/Gl6uABdw0WVllntn50KvpZicoQaiXTeMjKBmA=",
		"ivBase64": "T0JqsKacH/aaMkO0Sa0fog==",
		"cipherTextBase64": "AU9CarCmnB/2mjJDtEmtH6JwTrHzIPUO1LJ6dOQmMuofvgLbS8fV05FEVk4PAO7jpHVzOFZHffqbMM9roFBMcIHB9AATrWealhgzUwSzR7vMR8fpLHJCtXZC2U79HeLWK0GNftf0iiSfmcDKk9OIFC9gesFd8Vlz+95PqyLTUVS8o2M8PWcQAEk0ag60DMcV5A==",
		"hexKey": "9ba79cfe1252e6a9e4ef7d064f23b9ca3e92c69172458dc84efc41dde621ced7",
		"keyToEncrypt256": "00e492526875139068f9ffe09450acf56281c31dc7f64d40b73041ebfb80bce2",
		"keyToEncrypt128": "99c404f20f3dc46ec916560ffcad6708",
		"encryptedKey256": "AU9CarCmnB/2mjJDtEmtH6I820rA3acr6MPqQjr+IlugGmE0OrLKh5EGrK/M5Y5k+TsKylWr7HbCfVGVgyGCKxXRlxke1HVmQlvuAIpWGJ1i",
		"encryptedKey128": "AU9CarCmnB/2mjJDtEmtH6JnvnFTnq590HH6fk0RP3mawwG0RP2O1chTEk03qMA/WyTcbJrdWi5di3xS9Mglvt0="
	},
	{
		"plainTextBase64": "odFUp76OSwtYprFwGvAxjDIiB1LUkvtWv8YQ99cYmK8sz7PmUReA4kHrsuWtpZJ38ivivqbIjlQhpI6IJ3Ta+ld05K3i3pgzhzSCOtZSUPw0/KFGOMu0a4OG",
		"ivBase64": "efFISXpc4D34awpjOGl+qw==",
		"cipherTextBase64": "AXnxSEl6XOA9+GsKYzhpfqvwXwqBj93C8PthewmV7zDdSJkM2gybsxTsFVnIwGMoP2SnqkG9Y7UHTUFN7CzsNQB+zgr3GLR61co84V4hY6jkoVSikYwuxN82jJ/jPCcuT433KRg0tkD3jSvyUclAaKoRb3K/LK63af3Q343wXvJbH8YEXITsF1mqzkVS91kfKQ==",
		"hexKey": "975005a2f70dfec6d4240411f760a4f614abb3b05ffb5504878c9085694a9867",
		"keyToEncrypt256": "77e95006f3db36f4ea60f271b66ab699172ff98a3ab428563e5b7705f9647f0f",
		"keyToEncrypt128": "659f40e4313862516f927c42d28be9f5",
		"encryptedKey256": "AXnxSEl6XOA9+GsKYzhpfqtj57klUzvl/NAhX6V94eFtmme+HlAYKQhyZxHBj+AjT8kB9BZpSy44jc5rQmCGMB7zNmWQ7JU6/dNFgMhyMQqm",
		"encryptedKey128": "AXnxSEl6XOA9+GsKYzhpfquaO9TzXxkx0bbmehR1CQp1/QOw6VboB84mkwjPNzAvI08EXaXKkp+aIeZ3lYVvp+Q="
	},
	{
		"plainTextBase64": "WHNeAircBRD/3Le4P7xhF7Dm7FohnQwCYtSjXLmFxE82FJnmHJSB7cah+plVcgfHvOkyp8oyTartGqJww4drDKrT613AesRuLnzCw7wSjEM933vjhoj3pVi5vw==",
		"ivBase64": "koFT4N+wnflnF5YUgTOf/Q==",
		"cipherTextBase64": "AZKBU+DfsJ35ZxeWFIEzn/2mIELuKRm//lyuqGdxy1JB9T+/z05n8fn7ebpuVWx2Y/GiVwQ7mOzINhQxg9zBYuZgqmqo9K6wNk+jP85V4JnS3ojg0tq1ZfD37Tg0LXYca47s1rsUljTsxEM0dLBggyCBgidFZ9uAwz74oFsHobzR+L/GTTM+ty2n2Te4adRE9Q==",
		"hexKey": "259ce5fa8059a229416296cdf549724269826ae244e678fafcc43c99501e83cf",
		"keyToEncrypt256": "07e326415e3a51037209ab188a7f8b1da6ee565003ada465865d8d6ffcf9efd8",
		"keyToEncrypt128": "7b9c2f140d41679bd34f48299c49be2f",
		"encryptedKey256": "AZKBU+DfsJ35ZxeWFIEzn/0fMuy9DiU8/btmOSevw+X33X+vO5dExY8WCHoJGQUtqCVNT2MEfYPR7w+i2/TUJhvVUbYZaF6mpHBLsWzwWv+A",
		"encryptedKey128": "AZKBU+DfsJ35ZxeWFIEzn/0EdnjM6sv58mfOY2Xm7piQTAaj8PYbeG8c90nFleDUVMtJ0ydFiXLyyHPSqkWUFxs="
	},
	{
		"plainTextBase64": "b7z7n0owVx4cJsf+cy2GaCx38fjIMVsG8qtA3Gv6pcXHjQFdprcDseYhjl76xfcUKfIHnIameqWsiu+L+5XMb7GPgPGfXaQcZUz6GgVT75Nbn0CtkY25FdeZd3Q=",
		"ivBase64": "P4jAdkTx9bWxnXsVqN4+7g==",
		"cipherTextBase64": "AT+IwHZE8fW1sZ17FajePu52Eq6pkOZekRCLHby6M3vowp8VwlOIsa4OMXWZF1SK4sNSabe3j9MUh1X+rhi/JIdLjL1OsGLnn9V5eLe5Vqvs97u37Rzq85eA4eOooSn0hf5h3rEY0JtJcDDlb5gQMs0MaAFt2HZBg5vrJF84Wb+UmfTHrpc59Gf9C3PtVtBlIw==",
		"hexKey": "a68a3991d6f95c2129c150fc057446748a406a72e1db33c2a0c9fb0a2a298da5",
		"keyToEncrypt256": "026fe7b8daf3e43120d3484e7e2ff8cf830e9310f6880644b69b8349fb6e2afb",
		"keyToEncrypt128": "2f945b4350b982137c049cc3a1d02bc0",
		"encryptedKey256": "AT+IwHZE8fW1sZ17FajePu7DNq3rfB1632sYjPrH7qjX8lPU6h95Tfqpz0GEb5U1Gil+CVWhAtD3NB/I5ToXpAOXptfA4bKDlvRhWs6aVtPV",
		"encryptedKey128": "AT+IwHZE8fW1sZ17FajePu4u1dQNe2ak9DQ24mPndsLfu0Fc1GgjpkfWMnu4gYOl0hdsOaVrJSFh8DdF5KRw9NY="
	},
	{
		"plainTextBase64": "4MP9Wz5BjK+ocG1NSk/PurcYd17XxwkdEtkPpWTTq1ZvoBA3ojwb7H6hLWqjYieauQfK9I6gHLC73z0S5F8s4k63RjO5ZfQztorB0XcUbbzf0N5j/56VWHnqbKlJ",
		"ivBase64": "DximlTFNFECHYd0+vXE5Aw==",
		"cipherTextBase64": "AQ8YppUxTRRAh2HdPr1xOQO2b9KHVK3iuvhEWDtWSqUAJlhVrUJvlQccqWtj1cCoHtM/CS9G26CeF9BBlhcfoPFoNg2zxDq2BuSpRq7SwKlqlE5B6HaKShMRDzXpD3IZugA8dLxU9/oqLSKEZH9fMt2jyHydcQLRlgttWCnKxR2PL2A8BwRg47Nx5LQZeAfIdw==",
		"hexKey": "30c208f12db6677653ed2882b252dac250e2e81ab341117d7454b95a5b8a78c4",
		"keyToEncrypt256": "92b829bc61fe1085b6c8a80b2a8a0f3fd7dafddc99c52ce7176f650552b8b2ab",
		"keyToEncrypt128": "718f1d04b349643aced191961ab90f7b",
		"encryptedKey256": "AQ8YppUxTRRAh2HdPr1xOQM5i+wL/j+uboCRX3hflUosW8/xFuLH9ulWt1HbyQubWtijhc2eD/ECmyOGrfsDpxvmxILqa9ffD1Cdqx3M8ozX",
		"encryptedKey128": "AQ8YppUxTRRAh2HdPr1xOQPldNJZquR6/2Zc7sw4SmUinDobgjYU22E+56kQ4Ntg7GaUX6hlMc0J/bFCo6BAoTs="
	},
	{
		"plainTextBase64": "coOlNDP4stlm18OQZc5WnUqjxAMvJB0WCDfMZiH7qdl1hDPrQ3U21VvxPwwIt8jch9hMLnWWBGDSA175m53fb2jripLMLZdMz4ivNyXRrUBy6mT4VvW/cqgAFn3BqA==",
		"ivBase64": "Eaiikapu10SVc45i5rwqGQ==",
		"cipherTextBase64": "ARGoopGqbtdElXOOYua8KhkbfNSHG8jul7qyFcJfmE7HCPsBcY2Q1Umtdph4pNpPRBlzPKc2qDB4QPmKaXa7Ho+7TmLky3yqbGlomjENaIvGJWjggC6q2d77y2ZKg3kGSMOD3/v8hOdu66AlRghonDo/ZYal/NEdN+KcV9YH94qvYwV3WTsePYN/bP4wEKjvBw==",
		"hexKey": "45bbd65036cd37c517170709e0ce7b1f7245be9966595e9c87f9aa5c9fb9e08d",
		"keyToEncrypt256": "cd7ab276abb9db7430e1e69533a7d05c7d687190b9aaadf1aea4eb807bbecff8",
		"keyToEncrypt128": "6f4c57701be697da661b631e6a12cbce",
		"encryptedKey256": "ARGoopGqbtdElXOOYua8KhnBtNq1lYIl6rRc1piUbRgjW3dD3NCj73tMIJ322I60XvHLi9FrPOXeRJRQDnTmNHdtBNBTyUucJgusfDqakBX2",
		"encryptedKey128": "ARGoopGqbtdElXOOYua8KhkCsoE+vISpeoRYqYJm5EudfqY1l3ylywknhAfF86oTRG+kWYNmu8slhMV2BpHgYOc="
	},
	{
		"plainTextBase64": "ifCFOr8hVBhvMujpssTC3ES1lIVeKPVVRpBJTArA57N3CCnX5CovWciY45f62Pe4w+dlYtebMOK0nBpr8wQoZWol9Ggx2ugkErvBuQAh61rdUoa/+2Is5lk/99IMNYc=",
		"ivBase64": "yddoIR92vbAmwpyxNYU4RA==",
		"cipherTextBase64": "AcnXaCEfdr2wJsKcsTWFOEQkCZ3MsiWlIkHLnaoK7FYYqRUJlQ+iSjbOt0MFOCGvNoNucJ3tBafgSn3Qzeg1+mc6NRuSNiBJm2H3OeD59Ex4wwYBqsVkY1XmxDTGBZxGrivrHW924W1fCROvyWmre7B8rFD+FTmi1Nwi2AVqaNMPaN0/fHYCpQFjr959e3Zr9Q==",
		"hexKey": "5f4a67decfcb90d0ff18ea1af0197e1cf567bb9277e8ae19b804332fec612b42",
		"keyToEncrypt256": "eca15af22023901b072fcc277d1153f20ce818d661a93e2201435e540c44d839",
		"keyToEncrypt128": "b844fd7892fecb39bc108c6056ddccf1",
		"encryptedKey256": "AcnXaCEfdr2wJsKcsTWFOERCMlytCHSCQ+7OYWxDMnCMgJRw17ZvEl9ar7A5mb9CSzidCxgyERf/zbi6sjkIOpjGpBGOgdNCc7RnUorof0+a",
		"encryptedKey128": "AcnXaCEfdr2wJsKcsTWFOERPphS5rvw4ZWAJcieSkYuCtB5gzC836rVux0Y5xEB5ZR/OZlI0MBO4y83IvhBgZiI="
	},
	{
		"plainTextBase64": "jrKtL3dqP/HpUEk/yAElEQV8qE8mESYiDQdQTLkiWUKBFH5tTIzGjbWI7wt9NNWfvcVfjGVEyWvwpIRlKPJBe6PkpHYMsAD/3HQiNwBDYlICVJeGzqdLzdb6UgZDwYAG",
		"ivBase64": "Q0VX4jQVgq0LLQA86Up9/Q==",
		"cipherTextBase64": "AUNFV+I0FYKtCy0APOlKff1mGhLGpArVJhErNWD+ldFU/zO9Ur88CNDFLRulp2jnr6iI9lK020Wt68DuiWo3C1lNQhCn5PlXDg+u26VPEe5GE06QcmNIp7ZuQCSCtqpzZgbRr8vJtqAyD+/dVge6gB1ElSVgLTSJS3iIu/siHfUGFlXfQ4p35F0sl7c5qZarJkrPYXBEl/sp1NluEoUQNjk=",
		"hexKey": "1b98203c9be54cc74311ea73b35739a7561a0998eb1aaa86882223e41fd4eb88",
		"keyToEncrypt256": "3ea26904af23f2fbcc6d687a606e794b7af1ace4a0611d979e27d8c31a29bd1f",
		"keyToEncrypt128": "6dae7a3bf28240141222113610f26563",
		"encryptedKey256": "AUNFV+I0FYKtCy0APOlKff0Mkr5O9ckbUrI8bTTTvEg5GIhJyha1My4wmKv6+QlFTwM8VlB/Viw3Ozkdbs0CbbLpepb1GDURnH3Idq3XhhIe",
		"encryptedKey128": "AUNFV+I0FYKtCy0APOlKff2AoZ5twWn9wdxSem5NwGLKHsTciutzczcb9DYr1gqYz1O5goaM1qQNPxKxhl/qn1o="
	},
	{
		"plainTextBase64": "SGpUZBU3pPHccyjsWAFKZb/DLEO3gukEv8gjPdwvmJLFfygNoy/PJYe2ZGETZrDMiGUTEDXWg5OmEbd0PFhu/sdwmKOmAIliZLbhDT3C6bcLRvQ/Hig6zAys08w6I/316w==",
		"ivBase64": "9Hwfo9jMr9gws3BtRS3QhA==",
		"cipherTextBase64": "AfR8H6PYzK/YMLNwbUUt0IR0ZXgP/7i1Mj6UpIoR9P2Gea4bAWyJT150aLzCPollP4DaA/Xt0P3iOWZVYTEh53Oj3jpwZ5pGJJzNvpIDvCpReTfEgOzAigxJ2OiUE48jIwiREuoYrVdoeZV0Aa5Q0LsntzDHakNSkam5KG+orbqFHSk5aOoscbO/cCFlmzyDJbB4j2uNomEO0Q+BWF/em0s=",
		"hexKey": "0d838bd7e7fd1adbe41cc13b3a7abcfadbe556642046dc7add0de18e26d2b8ba",
		"keyToEncrypt256": "b797e1a0a79a7eeabef8181bffeb1ff084a631e8759bdfb9e59b5e49b1dabbe3",
		"keyToEncrypt128": "53e5400f20be2e48a948bf8c6d50d9cc",
		"encryptedKey256": "AfR8H6PYzK/YMLNwbUUt0IR4ftGHeZ8vYUDalCp30RJWsfGEEmWTB8ucqqhCHETn8L44L+y429spXbzJMZjx+y92T0/YewAaLvTk8sQfj5FC",
		"encryptedKey128": "AfR8H6PYzK/YMLNwbUUt0IRViWPenBX8byFZeCI32JHvKvhHNYI/XbqfbItu84fl5tNZq60iPia37XiSKl0xPtM="
	},
	{
		"plainTextBase64": "G7Sa506GmlzfGhyGPFJIyXEHMESJVSC4FiyrfuBJz5RSH81iKSldmoIDI7eFYZAKZyiR9N5iqcWCi5IaII6o/XtJ4uZsxIK2BloVWtH40BbpOea2Zpr03yZAM0/LtsGXcOc=",
		"ivBase64": "24T2X0q8A+kmYCCvidZXew==",
		"cipherTextBase64": "AduE9l9KvAPpJmAgr4nWV3s2XZ2YTHGmPUXsXGf9sWbC6UiGTXenvqquxI4EsOxkTjOECBYZHntdVPFN1Fx7CI3qU/219xjwbpnC1d2jnpT3HGgsZuxZjiGfB6DXwW7XuRAkqugt34YRifJI6tkiuRFwwO+0bDoB61+9xAlCNX2kB/YmqGje+3P5Ev+auLyEopHZSF3sW78MIyIIDAImtUM=",
		"hexKey": "8aaa486430eb9f2b56b0740fcb947acf02f666cfaef31af1f908e60397c43bb9",
		"keyToEncrypt256": "8a6dff82421c6af861537bf1c0e0dec2043dbd716c173c5f31f8594cf514c12d",
		"keyToEncrypt128": "00630683c6cd0e56091000726f2e7680",
		"encryptedKey256": "AduE9l9KvAPpJmAgr4nWV3sEUpwvE4egK0ZpKoJXvw0s4Weqx3yrmLpI9BDnMTR4nGNMnVe5iUVFSo+9fM3FTaJHHqq7hRfQhdmMp0bzWfyP",
		"encryptedKey128": "AduE9l9KvAPpJmAgr4nWV3v8QgQ7MXh2ZKauV3bt44jFckHgJQY7fIjQYG5oeBp6XLhb/mC7h7p2cJYlLbM4vZQ="
	},
	{
		"plainTextBase64": "7PFuHRMYWCh4rhL176jytE5JhYAU1NHFw6R5ChmXnLNS1OMwe56ZlNXSbgU6p/eNgOTPx+dPtqyQLAwiSdNhYfIKCy/whxLmczT3ul4cbUcasEdzp+h+ydIahBqk07TZhtsV",
		"ivBase64": "WqBJiejTRlJhY5VciaD4HA==",
		"cipherTextBase64": "AVqgSYno00ZSYWOVXImg+BwZV1Kue4F5WCtxgVcTwGyZJtW6AHBFQaEq1PWahwc9YvwOET4cybKVbim3uNPF31xllc1beP1tHXc7fM1KP7TGsD0/lqYHbZ8UqW0s2HDKjg9ACagUwDUzWj0NIX/2Ves3/JROrfTIkJDqSvBd2gy1xz5F3dL77QEjGhl8aIA4ZJJP3PrT9r4w9jLE8A1tmG0=",
		"hexKey": "f5ecb26c7460728863ea9cef8c5774299cf5f09a4cb3f5953bd849588629f275",
		"keyToEncrypt256": "f2c91e76268d111c32fe15f12a3a4180a8c445b657804715fd3fd392a9e332ce",
		"keyToEncrypt128": "d65577684efafbbca3593b27a75ceb67",
		"encryptedKey256": "AVqgSYno00ZSYWOVXImg+BxRuZMrP6hxUipwQyt87qcuyfUZa89/c/K65rxtLoOygAf+EBL0ycRKupk6Qy4eON79sznoURkfh8cDgXYRN+jo",
		"encryptedKey128": "AVqgSYno00ZSYWOVXImg+BxIRzMMCgsiKJBMCqq+xxnFGp7QyAij8ndPRF6C7m3Tgem3HxCkICZ5M6Cn3BY3lTc="
	}
];
var aes128Tests = [
	{
		"plainTextBase64": "",
		"ivBase64": "eYkwIRxd6H0gHKgxFhQ2Ww==",
		"cipherTextBase64": "eYkwIRxd6H0gHKgxFhQ2Wzqc4nGotJCI/MQ8RBzm2dw=",
		"hexKey": "b78bdea9c26d7956e5c0e93e089b8e23",
		"keyToEncrypt256": "6dc4db67340b27f69ae81fd3ab0b5709",
		"keyToEncrypt128": "5b404726040421c7aa7f98b54d28c68c",
		"encryptedKey256": "/uaYJ2ZkabyYdzJnSMqdhw==",
		"encryptedKey128": "o27A8IRR71E6IimXxslPNg=="
	},
	{
		"plainTextBase64": "xw==",
		"ivBase64": "866ni1ZETT7X6RJVLAnMUg==",
		"cipherTextBase64": "866ni1ZETT7X6RJVLAnMUrbLqERp0+cTqF8odB98Gtc=",
		"hexKey": "c5a6d584a2e4684e3b8c407c6cfbfad1",
		"keyToEncrypt256": "8ceeb0dcb294fab674aa35f557964450",
		"keyToEncrypt128": "0b941d3dc00f26c507c81426cc0cdda4",
		"encryptedKey256": "gKSencgTwvIUYERV+HVPjA==",
		"encryptedKey128": "U4HOnITq3jFTd3cB+hdmEQ=="
	},
	{
		"plainTextBase64": "I5Q=",
		"ivBase64": "DWP1SbOFVkO0q8sIogsT1A==",
		"cipherTextBase64": "DWP1SbOFVkO0q8sIogsT1C5+I0ILhNOsjEYOLmnEuZw=",
		"hexKey": "bb66c741542ef5b9d4d3d6969073fa21",
		"keyToEncrypt256": "7cbe5ffd2acdcb55dc4b93a20e83617f",
		"keyToEncrypt128": "b46bbf08afa9a4f1207c381a9a160870",
		"encryptedKey256": "y4ia68iYm8xtzo9E0YLYXQ==",
		"encryptedKey128": "BglxRzHii6QcHwnsi0jIDw=="
	},
	{
		"plainTextBase64": "Y9ZE",
		"ivBase64": "12IJmXAGSeYXZ/TZtsI91A==",
		"cipherTextBase64": "12IJmXAGSeYXZ/TZtsI91OxWaBffXpfEtHaLAFL/qIQ=",
		"hexKey": "6f4e21d3f5694d98b6ebacbac9a691db",
		"keyToEncrypt256": "a0ca246568ae2c8d70504918260f6896",
		"keyToEncrypt128": "49bef9a8807ddd30b289e24c5c86a1a8",
		"encryptedKey256": "kGokCXktNLXevtqsHiZ4oA==",
		"encryptedKey128": "6N9OvDVK5qpR8qwBqA4jhQ=="
	},
	{
		"plainTextBase64": "PqTXqQ==",
		"ivBase64": "vV9CSlRkCm08OyDoF54RXQ==",
		"cipherTextBase64": "vV9CSlRkCm08OyDoF54RXWSJ9/GkcgZprFsX+pS8hqc=",
		"hexKey": "426719b0b94744cdc22c7494b50d3118",
		"keyToEncrypt256": "139df9f63f785e39b124d996a59d084a",
		"keyToEncrypt128": "99541f3d60b5940436478c10a40d5a1e",
		"encryptedKey256": "2M3U2hc/qMOAlWxHds46Kg==",
		"encryptedKey128": "52u2fDU9fQDQLpDXiImPcw=="
	},
	{
		"plainTextBase64": "ZYNQHIo=",
		"ivBase64": "rwjKetmE9qu1lw9hQuN2Lw==",
		"cipherTextBase64": "rwjKetmE9qu1lw9hQuN2L60X6QHQgJ+Qx4x2YNTBFEw=",
		"hexKey": "68e1b7a1033e9c8b154f828ef52c4d91",
		"keyToEncrypt256": "f03a8d456edc3dc122b7d82a5574fc6c",
		"keyToEncrypt128": "69565a5cb350e8adcc9c43155e771be2",
		"encryptedKey256": "Q6c4OMetpzwADcvfVOfeUQ==",
		"encryptedKey128": "0x97OUWCjKGkunSODA4Qkg=="
	},
	{
		"plainTextBase64": "8TmzZJqZ",
		"ivBase64": "zd88Ar7gE/qSRuwSY9M9UQ==",
		"cipherTextBase64": "zd88Ar7gE/qSRuwSY9M9UbanGRr3BcnrXrcW6iagGN0=",
		"hexKey": "8b5c76b7a95dcb83d03795c3fc892edb",
		"keyToEncrypt256": "ffa0399c3be6a9914f0e3f6c57fb8b6d",
		"keyToEncrypt128": "d319a865d2dbe2370ffb73e169c5dea7",
		"encryptedKey256": "e10Ffuv2zjqEBxwiS7Rwcg==",
		"encryptedKey128": "l0Rfthn8QBQiYi8QqFtGuA=="
	},
	{
		"plainTextBase64": "xo0dBI0r/g==",
		"ivBase64": "ks8JxWn+K/lL4drh8LUbFg==",
		"cipherTextBase64": "ks8JxWn+K/lL4drh8LUbFlpbbTjHJHMdeCVcwv/bukw=",
		"hexKey": "28ab5ef1db09177b49ecbd6ae4063c00",
		"keyToEncrypt256": "35c3530c0a7211dbfb905e6b5eb4b6a6",
		"keyToEncrypt128": "e66599f7f906425fc8748f217d73766d",
		"encryptedKey256": "9DCZYBRcXapPnufKiI1r/g==",
		"encryptedKey128": "z1qPRweWTDrXc29IDjWeVA=="
	},
	{
		"plainTextBase64": "tkg5yZ4lb/A=",
		"ivBase64": "61KgKbf7iEfL5xkKqJVzgQ==",
		"cipherTextBase64": "61KgKbf7iEfL5xkKqJVzgfbuAIdhAR+4mjmgtb1iNzk=",
		"hexKey": "2a0911284ba1aa0f4741638e82f40a16",
		"keyToEncrypt256": "3e72fab44e51bf23a8c14f19f6edf94d",
		"keyToEncrypt128": "35514e9e0ff6c3c8a75daebe2627ef73",
		"encryptedKey256": "r6AK7WSi79MdKgTJgKGSgQ==",
		"encryptedKey128": "CsC+BLAq0s3j/rzGHDqsag=="
	},
	{
		"plainTextBase64": "FB9Hiuh/sSWd",
		"ivBase64": "9aLWXfl1XzNeVgZTWTZ8zg==",
		"cipherTextBase64": "9aLWXfl1XzNeVgZTWTZ8zpyloq/Ki95u/8qIoKZ05Aw=",
		"hexKey": "b728b7fd8508ed19ee9e60fc6b138919",
		"keyToEncrypt256": "5d404f41f565f4441fa56b154a1a5d22",
		"keyToEncrypt128": "1e009391badd1c4824efd17f5da14ccf",
		"encryptedKey256": "0f+MpSHEVrxENo+P5nxPag==",
		"encryptedKey128": "ThKNg8rfy798UE1ZDd7HWQ=="
	},
	{
		"plainTextBase64": "sAGUJKA+0PL5nw==",
		"ivBase64": "jjqTueLDv2qTxVsVH9bA1w==",
		"cipherTextBase64": "jjqTueLDv2qTxVsVH9bA14Y33Bw+5YR5PzQ8bhfpKR4=",
		"hexKey": "bbf2d0932b25b3b6857b9a394b515672",
		"keyToEncrypt256": "c8ea613669e37911418ffecec05776a5",
		"keyToEncrypt128": "b332c00a4f44b16d01c210f3ffc64a18",
		"encryptedKey256": "Ks4QIhUqXUM2U4qD1xNWHQ==",
		"encryptedKey128": "iuTClqhvCYoyZ3ODxKk4mg=="
	},
	{
		"plainTextBase64": "o5kbD0D71N9xHZ4=",
		"ivBase64": "3APYXOVq7cOKIdLEDJwuFg==",
		"cipherTextBase64": "3APYXOVq7cOKIdLEDJwuFkqjbv3BOdIXMV+VvUXq2Gk=",
		"hexKey": "2991524fc0af2c9f8aecc277148a6b86",
		"keyToEncrypt256": "ec630c2ea1777a3bd81ab4cd8f7efd16",
		"keyToEncrypt128": "b2a9a201ba178e85c8dd75e6714072d2",
		"encryptedKey256": "TWcQiIfBeCstk8TTq3l64A==",
		"encryptedKey128": "q1vbZUaL7dBSWSpLCYWlRA=="
	},
	{
		"plainTextBase64": "VZYVMsBSEB2xPIEv",
		"ivBase64": "PoJQ+p8kptvQNX/okLOheQ==",
		"cipherTextBase64": "PoJQ+p8kptvQNX/okLOheakk7EyPVUjNk1AXGG436fI=",
		"hexKey": "a49634322facfb51125098b6a305f7fa",
		"keyToEncrypt256": "0bccaca6f26ccddbfecf7b18c6fa0b2d",
		"keyToEncrypt128": "bcc568358feb2106fb707b5c94808085",
		"encryptedKey256": "fuuyeUEtcTGiTlOCnLSsug==",
		"encryptedKey128": "Yfdh/E44QfRPnVyZ8bK2rw=="
	},
	{
		"plainTextBase64": "ksd2f2wO6eayDCvvLA==",
		"ivBase64": "rFC8MJ+DlOGIwWOZwLr7Bg==",
		"cipherTextBase64": "rFC8MJ+DlOGIwWOZwLr7BryTWzDmbVxlmv6APKV9UpM=",
		"hexKey": "483737197809c10a0489fe482386fd0b",
		"keyToEncrypt256": "0441e1f4d33664a4f384ab1e87426038",
		"keyToEncrypt128": "9d78c1af78613e9d8fa1af64bece746f",
		"encryptedKey256": "YDmTNHAJdFKBGr/xAU+eUg==",
		"encryptedKey128": "43am33KXwV5TnuBwpJfuyg=="
	},
	{
		"plainTextBase64": "axJQqwBoL/iZF7Wg9R4=",
		"ivBase64": "vmDAhz7cJboyqw/RFFgkew==",
		"cipherTextBase64": "vmDAhz7cJboyqw/RFFgkeyoMqBe7qL7ci4VptBCVvuo=",
		"hexKey": "20c6ef4b2882da6975334edfcb0ea26b",
		"keyToEncrypt256": "401b486cfb81f13465c93addf33bd299",
		"keyToEncrypt128": "be2947011247c6bce7717f2cf65661bc",
		"encryptedKey256": "jUJBwKTONQSMAtO3Vo6ATw==",
		"encryptedKey128": "+9U+kDV33lWwsdk9655rNg=="
	},
	{
		"plainTextBase64": "kJAvx2YoNcxtZ3r8wQBP",
		"ivBase64": "buyEDYbbhWtaAWyJ9X0GwQ==",
		"cipherTextBase64": "buyEDYbbhWtaAWyJ9X0GwU1zyddEnfOvH2sbYmZ/DfA=",
		"hexKey": "9aeb77854c985a0b32c4f5e9b4267872",
		"keyToEncrypt256": "75889e0a4eef942c9f8ba4bae40483b8",
		"keyToEncrypt128": "5f27af4cbf0a950248a580d60fd26a82",
		"encryptedKey256": "hpuHsCroD4UvvunSj+kx2A==",
		"encryptedKey128": "aentp3WniX2Wbyu1X/rD9w=="
	},
	{
		"plainTextBase64": "2VK7CgLORHuqJKfTdOEWrw==",
		"ivBase64": "gkFBkoIpb2kj8WrhUQVtUQ==",
		"cipherTextBase64": "gkFBkoIpb2kj8WrhUQVtUQvzlpVMhCkZXBsOcyTBBrDUAGa7RaZSMuqOiwFDStDV",
		"hexKey": "46a86da4fcb11d1420b5be7c0a7e36a9",
		"keyToEncrypt256": "508161f968b2f95841480bca02bd7a74",
		"keyToEncrypt128": "e93c3c73147a1bf85d745715b7003f98",
		"encryptedKey256": "nqJ2KtOuXGsdSlOOMizYWw==",
		"encryptedKey128": "TOYR1WAIDlor49rQRbA8qw=="
	},
	{
		"plainTextBase64": "3fUroRIV2Sd7YG3BfpNmfQE=",
		"ivBase64": "C2v51iukYoWGhJxMtf3+Uw==",
		"cipherTextBase64": "C2v51iukYoWGhJxMtf3+UzC6hrTwCSdfNgwXJqtLZtPZHiOGATp7AeexiJ6UqNrv",
		"hexKey": "ff2d27a7aaf9496aa6b2e1912b9cf570",
		"keyToEncrypt256": "a36b430dcdf172b8a4fcac047bc04775",
		"keyToEncrypt128": "97b580e260eb87460d7aa998de40e0e4",
		"encryptedKey256": "kAeslBLS+yNZkTzMUlX12A==",
		"encryptedKey128": "d2PBce2qtsjdQDKPJWBTLA=="
	},
	{
		"plainTextBase64": "lNcb7PHwopFetiglIXU8qvOD",
		"ivBase64": "wdLf4/W5vfaLPr0EBZyxUA==",
		"cipherTextBase64": "wdLf4/W5vfaLPr0EBZyxULI6JOUsrYhvmZE+FodBJqHRkDxMKaO6kBryAV8FmePL",
		"hexKey": "78cabcaebdcb07d502178af495904473",
		"keyToEncrypt256": "1d1e3238f7557ade27624ff14a754c9c",
		"keyToEncrypt128": "a2c803b37ab1049ca19bc74b407cbca2",
		"encryptedKey256": "1pLlUI9dAVhAr7kJeY2sjw==",
		"encryptedKey128": "AIXUP9VpSKBLnr0hrCdMtA=="
	},
	{
		"plainTextBase64": "dXG55kw6MQ+nQ4h4G/GiGDPF0A==",
		"ivBase64": "HyzH2LmIbX7DFtJMKKSMkg==",
		"cipherTextBase64": "HyzH2LmIbX7DFtJMKKSMkk8+5Xdt04gLw5NMR/Qqk4KjGfP0gE/2y9l3gmgk2x4Y",
		"hexKey": "398b0dbddca6db9e8949ec8daba35d22",
		"keyToEncrypt256": "1321b4130927020eaf9bfb60b16ab391",
		"keyToEncrypt128": "dc21b3d8fc77081081c4cc145feca17f",
		"encryptedKey256": "/y2fTJw8P3t+yjJ564M8ZA==",
		"encryptedKey128": "EAHpmzWoByO2PW8aHoKZMw=="
	},
	{
		"plainTextBase64": "utcSgh8ykItiT0B5eQk7jvjC/+k=",
		"ivBase64": "gAiElOj9/iNkm7WpiKTbuw==",
		"cipherTextBase64": "gAiElOj9/iNkm7WpiKTbu2URsK5gnLy3FEeZhb/Z9/Bzdr4/kt7+l/0iMZtjrc7X",
		"hexKey": "774ecadc19b32a79869ea841f3708b8d",
		"keyToEncrypt256": "ecd3bd7bf5f7ae4623387c96fa83fc16",
		"keyToEncrypt128": "e946d587bbff5bbebc412520b07e6276",
		"encryptedKey256": "+B16e2bJ6ZQGBluZ1SxYfA==",
		"encryptedKey128": "M3o4aAUjGHtYlogWHCNu/Q=="
	},
	{
		"plainTextBase64": "7tmGisq42etj3U0dyUZrYG4zkI1D",
		"ivBase64": "W+X3Pgp8ES6dMCgyaGOByA==",
		"cipherTextBase64": "W+X3Pgp8ES6dMCgyaGOByD481p8mRGMLmHpPvV1zEN5BiSY757Vo9EuMpSztZUfa",
		"hexKey": "35e75fc97ca9f5cd0d3c5a51f3b90a69",
		"keyToEncrypt256": "a8b74473d488c6a4104b174c5c929f62",
		"keyToEncrypt128": "da6d97098ce15321052824c57c055155",
		"encryptedKey256": "CadCaAqq2IPHIPBtE8Ps+A==",
		"encryptedKey128": "aWbgpRalQ4fWAskwMT7iBQ=="
	},
	{
		"plainTextBase64": "SdG5wbwq1J9eIk7J+xQNgcP/dAc4Tw==",
		"ivBase64": "c9uRWwO7T2vx6pShU+u46w==",
		"cipherTextBase64": "c9uRWwO7T2vx6pShU+u46wZZL6iWuAzF4EsY6tfiEbvfSxkht23Mg7IxiWjE3EVE",
		"hexKey": "faf5e0324bd46829c2a350cdbe0665e5",
		"keyToEncrypt256": "37afbc70854e804c97ee23d93b9a5a20",
		"keyToEncrypt128": "6f4f66e07453ca6b93fe17ae39135c69",
		"encryptedKey256": "G4pwHg4go3Hoz1jOoffGLA==",
		"encryptedKey128": "zcL4vChfarLdCen6mO/LPA=="
	},
	{
		"plainTextBase64": "hgROaKbmR8Lq7jBVZBWqt1ANNcCtvvs=",
		"ivBase64": "5C+ufIZU9XdSGTS0Eap1Lg==",
		"cipherTextBase64": "5C+ufIZU9XdSGTS0Eap1LoRMVwq5LfKU4TobnHJ/SfR6wF+gsTyaDq/nAB2sbqJa",
		"hexKey": "bea8817afc9b0ab71dfcfca6e98ba0bc",
		"keyToEncrypt256": "3309dd341b1afe0fe0bc2dab607b78c1",
		"keyToEncrypt128": "59109f76a5932ce31cff86041c3c032e",
		"encryptedKey256": "9/jnmpc7y8R3XXOIc08BMQ==",
		"encryptedKey128": "uoGvGo8hKBTmBiar2OioQQ=="
	},
	{
		"plainTextBase64": "vCsdqjA5Dd4WW+wq4cbj0g3nl+waJ7St",
		"ivBase64": "608rmvusXC8oAj2ww8fFzw==",
		"cipherTextBase64": "608rmvusXC8oAj2ww8fFzzgRz/5+v2xMoNcePkeiSHzODzM1bI3rJx6K+PDQ5N9u",
		"hexKey": "b12109d1e3231a43fc426fd86822595c",
		"keyToEncrypt256": "5c05ba13c18fe60fc7429d0ca59dd8d4",
		"keyToEncrypt128": "303191f9ce273230fa57106872bf7c03",
		"encryptedKey256": "ZPZlg1ACkOME4RYVmuhB1g==",
		"encryptedKey128": "Z4kU3w6y215SESKWnCFjtA=="
	},
	{
		"plainTextBase64": "rxccYF7q1J/w9JAsc8jR+ytyvdZ+J4cvbA==",
		"ivBase64": "d/PCP8+6CrAmLcW3jgU+DA==",
		"cipherTextBase64": "d/PCP8+6CrAmLcW3jgU+DOlk5zLktyZiUFG4Nw/8/Wjv89zfKYnwH/ALoggHW7oT",
		"hexKey": "844c78244d764b49e392edeb68157e21",
		"keyToEncrypt256": "3a866862b01efe8c9518d66cd5510ff5",
		"keyToEncrypt128": "a3b376b79706a1ceb97636fb63773360",
		"encryptedKey256": "mJNynlqFcAg9kRTpTWIydw==",
		"encryptedKey128": "/l8/QPnpYGCqwfz9KEIrEg=="
	},
	{
		"plainTextBase64": "w/y7m2cOoBOJgwvHyb5XtwGD9Psc2LdNTMw=",
		"ivBase64": "8dHXVp+IxeVfVvwzo4eb9A==",
		"cipherTextBase64": "8dHXVp+IxeVfVvwzo4eb9KL7e/sUVtpT5ysYf+/qXNu3XoVymoxKnMqn4EJf1OR5",
		"hexKey": "83c511b4e34e711526dfe1432070e918",
		"keyToEncrypt256": "96d08d1ba1d96d835fe1dc43dbdc0289",
		"keyToEncrypt128": "f6e6d7e4583c55051f14b0eff22f8243",
		"encryptedKey256": "n1HDKSP3BlRBVAsHl6wl2g==",
		"encryptedKey128": "5XdI3qSZeHXBza3GOiHX+g=="
	},
	{
		"plainTextBase64": "PbmOmab6adbrjz/C2y+fWbc3fORK1E/ocVi8",
		"ivBase64": "bDt1eDPYBe+FuOEskiEi3w==",
		"cipherTextBase64": "bDt1eDPYBe+FuOEskiEi3xYpk5CPGc6SZYthaW0BKDmdqIyL1Imis3MYb3feNx5o",
		"hexKey": "d800e60dfc110cad269e48e2ed3180b6",
		"keyToEncrypt256": "453857310973bfd7593c7b009db0988e",
		"keyToEncrypt128": "90cfba6adbfb7868dd83bb3beb6904b0",
		"encryptedKey256": "r4KSN4+VUo0Q/EGXzhiKWA==",
		"encryptedKey128": "FmzRmzGpiNhUPOfG0fJhGQ=="
	},
	{
		"plainTextBase64": "6M2qdyScJMuxlDxohdM+uNL49WjWx7Ntp6svSg==",
		"ivBase64": "dfJM36SY2O7PEAiJk2cvMw==",
		"cipherTextBase64": "dfJM36SY2O7PEAiJk2cvM01CrJu4Eq1W39xefd3wTuk0gc0yH1/jzn5/N5QwLi3n",
		"hexKey": "ff39c6baf66857ce125fb1aa72992d4c",
		"keyToEncrypt256": "70bd3a2f962505a83dddae6038eb432c",
		"keyToEncrypt128": "900e97f56d679e001e3ebdcb65bde2c3",
		"encryptedKey256": "EleS2SovTngWO/H76ABh/Q==",
		"encryptedKey128": "PB2zVNh1QC71cz0nGT8M/w=="
	},
	{
		"plainTextBase64": "y+7rFVtxXjVlLOOonOOrIwIID0kWz5jRSkWxT+k=",
		"ivBase64": "6c+cUI7CwYxpZjWM8KKcKw==",
		"cipherTextBase64": "6c+cUI7CwYxpZjWM8KKcKxvxtCu21LmRiloVrSfiyO1VWnWucsXyPsXm1hP9L4oa",
		"hexKey": "21d3106a027c610725a0954f29910063",
		"keyToEncrypt256": "c5cfaf320946570d4a320b35bdc69dea",
		"keyToEncrypt128": "4420c130f9701c9c5db85d2b1eb4f905",
		"encryptedKey256": "W415M+sDYX6Y0BZDh8Rysg==",
		"encryptedKey128": "90nH2lkzNCVd/3A/eVJs8Q=="
	},
	{
		"plainTextBase64": "RYMpW+uYF7dyKV/iCncRA7Z8RwnYXpP4t2OnY+38",
		"ivBase64": "sp3Waa6S7mCIZ0VGzHnnzA==",
		"cipherTextBase64": "sp3Waa6S7mCIZ0VGzHnnzAJVvgZRQh/uGAMbHGs1WJovwSSedCTiSbp06N2mZRbL",
		"hexKey": "0a97e37e53b41898d0f06b583c77fa99",
		"keyToEncrypt256": "eb8d0a71bcde4e9fcd06ae8c379f70f6",
		"keyToEncrypt128": "c4931cab4ac6965724dc86acb3ff5840",
		"encryptedKey256": "YkLLCgjlyH45kMvpyMpasA==",
		"encryptedKey128": "PyM1JnrjuvFDvPP4gj5NEQ=="
	},
	{
		"plainTextBase64": "Y9NPQ349s7gRhpFriP9iu4NQWa2AhwSMW2YK2N2jcQ==",
		"ivBase64": "cG7PGTJ1iQxU/Rt2FXNRyA==",
		"cipherTextBase64": "cG7PGTJ1iQxU/Rt2FXNRyLrZ6iu1ch6gEzFwBH1Wrkya1jA5HIv+11HVnwlWRX5E",
		"hexKey": "dda72b18227c0b966df4c14c0b62e3f9",
		"keyToEncrypt256": "1ebbbc21827c298c91c61cdf5c1dc424",
		"keyToEncrypt128": "eddaa6152eae5003fbd01e099887c0c9",
		"encryptedKey256": "32/6X1wMtO4CE+/ynXp5TQ==",
		"encryptedKey128": "pFzAbpkqbcQr3tZlsQosxw=="
	},
	{
		"plainTextBase64": "0Q3ad8sKFThJzmctXWPR0Se31HRQbU+zVMcI3wgQJwc=",
		"ivBase64": "WGTzakX6lvgZQmE3VmNmmQ==",
		"cipherTextBase64": "WGTzakX6lvgZQmE3VmNmmYqLc36fzPCVfc/AalpnjDrZWVgHV3fo2Tv2DB+eNhkLjITZYudNZM7trLgkbSzKWg==",
		"hexKey": "e32310672a7570ef8e654461b04fa430",
		"keyToEncrypt256": "620effd54b0625c5f96866f57bffee10",
		"keyToEncrypt128": "acd618b07150fcb75a02722baf9e7133",
		"encryptedKey256": "c6ID7MD6LLHeaprTicNlZQ==",
		"encryptedKey128": "nqtpHyiMIx1JXMuR0iECEA=="
	},
	{
		"plainTextBase64": "RJgFOsXWWyZl8GoajWj6FVSQMHkS0v+uWd27EixKni3i",
		"ivBase64": "MJKnZ3bNnPPUHCOg9A3Qyg==",
		"cipherTextBase64": "MJKnZ3bNnPPUHCOg9A3Qyow8PeH5zpHNn6Slprkn1RLF9WkOMbmnSunPdmZ/c+Ob4cCzJxPlKMRG5HL1X6ESGA==",
		"hexKey": "bf8d169302f5e45157bc598b24290eb5",
		"keyToEncrypt256": "fef77205741836f0cb4fd4cd09967343",
		"keyToEncrypt128": "a17e1d60ebeede2a3f33edf32409d9ae",
		"encryptedKey256": "16GuVbywISM/uO4MtRrclA==",
		"encryptedKey128": "y6HDdz9Aw3xHNoSrIULPcA=="
	},
	{
		"plainTextBase64": "R3ds04JjQPCNpMeYtsjvvUT4VAYQNdn+O0B8ggiOsZSgMQ==",
		"ivBase64": "9d7Qq+4Xl4/V86Zjc9TA8g==",
		"cipherTextBase64": "9d7Qq+4Xl4/V86Zjc9TA8nN5oLCpTUgXnaAzK2a7xWZ0a/4kCUHlPxQ4nFUatwU/SpCCi3xRK21vvsIo0V+bQA==",
		"hexKey": "095c7a8c3b5dbb3c617fdb6aded7ff4b",
		"keyToEncrypt256": "36ac69644c7bff57c5365a2c7e5ce7b0",
		"keyToEncrypt128": "237c239128bf3bbcbaf1a92f5f47f135",
		"encryptedKey256": "s9vuWS3G5rdrHCtOk2q3qw==",
		"encryptedKey128": "Jow0q31NS73GSbRE0sYLbA=="
	},
	{
		"plainTextBase64": "Dn7Zr/iODASaIjeTTsHNnF6z1fvochc6eWR9yv7B+hhbXKw=",
		"ivBase64": "Xpo8N9U5THc5mGLvXaW4sg==",
		"cipherTextBase64": "Xpo8N9U5THc5mGLvXaW4sjFnj1QgHD+FM6wS6xX4EFNQwYy2KwfSoAPy+0SqcLLL4wbc7a/U1pdB2YqwNNAoVQ==",
		"hexKey": "b21a39012981123f28f8bafc3720d4f3",
		"keyToEncrypt256": "88106e017fe54284faaec3faacebe1bb",
		"keyToEncrypt128": "72d1d2fee968e41e1c50d80940579b5c",
		"encryptedKey256": "O74iZJnFOtImyvrfBsJB0w==",
		"encryptedKey128": "6RR46i2b2b8tOqHwH4x4Kw=="
	},
	{
		"plainTextBase64": "e0TPQWuVEwdduOWQi4laFXNYB3hdp6YVN56uRUIae9+OuKnF",
		"ivBase64": "m+Wr/06YM0av0jcWD0mvVw==",
		"cipherTextBase64": "m+Wr/06YM0av0jcWD0mvV/kULSx4Pf7Wboz++MRej2hqPpn7nCOgQ9BDB1gYaf7eP3zv9lYii/VHN8Yu2UY1Ag==",
		"hexKey": "3accf0a512a2e030943332ed0d6630c3",
		"keyToEncrypt256": "4958c5290b032898583d9436d2413152",
		"keyToEncrypt128": "3a98414d056ea34071df2e8ea6431e50",
		"encryptedKey256": "+/qDYXYxZROeT8PobJiNuQ==",
		"encryptedKey128": "zcAWN/ESqssZgju3lr7a/Q=="
	},
	{
		"plainTextBase64": "ATAQF63vWU2c1oI7y6zBtezkLD/JBiMbcS8Mv0XfJZvNgTQQsg==",
		"ivBase64": "UwHemADq51koSWU5iTUg5w==",
		"cipherTextBase64": "UwHemADq51koSWU5iTUg58gOvaQTok7jCKCn5n3ChB91EDL9NikCRQs+cuJK1tV8J7x7ki4lRZQHfSMgV5kXdg==",
		"hexKey": "3fdfde20b6b896cd8c68a0516d42c4b6",
		"keyToEncrypt256": "9526a21336f8921001c7d6b9b69b8531",
		"keyToEncrypt128": "f9cb0dc907b0fe00f8cdb06b73b49105",
		"encryptedKey256": "5KtHvcQfQAWvbyiEuLfm9w==",
		"encryptedKey128": "PdNxye53ljGgiANoFnm+Cg=="
	},
	{
		"plainTextBase64": "3rZJtf7AnWTdKy9nkslovp9NCuVoTpnk0lQDiZYPeZu8BL2uasY=",
		"ivBase64": "O659wPWQ3irc1ttCwg7mHA==",
		"cipherTextBase64": "O659wPWQ3irc1ttCwg7mHH/NbEe/xdRl/uWBtmY8NB+65ARo6lRmXvm3gibWOUDt/MB8I22oiXYAouZPc48YhQ==",
		"hexKey": "4beb1ede72b083619da454264c0ac57c",
		"keyToEncrypt256": "6d704e9962262a66b1ef3df768b1085f",
		"keyToEncrypt128": "6ccb393330faf1424396c754394cfa72",
		"encryptedKey256": "QbcYKJQ4LCsCjYLMYIJFkA==",
		"encryptedKey128": "Pgr9wTtzdXfr/5KhS0wbAA=="
	},
	{
		"plainTextBase64": "M0caZ1CHE1VHIQzeHVqRt40iEn+duRbYGTx5+n95W6mIzruDxHKO",
		"ivBase64": "CvK3eIWcb0DH39jMh0V7wA==",
		"cipherTextBase64": "CvK3eIWcb0DH39jMh0V7wBwyAty/6wPcW6bptL7GLLUt/2CiLtKxDM+lOi9405QJEYa4aviBZzaAXZbrqi7pLw==",
		"hexKey": "cde1d4694572b0ff818d81fc7b0300d9",
		"keyToEncrypt256": "2631b5a7911e0b50304bd09816b29ea2",
		"keyToEncrypt128": "12c42ca51724bee7480f7426e94031a6",
		"encryptedKey256": "MXnK4h81lm6WImzYOCj9Yw==",
		"encryptedKey128": "ff5MvrDawv9qwSaiNalh2w=="
	},
	{
		"plainTextBase64": "CWCDsXOxUcFenvmdmsMDJPGf5WJ/8IlkbfCWewf3M+obxP6AMXiY7Q==",
		"ivBase64": "f8Ixlp6TB0OqlkXoL41bwg==",
		"cipherTextBase64": "f8Ixlp6TB0OqlkXoL41bwh6KaiiUcaemH2wvFHil5bE5RbfOKL20Bh0tzEBJBSZIKcOtlq9ODAjxEAvZQcdBow==",
		"hexKey": "2884c4fe587f0f75fd413de947a96552",
		"keyToEncrypt256": "9549fa189f38eab2eeb26b193ab0d704",
		"keyToEncrypt128": "3c1246d634aeeac221beec070d7c54d3",
		"encryptedKey256": "3lKTd23qTJEbxxDUA68r8w==",
		"encryptedKey128": "RefWHBDlOLXX7KNfRu8vWg=="
	},
	{
		"plainTextBase64": "pg+zSvgiw3+ZgogOcyl2EM/9q/PK0W0Tkxpy/a3LDLcp7TtfO5zj3+s=",
		"ivBase64": "rEBJh2I0b+AhfD2YUzXRug==",
		"cipherTextBase64": "rEBJh2I0b+AhfD2YUzXRuoKJ+GuwQ2NS4iQpNhkefwBjsJoG/GSBGBlBs0NZDFqo6mSFUjveB66+zohxFZBH7Q==",
		"hexKey": "78c323c5859d9a2c2d937228dbf25f48",
		"keyToEncrypt256": "9a3f7734b8bd5f22484dd371e73a28fa",
		"keyToEncrypt128": "7f8d6e2e9dbc837dc0ce8fc6ac9e83ad",
		"encryptedKey256": "6HbwIA3nhqh+jRWzvgdxMA==",
		"encryptedKey128": "OFdkRjhXz0/neTh+d8obBg=="
	},
	{
		"plainTextBase64": "KBGCp2Xm2U8y900HtVR4beH/iAozpH3f7aVqhmDvmBdLCJsor7JYevbw",
		"ivBase64": "hVLR/C338dCGKxsetLy2rw==",
		"cipherTextBase64": "hVLR/C338dCGKxsetLy2r4ZQLGkBkxiLVVYH+SRNlE9+vygjUrdWhugBKDwe+JrtiuGrq9GuVVm9DSJmnkhGvA==",
		"hexKey": "891fb5681222b2aab2b8591084698647",
		"keyToEncrypt256": "486cf6a7afeda4f7d457ec9d547b22e3",
		"keyToEncrypt128": "b99c1280ab7101d8c3d19f6669ad90a7",
		"encryptedKey256": "QwY0gjXyuXjz3f87ERcs3w==",
		"encryptedKey128": "Kd6AydQ808dxrGXhDBNilQ=="
	},
	{
		"plainTextBase64": "P6m25Mns88rlXji1q455BFn0SG5625httbzOSrJ2zIdF4htU/jhN+AVRaw==",
		"ivBase64": "crDj3maia0BNe1Mrsi6nZg==",
		"cipherTextBase64": "crDj3maia0BNe1Mrsi6nZpTO6sqP+q9y/bR/oCILH7BVMsYQF9Ig/+jqhCQQr5ouWIHUOfey2EJ8lO3LVgoGkA==",
		"hexKey": "7187d17982d5adf5f3e29d87986f9a1e",
		"keyToEncrypt256": "b19ba2c1c23236fb3314603d54fc4774",
		"keyToEncrypt128": "7460644c1793cdf7a758f07117c54431",
		"encryptedKey256": "mIkQgnTSn9xw/WUWplb86w==",
		"encryptedKey128": "rZ919JrD5HdSY5cv7KxEmg=="
	},
	{
		"plainTextBase64": "d01tB3TSQnd18kGa1pepcWJJycVVF/sXzY84EOoNA7PN2RSuZsvJL4Bmkto=",
		"ivBase64": "3XfxgIWM4Qoctt35t2GJ4Q==",
		"cipherTextBase64": "3XfxgIWM4Qoctt35t2GJ4e+lrulpQAmltfJiijOT1Hb/2ggQn3RKGJLS1Er5acoKwu8iRnoN7vYAXtLWEe+hRQ==",
		"hexKey": "ae94aabf866196a808eac154ea18b447",
		"keyToEncrypt256": "bb0835e316d82629f253efc34b841d6e",
		"keyToEncrypt128": "72b47708e2118146c6ecbc2840417759",
		"encryptedKey256": "ZeXPl/SUd5mPDU3Y3jjbGQ==",
		"encryptedKey128": "bXvSRQ2Fh24OHtGTnaot7Q=="
	},
	{
		"plainTextBase64": "0peyms6waDELYGfHZPusx8CeLdtLSKb6NWWs9Yram0eAA1tOstX7mx65FmxM",
		"ivBase64": "1YKWQp2OzoiDcZmjRfMNIQ==",
		"cipherTextBase64": "1YKWQp2OzoiDcZmjRfMNIY9que1GocO9RiYhVLYn6S8dLBS4mm4wgeDd7W9Lp+VgYqe+no/1udOYsRfM07A3bg==",
		"hexKey": "0a80818222b9d3ec7ecff0f32b97a456",
		"keyToEncrypt256": "13d7914e988807c5f1c6ae69cfcccbb3",
		"keyToEncrypt128": "34c8e3dbc61b5d3728951205dd86943e",
		"encryptedKey256": "Y7+9WNP5DWsk64jqINivPA==",
		"encryptedKey128": "bDsqzpmLc3Tmyh6dz8EScQ=="
	},
	{
		"plainTextBase64": "hIbqEl6BWnxcN/3t/0roXNAb03LMbnzjd272t+EF7E4xhqP0wk9kaDt5qWCV9g==",
		"ivBase64": "6pej/n083Q6UczG7tC5gcQ==",
		"cipherTextBase64": "6pej/n083Q6UczG7tC5gcfzPJR4nc4+oCkr1H+Qu0d+xMgHE9q/1uEtpKGjIqR2jQN+8mJOer8IQhH5GAcTt+A==",
		"hexKey": "92dcdc08e943089f3a7628c3fb3c9cac",
		"keyToEncrypt256": "bd9b40bae35b89fc154dc391fda534b2",
		"keyToEncrypt128": "8d04354f810a74430d90d5231cb85d9d",
		"encryptedKey256": "GCo5OfRfGhNF/CVQwQssJA==",
		"encryptedKey128": "j8jbIORba/P+C8bBnkbOiQ=="
	},
	{
		"plainTextBase64": "YCtkiF/MbLoujtO1FeEzFId/DRPSLxNnM1s3p2BtUd/IarIB3p0NF/Ieldxd92E=",
		"ivBase64": "mCeHup7t5i5sGwQt3KB0WA==",
		"cipherTextBase64": "mCeHup7t5i5sGwQt3KB0WO1tCbfkmjc5JWojFLlsyHoJQc6b2U8LO19P5JS9S17522/mEwSYefWRso3N2a2Pmw==",
		"hexKey": "5db764526b1e3b1a381d36905b569bd3",
		"keyToEncrypt256": "a8a0d2a81eefbff18dee508ca9b92ffd",
		"keyToEncrypt128": "4968057e77feb625654df766bcde28f3",
		"encryptedKey256": "mi2XvazJqatJpDOispuMIQ==",
		"encryptedKey128": "ir/lPDSOrioTjKpjL6cdhg=="
	},
	{
		"plainTextBase64": "E9o1qlZSw7c4lezirsmWaEy94XGQs4T1qIllC0y9UWoaGEDgk3yjvTi4Pl2Y5MYy",
		"ivBase64": "Cz3ellVWEugYezl1BfusdQ==",
		"cipherTextBase64": "Cz3ellVWEugYezl1BfusdSbA9zs041NZEleTD2Emv8YofKbvO+1c7mdGJgMrNCA7LwHKMLC1CCi/QKMxxtL6x5i3DArU5D5KbrybYvCUFQs=",
		"hexKey": "bfd1d1074d6bef083d703b05a3517537",
		"keyToEncrypt256": "7f8e479a70a7aadc761644b4d72b4d7f",
		"keyToEncrypt128": "ec2a935c438ce74c31642d2e2a66c96a",
		"encryptedKey256": "kwOAYQMWEatkUWo/5u5Ewg==",
		"encryptedKey128": "My0DUhZy5cojhuGQ+JN5QQ=="
	},
	{
		"plainTextBase64": "CmYG1pxciSta0QCNWN401BiGX8nH67SegTSQ6jVhZ4EdF422qlY9YK7x+jkJmAIiow==",
		"ivBase64": "5/b1jFKLqJzH8i27koVDfA==",
		"cipherTextBase64": "5/b1jFKLqJzH8i27koVDfLRv9PH5d6cioeeEBhMWPfweIg4nT4ymYnkReh+rxnkM9PsYSDr+R/xF7ZNrGsIcEkrvD1JOrJvI0/uilSKYq/I=",
		"hexKey": "34f514a4c0b1b541d1c11d49f3583792",
		"keyToEncrypt256": "86ed18bc37300e881ee126ff3a9dbf11",
		"keyToEncrypt128": "60fbe2bb3f2dcf051524037fa3f68adc",
		"encryptedKey256": "srAae/Us20TH3BhsNY1EXQ==",
		"encryptedKey128": "K4v/UwRqZ3y8PyK1XIKiAg=="
	},
	{
		"plainTextBase64": "OvYIfYQLTrZc+LsHMaw4tCVF4VQ7Ghiyx7raJauijhETAUfrtG18JMZyAWlbICheCSo=",
		"ivBase64": "ZaRs8M+T1pOxX40533DCfQ==",
		"cipherTextBase64": "ZaRs8M+T1pOxX40533DCfXtfp0CFRKQdqPM6CkX1DeEUhOWYl9QURpLwO8NP6Ni2OkrIiwpJ9CHq6Q/wtiB8M8gl3iRpds7Y06nIkOmdX8Y=",
		"hexKey": "a5fb9726538b0f3ae369dabda5909591",
		"keyToEncrypt256": "0ef8f2c0a086ae3ce8dd9d14986019d2",
		"keyToEncrypt128": "6ed880a780bf764203fa0b8003da844a",
		"encryptedKey256": "p4iGN9OuU0+VRU4+kKfQKQ==",
		"encryptedKey128": "kaBNRvtnGMuKqMEliDfEJw=="
	},
	{
		"plainTextBase64": "x4MuHRNKlCIbeas1A8P6UvRN+gkgJRYkPQARcyF2ur5W63up8rDo+vlnPQFSvFkBRH2n",
		"ivBase64": "0PqbM/hsrvbv8unarpzKDw==",
		"cipherTextBase64": "0PqbM/hsrvbv8unarpzKD0J8ym6G+pKW6UDHRDJ943h/AwXz4CGZm0x2FyrB7DcplC7MnHuOynFlnoDs2wQjy8MutkWgGwhqlp0c/Y+cvCM=",
		"hexKey": "72beb658a4fe0c3ccefb3c5fd9eda0f8",
		"keyToEncrypt256": "67b6d5a01baf12942838df0760c3262b",
		"keyToEncrypt128": "fa3c6625551240d9075e0b2a05c61da5",
		"encryptedKey256": "CBx/874rb5ZZCsZf08jiOA==",
		"encryptedKey128": "Eq4Nn2TqDU+OwMvkVDvVbw=="
	},
	{
		"plainTextBase64": "fUHEEt/UXASMUdlHnB3EeqMjNM2TcayEn6ly3CJ10OUN/Znl7tnr+dPa2rVSpsW30AdENA==",
		"ivBase64": "bVbw/jhQlFO0PpL1xvtFTA==",
		"cipherTextBase64": "bVbw/jhQlFO0PpL1xvtFTPPypA5ruMlSkl9sN+sc6ulWw2PQUKyCzVXtx+CWczJt8DP++lCu0nzWo/iXNQkAZeYUYBT4Jb1aeCf7jLPvZc0=",
		"hexKey": "1d568fe4d97972aaee11e6551a522ffc",
		"keyToEncrypt256": "9e83cf144dcbbecfeef488ea1ec7a1bc",
		"keyToEncrypt128": "dc5ee5e1e8689a7db1ad2ac55ade2105",
		"encryptedKey256": "eW3zbGo3s1s18TfVWRDi/g==",
		"encryptedKey128": "ZWQ3nWuBEUZy1wdWjmPCGg=="
	},
	{
		"plainTextBase64": "sXJu2WlR3mvASS77JNLzshYhHJvBp3AfdB1fVHRcp6OrDYPALaLTZxDObc8XJzVb3pPOkbA=",
		"ivBase64": "H2ANzO47tOoujeWEu6xaHQ==",
		"cipherTextBase64": "H2ANzO47tOoujeWEu6xaHVLKbjN7Q+lLxg7PYLKZdqnAcIbfPN6V2cl0o+qhYMjxNxTO1Nv82yqbC8g79ks24kP+mdIpsKnsj5TgycEtKrc=",
		"hexKey": "c2d534fa04d3654a76cfc88799df9c4d",
		"keyToEncrypt256": "a15b7b8159f41b7ec5b014b238aeaa25",
		"keyToEncrypt128": "7f4708a208cec11bd564e02a345ff68c",
		"encryptedKey256": "bJ13ByxAwE0QnZ8S9lYkyQ==",
		"encryptedKey128": "nwumOUgQqFCC3x6yQQG40A=="
	},
	{
		"plainTextBase64": "iqwL9C8zry7hBR7Y4f0ZEzyLJedV6q4aEH2TFLj60+WQZwy5JdJCG0WmVzPU9ZfTf36qcLpo",
		"ivBase64": "bqIQu5Tm/bK9PVipJmdB2A==",
		"cipherTextBase64": "bqIQu5Tm/bK9PVipJmdB2FyLEXBHEL1YNQlEeWL2Oiiw+bQC/oNKJSuZjX0KB+E5SF818TpxEhnVTNJPtlqYNrnBzhJbBeQnpQa5mIwNdsY=",
		"hexKey": "982dfa354e127ff0db9f42b38393b158",
		"keyToEncrypt256": "1d7d137aa7e685ff8b2ce33497050c92",
		"keyToEncrypt128": "07b3dfcc4661879aaf66e21bb9aa1028",
		"encryptedKey256": "TkMcDXMtYD5mdtLgEeXmvA==",
		"encryptedKey128": "Y7qRX17Hhxai9gTdJ9zwpA=="
	},
	{
		"plainTextBase64": "TYdefiWYiZo75Zo5m3FKs84vSngXP/uScx5DcKwm4CIMV9+ugluF11/6Nqk1rYtyuNguSusvzQ==",
		"ivBase64": "dcfK4LFxVHhl4GX2nu1rHA==",
		"cipherTextBase64": "dcfK4LFxVHhl4GX2nu1rHKgFGfSuW7ONb9gnNpyj1A9LlzTQF811Zp9MX4TMGq3CiUs3HrDNGf6L9dmmzAMgb9XaDMthMbMF+9XISZ6p7D8=",
		"hexKey": "a06aad5d11955414095b79a70fbd5003",
		"keyToEncrypt256": "d04b9632bbb54003d411a360e38029dc",
		"keyToEncrypt128": "0186d8a4fa89b97c272739e358c0776a",
		"encryptedKey256": "WpRvrYPkIDvq8f++sQMilA==",
		"encryptedKey128": "wVOKWZX5Mm/wbhvsj3tNjQ=="
	},
	{
		"plainTextBase64": "WGBO1MbHBXMuguHsm5Cr+nGdCbqgtjVUQrPXVlgSTZauwVYjGP0D5xI22i6asbiaaXeflBf4nbA=",
		"ivBase64": "aCmCX+WKwort9ypT8JchPA==",
		"cipherTextBase64": "aCmCX+WKwort9ypT8JchPDAhu5frlqC7zAZPAzj0Vhcq4cmG5+iSzPzKQDqGa9e26Zg8ZbPj//VqgTPGulOn3zVp9T0l0Pl9ATFVu+1LwPM=",
		"hexKey": "b24ee2daaefb41d7f9a55ddba02edd54",
		"keyToEncrypt256": "9f03d2756b2c1dd5b6198bdd4f720ee6",
		"keyToEncrypt128": "9997b239c5b96cdf575a924fc2436665",
		"encryptedKey256": "f0OLd9mjZ5/oBzY0nyxtcw==",
		"encryptedKey128": "gCZfwfWaZaMo3Vm27NZRpA=="
	},
	{
		"plainTextBase64": "sKFkMwWnniOrG+9GAXXIuZ6uk6qfFFlL7CQ66xKqGq+auIht4A/NtR3LAys1cqHwCqt0A2dAEDWA",
		"ivBase64": "AaXlDWsYrsDyGb27WJaWgA==",
		"cipherTextBase64": "AaXlDWsYrsDyGb27WJaWgDyFC9iMKeY8Z4vNIdWrlfGTMi0ouYgmqJC03HjT9tGbR6VaZY1tJOSD7YTVAnxkmhb3NSU8qdPVzn+mluGi4Dk=",
		"hexKey": "78bab43df6c0bcb9d68db29085fa1c16",
		"keyToEncrypt256": "86b73b0260c41567e8b822328a59041f",
		"keyToEncrypt128": "5aaa9850a5aded6965afc2480ade0af9",
		"encryptedKey256": "RCG68JylOFcCstmr65gJNg==",
		"encryptedKey128": "QB8ZSE0CS9IkOnV86qu41g=="
	},
	{
		"plainTextBase64": "ZN91yHOe/2fovEfqpEow2fliktCStt1MscEK095YFWiV4oofRynRhHzJTRGjtYw+zalG60mEGLbNjw==",
		"ivBase64": "zPvNbhi/QdoU93z1Wj/sjw==",
		"cipherTextBase64": "zPvNbhi/QdoU93z1Wj/sj+4EbIuIWBo1bwGf4CIyB2pI0OIjRIUQZK680dvhnhtpLr8UrYyd7j+9r4E+/CE1J3Ok/x/kN47RcpfUBkeEHdo=",
		"hexKey": "c3ee2acbeb1e0751e145b76b71a90186",
		"keyToEncrypt256": "ef9aee77191a345a709bf4a14c24e234",
		"keyToEncrypt128": "055df587c638413ed480ccb5afea0a96",
		"encryptedKey256": "T4N1ZfbWNwJBmmvB5fPpDQ==",
		"encryptedKey128": "PdphLR79Hc+202VebW0gdQ=="
	},
	{
		"plainTextBase64": "fpLHIshUBfeEVgtf+R0B5jn4VYeEBeR2kmqfkMbOlgsc/FCiJUmLgFH9aWRKF2gSG/l/74lKAdP/Eyw=",
		"ivBase64": "+5MXLMNhR7fhdMbt0dmMxg==",
		"cipherTextBase64": "+5MXLMNhR7fhdMbt0dmMxlmKJmwH3z49FkCb7mo41f7GxYL77bqZv2iz/IVD31xGGPfmqBZpHv1CSXyL7GJGndwiHdk8uvSuuihHNayAiIA=",
		"hexKey": "e256d8a070d8a00d076ba7df52d63763",
		"keyToEncrypt256": "ea56fda6adae7003d2f44038d91c55d7",
		"keyToEncrypt128": "f12a707f838b0da19122f9becfb9a579",
		"encryptedKey256": "SVkvRAwLU2HpvwDO4J/mjg==",
		"encryptedKey128": "bxF0XqeqdGoEVBc1SLlRIw=="
	},
	{
		"plainTextBase64": "XhVocPLiOdlSAclWHFAk9Ow8Tm65wGILA+/TBeZI3lOo/AEXVZmikzqLQwZyZc9+k8kHOo1g/vYeXp8j",
		"ivBase64": "+QrF+Fi84oERiAxJ48D0Cw==",
		"cipherTextBase64": "+QrF+Fi84oERiAxJ48D0C9TKHZTOENCJbU5Z/wv2b3YG7FvEQyzkncgSMxunusn1MgpXpq3S0D5HRyreAuKMMpeMAsnAuoEGkJ+4weBSre8=",
		"hexKey": "ce10109f69515e097ad27f344ecd04ba",
		"keyToEncrypt256": "0013c7e96a2747ac9d8959899a8c7a5a",
		"keyToEncrypt128": "9127dbe62013ad55d52326095abcf079",
		"encryptedKey256": "g4NdaHwbtzlw2V5AKi2HMQ==",
		"encryptedKey128": "KXAMvlvDBH3fRCeJeqa7iw=="
	},
	{
		"plainTextBase64": "3pCHvtNAW1uQn2KSc9O4/ENVp7p1jbRJqIDTf4qErFAh42EcqK5UK4/rWxbxoKfxuFvtEQMo6IvmHSWLZw==",
		"ivBase64": "wmFPmg5bKL+0/BqJvYZUtA==",
		"cipherTextBase64": "wmFPmg5bKL+0/BqJvYZUtCngXm+GJI76UTMHKhSJowigJORzM+IHudXuj8i5ilsLNHh5ijO6Rzg/Otk/MYSuB5Gh1mXh1qBPOYFAqzqI7/8=",
		"hexKey": "ed6a9f46df847973d681d439edf2dd21",
		"keyToEncrypt256": "f6db85237f288ca0c8e0c3b6f41c6a78",
		"keyToEncrypt128": "db61529fb31bd697a28eb3b9d0f6db19",
		"encryptedKey256": "yBQ+IqUOYwPomOokUm+Isg==",
		"encryptedKey128": "qBlXxElTK2ftPJUKVYnWpg=="
	},
	{
		"plainTextBase64": "BQT9vONoHEWfANRJWUYaiX43yO0DrMYZ3JHMiBO5W86pCAcPypOpWbgKiH8xEx41DaOnwkEtTlVxeFcPyFg=",
		"ivBase64": "VKfOri9eSLjdxakBuUPjPQ==",
		"cipherTextBase64": "VKfOri9eSLjdxakBuUPjPYwCbv4kHhze9I4ZqjK5ARWeTnITSUv1p6gaQ5OFkCOsjVSkIsvzJDHmFB5PEoeAVJa6meiY6eqMdINAAaqGUeo=",
		"hexKey": "6ee39cd35add079000d1e5cbf128d1a2",
		"keyToEncrypt256": "d910ee42aad3fbcd7b8a4614d679f04d",
		"keyToEncrypt128": "5f52801d60a062197debe01743ba194e",
		"encryptedKey256": "yyTkE2kmuOE2cKeTi3anTg==",
		"encryptedKey128": "PxwGn/JoE5xLwvEEvDrAig=="
	},
	{
		"plainTextBase64": "cTzO9u6+nWdol+pEJLjvkjKZlOFF6sil66xR9NhZEY7BMhe3RtylyHNtsYovhU1PR9DRj4E1piuNQ+vphgVc",
		"ivBase64": "de8e7bjoVL23KUEEOmyfLQ==",
		"cipherTextBase64": "de8e7bjoVL23KUEEOmyfLSS/ude8K2m1+cxJ5mTnBnyFNXbh4j+zw6iOg8/hGmHlzjreJGzKDg0Fdg/5ixT4DhBm0CH0b8mj3tQdZrV38lo=",
		"hexKey": "f1d2a75ed91e5b4e5de20be3607d39c8",
		"keyToEncrypt256": "754a73da09d718341ae1dafdadb2e9fe",
		"keyToEncrypt128": "1e2e0179a375229161f95e23e5519934",
		"encryptedKey256": "PSP26T4I/AB/kQme0uZNwg==",
		"encryptedKey128": "9HQoVVEaM42IUz+aaRDBOQ=="
	},
	{
		"plainTextBase64": "sBkhX+lxXSgMVPqW1iT3hri2awcdOCQY6emCUAF/Cxcd04zmJ4vBYU5DRO6h82bmfBC5TjZYs6OP2WsaJXWfXA==",
		"ivBase64": "QE1/ACSNnyksi37S9fptEQ==",
		"cipherTextBase64": "QE1/ACSNnyksi37S9fptEdZ3dt90wzESOs/2ZJNZsFDnvpwwlqKfmYmz3/cwXPEQJ0MWisBvkCTt5rka740E5D3x19k3yXIAyFuYtG2cvQ1om6qg9FojX09+Xf2yA5dp",
		"hexKey": "c22ee914cdfac26ba495a34f33fa7d7d",
		"keyToEncrypt256": "b2682185932ce2320920b64e8578f6fb",
		"keyToEncrypt128": "01d7cc5490b00b9aa9edd694b3c51c3f",
		"encryptedKey256": "wrmV+5KHavLOGLZ7U0fckQ==",
		"encryptedKey128": "16H8XpaX35m7q3olai00Bg=="
	},
	{
		"plainTextBase64": "vrp0xJenA7f+o7HadMRojDApUSlqMmhwBPcygzqKS9LMPPWVrzvIOLe8uYrM/hR1MWTUTxoSouBZeRLNGXtR3c8=",
		"ivBase64": "vIj5oFkY7GVijbS7uKyYCw==",
		"cipherTextBase64": "vIj5oFkY7GVijbS7uKyYC/ydWH5JVEUTzNt37e3n2bA6JteIe7Lg6irjSUaCLnAIwkxfkKqg+pRT8Gsxz/OkUsHQHH3woplU8iVkif17u+LW5mao+Pf6vkXFzSUSwhAm",
		"hexKey": "9cf9c16ed736c0687ac8b78e0b174541",
		"keyToEncrypt256": "14247c687ca906c8451cfc90be50d8bc",
		"keyToEncrypt128": "0eee0be41c6c37a22394c2144a4fefca",
		"encryptedKey256": "ENMZgYNYd4vN0jqeRrOxNQ==",
		"encryptedKey128": "RjskOEGpDEntgDi4Z+Cj0A=="
	},
	{
		"plainTextBase64": "1DZxQ9vPT0253bkujX3Fwz72vaEPKWf6TWLfyQBGAuO2iRLRK5m+IePicYJgdEt6HsILviT4oCN37yX8c/SPOLzU",
		"ivBase64": "L4r0tW6AbhAPcgFP5ZOOlA==",
		"cipherTextBase64": "L4r0tW6AbhAPcgFP5ZOOlAaxbDv9cHjGqTIicJzshfqOSPi+JKqGbQVg+SPscjEkrSW745rLghYIijqKx850c/Dg+JaW1F384fT0zey2b4Hvzzn4kzRmV/T7AHACFwQp",
		"hexKey": "b00880142ad8aae33ee003ee7f20da22",
		"keyToEncrypt256": "823ea09336c8d68116c278e60d4afbba",
		"keyToEncrypt128": "2f3f58c976ba61cd20dab36844039759",
		"encryptedKey256": "e3vQSPffleZ4dtutSDkThw==",
		"encryptedKey128": "8BL4S9RYw4ahPURLmp+k7Q=="
	},
	{
		"plainTextBase64": "TQYQX9O3HkIIsDKCUNNdIPdAgk6rkamPssSydIfWkza/iyo75H+k4mV3jimYIJSgN+8j/cRxJvWdlkWRxJ0l7bwRgw==",
		"ivBase64": "N2oNCVp3XA7CxXOKBsUADQ==",
		"cipherTextBase64": "N2oNCVp3XA7CxXOKBsUADbw1VlIk6QoTIU+lwEy11TAl84yBip+TPw/pWKBTTPvR4DuhTidlR+Yx6bpwsrjLRUnW+sx2f8eP44DU0ls0d6m3nXBbNjA/D9bMd5/w11NW",
		"hexKey": "a1e3f369eb4b91cb1dd2ff9a2828b3b6",
		"keyToEncrypt256": "e933af192cd8e2d33ad27de307a96f8e",
		"keyToEncrypt128": "a94de2d76209ef5215217fbd4fa9b1b7",
		"encryptedKey256": "0hUo3afCrcTO7nMDfFT0EQ==",
		"encryptedKey128": "eTDMCW7VAfenTnmwHt1gfQ=="
	},
	{
		"plainTextBase64": "mQbyBQ16ihJhr6Iqeoq1nvUVl9jQpXnAYWaKRn5/l4fkBNxepwrp8lhy8R3XBQtBGNjwsBcPimomdzejGp/5NnSY9Nk=",
		"ivBase64": "CnXpIKlBkxu89SuBI9qQgQ==",
		"cipherTextBase64": "CnXpIKlBkxu89SuBI9qQgbIrkNektvRhr8HQMQpVlPYlZWiUpfcW8Jkycz5Ec/F614iqfraBsh4texeN3ubwMJqhdiE95SXGVRH+OGlJ/RXLFGlqpTPsPBokWRmQUARR",
		"hexKey": "7fb83b41b4d04d3a1f67c638ed7ee2ce",
		"keyToEncrypt256": "d741cffcce122e7b2a9ea081b98b863a",
		"keyToEncrypt128": "da068902ccf3d809da2c5dac15f4bc35",
		"encryptedKey256": "9/o6m0L7rcxnQW2E3JaSMQ==",
		"encryptedKey128": "YxBPMDnuy1zC0+LO3EsQjw=="
	},
	{
		"plainTextBase64": "oqR7wW/TmxJaqqFcQKcvP6bHsSBv05/rQ7q2mr3lqme56OdudeQHnOEwSN6WGcWWEcCdeXFUHjq3Z/55vCs7wGEGsZEu",
		"ivBase64": "M14OYE97djBrbJv+YW9F2w==",
		"cipherTextBase64": "M14OYE97djBrbJv+YW9F28dhTjLDrg5sOclx14fkZ6aTqPQl3x/kjF2V7J+NvK75afFUBj8z8BxlE0Vqa2XdaPAK9qn9bZLb+EDsaKkQD1dNaVpATKBzk7TA2DbzfTo2",
		"hexKey": "cb4a4886eb2697ad9d7678ede74f2c13",
		"keyToEncrypt256": "e0e51f54a539754dc234d0c87e76c04e",
		"keyToEncrypt128": "52dac0faf0895fee8c27242862a94c01",
		"encryptedKey256": "0H1mgd392uxEgP19IVr2OA==",
		"encryptedKey128": "9dNKT7UWHcOlK4TEnrkm4g=="
	},
	{
		"plainTextBase64": "HpnPjhogJBmZEmC9lf4qqDa3y49n+UuoxASaAXqU5wbrEQYPA/4NcH3TPzNn/6u0w5LeqxRTb9xbEidrExobGm4v8h8xGA==",
		"ivBase64": "vn7loRZ+05Dl8RgcRjWqIw==",
		"cipherTextBase64": "vn7loRZ+05Dl8RgcRjWqI4B1yCLEp2tw5jIGlkPk6AThKDd0DkEur8CN6c6F5Ap+1W0ZtA7Kk48l11rMGOWmOCCWtEhIULpUmZ4zaP9EBSvVQGhwhSaNccmZtEIeve8l",
		"hexKey": "5eeb3b5e5c3b7b4d0aaf96ab88535680",
		"keyToEncrypt256": "14ebd992cdb955d0c410c3ca892929de",
		"keyToEncrypt128": "b7ba98aec01dcac014a299341d018e50",
		"encryptedKey256": "mKV1tJQDzvMqOBRRabfPJA==",
		"encryptedKey128": "wL7nHcuQCb+Wj/VlBYTTug=="
	},
	{
		"plainTextBase64": "U/lf3Ga5AP8cezfB6lgTCJ0MYPnWji94ym6ImOdTY+4ZFLkBeyYzj2eB7UADMkFomqnI30dvO6bFcSbzaBrjd8a1tFKs+nk=",
		"ivBase64": "ZiSyzR9aFo1HFBdtOw1MMw==",
		"cipherTextBase64": "ZiSyzR9aFo1HFBdtOw1MM0/7XnHEuNb9BtY63YTkrRuWknN3/XU7D6d799KcBMPKXt+WZxrW75Fwi0AupWRAu07pEnb/vvzaoByRkWNI+Yn3Cy3s04iRaC9RgOOuu6Dt",
		"hexKey": "144b0c045c46874c7e32ed4637558683",
		"keyToEncrypt256": "e97a43a745cf3fbd1a928216394c09af",
		"keyToEncrypt128": "a819212974a01459fa6d6ce703ba0fcf",
		"encryptedKey256": "q2Vvvjbw+lvtz8dnv/1czw==",
		"encryptedKey128": "79fL3E/U/tN2SEK6rzkRYA=="
	},
	{
		"plainTextBase64": "qKWMwzuLTeloL5r81Y9fd7+WtcNN8gjUiRMvTIQQs9UoxX/FjB6eLCtdJBxlr2/xkkj1Nb8IWsaDYkSeq0Jl84xrehOAupy7",
		"ivBase64": "DDwy6krNkkXoRNsJYjDHRA==",
		"cipherTextBase64": "DDwy6krNkkXoRNsJYjDHRBO2jzz9p5Vm+Qq5LN75Bz03d3hUlmeqrgdC3ARUxpM59c56ZlW6Ayn8GfTFputK7hlbpjbNJej25H2NQXr0+ix1Gv8z2p4OZU2cJcQ/7rVa",
		"hexKey": "5dddf8ff341a5762f9c30f12df2631bc",
		"keyToEncrypt256": "53e901e5b4e0a1da247e67b49a6908a3",
		"keyToEncrypt128": "49b9cba69c0c0814185548c72250f48f",
		"encryptedKey256": "VQxc//MDd99a9utPoUeung==",
		"encryptedKey128": "gGqez8eOmMALYZ6sRSP8eg=="
	},
	{
		"plainTextBase64": "yc4ZbGdSK8mHZU6zTIC7gzlTcocnPY+H6Bk1DtgxKL5bi0gWD8mJsa8/vR4DEk4fHpeDeNh5MPAkkqO6C9K3CkfzKBpHSiisJQ==",
		"ivBase64": "864rDQYG4NEsbQGalOp1ow==",
		"cipherTextBase64": "864rDQYG4NEsbQGalOp1o4y773+q4SwfeDv2k2n8E1SA59cwYCvNfQDl4p2njMtpUENBSrOb9ShfOM0DEKS8YzoylDzr2DrIIvEVOcmpjjENZRW/AFaP7s61wFpmHxYN",
		"hexKey": "5f40c549be29abeb30769a54b63c66ae",
		"keyToEncrypt256": "6dfd8990f2cf210e7b5818f5d61536a9",
		"keyToEncrypt128": "5f746368f2903ccea30f27c27efeeb1b",
		"encryptedKey256": "U3y29lLyo2W5Xo1k7BCtsQ==",
		"encryptedKey128": "s0n7a2kx1rA6WBAGcQ4/bA=="
	},
	{
		"plainTextBase64": "cuCHZR/xTKwGW5KSRR8Vdn3OacxUso/G6syNOWe/D6io9P0EwcPmEO8E+8tno4kYSfOlxgciDLVSCw0kz9a/caARj2UV7sYVs/4=",
		"ivBase64": "EEZJQQiVUMidzNHOgN26Cw==",
		"cipherTextBase64": "EEZJQQiVUMidzNHOgN26C83NgzaJxftmvWg+CsJVrtHpAA1SVcJTqSZeY8ZJQiPliQ0//bleTX2KMlzqpU8eDWlSL8UJYDWVMss2u1WIJ41r2bs7U2W3SaZWnbKPVhe6",
		"hexKey": "caebab2d02328c66e9a84e0b64976545",
		"keyToEncrypt256": "d7f448d35cdf3aaa125a6773c0778f28",
		"keyToEncrypt128": "b074a5749ff7b9058ccedd82086476ec",
		"encryptedKey256": "ZUzi2vqGvtSM8sQgySe24Q==",
		"encryptedKey128": "i5VxTftvaXiJRXnwxz6qjg=="
	},
	{
		"plainTextBase64": "d5L0ROVJVOVVoTqR95a98n1zRr22T26plyfKqdBMks5Ev3LncYNMpihI7DW25WFy9wfnwr4GBUhCX+yBRnnEyypkLR/89tVLPGW4",
		"ivBase64": "iaYobCcsMvvx/f/UithomQ==",
		"cipherTextBase64": "iaYobCcsMvvx/f/Uithomd+C9g533zh+ETcUUoFkzGAHZVDvfjS+ku3RuI7fFCsIYa+FSjpDbnBrfMi+nU6u6xsnScehn/36+2wwPbgtJX02WEhw4KqJl/uvJre1rEHZ",
		"hexKey": "90c0ce4a4433729831e167d52f9e5b18",
		"keyToEncrypt256": "c71de7423b28eda6f9aa279f0f66dd5c",
		"keyToEncrypt128": "12496dd0075aeef9f5e3b99b989dab6b",
		"encryptedKey256": "k8Lr7t5rRQcYgr5xPJlVDA==",
		"encryptedKey128": "tOcZqxm/AbwnWft4X6KCtg=="
	},
	{
		"plainTextBase64": "VAqZTEoL0ZqlduH0kVg87d5VPM0t3YHZyQNCbxMHJ/7qw/PbPTWd1FKPk3F6Ru/2yur5DlqN9mvcC3GVznxDUo6th2t5kiuS1EtOmg==",
		"ivBase64": "Hz7wwp30N7Hy+kbSA0M1oA==",
		"cipherTextBase64": "Hz7wwp30N7Hy+kbSA0M1oPTXcdQ1Sy+Qcpun5uHwdVNgpkEb5sKMtmTk2YOzvcU1EApAmIwRPTeJ/j2XdsTqPD9XGT+K6uxdlgrVAHrGeG69jyS/qCT10g/q6IHM753L",
		"hexKey": "48fd3c399fc2ab5a0f30096793f2e3d7",
		"keyToEncrypt256": "b4e6f1043a55ead2cb7b963e11c94cf9",
		"keyToEncrypt128": "a69f8045d254f21dc79aa44caf775cd8",
		"encryptedKey256": "fiz2V0iVTjqqKhOnu5W0Jg==",
		"encryptedKey128": "1u5sR3ZPwux7qkyq381NLw=="
	},
	{
		"plainTextBase64": "0WPDcvW8Bpx1xbc4g0c0JnN5OCiev4dPS919lo1EHvbxe4jZAKETVi59OU52c1kJBGrPv52RSwMHpWrjq2WCQ8eWMr39HtU1y3gqEog=",
		"ivBase64": "yYl91PEzZNlEtUVAXPTs8g==",
		"cipherTextBase64": "yYl91PEzZNlEtUVAXPTs8mGqtACL05qpVsCSsXVDV4koQVrvM/ebQ89crIPeFm2muRuDJDCmWQLX4bIHhYpqlZb1+nOleeu26ZNqGT9+Lobj5tNw+9m/bv2AbCKIMRNq",
		"hexKey": "5c705e14aeba347b1914e1a929d51398",
		"keyToEncrypt256": "2a6559f89323b3873052f1f608514c6d",
		"keyToEncrypt128": "126a4f1fe2c1bada6531f1cee610f767",
		"encryptedKey256": "bagxDLV9Oetj8kVVPRn3EQ==",
		"encryptedKey128": "EJRSzZiebevNgdWnuOJo5A=="
	},
	{
		"plainTextBase64": "+YkOqjTeT+AIH6I8xHN53yxLbxD/uhU7M/Dgf9hfH4VOPxURXktzcEZLmh8bz1FWLLDj05FDzElxIofu9wpbRZQGcQx1TNc03VycPIXG",
		"ivBase64": "ia+6dd2+S+EacPlBfqPooQ==",
		"cipherTextBase64": "ia+6dd2+S+EacPlBfqPooRZWSO4YAi0tQsngrSrv72FVwxIr7HKuY/vaPxuF0jC3OAqGzmol9kQFt0/KrSTSsFeC5qx9OX1KuYhKOPtAGRvH5l7AIarUc4sO5gPo2BUk",
		"hexKey": "0c9eec6310003fb549f84e885bf8ac34",
		"keyToEncrypt256": "bce88332de4fa42ee093b06afe16b5a2",
		"keyToEncrypt128": "0f72e035f2951296099f95d5b069b791",
		"encryptedKey256": "QfTTZv608x+ef4yooS7kHQ==",
		"encryptedKey128": "lf6Z8i8FB63MEXXpUvg1LQ=="
	},
	{
		"plainTextBase64": "mefPqgciOnmLPUar7wODKlwBee+ObbntJVI9sdlgFToylFCSAxrENsY7kPrM/NA8/e5YTdMqBdAt3GRDbMuKgWo5APfFHeJkBzlrllO2dQ==",
		"ivBase64": "NUNcNWNzIW3JDbxUDbaUmA==",
		"cipherTextBase64": "NUNcNWNzIW3JDbxUDbaUmDJaAlDW0J7kATe9WpRxnwhZN+yvb76qscnI0VCpON4BzXby326FM1cERMdBr2ZzMHgW74YBmSTXHqnAtiDZDyLKW5Vb/0TJZO3p6QsV5kgb",
		"hexKey": "bce711e90341ef5671c8a1214793bc87",
		"keyToEncrypt256": "92df61f64234712ebfec49968312a024",
		"keyToEncrypt128": "498f92ddaee11f2e7c5f7a3b7e8e8bf1",
		"encryptedKey256": "Zd1dU5yGM8NdiWVoL8gFew==",
		"encryptedKey128": "S9wVCQqWuqLKi2g8/NTmIQ=="
	},
	{
		"plainTextBase64": "MD4OmrTHsvEuWLHRsRedCHL7hMi6R1NwHX4IQ0cMPyWaYEdSKXeWRBtNpLCJMoMTukMq4mkRaQQPx5gihOyhwCZBvSamFV6TCeTlTtLhqcQ=",
		"ivBase64": "e/W4nvPfLI9dCu4yz86ghQ==",
		"cipherTextBase64": "e/W4nvPfLI9dCu4yz86ghQxYTN2S7M4bqa/sId7IuRS2YF3hXJn0B5IuJgepWmZj6brOHiR4ZZd8gCBhe9Xz+iK1gFEqfCmEoK8UDOagk5ESB9A7KX6b1fwC60R+Ax12YFrpUXbwbjMsORXr03UWpw==",
		"hexKey": "b76a65e60aa1d87671e29996f7c77966",
		"keyToEncrypt256": "b7b23a741ca3dbf5b3cdf7bdd3d9fadd",
		"keyToEncrypt128": "0d24ae115481b2f7fe796e65ea436a93",
		"encryptedKey256": "gacZlLK7s+hX/GLgdOwXTg==",
		"encryptedKey128": "yaxMmf85dn//u1lKh8L1yg=="
	},
	{
		"plainTextBase64": "bcZj4db9jrIh/oJEGaPxtUX2ZmXP5awviE2kytmH4kLb5Jft9TyvEU0DyOMTN6CUJavfbu5ZnE1Lfvn/N34ee5vaXUT0nPmLzQ7gS+vQBubi",
		"ivBase64": "S5yCXvz8YTzRg0AatuJ88A==",
		"cipherTextBase64": "S5yCXvz8YTzRg0AatuJ88Aa2vvKR8lEUk5fgbLDMq6Z0F82X8Jg2XrqbxBiEcJg+c3YF7J0RtV38xC3OoHr/1pA4Hc4+i8dLdP4V9NPO0tq1B6GevlLZbk3inLiJTYzlV7spiyA7ReFAVB0vdgWE7g==",
		"hexKey": "cb32fa6fb1d4f07cf120ec658f2f3e4b",
		"keyToEncrypt256": "ed77bb0d2d607b36a78a929d5188646b",
		"keyToEncrypt128": "877615fdd13c877b03d04e179171b21a",
		"encryptedKey256": "qoUKR4aYA6fwzbJWNvhIPA==",
		"encryptedKey128": "tHEfkc7JCNLYIEw3mWuQAQ=="
	},
	{
		"plainTextBase64": "vYJQLXpca2bgC7sfBREc6Pys+5gKl91zdfso8NMwSvUXwaUQiBD61TxzLOV7JsopM1L81FWu6FS9hxbwNPLI68y3uC7l7kg75OeRzM2smcu2rQ==",
		"ivBase64": "ylv6FzZdGlGfVFWg2jEmKg==",
		"cipherTextBase64": "ylv6FzZdGlGfVFWg2jEmKp0KBWg49Q2AFAN3TPQt9Yay+Hxwvw6qa6tbmuxeFDiz03tT3VxzDJceOlKnzvxuYlJiAjNhpfi2aw//BEWMiz6bMcxXEMiPXSzfcnZ+WOJvTRbYQm7CZJdbxNVSJ5Ul5Q==",
		"hexKey": "da42389eac5ae57964bd64f52ccc3859",
		"keyToEncrypt256": "2af78c33988e676d944ab36e0466345f",
		"keyToEncrypt128": "98606d939f8e1ac3226581247f59d0eb",
		"encryptedKey256": "2xn0wcN3mrL0zQP+w63msw==",
		"encryptedKey128": "P0+2KxtZ8fgfHMjlDcm3TA=="
	},
	{
		"plainTextBase64": "SqI2mrCj4vhyIwkxbVP5/uQvMpum6CMcKgwxQsJNCp1+JJNyq9nnzmtWYXQh89rMMgO5zc8U5+5pIROKo5g8v4r3AMFHFKDbUlNWsME5KkE5XAw=",
		"ivBase64": "X30Pi67OxRHKFNw7pnAM1g==",
		"cipherTextBase64": "X30Pi67OxRHKFNw7pnAM1pUUklg+g7WGrr9yWteXu2qOd+jpvcGLIJkMPADCLiD0O9lHdH/DjrVGid0AT22LJQhwxZAVD2r60UnPHgPQvXD55Nxu1b+U4tB13OVI7Wd47qzRgAMxOk4gJeVrIGa6EQ==",
		"hexKey": "296f34c4fc4d9042d892f16d7ad8e2a1",
		"keyToEncrypt256": "f929363b2800c944912f4330eb225b34",
		"keyToEncrypt128": "c37358de080fae63ed0e5d8f85bad48f",
		"encryptedKey256": "rJ9cQKpsbJUWL+1ia3TTVg==",
		"encryptedKey128": "rWXoTnvQnWRVMaz+1lFgRQ=="
	},
	{
		"plainTextBase64": "JZRrrMdhUU4T7oxe3bbSiYexub7LKI9hWnXuwgJDa+1Pw8atQ3d3oYcn1kKs4l6wdeBYH+VzEfCxSiduDqnXdGJONEsaUxBeH1sBebwIT7Zt2s9U",
		"ivBase64": "EzxtsZfzS/5EhPHvyvxl0A==",
		"cipherTextBase64": "EzxtsZfzS/5EhPHvyvxl0EhZI5qPu9k9dLVosRX7J0qt6Bjfm9Fj0Q+sV9ettLC1c+MSzo8NL7mt8GnZCJu4wWPM/7nAEHuVQrnHlGVOwprhqrN6DyaJZznST9TxRWjPZDmgUUMtmM5iKQY82EHHeQ==",
		"hexKey": "5d986fada8cf3cfc707134771668f8ba",
		"keyToEncrypt256": "e1cea3d5547733cfbcaedfe0858711a0",
		"keyToEncrypt128": "ddddb62b2adc4e20e7f5d2a7188bad83",
		"encryptedKey256": "VQ1bTrE+4EerhT7OlzkHCg==",
		"encryptedKey128": "YiQzOCoadLCqpG+KwKmcEA=="
	},
	{
		"plainTextBase64": "GEidOk4LeRHVc/tsfLE4vEENg2NJF8mNsPjEHkFAqXM9oB9R8ldq+4w7XP6fok/4VqKsT56iqn64XdhwrRTCH53mVXmY+SSKx0xmlNXyreJBoqXvCQ==",
		"ivBase64": "EhKzrUmphPuFWoVzVmWBiQ==",
		"cipherTextBase64": "EhKzrUmphPuFWoVzVmWBiQ4KWExyBplwl+r2akaAHfFnZ+WF31RN0Tbi4JaTPCRJv5+NfAelOw3U0Fy6wHuxoq86LKBAwwGsjniU2K4ZvsopVuhOxT+mgxm7Nzh+mhZvC73FI/ttBWpyqjGLQYyolQ==",
		"hexKey": "1e653a42718fc824cd2bf64b8605a07c",
		"keyToEncrypt256": "3ce5ce1f63cbcd3456e5f7ee37a79bf7",
		"keyToEncrypt128": "fbfa50a6ed2198221bbc3ad36f65bfef",
		"encryptedKey256": "fWgUZ4rWDjUipbmd8D8K9g==",
		"encryptedKey128": "n7C5MU3B5tZ3Q6W5yUCY5A=="
	},
	{
		"plainTextBase64": "dbd8P/qHP5y/Kdi6y7m8u4RlA0wAZ/qGtka4Hx7R/T3wqejrKr5roF5FhFNPqrzsKLevKWbGxR+zCr1k3SgKXFgzjcykvaezSTI9rRjZyZ3K2ToPGoA=",
		"ivBase64": "D3aJUcuhRlQJw9HbEE/1fw==",
		"cipherTextBase64": "D3aJUcuhRlQJw9HbEE/1f3zCgxQV7/zYVDV2a1/TDoU4mVFiEAqyBOlgMcICpdorqMgbwv48LZdeBZJN2hB4D60MuxXGM1E7EZhGlpXNitfPXYJAVY6gYZHUPeJt8ShzOGMLYwnqS1sCzhzqpGzTew==",
		"hexKey": "24aca4e1c5d46847e40cdee589997f2e",
		"keyToEncrypt256": "0ab230cee6cc08695b572f1c257ba848",
		"keyToEncrypt128": "ed0b7de39f0fb59c69d848cf2f34f621",
		"encryptedKey256": "P5B8ibTg4NFf3m/9oH8R9w==",
		"encryptedKey128": "zBDlKw4W2SvxOsS5We/cLQ=="
	},
	{
		"plainTextBase64": "+egEayRDx7+56gqSHNV2rT4212heFf/yNi9efEvhb+HoKQIdQlebkTH5+GLqkUp8Fi5rmsyq4oXpQX8rYZLFf1qDbR3xhNmP0Zlbr+od5Pfxwr3Zh1+z",
		"ivBase64": "QAKilJZoz3Gmp0UeW7HyZw==",
		"cipherTextBase64": "QAKilJZoz3Gmp0UeW7HyZysXvL04ZDenuxxA4V7rd82gEXJhfEg6nhu6fOVQ/9+m6IVh+lYlDOxr2zWFV5FeeL9XjR2X2NIKrY53u4lMH4Nl/+KHjYsT+9AoezHT3uffE/p1wURbpoo+MSrwnAo0Ww==",
		"hexKey": "26c81d8ef6a36640bef0df8f39fe2b71",
		"keyToEncrypt256": "56b8d0faf66e46e8eb962af7c6dfdfe5",
		"keyToEncrypt128": "f77d4de235d7ee8a81ed153ea3642346",
		"encryptedKey256": "r3QMCRZkllDJMczdwcl7GA==",
		"encryptedKey128": "ZZ5uUuazxtgmLDRlt/T0gA=="
	},
	{
		"plainTextBase64": "Mjc+R4f0MzJ18pPS6kch9+MkhLJH61nhIvr6XPlwSccT8CxmsMtSXdnPzDgSeF3QgBYP90sWYbvXf719L10caWS5uHz9nIiffXOYBO0L5lPoaFQVBaRGBA==",
		"ivBase64": "x6TJDWH3hy5Y2WJXFbPynQ==",
		"cipherTextBase64": "x6TJDWH3hy5Y2WJXFbPynaAq14cxKDrPZKZ7zgYcpkRShL75SYscu1v6nGZVojlI6z+xJRfqQWdyi8abeUIHN4q7tOICYg/pRWHFT0hIw0mLTyJxUXXz3065E0NEVHcZIjz4DSAD+3xEVHk8jaE3gw==",
		"hexKey": "d5ac40b0347a6c951cd34a67819ffb42",
		"keyToEncrypt256": "abf19b2e349c735eb9e3edaa559d5d9c",
		"keyToEncrypt128": "a7fc7d29268bfcce1938e9e4e84e6c5b",
		"encryptedKey256": "zeuQVOZ8/qS0R/U0q2WblQ==",
		"encryptedKey128": "ZiufPkTwixWZJLBkcjiiQQ=="
	},
	{
		"plainTextBase64": "nf4QAPZf9qlynIew7+dXZ+LmtiGgP851OmalpPbj/OvBY5K4Mk9pbb/hxYpdETjVehnWbWS8sV951zniLWmZ/LKOPPWNn7e/cR/sCO/E+p0aj3tbAX4f4hk=",
		"ivBase64": "Rtzc8coUbOuwzPu5tBQ3jw==",
		"cipherTextBase64": "Rtzc8coUbOuwzPu5tBQ3j3kg48eeNZuoQlcVNSjXh11sTskiHx3EDCkWPm+Ut5q2+4PSmJkoKj7yTfcr0pVSc15ZUu7AyqKR7jsVofOKroIetRskz/VmowSr97PnNkqYx0AVlP0CeLlyaDuSfpca1A==",
		"hexKey": "ab9a260d8494fe26fa43eb08fe59062a",
		"keyToEncrypt256": "809b07d4ec716f083d8d3c1da98c21c6",
		"keyToEncrypt128": "49e266fed0be4cae2e772461117b2494",
		"encryptedKey256": "IG0/aaqszVubp1r4uytX0w==",
		"encryptedKey128": "Ii+djyzmIcXQR89NrrObFQ=="
	},
	{
		"plainTextBase64": "NRfm05jJG58aYkohYGJg/Y/e+siJUCe7OxXimAA9IsYhSR0DVn7MSV7pmFST7pYLpCeZfKGu7nGnYp2gq62LchNHAdkL8asjs9BS/bLoPafdll1GKVskpVwN",
		"ivBase64": "ooWNpIumZbVs23qoRoAV0w==",
		"cipherTextBase64": "ooWNpIumZbVs23qoRoAV03Ck+pvdAybFBD1wtb2jzd5onthVrmbeTyaDfjiWx+KS0YM+H3LEd7ZWIqPrSjexSg3r8z2tIw/ckZveysq4IwPsAa2UVbOIkwtmW1aZ7tgChXAXHlndghxsnzNsFznuIQ==",
		"hexKey": "77ae1de4449c09247ee3e74b9897f864",
		"keyToEncrypt256": "34559811b52741387b231f45c60d2323",
		"keyToEncrypt128": "fb6fb894b3ce79e93e165a7dfb4d7c79",
		"encryptedKey256": "4k3jAh+j5DMcOq6q09a7bw==",
		"encryptedKey128": "VVvt8jQEfRYTolgUuEMP6g=="
	},
	{
		"plainTextBase64": "PSd/uQCeVqQQxtrONK725A3HfyoaqNoDGHFtyI6TgIooWwCwSeA0BAYhJLC/C1DHPdANZ2dbsGFNE40opP28NWZGZpXFtnE+U/k82b/fNidJjxDqpG17Dsr7Uw==",
		"ivBase64": "ucKk3nY/ifKIb74DFu36bw==",
		"cipherTextBase64": "ucKk3nY/ifKIb74DFu36b791LQ+4clH11VWFJgJGYppEhjOd/Q6i9tGTmw/hBCJFbpFcWCeSYB7Qkkj1ga9NymImQCkXrlsL3bGjr+klfFZYGbUhR8DaVo5YrfsZoTI/VVlUU6WfwCLryqeBG4GUdw==",
		"hexKey": "0e6907d0d5b411d5946aaa1eb504a090",
		"keyToEncrypt256": "b191cd9aa05d64207b431b7988091601",
		"keyToEncrypt128": "dd73fb2da37c26708edb313dc1a32e7e",
		"encryptedKey256": "m5CXKTOJvLRdTBJ1ckRa9Q==",
		"encryptedKey128": "BwVxusQGSE4XsVJsvTEg9g=="
	},
	{
		"plainTextBase64": "RvctZK/M0wMAW4j519YqayBGZ7FCy/NnoakUOFx85FKYyirWgVwP9Ueq9dym1aslMcPU36AayOhk+H3SZo3oQZn3NiPz9qwN43dgeMcxJIv8AuS7FRZYbHVGcX0=",
		"ivBase64": "1LFptZmHNpIU840IhbPROQ==",
		"cipherTextBase64": "1LFptZmHNpIU840IhbPROQJ7T+Dg43p+689kVtgB9igX+T1OXxgAXaSMFw8ve0iVr10WQMfcy4+p0Fsa3cc3aaC96EmPHl8Gi0aqPoyweqghP+viJGDdXOHcmbLn+FmdsKskWwaFnO7W5/tt3vxAHg==",
		"hexKey": "c18e71d522a922bd8eb4faba37c007b6",
		"keyToEncrypt256": "e116d9a4d7e45d092b7e0d0466306e68",
		"keyToEncrypt128": "bc7bcafb10f6836b26a975a6808f9c0d",
		"encryptedKey256": "+evaGWPXmNnWVabWMUzfIA==",
		"encryptedKey128": "Ake6rwK4ovemjf5xtfAypw=="
	},
	{
		"plainTextBase64": "FrgvmV0OhfAyO8UCFV+2+czkvSZvb8Ee+ixNH1BVRUZ94ulvarQ4mqi129bQyXsEJLY032uTFASyoNIHp/3+51fzdZTLRpqdnEMehtoTFK7QNi1B+9RkEGQU+tOv",
		"ivBase64": "HaY9LZTnbLwp2Qw/wnkqtA==",
		"cipherTextBase64": "HaY9LZTnbLwp2Qw/wnkqtMe5FCapr+XBPIBGx5VBc5SpWbM8s7L1xsMpldkoUUCe4huEYWFDCAGUxjkZULTdmW4ATwwFp0ZqomrudviRF7RsMGwvC/SJ+2cAMo0A9EtNXpVRiDvJ6nGiMv/On5U1gA==",
		"hexKey": "947af6776b0c4f9ff943c887612b2c4f",
		"keyToEncrypt256": "08d99c9785fbf408e99a0853ca810384",
		"keyToEncrypt128": "c147a124c891fd8b06feeeaea9cd6c63",
		"encryptedKey256": "5yNSpIyhqMWhDITHXiQA7w==",
		"encryptedKey128": "HxbZdTZ3kU0xgV0KNGgZfQ=="
	},
	{
		"plainTextBase64": "fMPf4u/d62a3lzYUv+n2OARPs0vyw/TKebJT91Jc6KUOfsLnTYUMmK92Sezlih7RezHmwO5cdNbmTUxXVfuqk7TO0QqOGxsC8NaDPH5AdVJh/elxYbwVbyHxL++NYg==",
		"ivBase64": "fR44k1Z1SucXuf5laytWTQ==",
		"cipherTextBase64": "fR44k1Z1SucXuf5laytWTUFa3jy0rSCNtjvNRzrc1JNup6baCpra2E55aCbGSA3xdDOQ4Z/bwwfQZ7crGB+mGHgJiyCEKFbeWCa5DO+/Pp2GFI/3vIqdL98PQnjbmuF/ZSMBdLTt+nK6/Pr9JAfNCw==",
		"hexKey": "dd146ef6c4456937a3d8c0b5a4ec4d80",
		"keyToEncrypt256": "bafbb7a9ad551f5261a4c5d1dac8d075",
		"keyToEncrypt128": "e9c3fa8a5d0a8f22e0ecf08ecdfdc3b1",
		"encryptedKey256": "ZpX6IFXWoC2c9gGHfMokzg==",
		"encryptedKey128": "TLxQ++E9Qd2j3+MkwPdcaA=="
	},
	{
		"plainTextBase64": "DlVKL8xYGczpqvHowPHHfZta2n8eaqhWOmGMIWplbA5e5dRgBBZRtUtGw+avrBduTNyvmN5rf97Udey+Zp4rCE3ZExS1z+qVutwr0bbky7WFxggF6xx9Gxsio+WN+NU=",
		"ivBase64": "GDL6iN0EYWcupkU7IKGMaA==",
		"cipherTextBase64": "GDL6iN0EYWcupkU7IKGMaDjyozlKMTYAEF4ejsRwNPNGe8Z/CxoqSBI7dtUqH8RrOYtZNwZEMQnBtvS/N+r12K/CiVWFeLXolbSWO2CB544JnqyFnSuDnwxzO+BkA9DRs2CAlp49iFCuhcoFN22Y1w==",
		"hexKey": "b10037709cbca309db745f76d61c618b",
		"keyToEncrypt256": "111a6442e9e38ad7ce1f36dccb51d73b",
		"keyToEncrypt128": "9296e8d14191e9e607fa191829bfb9e7",
		"encryptedKey256": "ZkGcaEUa63q0uQG10K4Khg==",
		"encryptedKey128": "xBeodzJnqwF/fvO1Y5tnEQ=="
	},
	{
		"plainTextBase64": "zkAxTtiXn4rCMJIKaBQ/bXL06VVvJ3XH/I6ENQmQyo1z2VdpPrHHllc+yPhmSzMcgaIcgKyEcA7nLZIGSekhFf3GajJIb3hUqXJqJfe/5DL/5aZdUz74wEz2llsPn7+c",
		"ivBase64": "vr6HVnuNFlYtQLHPpfTqWg==",
		"cipherTextBase64": "vr6HVnuNFlYtQLHPpfTqWhyqgaXZIF60Mo7ZfLE0b8aay4GEm2MyUuCnWiQkJ5z1sXHenNiHJCCz8/lipUqcV/r6jn4ZZvEv2aG7hZb64ZjtTojkOYoZsJpzZ9NZqmuiL20FvWgmbMRRtEJzzM/wCeG+1OV07dWSCtabxSevInI=",
		"hexKey": "d1278b714121fea72c7d540c30283c4f",
		"keyToEncrypt256": "576366260e4265d278b6193e4898e6d3",
		"keyToEncrypt128": "5c903a3fe73acc9233121ab83966cda0",
		"encryptedKey256": "pRfqdK8ZW1uirBergFvgLw==",
		"encryptedKey128": "V3b/dJgfEfN/wHS5IRzpTg=="
	},
	{
		"plainTextBase64": "D8vC8RP34D/46ot6epxDMAyE4V6ASRWKeaHgmepLWr/GD7U5vbp7nmQ2Ovlx+mrkyigjfOEJWQWpnMHJo14a2NyqofmVTaBeGnKUXsZBPNSjCeFvAEeSt1tIvFGeolWACg==",
		"ivBase64": "WGZRt5V9SkDG1totRttwWA==",
		"cipherTextBase64": "WGZRt5V9SkDG1totRttwWEDBT3O5k6ohOXP80itI9IqNayLYwznzsmvIutr2HsDcwmCOOr9Weft1IUa8NpQzd3Ahs5S7c98Uc7jK+DBQBYnvFKA60vpBSBhwLm2FubSWA/1nSq2CDPMvCQOWcHKdW7yY0zBlsf3gQzccgVdPCJM=",
		"hexKey": "a70f56235509305bd564d1ce8f60d9ba",
		"keyToEncrypt256": "bfee1c50343d9ce11f3e97e61db82bff",
		"keyToEncrypt128": "48f27cc40191571707a90ad5c7a13653",
		"encryptedKey256": "ZuRgLHE6bF4qcBrNXx3PFA==",
		"encryptedKey128": "otyQmRWNgT+FK3n0NOw4tQ=="
	},
	{
		"plainTextBase64": "bS/NgnhPK8yjIP890UXhy9gaGcpjt0nfdP/8cAGRXK7z2omtkT/HX1Nj6jPe0zT/6vg4XskV/CsdGza8iL8iqOq3EG0GMKPfbLVIlZxYZYqrulUXpL1l72P3jkmquuZ+oXY=",
		"ivBase64": "qrE2dSB9oMdInDDugHuBhQ==",
		"cipherTextBase64": "qrE2dSB9oMdInDDugHuBhfbpDcek2E0rqN1W2tM/nneK4GJhhTDsOPNWrTRDLJ//5lRjTrtBJd0vLyYGhZ0YngtW4TKOeDjqT9F65KbMzh9VrVZOoJFh/ieskxLsJOAp/CGaUgRp9FiLfenyoFEkT0dxugOkvoOe7pJjWLfIJzM=",
		"hexKey": "6be5dfb7053e165f8735bfb60b9d3c2a",
		"keyToEncrypt256": "fba529983a4c8631af27f4f0dce237ba",
		"keyToEncrypt128": "9aa84152137d82f20abe6d4b8d6e5bf6",
		"encryptedKey256": "tupxrTWxjUkQ30ItBYw1Wg==",
		"encryptedKey128": "c6pxrZmFkYo/03nuTlM8Eg=="
	},
	{
		"plainTextBase64": "YG8+cbWzVlr9HaIK4YhA2PjQ1TVk48wGdGHGCJrA1LLkI6K3lApV04jLib2WZX1qFHYnYlxdvsI8ae3T4am4bARk+CfNkx99IKDXA9mkCtG5zr+7qyA6W1u84S0MAkTY9GT0",
		"ivBase64": "KRCJMeES3hBuVM0996s4Cg==",
		"cipherTextBase64": "KRCJMeES3hBuVM0996s4CsNsDoZ8uCegT8HgcTv5eh98AzkHfLJXHChsD7ujKlXZ2ruVr0bJfuWorKfgBndfq2p1fd7Uoqz+C2rGB9kGogPw2wdIIJUi3Qw6AOs2jIzL/DeA6lBp+DMTuaEFRfJYZodyH7x6F+cjmSuqZmqKH18=",
		"hexKey": "a88c822d12024bff4730222f79e4cfae",
		"keyToEncrypt256": "de44aba95fc04c32400a995094ebc04e",
		"keyToEncrypt128": "11b8e5d87dc83a84678a2ade77347585",
		"encryptedKey256": "zppOOKsKdYql6HXy/BPhkQ==",
		"encryptedKey128": "Fx/ft3T73N39V98+gQ/uuA=="
	}
];
var aes128MacTests = [
	{
		"plainTextBase64": "",
		"ivBase64": "HIY4cTuAkAhcQJJHotO02w==",
		"cipherTextBase64": "ARyGOHE7gJAIXECSR6LTtNuN6zdinPUttnbGaeDrYgxD7JXSbdGDbx2DdTULVMkYVhUa3BwnY4ZZ32NE9UaRRBQ=",
		"hexKey": "4bc1c3c7372314515336a9ee511f2010",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "pQ==",
		"ivBase64": "j/ryZOTIEgQpDHuep9cQkg==",
		"cipherTextBase64": "AY/68mTkyBIEKQx7nqfXEJLbxmBks/PhMNi5exA6qTFA7xEnPvTrX5+0yySc+Ms2iBrG73nZzQ0FBqZ6QJihA3U=",
		"hexKey": "d49b1428cc8bc24f6de56b07982bb275",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "fmw=",
		"ivBase64": "8SqPc4BuqD0GDH6z2qZn0w==",
		"cipherTextBase64": "AfEqj3OAbqg9Bgx+s9qmZ9MCd02qMaXliSeJfdkh8E/YaikG8nAC+cEHz2+BsqgtapcTIR26zE57PCFBAtpic0Y=",
		"hexKey": "5008ac0d3da17ac3ce15b5b379a3d7b6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "v14a",
		"ivBase64": "OMGjfbwjimxNp8RrO7OwVA==",
		"cipherTextBase64": "ATjBo328I4psTafEazuzsFQkj2r1zWTtlAKlStvUBC1nmJ17pzH7Msz1wW0JDSx0fyJagnMi3YZyvabh6FqjHDc=",
		"hexKey": "652faab76dc0254d2985453e8bdaaf55",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "lh+Ljg==",
		"ivBase64": "Bp3ALw6jvdqCKj7Kw3yi6g==",
		"cipherTextBase64": "AQadwC8Oo73agio+ysN8ourNshRMBj8zNwJfuPG3z7kgNBniGYFLXBFXbKKZXbQG1V+zdMvt5tuBAp4lOuuVUx0=",
		"hexKey": "d4240a0d5b556d1dc7489b05556754a4",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "29WWBYE=",
		"ivBase64": "UHeLNGVE3sWSm+ErLyU/Tw==",
		"cipherTextBase64": "AVB3izRlRN7FkpvhKy8lP0/KfmRnU407lJS0SawRNUC4+P5te5YTFT2Ut5w3dfkK29SkeJnJYJtDgOSHTGgbq9g=",
		"hexKey": "02405f87171742123873a032680b64f6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "1bVjctu1",
		"ivBase64": "soBz73BECrBXi0wH1f32mA==",
		"cipherTextBase64": "AbKAc+9wRAqwV4tMB9X99pjSApw1ViSoSIzkYcGsiosDLL3MX88eZzQRpHNn+ix6r2RL/PiMudg5hqWkT6Xfc/g=",
		"hexKey": "d939a3201e4251ba8f26d326f3c0678f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "7cNfimtBxQ==",
		"ivBase64": "MMpA7DmMjlwmROh6JhQ8ag==",
		"cipherTextBase64": "ATDKQOw5jI5cJkToeiYUPGoJO111QAYjiKsCGLH2//BkGDzwxoV5QWsGwf2E2to900HxHwEhPh6LmdHPq/71U2Y=",
		"hexKey": "aca96cf67c7c5d26adc413a6c945d0b9",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "ZcfUD18sVq0=",
		"ivBase64": "KG14fgPsIouuG1tCrJfFkA==",
		"cipherTextBase64": "AShteH4D7CKLrhtbQqyXxZDJPtENpU72nHJabPlJNwRmqeEVYJxOMOY6WcsC/1MC3viYr0HTdmVhOdNrUphomw8=",
		"hexKey": "03ff51e5a3c8c469aa41dff7b65283fd",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "QYbdZr6R+rqa",
		"ivBase64": "ZmHRnRu6r345U6OG6RSiaw==",
		"cipherTextBase64": "AWZh0Z0buq9+OVOjhukUomst4VFTy3WkI8WrS+VcAEhDewOXxKdgy603lBIYXOxVvo0SOHKCo+cbgWU3nQSGgK4=",
		"hexKey": "a76e622dd3299cb8949054a0cbfeeb37",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "UWOnb0JrDphtUw==",
		"ivBase64": "wQ/nh1PRUP+hl4zvz1saOA==",
		"cipherTextBase64": "AcEP54dT0VD/oZeM789bGjgN+mgB6n2nabZFgjasnGE6MRez9Pfx9Unz2kwdJU51sqHS4NPIwYwHJ/w2wLFfJOU=",
		"hexKey": "af77d2921a71626ad271985dbee10022",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "n3/R8KP7vFGYo9s=",
		"ivBase64": "yDhdMnFWD24z4QJoqZTNJw==",
		"cipherTextBase64": "Acg4XTJxVg9uM+ECaKmUzSfv2UDPviApkMiWqFuzmWDwVcg82W36NX5yJaiQtElb4I0fsZI8DUYtSlhbbJrPt3E=",
		"hexKey": "607f8181583b539410ce25b449f30676",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Ji4KDlTJn1/NcHOm",
		"ivBase64": "SNDQ4+oNSYllDMUMsHYu+w==",
		"cipherTextBase64": "AUjQ0OPqDUmJZQzFDLB2LvsJfzhrMi7rofFWMcBzW0ltPq7g60Y63vV6k6LYS2WzSZ92pdVQcYBg2hEv4Xz45Zg=",
		"hexKey": "dd7c813d80cbfb561b926c4b5780c5b4",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Aqyl64iTKbxEGsVfTQ==",
		"ivBase64": "mZCLgD3t5P3DZMlJ1CLEEw==",
		"cipherTextBase64": "AZmQi4A97eT9w2TJSdQixBNpeMI5mXqPJ8byoQ9LpaDUwkrP93c6v/U3YjvWV+n69kGbSkvPceGWSZbc0QaBKUE=",
		"hexKey": "822850905d798ffcf0e7fd07eb4decc3",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "cIrQCwzmaXbqThhEXug=",
		"ivBase64": "pWqJayX8JBU8I3c3m3YzMA==",
		"cipherTextBase64": "AaVqiWsl/CQVPCN3N5t2MzCYExJc1eVUVw0KpqueK2W/GGgarsb/jzt0h41uPuC+t+Zh0asH242xWlkmpWbtGiE=",
		"hexKey": "f69edcce257a284f21d8b51125e0790f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "/Ly4GmtuCdpbfzaiYE2O",
		"ivBase64": "rLufSRZ+oXDjf17BjTpQEA==",
		"cipherTextBase64": "Aay7n0kWfqFw439ewY06UBDl1MSxSR290hEfCuWTRr/6Njd+d1oYyERrYh80O7+FO61Nx7NeGthxiaRlq8doPRc=",
		"hexKey": "7f7ba5619406f86b3c2ae2617bebb14e",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "bocqNMqPsqUUJJvRKClYXg==",
		"ivBase64": "Ul06MQ9FD+UO4yl0/X8Uew==",
		"cipherTextBase64": "AVJdOjEPRQ/lDuMpdP1/FHu7c9af1I+IQ9krdT9CbHBu5yoBMJ5s6IOpXYMx8TxuC+xX5WRDiUhjLuNExHa3KoDzyHt3hI2gRNWgsE9XGCrx",
		"hexKey": "b231fbf111c28466042b33c6f40fa63c",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Zh7OxcpVQUbIpk/NRAEdRGs=",
		"ivBase64": "aneu6FuTMb/YARUHSKrs3w==",
		"cipherTextBase64": "AWp3ruhbkzG/2AEVB0iq7N/H1sIAPBpxcnhWAPEcnyJnoJSr0jeakshEyUmUuTmJ3BwMYNTKTG9XiiUbgpp+V+wIOEe4CtPjzo+DDmYUOf7S",
		"hexKey": "a9ead720e6dc383fb1203290d6a20eba",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Wxb8RyKgNCKj0y1NftqAnpLt",
		"ivBase64": "lPp0REgCoKnV7hIYJNZGiQ==",
		"cipherTextBase64": "AZT6dERIAqCp1e4SGCTWRokndXwNVZi4Iwc8+FSOGDtUcyOX8aMpOoaxHAHjSSHqtP9OdwPEa+FdXocucv5z2/3CUG4uca7/xf3j1lqTFGyr",
		"hexKey": "63aaed5654c4f9459d9f5e572ab00f79",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "7S2V7kAP7JVzkS23kUkQtZ+goA==",
		"ivBase64": "Ap0xZXnITZllvrXeKx7Ixw==",
		"cipherTextBase64": "AQKdMWV5yE2ZZb613iseyMepFdp+66XdewHXKh2fOVVdpXvGNBABOW0pr3chmBqdMTCO1l3v5p0y2uA8B9dbxjn0GMqv92JDgUUuorxD6ou3",
		"hexKey": "a0e90923ee5c42068fbb8aa08c11179f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "QTLX3LwJZ/QtqKPoZ5C+TUhhI5M=",
		"ivBase64": "dPis0GOt6yE8naL2jDx7bw==",
		"cipherTextBase64": "AXT4rNBjreshPJ2i9ow8e29RpL4AVqvDIlkz9rSmmSuTR98NqdYAMu/dnKawDj5pcpkOa4hvnVc2Pn/Q3vV0bWBasAt0Q1Cu2JKj+AWTme5T",
		"hexKey": "2a8cda6d1b11579a57d65ce081cd95a6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "GQW/VgubLMlt0xaiwhXdgwLEqSSD",
		"ivBase64": "ToMpp9878dm2wK5/LFNQFg==",
		"cipherTextBase64": "AU6DKaffO/HZtsCufyxTUBZB77JiiK66KtFKK3C5a2zDRkhgTGfDDCzA5lRYvPFG4FldEFj2LMdUOnMfVmg/fGxK1GPU/cbttagsHadA11BL",
		"hexKey": "caa97625b8480817344e0bf5c058b9a0",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "wzlZrklvPksRd76n3nET0GERn0FzSA==",
		"ivBase64": "Dyj+0rUApDIwhxVwCSo6gA==",
		"cipherTextBase64": "AQ8o/tK1AKQyMIcVcAkqOoBYZhNr3P+K8pB+A+ipdbiyDcUJm7K6pSHFMJ3LmBar/H50pSEizsd6UC+Wxrt/B/okMWdIBF34QA1oJagEXt23",
		"hexKey": "9d2efa42a223244dac12f8ce3e1ce943",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "DfPkD5hS9KTC3/A0715ZlLcravIEHNQ=",
		"ivBase64": "/G/ykgqNjCFb2q4a4tjRlQ==",
		"cipherTextBase64": "Afxv8pIKjYwhW9quGuLY0ZU0V2+i83Xua97MKfz0Ay+4bokKYsRMbcPQsVhlsuLgfpMI2Xc6riQpeUVsrxwGqbhnFgCV0LHACb3N5wgnDSY4",
		"hexKey": "63ab54ad22b46064bb3c7ac818515379",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "rKGf+Ufo9Q5EJnsKB0iPfV5DSd8U735P",
		"ivBase64": "E1u77bIZDfnr7Z3roR2EqQ==",
		"cipherTextBase64": "ARNbu+2yGQ356+2d66EdhKlne3C1nHZBH0F0qDNFtLIL0RBnwMDBDwSHGAO9uMdNQBiilPHG9LeBAn+x2pC+nGMHPkmhTeLO0REdt1ZPJqNz",
		"hexKey": "6e8612325c75a12c4cf355ceea874d39",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "BMeZL5Vtu3MPoE0bNr9zs8TiPHDsAkDyqg==",
		"ivBase64": "pPR6SSPLtpR7XcaGd2Yf2g==",
		"cipherTextBase64": "AaT0ekkjy7aUe13GhndmH9qfPsG59DR8EoKsEnpd+8lEVYQFH+psCRovyMOOTjrdK4FN2hDpLwWaNwy1M+PccZco2q4kEQDL5lScgi7zlv3w",
		"hexKey": "7fac2d23ff242987ec75157f9006f41c",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "tkh94n0B/H+sUf9xpMB5RhmG31TQafy8dfw=",
		"ivBase64": "vOhYWcBoK38QJ1+1wj4rkA==",
		"cipherTextBase64": "AbzoWFnAaCt/ECdftcI+K5BVpkCwJWdUfI05RxdQxRc9nrh6WvMDhntSNcv+XrBHpGE611MyDJuxRvU0s3WKFVdlgUJVvU3MpkXqkLm95oh9",
		"hexKey": "160623628d3b5bda63032f539a0ac37a",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "x4POSC286qLRU4yKl1uF5MjPdS6VwrmmxWhc",
		"ivBase64": "zl5QOb0/3ZhPftjKpd/wZw==",
		"cipherTextBase64": "Ac5eUDm9P92YT37YyqXf8GeiMwuM0ZvWdm6myLqXsFyEIMa0cP+D0v015vnLwsXGmcMCmMnBCOXtPpTW6UgUzmgDxWjJpbqDYskQR+y6meKe",
		"hexKey": "79f99da922c9cd54fcdced69fc404009",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "LVsaJFgnd+nSLwHMUCYi/m0xYkK/faKC5F+wVA==",
		"ivBase64": "z0qE8rT1/WClYbwOtQDrzw==",
		"cipherTextBase64": "Ac9KhPK09f1gpWG8DrUA68+K6aDBe7714pZH9W1Knm75Gc7NWuT38jlysE1SpUWFLSLqMI6QKyxv4rk+fh1I9hUNRjCmgpTwztUEgjqkr9Ku",
		"hexKey": "dd8b987a39a0828ad018a23bfacb0c82",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "0/kJgeGozlPi3O2XhzgxB7xprhHxW/3PeQo2O/I=",
		"ivBase64": "lqteL/FieN+IqAR9A1EqTw==",
		"cipherTextBase64": "AZarXi/xYnjfiKgEfQNRKk/72gf5cqNJ/osxVdKQ+fbV2km4k4ZLKr6lv3nT6wkvWnddqndPtcGVZQ+H62Kdt3fMj0qhxMwTTQs4yO2SDrlV",
		"hexKey": "9e6dfda20d834c236b2792f2d4f80897",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "mS2kWdZax9XrFdiWfVFD/yiv4zrU3gfTFpqOWocZ",
		"ivBase64": "9PzH3Gi0Y0+LeYcIb6BYnQ==",
		"cipherTextBase64": "AfT8x9xotGNPi3mHCG+gWJ0KfyK0NU1er9CrAQIJL66GbaxOrl4Mfwq7wxy3S223UGF+3YuiGStIr8Rsh1fjbQz+zQsWAhkG0By7zplHkXZ7",
		"hexKey": "3258892fbef3103a857f4aaa656552aa",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "GCenwUlCqwjjJGf3iX1AY9B0GRJqw803DAr8UP8prA==",
		"ivBase64": "/GyIrHK3/3PXNIaK1sgAFg==",
		"cipherTextBase64": "AfxsiKxyt/9z1zSGitbIABZGi3gxvhNIx2MhLRV+OPJ9m47cJc2kbgETnmGWE2oIqDwpZVJ5uTZ0fNp00d9de6/wgaf1EEc9e2EsmjqDVqx3",
		"hexKey": "274b3cde7c70a217bd4ab1c735e7d7df",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "UBDkTQ4MM8CLw53qFA2dj4U3tDkGwu0MQGDFssmzMok=",
		"ivBase64": "LjUqN9R9iqBxxHEwKqHw6g==",
		"cipherTextBase64": "AS41KjfUfYqgccRxMCqh8OpwKNDEcsU4AERtM1fdNT1JXPIgj8yOM1HLjG7zvb44GGNpOUZbG//BPRczd8TfX+jl4/nCjb3uJ4EefZfU6wHs7gjiNvo9ZW2dYTn+pkxoeQ==",
		"hexKey": "ccb579e9e348472fb49a14323f22250f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "v1Murc5chJeh1eNYpu0e20pcU+pf0ykCIMGxjWN+lXXc",
		"ivBase64": "IuPYE38tDYbff6cmwZWDlw==",
		"cipherTextBase64": "ASLj2BN/LQ2G33+nJsGVg5cRf4F8zMEMLgH1XKI49kc/fzlf6qyWLDPR1Ro2KQ/LW9t+2uHl6oPMRYbjs3xsNQUqrUhQtujByCS13krfq6KmlwI61XjPq0CHL4GhmrnXew==",
		"hexKey": "f77ef6f6b56d19d1cb9ee426a81436f2",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "PgWBAQ+cdg+MzXTM4bevRyYdHGwiOHd5DHqCm+TMRpuZ8A==",
		"ivBase64": "8ItikBBCFikoE9M5nE/azg==",
		"cipherTextBase64": "AfCLYpAQQhYpKBPTOZxP2s57zQS2wHiLnS/jIKZ0CXY7fAaelB+KBbTaSmfbF5Eb14Croln6vR01EfPZWbHewmHpAea9BwY1epPLctA0XZQX1ljp7l2Z3fIXzNNoOXrPwA==",
		"hexKey": "4222a538041057ee048773224c260232",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "lm1jiCSdLwzyC2dYCBzayOyQ9ux1iDGNVrHMd8SeDNCNSj4=",
		"ivBase64": "sBWuk1d4pXQApLBIhbAE3g==",
		"cipherTextBase64": "AbAVrpNXeKV0AKSwSIWwBN6CEGSDH+DJtxEg9cjblbF5ZJc7Jr/AFzrX1ZEBNhGu89u2DiuTLmBXhS0YLNEMWzdeOTkw6JVQ6XaDW++loaGw1LyhLfr0nvnBYfzfinUwHQ==",
		"hexKey": "442614ad1b8365157ed0fa52c83ff86b",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "2fNV2wm/FosU58Sw6XwctR1ohk8ZAI9vZ12f1/jRQbC9BATQ",
		"ivBase64": "iGPiBGw1fRVgJl8loEkUHg==",
		"cipherTextBase64": "AYhj4gRsNX0VYCZfJaBJFB75Yp/sk+bLVOcECnuT3oNWhSvQWnNnppveYBb0CwIZecH/ae6J62wjM8aQZi+Oca+yB7J2Vt4A/hle28eGSKPtuH4pr8/5BLfjJzgXRbJzsA==",
		"hexKey": "e173323c0d0a0a6bcc7965f4e4eee4a3",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "DIzX/UskKK4iEVyG44RAJFRi7oflGyTKeNqdrVnH8vSZoLJhFg==",
		"ivBase64": "3F+fh4fOmLPTqefwD4m15A==",
		"cipherTextBase64": "Adxfn4eHzpiz06nn8A+JteRFm2BMvgxnOPYb43vKk3y8XPqJ5muAtLmdWVpK50Q+pVPwG01B1LV/Xqqye9JG7++KyUp3aNDzgzRBSAaUFhAH4dVrSbjJQ0vZFANMJx/qcA==",
		"hexKey": "e5fcb4de1c40d0062d332422bfbd76a8",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "huW/lnH2MBZo+7T9Kb7EQ9NpgLSjwhdiw+egGOAK2+8RYQuff3s=",
		"ivBase64": "8tyzDF+kkb50pFXvATs4QA==",
		"cipherTextBase64": "AfLcswxfpJG+dKRV7wE7OEAMSRUP3rZzX2tnJ97/Ifv5WTHxJI8lMV/uwmESy2GQO/dpb66JKSJN+SyqH9tumhlaelmIBVLimbGpALQlb6RVW5KRloPuQ727iS9CATM7rA==",
		"hexKey": "4a8fd8bae4db8f1701a5e8dfe2b0d44f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "OwIDkTAcA8t1n6KQ1TNr5vb6mWanshsP45qjFo65FEJPY7nMHQMF",
		"ivBase64": "A1Mx7qLmW0mKaSrlzEtBdg==",
		"cipherTextBase64": "AQNTMe6i5ltJimkq5cxLQXZaHrAx6MO+V4K3NNjTSYfyI3rAiWYPkVDzedDoU0WMrjXVgyGunUopr/vIs1alRF2pV+YwyA+D3TDZkRFPF355XEhLrMgarujyAQh//Xfvgw==",
		"hexKey": "f1f5cb828053fbd23306c63199bde970",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "pH/wmBCet68C+8hIKZx2l7lWVcAi9bkeedehxwnAmFvBiFGzYKKGZQ==",
		"ivBase64": "ECZpGdeWipm8Ut1Qin6Rtg==",
		"cipherTextBase64": "ARAmaRnXloqZvFLdUIp+kbZyEGaDy5gdwh2MX7j4okJlwPiuslssiDmULbMRQMAlDvPal06lbjJImQbHZDuM7rAhaiVxlmw78CudG7oOzUYUlDh+dSDAtXchd8J/B1NJMQ==",
		"hexKey": "cf526f7363edfca91a451e35f5f74680",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "D0JTs+VfvOEXwjurFLFB/XzgSuQRwswy6GyLEOnTBXx4T51hQ9/F0tM=",
		"ivBase64": "byKRuNhU1xC0YzDztSX6dQ==",
		"cipherTextBase64": "AW8ikbjYVNcQtGMw87Ul+nW8JKjCQpYMD0+XGGMN0DlHDeCj+a0vqhSf9mrZYyBvygBrh+qMVD8Qfpj+1f82IYDOBVeM1cpkBNvna3ct0meWx5WykGOxiaOjrD3zg7rKRQ==",
		"hexKey": "cb944f8475dd29b3a77270023c4f3b3d",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "+vW4+VFrG3I3ySs+HWjl1unfYDTFhZTOUfqHISae4vbkoOKuHMXQGcxl",
		"ivBase64": "IXE+On8vYU9CZHw6CgvmPg==",
		"cipherTextBase64": "ASFxPjp/L2FPQmR8OgoL5j6jUqp6kDwqGKDL79u7ktlmeyiHhH70ZndNOPNqQ/tNNyw1FMt21BYU6HqqxzPAx6lKhAjicBJZjdYfeODuaUpZAcRS3CQIiv9K7pOm6lSjbw==",
		"hexKey": "6745147491c20dfb8655e72556c1d8ef",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "OtI/CGkkkxGeU2ZZ/sSiMUcPpESv7432n2zmeXXjUnebmnZg+2sArv6X9w==",
		"ivBase64": "ETAZh7p0cnM79jFxWFKipw==",
		"cipherTextBase64": "AREwGYe6dHJzO/YxcVhSoqelkGNBUUyXjeQ93xSH8SJwZFDwzKLCCXwURB738TX8BwfFwg0c1ZTri818lvGkyPN6UlWJzMH3+pQTRNgTcn7Mwsx4BPkHq9IvmhOEHOJO4A==",
		"hexKey": "33059552acf2e07bde9507126dfddb83",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "JPZkhc46Dq8CzN10vfKULMnGTRznY8yYvgmtPp8oeEZuH38nwi2PVBrQDx0=",
		"ivBase64": "k3ipgxpiEnMr7TiFykEZvA==",
		"cipherTextBase64": "AZN4qYMaYhJzK+04hcpBGbxVmN/UbQM4vInrcN/umK1FdDsaRvIfFeAdVgXmI8XMAeVeZBLb8wU5PtdB+7JrEz+fq4RmTvka+QxjD6VMvAAaW8ttWynfc9gmxYSUMRziCA==",
		"hexKey": "096c2db5e4cb7acd20702cace689fd25",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "cMPBarl9b0PnGiHpzGD6fOinyCN2QmzkPCuuWp+b0eIkbhaxBzDZAufgOkWS",
		"ivBase64": "j8+iVjs+TiNE2QFZ9LUHoA==",
		"cipherTextBase64": "AY/PolY7Pk4jRNkBWfS1B6D7kU4oS+R5hOQS19ChxnjFMfhnRPbMGiCy+GsBUX6v+Jfpg/NRtKZvs/nPW3eJ1OCy1aonu+IpNX5tV5inl7IUpw6k+qv0QuyGh4AkCsT0/A==",
		"hexKey": "87204fce8c455b372ebf5ebf8d75f2f6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "mlkCvqAdGUVG+L3Cv7aNn+hrAbqeyoVZaqVX2sw4ibvH6FnHx4Jp/nGhJYx51w==",
		"ivBase64": "HYksVmSI8f58ezCCfXrexw==",
		"cipherTextBase64": "AR2JLFZkiPH+fHswgn163sdouwOz2FNLO0YoJDPw/ywq40KmVyuyRNUzLK084Ub3aWtOYx+FKOh9S7hJjaOkrHiDbPd/fj9UciWKFYDtn4ZbNypIU/jMoE7B5JEjGJ6ixA==",
		"hexKey": "da2f2c4f5f757a6ad7531e78a09deba7",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "QoAZbu9FW/fxtQbQ46WWnzcRW0rFqpBkPXHgBvYesi4mpUA25bJjqd8r08wM4Hk=",
		"ivBase64": "ZSuc/TYoHf21lrp7qhQT1Q==",
		"cipherTextBase64": "AWUrnP02KB39tZa6e6oUE9WNYz0xUGhBd9gYbkOGaZpN8i95YE6tRaqvulA4oPxTf9d5FktnrAUyjQ/6YfuM3w0gvH4aHSus9lEivHb5QwyXg84Xj9uTnQUx+cKZLtVIdA==",
		"hexKey": "39f46a261349807bbb6f296b94513d1b",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "cGVHW0jr2qTCJ+9Fpbcjj/pATW2xtbi6K7TQaVtc0VeL4PXGtsibmpjTWuTKHYdH",
		"ivBase64": "OZ3ZEMWNkDOsDmvJF+8c7g==",
		"cipherTextBase64": "ATmd2RDFjZAzrA5ryRfvHO5WQepyarNpkj90OYWfwoGdxqte9ZUOkjj5RwnliOi9zDh5ek/2g87bUpeFc53v/KSBI8E4hCg9hDGvWNE04JpeIUmoxdeF7UuNqPNL/hoN5KC6TKS3DQA7YMdw1IAFgzU=",
		"hexKey": "e58e0f7d44a3199dc3db992ed9f69c36",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Iz28PWjU/4KYI+lFpSCgHkqW3kah4VLkkQR5z8rI0afv9pOgwa+JDqVLYiuJTNhpZA==",
		"ivBase64": "QrjYOCPcEg8PvY1Gj7RaHA==",
		"cipherTextBase64": "AUK42Dgj3BIPD72NRo+0WhyRd+jdyGw/A8RH9h19y3/Hq/6YfsOrQlhyg6GlANRQRXksgS3i3kDWr1gAhOGIRUmphoNWz614T2xGBdSefrnidXNIwiUnuqqoIN3doqCxKRST38Z4EovXE75VHD2CmcE=",
		"hexKey": "03e1dee32531e09f63d744ceeb72f4cb",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "Pm8ZrbAKCPLIiWJ4RLzVBzp97Ik5YDO0Cn++O5UcagRAhjy9VUQUy/UQ/dpME1a21Qo=",
		"ivBase64": "v0fEIii0p/2wHdIx05NhQQ==",
		"cipherTextBase64": "Ab9HxCIotKf9sB3SMdOTYUE3rwlOqtbQYdoChwWdxsLmmDilTYH0VaKHykN8e8LwXLBfWs2dRbxasVb3sm07OnAa/7z3YnsNoWesIebp8pVLpAI9OvmpRSyEtjR3IhOLS3CtDYgkuYr6GRdlErIA7Vc=",
		"hexKey": "ca7225d5f03f31168a60f0616260a8c0",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "JLW+e+QemctdEdonCy/ebt7fif1QYtzvBSFGzVFg2NOIcfDv/MNhUUCkvP9RXZwoAWrM",
		"ivBase64": "B69Xxxpi53Hx47Auog6log==",
		"cipherTextBase64": "AQevV8caYudx8eOwLqIOpaKxb63ulnslpn6qKUsW7AqefJEHRPkaiWlcStJd7vnniZsc+2OczQUfEYZka/2M40BT+APJYe5Bk/sNhr7N1mq6Clu3WsY2qDwhORzQKbM31OcGkBwaUK0u4weEINEfiJs=",
		"hexKey": "73e460e9f9b3ac541b95cd866a691c5f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "+DTmRbMb3whhFEcl315cN1Rd2hcH0hyBdgJY6edza9VLnFmnKp171GjWiDFBARdGbjr7Eg==",
		"ivBase64": "X/SL5pxhPVwNjqtpEwghsA==",
		"cipherTextBase64": "AV/0i+acYT1cDY6raRMIIbCLQhA3hZrhN7pwFqbmkAlfKyfBInawnuVaXu0mK/GRZQBXejBAyHmhhxGHX9k2JTBwKF8ISQSKO5Mjhg3lLvvt8wakDXQpygddX/viDO+Qrl7SMAUR8AgSkLaxTFFxQ9Q=",
		"hexKey": "d05dc54a27719031818ff99fb4b8f29e",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "h1HNOeCKXQTY8EZDKDu/oDNe6plxwFUR/SwH5B+zdOP6pgsUDx53KR+UoI7nUo2p0qikdh4=",
		"ivBase64": "3+2zFV+bj3ebdg9O9hdcTw==",
		"cipherTextBase64": "Ad/tsxVfm493m3YPTvYXXE8dsjFe2T53uSOjsN/A/jNB55FLpuSkoIqE7zX5EPG9htpprMFfv00qqcYZ4M1iEhP4bPuhY/UsI68lBDH7LB1L5tgF7WWYURbqB/VyA7OZPKf6VDOf46P2wA10tq9YbVA=",
		"hexKey": "dd3c3cfcf7b9282ae5ec105f74b01608",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "K3vAKodZBYmnzi1Qh0AOjR8g9h6FhDVRoVkWgG/ceIErGKlTcE4SfMakv7LMRMcWwhwU8d/J",
		"ivBase64": "Wby4q2PwvXlOcbUgHzynoA==",
		"cipherTextBase64": "AVm8uKtj8L15TnG1IB88p6CYlYJfw7w1O+nRYjqGQaXryBVL5aUKWObIKOH7lRzkhe6UJjWwTBuiUUQsGSAF7irgHVEYgc094qt6QwVHooeJTjCYOOq10QBkXKEMHM9EvmE+1j2SlGDCeO6a0VP1+tQ=",
		"hexKey": "7a5d91e2386cbf4d3710fd13eb8b4281",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "MSmexUi+2PKcrk6ebhkNvX4i5qztMBDvplLwnB4547ij9uivKenuLgqfoxLvGpXclOObByO2jQ==",
		"ivBase64": "exDkrFYXcUqB4rquFUSUEQ==",
		"cipherTextBase64": "AXsQ5KxWF3FKgeK6rhVElBGHV3tH3Iyt0tov6f5fLXFx1RRoTcOgqjgCO0N0M9bUeImmWJAU9wFrUxHkzDdlkgqbU2OTtqr1kULE+RmH1WpYm7BYmwd+dt1RQFL+P7WHdX6tPK3Fjeaw2If+cNouU3g=",
		"hexKey": "63aafe48117df3f4663e836df9403a53",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "9DjQbZXOF1/zxRD5n+BMn7SeSfuGlQvZQoqYB9DDQDj100A8aF5vXpsc5yB1z238uaD0c9zaIhc=",
		"ivBase64": "VMtVGtRIKLgbjieGPuVMaQ==",
		"cipherTextBase64": "AVTLVRrUSCi4G44nhj7lTGlOftEm+FQGi4mb5uE3k54cHHlL1TRAhfdE+sNBrXgTakvXGbHeEfgTh08qNDx9Wh6gtGo8JFD0sknLcAdO6khWkKveUBa2bxBhga2E8BXshWWcUC5ql5c0r8KI3GGS0KE=",
		"hexKey": "72a975705fb5826068926431b3ee8e3d",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "M8/s8Og7SRvbde1CtzhvE7blka9Yxqmx/crbMsAPtAIhmg8SBl1+9GnjeCyI1kwD1siPdOJ//MN9",
		"ivBase64": "RysUPDNEf8jvhh6Q7bTV/w==",
		"cipherTextBase64": "AUcrFDwzRH/I74YekO201f+f8rx25uCB0rG/u9vomXGQ6addYiR4o3NcGl+Cnlw/C/kl9eA5Z1jCmBAxd6XGn4lOWpkPJvTxjHGDFJIPVTmv0upfwmsFZNDxE3+4haZ/6XqBId79iS+jTTSabZas6tE=",
		"hexKey": "4fc306281308bded7e882eff0e33248f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "hARy6WQYD3e/mbgG97MPFAjQkKPzSHb+xttpk1Qbj21nWMKYNsoAmru5jHSuEWQanG9WL+3yHslqMw==",
		"ivBase64": "sEy0K6327Zr5RBqOD+QhFg==",
		"cipherTextBase64": "AbBMtCut9u2a+UQajg/kIRb5z6tGBxdUhCsX4H1g4GUZHkqH8MBW683qIiHxRcMQS4BBbbhqzh7D29GM31r17gUx/mY2ezYw/d6TVNvVqGdLnTHV9nQrQbKg9fUPOSiTMLNVCdesXbyElYKBAWup5/Q=",
		"hexKey": "65dcf6261ce9b11967b0dbe1165127a0",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "rnk3wgFq/v+JUo7MtTQEna1eEYv12PvUWJJtqAfQPKG2JexHE/bB/M7k8UsyuJwcAl/1kGVgTTpKjFU=",
		"ivBase64": "9dfnH7lznx/iojiJFhOveA==",
		"cipherTextBase64": "AfXX5x+5c58f4qI4iRYTr3hmuP1DWXWlo8zsaZdTArLHEOd6vD32QNiPW2M4EGQLTzUoXXYfp27Eje9UdlQqTXI0okTqJFjhDZQ6zeYtI+/ClaCAQ21Ozh/Km0HylV4TtwBQOx3vjURCAgqxqM1vn/o=",
		"hexKey": "f1a418bf9ed36e5032c3e849af3aca95",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "W8NRbkTC0YJuiSleBDqcZ3vuKOGi0PIP/NhO4JfZm+KR0xTLX5DXBnnvqTCZWsq+w2IbmlqP+cdMDuHQ",
		"ivBase64": "80nS+l8aWyYsu725zLsiHQ==",
		"cipherTextBase64": "AfNJ0vpfGlsmLLu9ucy7Ih2kSAgnXwQoNVweiKyxSL/wCBRkNEzavws4eec9cWzqDXoam+LRCxVXIdnf+//sjB/X6E/X2MVRG9O9xHvDnzRKbnxemWcdQwYQVzzE8StJwiBpmNfuJLr11D2v95N2PkI=",
		"hexKey": "4094004b2ac08edd922fc8932d4048f0",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "0haRGKZXk+yeVFqCe9LhBWgpfxgXzwdNl/iSVQ/CTd1AE3tpTvhepKXoNTLsPncd3c2JspxSwch9ZCIVmQ==",
		"ivBase64": "TE0cw3s5o4TukCv7DC0WwA==",
		"cipherTextBase64": "AUxNHMN7OaOE7pAr+wwtFsB7zBEjqD29jRvF9cSvcriix7E6iCHIWzZ36qcRCPqjmMY9rFkfNnQNBjXn41FZHg9q141wsNtjczuewReaQoL6fnNyVA9yWxKHVCIo5+mD5ZYyoA/QGzj6CfEDDsV30TI=",
		"hexKey": "cc1017d9ae87bbf18ffd368b7eaec48e",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "QFaWXs+4nloVw7TXQSr7eHsBaQOiseqNKUj28FWjJfNKJbDKVF79tzKzt2AnUCYUB/4Omns9iVtDy/G5UzQ=",
		"ivBase64": "HuwUCZJa2Yi2siNcJ2RiLw==",
		"cipherTextBase64": "AR7sFAmSWtmItrIjXCdkYi+ghfMfF8SrHfsXDiAKxl/yzgOS1I2n1kgf5653QD3Tuqmbe9eesk2K+1dkUkjNuAakGiqnxjfof2AsNVbm8P9e6RWQzTtYCWrYxo+EKb546Tzyah9JfequuyTPeq8MGn8=",
		"hexKey": "d53547f7e2183ea7e882ab12d53da8ac",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "NhIrWq1+HdC0spzrVYImwFVP1AohcyWrTBAM7E31+earRRpouEm8pYF6YVWzHcCHv+TFUqwML66q8HpIqrlR",
		"ivBase64": "bCuSRiQENHLX9zuvxF6Qdw==",
		"cipherTextBase64": "AWwrkkYkBDRy1/c7r8RekHfsqX79mZMvr1rb9ixIDM3Knq0+izV6VByZNjvVswzRm4aHBvmeKVRvUou9bMs/tUV8lM/iaHWY5BBr9iwEOFC8YWD9LRoKetJi5YEIuHDHchSC760OinKKW3SMn3ln7RY=",
		"hexKey": "25525e5df2ade1bdf9b35fdf995db1fa",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "y+zn1CnHjL3AluNxtCJ56NCmjmdR6mfrct9fVkGHBGJCA1V3s/4yyLDJZhGGElWwUxAX8b/MJ7ITMP3M/E/kBg==",
		"ivBase64": "WEjwEFX1YATSXX64cXxZbQ==",
		"cipherTextBase64": "AVhI8BBV9WAE0l1+uHF8WW2//EYkppIn3+BWtpygXaTekDirL+Zxj3Vi4+L/fBw47mH1Ep6nT4rTRqy6VpEGRrjaYKi0tzKHqnSc3nBQ/0JVdcROBP8vaoYpU8Qo1xVKo7KkFzhE+bNcJqzl0rJYgn/NDJdkm+ufDfNMCxt3kNOa",
		"hexKey": "46a9e97cf6b808469eef0439da504a47",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "i3AeoXBH6wtS9WWHLj8oPwe/rX/Ns+ZtYHoONbCs4P+NQ3PKdDym16emrgJWI7QIC2d1i5h11lLa8hkkJxWmTew=",
		"ivBase64": "99Pbvo1lgZYghf8Qzk7DTA==",
		"cipherTextBase64": "AffT276NZYGWIIX/EM5Ow0zY7agDN6hsYHsqtforcFeVEx29+F5dS5ap5h38VmGVUiiw3SQvIQ25HiZi6OBwTxUcvN+eBtfj/wGMBrfCDn0GmRKyKDyLcfXeuAd/V6mpF+J9S3K64CXtLLpKFFD20WNr3bPCWrgjSTXHw/sZpSnw",
		"hexKey": "d82dbe070c4bcf227b77c5ee1e0edb36",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "duDgEUFLjPoAO8yYpc462CtZr96elu/tNcyyhJ7xvFCCNSWy5ra1POg1sWQMY3itUyCc+uxNa3OLHgpNCrjB/Dm/",
		"ivBase64": "CfcstUmpU+uIlrvkHi6XJg==",
		"cipherTextBase64": "AQn3LLVJqVPriJa75B4ulyah0gbC737oA3U7pdLyifOvJqXkdwAWAVmnrbQ3qgj+qGuUMRcFrCmySa1AfY3W9A4emWtWDPPeIYGQg+4hilbGRtuvCvYbcoC7g/UHKxbtSVa3C8Sw7sP50I4jnHqCXuW4Q3wTWPc/E9dDQ6Qh2/Rh",
		"hexKey": "4df93a3bc70f0506f2c46d59f99e9190",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "TOyJ8XWfbDivJyzLyUBBu1wSEQYIcXGvNq4bk4aS3rvQ1zKvIntq096u10vRp67ax5W2Se4VYW4sASFpRCx+AZeltw==",
		"ivBase64": "1OpgLupUPuFJtOqvKOp7LQ==",
		"cipherTextBase64": "AdTqYC7qVD7hSbTqryjqey3ZWxAvB/akhwmsqnXRwEFvnl9yc23VLn2+MIegRdQpIDwW24cgRBYj17eCKcseQglk+Z0Y1wqY8+ybKGNUJGaV31H60yrEc5EUZTvsnqu5D4Frylz2MRvh6alRxvjkVWnnGVqpbjanzUqt+SEpA30G",
		"hexKey": "1d9cf11cc45c03aedaa60c25f3c5d9a9",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "AjFje02j0JDmRI4hvUTut/Um9Nx4F5LNWdSgiP7Ldx1eV4wZoRVReWKVnqdKx3imXOmJrzzoqTzkhRaj4vVxM8jsaAc=",
		"ivBase64": "rhTeERF6xHJfn+jGRw/96Q==",
		"cipherTextBase64": "Aa4U3hEResRyX5/oxkcP/enImChECJArCtd6uf58011D5Qfyl7ZS2ZbWwWjmygGLDXFBMJ5BB5KdMRoUUrORdxyf+wh3FbV5XrNiIH05klEGxra7KHfAnnh5/L6NWlxMhwQXeUEOLIJHuINac/ejt/Yy0SNLVJIuA0wCrbminJJc",
		"hexKey": "6d36a61fa4588a194e44627feeb28a4f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "yq8MgJX0L8hYCLmKmhvxftwczE1YMdLIE1wWd1uTgfs9OFfX73g1xUgB0+AzEu6L0tBILnmNRZ7hntg3+xubhq3xp51E",
		"ivBase64": "PqtJEMySueOVN4CjqKWb4g==",
		"cipherTextBase64": "AT6rSRDMkrnjlTeAo6ilm+LJdXL7dYZP2Amo6Otn5/UQ+ivPBTqXgGJrt+gYlCTk4ifEQpAGBFtqRNcvpWpAIfKRrtox26imHfNo9SovB7UtiAUwENyKgmCYDpHopBv2sYqtNBnTG1nR414XRvOYyOUE9dbfJ0A+FItVjAdqcAGw",
		"hexKey": "16d1dfbf862592fa9a3220dc9c3b2175",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "m3EN1a4/3OufH7/NBvctbsNYCnWS8+tRohQ6EgN81Nbq2fUlBMLn4EuF8Ns2RsnmQf4NB1yA3Aj+fRXkJ4GKoPxOsBsxoA==",
		"ivBase64": "uwBeu9QSefZbyv5cfYogFA==",
		"cipherTextBase64": "AbsAXrvUEnn2W8r+XH2KIBQoPE5mJKr6KfsqLKBkJg5TMOPJ+oHJTtBfkenwYnu+qDYXRrQR8NErjtnJdg8GzwMr1646P5UgqnSC9P6vLU/uNrVNt6mpGVMNw3u2QJOPiKaub8K/FN/esXkmf6+jgzhry906fHhBwUlhPYGs1FpO",
		"hexKey": "38dcb274c7113a91202956c0934fa75d",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "YOfgOm3DF3v/idH+3k3QzwJEX3wopJb2Ud+ihIzuFRaeIix2xKywOeGd7Ac8Lg33IV0y536YNljs3GE0YfQCDy7dBMnJAJ4=",
		"ivBase64": "HZmAwJzUedNg3XlbEhk7mg==",
		"cipherTextBase64": "AR2ZgMCc1HnTYN15WxIZO5pEAEiEXdvPKGWSZMpFhoPMz4jg9L7Zghx9PuOHLPE2bg9R6x/KeR5tP1p7n1Riy2kDoAka1xrk3uKxt75Bl7T8Daf57Uzinm090I0ICaC/cASs9sFx+CQPy4+3DxpddqAObA5aLBwzxzTw9g3a8Rbb",
		"hexKey": "b30205892ef9e24062e518b155265981",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "TF3zTfYKt1a0MNlFKUjUAEA++SKIVLu2GlWpipvgiqWpWA7JbShJMXbyqjDWQna1k3v4J8vFVZehzrSx6Yjcerrzkl6dihDD",
		"ivBase64": "BshL+BIYGAhsbR0D44GZkQ==",
		"cipherTextBase64": "AQbIS/gSGBgIbG0dA+OBmZFx6qtBCbco2Bc+gJT+D612x4bbuj33EvpeRaXupPdr7VXPmYgux5XfmV53QIPqUZO4Ht3lfX14BaXiLhQ/wwAlmAWY+E464+v4H63UJ83WyW0Hn9wsbyielmwYi+tsiZJgaqgSiS6YCKvgLuEMKmrn",
		"hexKey": "082bc9ca3052d41fa3fc9ce80d7f4413",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "vtuh8ZRaK8LemolBVpDxL1/OZAFEHPDQ3STsilOOrmyuLzDaMJ7zcgYDD0K+gKbrFEEymRHiC6U0gjviSJs4pONhXqwDXh9YJw==",
		"ivBase64": "wJeHVhYeihNToj1ANaZ7vw==",
		"cipherTextBase64": "AcCXh1YWHooTU6I9QDWme79YEP6i+dk9z/im03JNADDM+6kJvw8KndQpk2FFMxeC/ozIsvdip/01otKuxlqeqr96ukVZZq28C1cy3M54KAoz5lv1dU/D4Pv6btnkwePpHUr1VI6C2A0ICs3uVr2T1JqOh+DpiRn5gx30eXX8ln7B",
		"hexKey": "5eb2dc47feebc69ff5783394a3e403b6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "gK+zRgmNFX9JxHkDUN3LoVd64LHvXBWLtwUCjZeY/L5umMaGPg0OkwRH/t6W5rkT7+78CMPd+rskS/FUnV7FDS2Oj2EObtDshwg=",
		"ivBase64": "ZlireABeUkc0ql5cneMglQ==",
		"cipherTextBase64": "AWZYq3gAXlJHNKpeXJ3jIJWdpAz3fvG/RplGw9L+pG9PrBjcUo2JyfZL/vei05utJGCBxVpp0DHNvnPmVSjFGjzofOb+WFEuIIS0gWhC1QbaA6gqCJbWMU6Bk7Xe+fsSJbC/TmmZfux6jk65BoeD43/nRpGyUudBmGNOLRGx1oNf",
		"hexKey": "89a1fa662ef06b0f816d4d372a2c6675",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "sHJjFpULKc0AIplBuANuXfACAEopxM6yciy5r6WEH1E92vKyfmFGKZl028S+R4xo+cK0EhbkB5LcJIeWJ67VgcT7TnMcSfwaMKqu",
		"ivBase64": "ftRa+3eTdxc1PLh/XONAHg==",
		"cipherTextBase64": "AX7UWvt3k3cXNTy4f1zjQB5niwH/n8HM4biT4SqXswBxu+WYR90isC6rMUD9MWNG5KdVeHXq2489ZA78t6AcQXDl4MpFKdHR8Hmr/CbOQ5f812+xTTYjG2Blg3Kp3D6SEET+31T6mvlf6a91Lf+mXI4LyvnnA8qU/BXGpS0ktlS4",
		"hexKey": "6210baa74320848bd72548a3fd61c42f",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "iZ/VRdPu4n6NoOliazQWwgJ6SShoVEHe6WufxCj6bxEOb7sUuz+umC/tLaq8ElDxe8g2FN61nyghxWRp+E1+L95eWkOuzI+a0mCOoA==",
		"ivBase64": "3z7YpDXIdHqyG3DevbZqmw==",
		"cipherTextBase64": "Ad8+2KQ1yHR6shtw3r22aptNnk9b07ISmil7flMgBgAo0WUPVknBe4H/QP9aaXTo0PIKMnuRnbzHXCQMlM3JnIhxQcK0Sgm5I685MtisNOKP2i44u+z3ziYrZoPrBZ1mIly4wi9sJgqyA/kuDJlf41PsiniBYr247+tFySO3ztuC",
		"hexKey": "57c86424671a516b6150b2e01e98d8de",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "CLLOSgv+D0yhaszfgjKP3DI38fiClkJRoApoobQIWOjnqKlwSMkewG/zwijy8gtCrVDO/rVWRYwsaTm9vEhpPE3Vxmet05FXXVh6Izc=",
		"ivBase64": "beeNWjx0AbjL+NDdu2Nq8A==",
		"cipherTextBase64": "AW3njVo8dAG4y/jQ3btjavChShB1FBQxz9K8T4jHTX+sDFQ/qwpmKeXzajiXfvTiyB+UAeAW1BGKPUZF9V3rjUoSRS2Qzd1KbEKJwQ8Rz9+w/qOcAfnqCHyiPqpK/QGMdf43CNanSmak75M4O5AL42Iti5aqH9nU8L6H50PhXZFp",
		"hexKey": "d9bd3c883fbbc032f63679be5938fda3",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "SP9E3M/TidROzfkL9vaR+smU2ROZw9AoO/T3dOTutZyLV6F03IjvlD9yass/rEJpn04xxUwnX+5W476KMVSLz2uJ+lgoji/u0NPq0Xnb",
		"ivBase64": "vGcuvPTcGDmLsHz/kvK5YQ==",
		"cipherTextBase64": "AbxnLrz03Bg5i7B8/5LyuWHxBLQEsICNoZyDglFmjQKxSGV/xY5ScCNiZmQuf8l9PAPtdZ9Y+M9pvKscN+F+FeqQRIZMWbvmkIHXlSN06YEnr5wEk/Z0gjMZ//AvYVtzdbhuvEYafeC6PZp+MKP2gLVhvnKK6ODpmQoC4s5Cb70F",
		"hexKey": "ab42db800d26fce9631ef3490d66eea6",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "nPW+kN2o7MyTjagDhl1pnmgIhpnpxL8nx1qxqVOL4xd5uJ38yQkYk68/Ijek7so4qmcsY0y2HQvNOPUfNfNt5G2CKkaoxD5O83qgGOoZaw==",
		"ivBase64": "3MGf6oc/pd+vgiSWQsaxtg==",
		"cipherTextBase64": "AdzBn+qHP6Xfr4IklkLGsbYH/1Vj4EQDAPjZTP8a+t50T12cw/mOPi5xT2mBBJPbUHgkE5Q1p88pH5eOMWNlUWIEewAsh+vQ8LcsUAZ2ZzASg4i8HBV0FLIfff0yU9lT7Jz9EzP/lycjrJWJdlzUHF4R1qUvZoMQfakuKWJVBrD8",
		"hexKey": "97dcfa519793d2d713ff6271d77cbe6c",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "BhWYcR7VmYJ0SYqsaPQ+ltOulfHcogwT8BPFn6nkckGh2LZ2I+AwhGrJ38OUJeKX5zari8VGfEf878hCTVxaYdnXbPb2er7oUz2NHqo2ycU=",
		"ivBase64": "7K4xeqITB4eZJs67T9E0IQ==",
		"cipherTextBase64": "AeyuMXqiEweHmSbOu0/RNCGlWJIivUJrT7fwLSy7bW0huHcJnrXUKZ4ft7VAPIcB8niIlYnbusBzLdqY9l40c1KA/WfUtkz6lMM6b9QSXIVRIXavSN7Izq5mgZjkydOTNxC2ALXUy7NarrksKoWMzEiyeCajKszEoLh3BSwxfNtwxSDCGxFUNW0XCOewKXJwBA==",
		"hexKey": "c1e9920c0f3f505c2cc5df12a2f75de2",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "KzQ7Ss+6XXcwjaCEAhhjhm4zWRWIvHGzxA8d8/lFzTKUr/Ml8yotZXdPcb/Q2t/VExKwZ8BREH6JeQBrskdxlyNuguH3d3JnFm41YIaiweGp",
		"ivBase64": "156Wq0sxvndJzZLr+xEkGg==",
		"cipherTextBase64": "AdeelqtLMb53Sc2S6/sRJBoNZsJWDHuzcbDYTabjO2dHLgVHcC2fFy/nyfZ5lUl5gmGvAtN9T7w+nrIp302TuMtyj3r0CfK4LEB7ePwZLoxzZaOlNb0dnvUd/wO2vVv3/qhJBjPBoEPaWfIyylo169gqB+vZ+Tm/ygCU1wSWOp5I3tq6iHnH+YS0g/paQhv+aQ==",
		"hexKey": "1248f2f0720a2cc668439ffb6ed95bcd",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "qBtBQFDeDPsfgnm9aOByOiOYhVwrvCEasNToqiy38cB+3kJtQsseheb5+c+mIHJD0iX9e6nzdgRfcia2soN/Uv04IrR724V8DzsMwbaTEYp34Q==",
		"ivBase64": "Fh2XTS1qwaJGRp7IJyn5gA==",
		"cipherTextBase64": "ARYdl00tasGiRkaeyCcp+YBFdm5ZpzhFk/ejnHqvuhEr16l41Z7wD9BbXe4M0UBPJtvOHCJHshSe8VU6zAGYbSKjBR+b1YyPrxmTA21P2OBo5I0TJ03gmmrWE6rlFkjKpr8+9l/2pQ4RKhoWE8dKab1blDbTE1zXRRGeB64+OULX6Gw5XuG/zCflFM8vKpOuXg==",
		"hexKey": "590c1ba3494972180e99601a8553a026",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "DvWZ4bu8hwKziO2TA8QxCLwPptF6JYtPsyYjroNc9Ah+UZv8MLtoG7AcUuDzI9esXM2VFy0Kl12tIa7y0mczY4HmOW+ufDAEwIKVBAmkoiRJmVQ=",
		"ivBase64": "wkCA3rQIfrxXOqYFsYl80g==",
		"cipherTextBase64": "AcJAgN60CH68VzqmBbGJfNI9Xh46uS3PP4aTcAXAA5VQ1/FQywC/K4K+KBjTBij02YTSozeXro7aIE19lr13yk20UXa3McKt8axiXocfFXxaSbCUXZIw0ROR65pu0vNqk7c/qNphLKPhb93g0z1XKf+PsML9MjedBxeT8SGre7EE0mIQlgJ4e5sjlulVneuTfw==",
		"hexKey": "b4f81b57bb9d8511e017aaf3896a83a4",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "7aCDlOOTeu4pR1SQg2UEFGmiKvUNSRJpl8VexXWVvHfQtocaJjP4MOANqYVJgFRWnzqL7R/o5X7INE23TCOrqSSJuFjnLPSbHxTnjqVagmId4TPl",
		"ivBase64": "w35rcT3n1X8GqK11a5tTIg==",
		"cipherTextBase64": "AcN+a3E959V/BqitdWubUyIxxGDD/jJom/L7b7yf03MTqAj66FY2dlyF+yb5TLw0VAgqctjK1/fJaEFKNVwn6o362HMiCmcFMCYa/clbZwv4bUboWL1l46hVraYAfEWNKs5yTs4TXkbuInL+qdg9iT9GuF2t8pOYCuqRAsd0pIS3Cc4p3x+GT7NZLWZWpakdvw==",
		"hexKey": "f8de3c51737ee01ad7a4998b30762986",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "jDaJxTf0jkPe/MWAH/23qE7NL4hkNudTnBojxFDs7vgjv/nuEHXcyA3RXYz0mKhmJy/qLOCddw6FNNthS5NyioQ/0ydngVPHyNIBoz2RDQ1IkDxw7g==",
		"ivBase64": "xP92Tzs1roCeBN765tNvzw==",
		"cipherTextBase64": "AcT/dk87Na6AngTe+ubTb8/zs8srEBDfGBr1YbrNqilbrS995+xk2NE0IuPjOmqCowlrCZI1Y6UkCcmlII0VXpnb1SN3244ae5UYpgWxu/mMEIfPsMu0q6bnOR9wfLjAZJHql7r4KTXIymk80lALTEPYV4tDTRuDauE7Bh5v46IijHlt6SoiSYBGQXzbUDUTQA==",
		"hexKey": "9a934d83cc2aba685e31ff03b2c4d5b1",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "ZTw3jlPE6FgkSoGuHssezABnqa6xAHmjKsiIUPOoGM6AzmqAhhKDvHcIudYwaEMu+SrH7/Quacw9cdOO+fMeoNwUkL2r+8TGoq2/da3zRO3Zw7Jzf+w=",
		"ivBase64": "su7kFRtU1vd+9TW92WxXaQ==",
		"cipherTextBase64": "AbLu5BUbVNb3fvU1vdlsV2kWBY4MnOdJOqFTtD/3uwCJnlJvWODHaHSjli7KC5+Oe36QkUhGJo5p2gybGM0/t3GfgePgyZizmGVh3De13vpNt260jqStmrQrhCa3eZLtoZlV4umKmdFnRHZJRieRqmfCkHx/s/StwvZjazqj6LezbWra9w+mu0iF4D3vZaaarw==",
		"hexKey": "2687fe88c1dbd78e7d9f1f2bc55df682",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "iYIY5M05ADlVnsfpR4cf3tkY7F/Kn2yxzzv4M740YHD7H4wKUeR7R0iXkvGIfqam+y4GUvGPZluWsllOx+rdRnk3ROyRK5QtXKZ2v5NmmHUcLXr3pn9s",
		"ivBase64": "rfOQaQJQ7geT13sAK1GzKA==",
		"cipherTextBase64": "Aa3zkGkCUO4Hk9d7ACtRsygJTbyXD8LWjRjfCBVLRt53GocO6QHqLzqK/X1+hCeSOu9LZnRhWyuOI+qtPDKiR00aoCjtrpfeijY5sJWbfwQcnAN02F1yvj04tlV3az1gDIO3R6QkvZeWaL6a3v7BSG6k/S7gZyq0rD3Aw1i5HsNzVVxZuB7YP5VCrrC7K24sKg==",
		"hexKey": "179991c84cb9207da8a0842b9670ba1b",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "z4gutP075b4cK4JXAaupAxYuMbgwFyZShtrsYmxqtyQLWOu1t2Az28WzBh25hSgtYDYgEAqVDNtVsDtaKczhSmE63YVH4QPogH2DR07gFYHvoldG2RFO1g==",
		"ivBase64": "gpGUgRK/Osocw4unMnp8RA==",
		"cipherTextBase64": "AYKRlIESvzrKHMOLpzJ6fET/hi1xjBVcMAHlyzUCBuqcdlz3614+xkQpA8nFBdORzyTjOiMlQGhCDLvnEC69U86WzId01VWM8C+s6MhXl9mWDg2rT4G/AFURjd1K1V/exaT0IuIwRfHQ0uoIHtaB1ffU+l/d7CsBjP77BB3ZBGZZ5WA7kCQXAl0kkyU2cBb1sA==",
		"hexKey": "867ac0ba4a1a3b042d200be0c335976c",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "BmJyuO+ZmiTu4kmKxJFFgH9TGSvUtjIQxn5zHw7y0KkJsjf881tFSVDIoG7Qd41yrCs4YIDPiHDbDcJ8Xy4h8AVMi4lTDhySnKWcYhsSN1CwNsSQP5mY0TA=",
		"ivBase64": "8TXwd71VbJhb89h/OyeJmA==",
		"cipherTextBase64": "AfE18He9VWyYW/PYfzsniZjdUAuwb1EYa7IDbZcz85m8ainCnIaaBnsrojPOSuxEyq4J50yJxnTZL+Zww6wxJb5QBOHoShld9KOvv0frwEuJKs/WIaYvqp61QrIMHmYxpHF+/Ls3aHX05flw41dS8/Q+SA0H/Y4Lc74odSxojwZ0UHjKaEGRygfPQ6IjurTIxw==",
		"hexKey": "4aa869ead1e06f2147a097a5a922a54a",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "b36/YbO/Ivb8FJO9GIVflDaWohroxzQ4MYeLf0HOXiZ9SHBrDZyFnBalWmKEoA4fOCM8C0aL1X3405pACzbZFerfIbNP3VEcLw6ZI3ceuvyt7g4yUH/OC1Jy",
		"ivBase64": "17OohdpgOt1mLvgvT5qKXw==",
		"cipherTextBase64": "AdezqIXaYDrdZi74L0+ail9iRglCF0ME1D3uurZvMZydBWwKolE1TzJm5gqGf3PU9uz0UWvRyRE81ZRObKly8mtKpx8VqbrlgPxP0S1QMl9keQBHQnZzEyEydGFaJmaAiOYBPvCCUmFV/u3hz/rn2QoGxZ+uIL001u+/9lXyK/ahW19E+TNNYe2wUB5K2Y8Y/g==",
		"hexKey": "1770dd361a295fe380dee7ad3b65e2b7",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "GF3tanYkpR6SqD7eJecHHD3961E2vFrQFFVFcCnEBc5CI2PG9Vp6NxaXtXOv47zvWbukfEn3iC/hfAVaMigjWk0WiNsD++4mNoNQbJbOOHtZ4mtpLMABkm3v4Q==",
		"ivBase64": "UNCsf84u+jaEHjEG6Qa8pg==",
		"cipherTextBase64": "AVDQrH/OLvo2hB4xBukGvKbJSrPAIxUuR67gVJZQh5zcu4nMwc/tpuEObUBPIgrsUH73/4MklDJulou74VHR6semT/19zMHpljss9nkm2k+V7QTjUR3XzzhRlDfS/WwjHtnGRtSyShob3Oej7ng6kURfwXGo8ahYASgapccFJNqEPCDAISSFI8rFA76KCrlgpA==",
		"hexKey": "0fc59d02629cf848b5484b61e0559e80",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "EHvdnUC5BnAg1BljdpdJUVSt5OZYd+CHOkRdV4ATdpsZLnEQSOhcwub+bHcyHfnNeFjJncpweXJ6ID5dmtjSs9WXZNsE76OKiJdqpSNPeRMlPqvTCnd30nG0M+s=",
		"ivBase64": "qSyNB2nbfNlsD8mhRwc1qg==",
		"cipherTextBase64": "AaksjQdp23zZbA/JoUcHNap/lBJN7JklemZDoejVDcBHKdCJhzNdd6YIX8FFF+qpCmu8M2vUc/WJN4QAqBUukUKPNU4iQhFTs/YiHjfpZqk+O12ckWZE3Nw3QA01+A7KylnL+DRpubZAs7yHTOsyfWFuMK4LKWZJ/cH3hRJKZ5JSAdHiq3edhK7pWU2TNCZmiA==",
		"hexKey": "e1fc29bf2a081cdc56a2f83ad9f508ca",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "8e+C7uDxb2c4rF9Y35KZIk37Xk8sMKwN1GqXtbbX4t+ne70esnEGv4gaEpTzVysEpBwQe6Zbho0tRrkF/v16XMGXsSqClCBcX+WTF+2kzpoH/iR/8a9wSG/bS0A1",
		"ivBase64": "hKs/0C8wtRCWmxWBJTPuJQ==",
		"cipherTextBase64": "AYSrP9AvMLUQlpsVgSUz7iXTk1oYzAo52EjneWwHLAajSQg43il+qKHePKt7AIrCZxYN4c4vveaJur9bnWowcjkt/JV7BjsbPEbyH2ntyxN25iw5EKw130wP4XR7LO2+NFyneDj0IwAO9C0+UFrtsteZCr2y7scJmH7ktRm8ZQI/l9DhU1ae5EDVtI9hHy/ZiA==",
		"hexKey": "e1c3f784f3ef70cb441fc43f03dc5971",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "NLBIS5gBV2mrQDYZPpYGTajIFIGg+p74j0gOlcL6dshi7xGokYXSw6O3FXHxe+VXXkhbuVqhH7O79QHEjqB4P77SqDQZRnTVGi4hKLdh9McqATy0wu0w6XwTQxJBcg==",
		"ivBase64": "4oJtsEj8i7jWeZvCiY2cOQ==",
		"cipherTextBase64": "AeKCbbBI/Iu41nmbwomNnDn0DM7pRFgeSju40DAGWUBWQxlslNy9yAORM3F0wBZ+1CyW+0zqKLQ2//qVjMKDihagNUu45DGjcblMgwJDZOzhYghBVBpiF8hW0x6nZk1JTWOLORQWIvVougybra7vhIuPuQwQd/rKlw8tSo7vdmgO9XN55y3gdPq9jOw3VDP/ng==",
		"hexKey": "6b706832a390a45b5695f74a48fcc095",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "WguQ2MgbTL7MqKNpse7Lb8fHtf67zM7cFDIT0eaWBmsklildbnUVVmkzV1Fdkb9iGRoJt8HrOTGJOWQgG64bAs6cJMuhnKohYrecNU5kj2Hslu9q8gUrUm8/3xKmjA4=",
		"ivBase64": "u8lpPiiv+zz5KXhDwgkBBg==",
		"cipherTextBase64": "AbvJaT4or/s8+Sl4Q8IJAQZZ2orszebPoLcrrKBYDAWQbMgNHaG3hNO1dFuj3HPE4Npyy7igJMpt/ny6TBA/IoRMvdkVGszFxZRlCdflU8pe5+Frl5YvMoAwNJ+zzZaExLGSbVae9FTtp6a4Q9hoj0EscEd9R04oZ4UVgRw8P44EKj5kwEAJaZ6dbt1bgAfP3g==",
		"hexKey": "d0a87c31af37c0f82f63fbd919af5ee8",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "D3a43hlqy1jgG2c7Vszp9gfc0Yqv0NMVaLHgsoeK/i4B3Tc2dx/4gz1QRKCpE7wErrYUMU8ezN+9bw4wC/x5PkcWK4VL2ersSF9Gcd9dvu0GV4+PWn9fRFhkW4EGk2Nr",
		"ivBase64": "G8yOul1FQzKDG9HTFashiw==",
		"cipherTextBase64": "ARvMjrpdRUMygxvR0xWrIYukCrTSqxt8rkAVYZyruWpQwpRzMZvIl24XdbqjUnci1e+X2EMqa6+pJJyNbbSLes30uNHDEIKFVkY+zw+ZvMuMvm8N+l7GxAnKl5W5Y7V7dJcJFUQ400zLd9lG3kh6EuMKJ7BOhrpI8BghevdxLPRFN2X1VMRdLbCmibCVcqI/axSORqsaAIj+a4n/ImbEfEA=",
		"hexKey": "f126c9873bd3ca4dd349017c0c247724",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "AInA32c5mDQ4y7dTrDd/I9u9yv6AVG983o93ixm1oYHrI8iKfGjAoWYI3flLEOaoKWRaI6LdDh2uHfIjy01YW5PTkr/SWcIikYTVckcKH6Fm3MzJrZ1zQEONQHNrtwOevQ==",
		"ivBase64": "KNojLMm8PV2QWsbJmKOgiA==",
		"cipherTextBase64": "ASjaIyzJvD1dkFrGyZijoIhmvp7YUPo3ie8RmNlo28F08Tf3Aoez5y6JLCNioGHTMVRcLYEt7D0uKM8U41qw+qpL8/bjAtfbSJIrDNFX6h6O/+2vej3gjolHLboEbxx0UqSpnOTJ641Kbte/SIvqDPNI+hjoffyXmmCU5yPTT0/pSqLmje8Zdt7rIFyFPbAEpzYgset0z5uoBJ9HP9EOjJg=",
		"hexKey": "4e7b87fb06f7d059c1b8fe115da9cf09",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "QfukP0W+lFXtu7J+BsMtEqHhAK31OObNHf2sOvK1qBnEwIldbedF7rkHX2v7QXWHNPh2JQfTmhRuae3MDaTELp4SY/0cI7g27zXfqIKLBgR2xRam1lFbkHEwdrXd+KOHcWQ=",
		"ivBase64": "WTFluX3uVbUh9oCnHmavMw==",
		"cipherTextBase64": "AVkxZbl97lW1IfaApx5mrzPeU4XCYmsxN5W0poUu9Hs+5aiQ7TP0GCz2KVCqNwIWWOIvUNlNiNiv28UyW4iqqdRdUnYssvovG3vT+bUgmC68Kl9qGJI6GisCqIuZvfIClv6Grs5QU34WAXLRrfoqwyKVjDuMjxCW1P0IbvBLoJ8cgjumd38gXglXY9MH8EQYlhFLLfbJbdK97yB6ts5s7n4=",
		"hexKey": "34685b0fad34709ce7b4640167c6077a",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	},
	{
		"plainTextBase64": "iuPm5a3hM6OjuaUAYP47QeOjp0640otrDGnp0Qsk+4KyuChCXv0GtLMO85POrCTfFYigMzsV/+KtZpyRzygJ4C1CyFQMr1Yze0zPOXfXvPtzEqatCiiXjHaas2oBx7UvYdk2",
		"ivBase64": "I3uj9fze7UvnoFWUb3QVcg==",
		"cipherTextBase64": "ASN7o/X83u1L56BVlG90FXIiyxc0q0da1GcAiuQiGJvVUijbM9uT0XQCxPTtkzKf8W4BaDcMwuHcZ4I/zzcZbJfCmv2I8qTyLJBu2GinFpo3W1EkknxY91rKraMbXIxQEbZN5nReb8Zcw5G8MY2vQ8TQMDh7THmB4/PST7DwqZPLpvaO7Ks67vJsZSbkgHxyVO6ZetgYzCxOOVz8SGH4lrw=",
		"hexKey": "de2194fc4f7e4788c14b47f06d388d4d",
		"keyToEncrypt256": null,
		"keyToEncrypt128": null,
		"encryptedKey256": null,
		"encryptedKey128": null
	}
];
var encodingTests = [
	{
		"string": "Itrntinliztin",
		"encodedString": "ScOxdMOrcm7DonRpw7Ruw6BsaXrDpnRpw7hu4piD8J+SqQ=="
	},
	{
		"string": "dam",
		"encodedString": "xIBkYW0="
	},
	{
		"string": "';Ocw",
		"encodedString": "Eyc7T2N3wovCn8Kzw4fDm8OvxIPEl8SrxL/Fk8WnxbvGj8ajxrfHi8efx7PIh8ibyK/Jg8mXyavJv8qTyqfKu8uPy6PLt8yLzJ/Ms82HzZvNr86Jzp/OtM+Iz5zPsNCE0JjQrNGA0ZTRqNG80pDSpNK404zToNO01IjUnNSx1YXVm9Wv1oPWmtau14LXntiB2JXYqdi92ZHZpdm52o3aodq124nbndux3IXcmtyu3YLdmN2s3oDelN6o34rfnt+y4KCI"
	},
	{
		"string": "",
		"encodedString": "4KCc4KCy4KGH4KGb4KG34KKL4KKm4KK64KOO4KOi4KO24KSK4KSe4KSy4KWG4KWa4KWu4KaC4Kab4Kaw4KeO4Kex4KiI4Kii4Ki84Kmp4KqI4Kqe4Kq14KuN4Ku74KyV4Kyq4K2C4K2o4K6H4K6q4K+I4K+z4LCM4LCi4LC34LGW4LG44LKM4LKi4LK44LOd4LSB4LSX4LSr4LS/4LWZ4LWv4LaF4Lac4Law4LeP4Ler4LiN4Lih4Li14LmN4LqI4Lqd4Lqz4LuL4LyC4LyW4Lyq4Ly+4L2T4L2n4L2/4L6T4L6o4L684L+S4YCL4YCf4YCz4YGH4YGb4YGv4YKD4YKX4YKr4YK/4YOb4YOv4YSD4YSX4YSr4YS/4YWT4YWn4YW74YaP4Yaj4Ya3"
	},
	{
		"string": "",
		"encodedString": "4YeL4Yef4Yez4YiH4Yib4Yiv4YmD4Ymc4Ymy4YqG4Yqd4Yqy4YuM4Yuh4Yu14YyJ4Yyg4Yy04Y2I4Y2e4Y2y4Y6J4Y6j4Y634Y+L4Y+f4Y+z4ZCL4ZCf4ZCz4ZGH4ZGb4ZGv4ZKD4ZKX4ZKr4ZK/4ZOT4ZOn4ZO74ZSP4ZSj4ZS34ZWL4ZWf4ZWz4ZaH4Zab4Zav4ZeD4ZeX4Zer4Ze/4ZiT4Zin4Zi74ZmP4Zmj4Zm34ZqL4Zqi4Zq24ZuK4Zue4Zuy4ZyN4Zyq4Z2H4Z2n4Z6J4Z6d4Z6x4Z+F4Z+Z4Z+14aCP4aCp4aC94aGR4aGl4aKA4aKU4aKo4aOB4aOV4aOp4aSH4aSb4aS04aWP4aWj4aaE4aaY4aaw4aeE4aeh4ae14aiJ4aif4aiz"
	},
	{
		"string": "",
		"encodedString": "4amH4amb4amw4aqG4aqm4aq84ayB4ayV4ayp4ay94a2U4a2o4a284a6R4a6l4a654a+N4a+h4a+94bCR4bCl4bC84bGT4bGn4bG74bKW4bKq4bOA4bOc4bOw4bSJ4bSd4bSx4bWF4bWZ4bWt4baB4baV4bap4ba94beR4bel4be54biN4bih4bi14bmJ4bmd4bmx4bqF4bqZ4bqt4buB4buV4bup4bu94byR4byp4by94b2V4b2t4b6D4b6X4b6r4b+A4b+X4b+s4oCE4oCY4oCs4oGA4oGU4oGp4oG/4oKU4oKr4oK/4oOi4oSF4oSZ4oSt4oWB4oWV4oWp4oW94oaV4oap4oa94oeR4oel4oe54oiN4oih4oi14omJ4omd4omx4oqF4oqZ4oqt"
	},
	{
		"string": "",
		"encodedString": "4ouB4ouV4oup4ou94oyR4oyl4oy54o2N4o2h4o214o6J4o6d4o6x4o+F4o+Z4o+t4pCB4pCV4pGC4pGr4pG/4pKT4pKn4pK74pOP4pOj4pO34pSL4pSf4pSz4pWH4pWb4pWv4paD4paX4par4pa/4peT4pen4pe74piP4pij4pi34pmL4pmf4pmz4pqH4pqb4pqv4puD4puX4pur4pu/4pyT4pyn4py74p2P4p2j4p234p6L4p6f4p6z4p+H4p+b4p+v4qCD4qCX4qCr4qC/4qGT4qGn4qG74qKP4qKj4qK34qOL4qOf4qOz4qSH4qSb4qSv4qWD4qWX4qWr4qW/4qaT4qan4qa74qeP4qej4qe34qiL4qif4qiz4qmH4qmb4qmv4qqD4qqX4qqr"
	},
	{
		"string": "",
		"encodedString": "4qq/4quT4qun4qu74qyP4qyj4qy34q2L4q2f4q2z4q6J4q6e4q6y4q+G4q+a4q+u4rCC4rCW4rCq4rC+4rGS4rGm4rG64rKO4rKi4rK24rOK4rOe4rOy4rSL4rSf4rS74rWP4rWj4raM4raq4reB4reY4ret4riB4riV4rip4ri94rmR4rqH4rqc4rqw4ruE4ruY4rus4ryM4ryg4ry04r2I4r2c4r2w4r6E4r6Y4r6s4r+A4r+U44CG44Ca44Cu44GD44GX44Gr44G/44KT44Kp44K944OR44Ol44O544SS44Sm44S744WP44Wj44W344aL44ag44a044eI44ec44e844iQ44il44i544mN44mh44m144qJ44qd44qx44uF44uZ44ut44yB44yV"
	},
	{
		"string": "",
		"encodedString": "44yp44y9442R442l4425446N446h446144+J44+d44+x45CF45CZ45Ct45GB45GV45Gp45G945KR45Kl45K545ON45Oh45O145SJ45Sd45Sx45WF45WZ45Wt45aB45aV45ap45a945eR45el45e545iN45ih45i145mJ45md45mx45qF45qZ45qt45uB45uV45up45u945yR45yl45y5452N452h4521456J456d456x45+F45+Z45+t46CB46CV46Cp46C946GR46Gl46G546KN46Kh46K146OJ46Od46Ox46SF46SZ46St46WB46WV46Wp46W946aR46al46a546eN46eh46e146iJ46id46ix46mF46mZ46mt46qB46qV46qp46q946uR46ul"
	},
	{
		"string": "",
		"encodedString": "46u546yN46yh46y1462J462d462x466F466Z466t46+B46+V46+p46+947CR47Cl47C547GN47Gh47G147KJ47Kd47Kx47OF47OZ47Ot47SB47SV47Sp47S947WR47Wl47W547aN47ah47a147eJ47ed47ex47iF47iZ47it47mB47mV47mp47m947qR47ql47q547uN47uh47u147yJ47yd47yx472F472Z472t476B476V476p476947+R47+l47+55ICN5ICh5IC15IGJ5IGd5IGx5IKF5IKZ5IKt5IOB5IOV5IOp5IO95ISR5ISl5IS55IWN5IWh5IW15IaJ5Iad5Iax5IeF5IeZ5Iet5IiB5IiV5Iip5Ii95ImR5Iml5Im55IqN5Iqh5Iq1"
	},
	{
		"string": "",
		"encodedString": "5IuJ5Iud5Iux5IyF5IyZ5Iyt5I2B5I2V5I2p5I295I6R5I6l5I655I+N5I+h5I+15JCJ5JCd5JCx5JGF5JGZ5JGt5JKB5JKV5JKp5JK95JOR5JOl5JO55JSN5JSh5JS15JWJ5JWd5JWx5JaF5JaZ5Jat5JeB5JeV5Jep5Je95JiR5Jil5Ji55JmN5Jmh5Jm15JqJ5Jqd5Jqx5JuF5JuZ5Jut5JyB5JyV5Jyp5Jy95J2R5J2l5J255J6N5J6h5J615J+J5J+d5J+x5KCF5KCZ5KCt5KGB5KGV5KGp5KG95KKR5KKl5KK55KON5KOh5KO15KSJ5KSd5KSx5KWF5KWZ5KWt5KaB5KaV5Kap5Ka95KeR5Kel5Ke55KiN5Kih5Ki15KmJ5Kmd5Kmx5KqF"
	},
	{
		"string": "",
		"encodedString": "5KqZ5Kqt5KuB5KuV5Kup5Ku95KyR5Kyl5Ky55K2N5K2h5K215K6J5K6d5K6x5K+F5K+Z5K+t5LCB5LCV5LCp5LC95LGR5LGl5LG55LKN5LKh5LK15LOJ5LOd5LOx5LSF5LSZ5LSt5LWB5LWV5LWp5LW95LaR5Lal5La55LeN5Leh5Le15LiJ5Lid5Lix5LmF5LmZ5Lmt5LqB5LqV5Lqp5Lq95LuR5Lul5Lu55LyN5Lyh5Ly15L2J5L2d5L2x5L6F5L6Z5L6t5L+B5L+V5L+p5L+95YCR5YCl5YC55YGN5YGh5YG15YKJ5YKd5YKx5YOF5YOZ5YOt5YSB5YSV5YSp5YS95YWR5YWl5YW55YaN5Yah5Ya15YeJ5Yed5Yex5YiF5YiZ5Yit5YmB5YmV"
	},
	{
		"string": "",
		"encodedString": "5Ymp5Ym95YqR5Yql5Yq55YuN5Yuh5Yu15YyJ5Yyd5Yyx5Y2F5Y2Z5Y2t5Y6B5Y6V5Y6p5Y695Y+R5Y+l5Y+55ZCN5ZCh5ZC15ZGJ5ZGd5ZGx5ZKF5ZKZ5ZKt5ZOB5ZOV5ZOp5ZO95ZSR5ZSl5ZS55ZWN5ZWh5ZW15ZaJ5Zad5Zax5ZeF5ZeZ5Zet5ZiB5ZiV5Zip5Zi95ZmR5Zml5Zm55ZqN5Zqh5Zq15ZuJ5Zud5Zux5ZyF5ZyZ5Zyt5Z2B5Z2V5Z2p5Z295Z6R5Z6l5Z655Z+N5Z+h5Z+15aCJ5aCd5aCx5aGF5aGZ5aGt5aKB5aKV5aKp5aK95aOR5aOl5aO55aSN5aSh5aS15aWJ5aWd5aWx5aaF5aaZ5aat5aeB5aeV5aep5ae95aiR5ail"
	},
	{
		"string": "",
		"encodedString": "5ai55amN5amh5am15aqJ5aqd5aqx5auF5auZ5aut5ayB5ayV5ayp5ay95a2R5a2l5a255a6N5a6h5a615a+J5a+d5a+x5bCF5bCZ5bCt5bGB5bGV5bGp5bG95bKR5bKl5bK55bON5bOh5bO15bSJ5bSd5bSx5bWF5bWZ5bWt5baB5baV5bap5ba95beR5bel5be55biN5bih5bi15bmJ5bmd5bmx5bqF5bqZ5bqt5buB5buV5bup5bu95byR5byl5by55b2N5b2h5b215b6J5b6d5b6x5b+F5b+Z5b+t5oCB5oCV5oCp5oC95oGR5oGl5oG55oKN5oKh5oK15oOJ5oOd5oOx5oSF5oSZ5oSt5oWB5oWV5oWp5oW95oaR5oal5oa55oeN5oeh5oe1"
	},
	{
		"string": "",
		"encodedString": "5oiJ5oid5oix5omF5omZ5omt5oqB5oqV5oqp5oq95ouR5oul5ou55oyN5oyh5oy15o2J5o2d5o2x5o6F5o6Z5o6t5o+B5o+V5o+p5o+95pCR5pCl5pC55pGN5pGh5pG15pKJ5pKd5pKx5pOF5pOZ5pOt5pSB5pSV5pSp5pS95pWR5pWl5pW55paN5pah5pa15peJ5ped5pex5piF5piZ5pit5pmB5pmV5pmp5pm95pqR5pql5pq55puN5puh5pu15pyJ5pyd5pyx5p2F5p2Z5p2t5p6B5p6V5p6p5p695p+R5p+l5p+55qCN5qCh5qC15qGJ5qGd5qGx5qKF5qKZ5qKt5qOB5qOV5qOp5qO95qSR5qSl5qS55qWN5qWh5qW15qaJ5qad5qax5qeF"
	},
	{
		"string": "",
		"encodedString": "5qeZ5qet5qiB5qiV5qip5qi95qmR5qml5qm55qqN5qqh5qq15quJ5qud5qux5qyF5qyZ5qyt5q2B5q2V5q2p5q295q6R5q6l5q655q+N5q+h5q+15rCJ5rCd5rCx5rGF5rGZ5rGt5rKB5rKV5rKp5rK95rOR5rOl5rO55rSN5rSh5rS15rWJ5rWd5rWx5raF5raZ5rat5reB5reV5rep5re95riR5ril5ri55rmN5rmh5rm15rqJ5rqd5rqx5ruF5ruZ5rut5ryB5ryV5ryp5ry95r2R5r2l5r255r6N5r6h5r615r+J5r+d5r+x54CF54CZ54Ct54GB54GV54Gp54G954KR54Kl54K554ON54Oh54O154SJ54Sd54Sx54WF54WZ54Wt54aB54aV"
	},
	{
		"string": "",
		"encodedString": "54ap54a954eR54el54e554iN54ih54i154mJ54md54mx54qF54qZ54qt54uB54uV54up54u954yR54yl54y5542N542h5421546J546d546x54+F54+Z54+t55CB55CV55Cp55C955GR55Gl55G555KN55Kh55K155OJ55Od55Ox55SF55SZ55St55WB55WV55Wp55W955aR55al55a555eN55eh55e155iJ55id55ix55mF55mZ55mt55qB55qV55qp55q955uR55ul55u555yN55yh55y1552J552d552x556F556Z556t55+B55+V55+p55+956CR56Cl56C556GN56Gh56G156KJ56Kd56Kx56OF56OZ56Ot56SB56SV56Sp56S956WR56Wl"
	},
	{
		"string": "",
		"encodedString": "56W556aN56ah56a156eJ56ed56ex56iF56iZ56it56mB56mV56mp56m956qR56ql56q556uN56uh56u156yJ56yd56yx562F562Z562t566B566V566p566956+R56+l56+557CN57Ch57C157GJ57Gd57Gx57KF57KZ57Kt57OB57OV57Op57O957SR57Sl57S557WN57Wh57W157aJ57ad57ax57eF57eZ57et57iB57iV57ip57i957mR57ml57m557qN57qh57q157uJ57ud57ux57yF57yZ57yt572B572V572p5729576R576l576557+N57+h57+16ICJ6ICd6ICx6IGF6IGZ6IGt6IKB6IKV6IKp6IK96IOR6IOl6IO56ISN6ISh6IS1"
	},
	{
		"string": "",
		"encodedString": "6IWJ6IWd6IWx6IaF6IaZ6Iat6IeB6IeV6Iep6Ie96IiR6Iil6Ii56ImN6Imh6Im16IqJ6Iqd6Iqx6IuF6IuZ6Iut6IyB6IyV6Iyp6Iy96I2R6I2l6I256I6N6I6h6I616I+J6I+d6I+x6JCF6JCZ6JCt6JGB6JGV6JGp6JG96JKR6JKl6JK56JON6JOh6JO16JSJ6JSd6JSx6JWF6JWZ6JWt6JaB6JaV6Jap6Ja96JeR6Jel6Je56JiN6Jih6Ji16JmJ6Jmd6Jmx6JqF6JqZ6Jqt6JuB6JuV6Jup6Ju96JyR6Jyl6Jy56J2N6J2h6J216J6J6J6d6J6x6J+F6J+Z6J+t6KCB6KCV6KCp6KC96KGR6KGl6KG56KKN6KKh6KK16KOJ6KOd6KOx6KSF"
	},
	{
		"string": "",
		"encodedString": "6KSZ6KSt6KWB6KWV6KWp6KW96KaR6Kal6Ka56KeN6Keh6Ke16KiJ6Kid6Kix6KmF6KmZ6Kmt6KqB6KqV6Kqp6Kq96KuR6Kul6Ku56KyN6Kyh6Ky16K2J6K2d6K2x6K6F6K6Z6K6t6K+B6K+V6K+p6K+96LCR6LCl6LC56LGN6LGh6LG16LKJ6LKd6LKx6LOF6LOZ6LOt6LSB6LSV6LSp6LS96LWR6LWl6LW56LaN6Lah6La16LeJ6Led6Lex6LiF6LiZ6Lit6LmB6LmV6Lmp6Lm96LqR6Lql6Lq56LuN6Luh6Lu16LyJ6Lyd6Lyx6L2F6L2Z6L2t6L6B6L6V6L6p6L696L+R6L+l6L+56YCN6YCh6YC16YGJ6YGd6YGx6YKF6YKZ6YKt6YOB6YOV"
	},
	{
		"string": "",
		"encodedString": "6YOp6YO96YSR6YSl6YS56YWN6YWh6YW16YaJ6Yad6Yax6YeF6YeZ6Yet6YiB6YiV6Yip6Yi96YmR6Yml6Ym56YqN6Yqh6Yq16YuJ6Yud6Yux6YyF6YyZ6Yyt6Y2B6Y2V6Y2p6Y296Y6R6Y6l6Y656Y+N6Y+h6Y+16ZCJ6ZCd6ZCx6ZGF6ZGZ6ZGt6ZKB6ZKV6ZKp6ZK96ZOR6ZOl6ZO56ZSN6ZSh6ZS16ZWJ6ZWd6ZWx6ZaF6ZaZ6Zat6ZeB6ZeV6Zep6Ze96ZiR6Zil6Zi56ZmN6Zmh6Zm16ZqJ6Zqd6Zqx6ZuF6ZuZ6Zut6ZyB6ZyV6Zyp6Zy96Z2R6Z2l6Z256Z6N6Z6h6Z616Z+J6Z+d6Z+x6aCF6aCZ6aCt6aGB6aGV6aGp6aG96aKR6aKl"
	},
	{
		"string": "",
		"encodedString": "6aK56aON6aOh6aO16aSJ6aSd6aSx6aWF6aWZ6aWt6aaB6aaV6aap6aa96aeR6ael6ae56aiN6aih6ai16amJ6amd6amx6aqF6aqZ6aqt6auB6auV6aup6au96ayR6ayl6ay56a2N6a2h6a216a6J6a6d6a6x6a+F6a+Z6a+t6bCB6bCV6bCp6bC96bGR6bGl6bG56bKN6bKh6bK16bOJ6bOd6bOx6bSF6bSZ6bSt6bWB6bWV6bWp6bW96baR6bal6ba56beN6beh6be16biJ6bid6bix6bmF6bmZ6bmt6bqB6bqV6bqp6bq96buR6bul6bu56byN6byh6by16b2J6b2d6b2x6b6F6b6Z6b6t6b+B6b+V6b+p6b+96oCR6oCl6oC56oGN6oGh6oG1"
	},
	{
		"string": "",
		"encodedString": "6oKJ6oKd6oKx6oOF6oOZ6oOt6oSB6oSV6oSp6oS96oWR6oWl6oW56oaN6oah6oa16oeJ6oed6oex6oiF6oiZ6oit6omB6omV6omp6om96oqR6oql6oq56ouN6ouh6ou16oyJ6oyd6oyx6o2F6o2Z6o2t6o6B6o6V6o6p6o696o+R6o+l6o+56pCN6pCh6pC16pGJ6pGd6pGx6pKF6pKc6pKw6pOE6pOh6pO16pSJ6pSd6pSx6pWF6pWZ6pWt6paB6paV6pap6pa96peR6pel6pe56piN6pih6pmJ6pmd6pmx6pqF6pqZ6pqt6puB6puV6pup6pyF6pyZ6pyt6p2B6p2V6p2p6p296p6R6p6l6p656p+T6qCA6qCU6qCo6qGF6qGZ6qGt6qKJ6qKd"
	},
	{
		"string": "",
		"encodedString": "6qKx6qOF6qOn6qO76qSP6qSj6qS36qWL6qWq6qaB6qaV6qap6qa96qeS6qeq6qe+6qiT6qin6qmE6qmc6qmw6qqE6qqY6qqs6quA6qus6qyM6qys6q2B6q2V6q2p6q6B6q6V6q6p6q696q+R6q+l6rCB6rCV6rCp6rC96rGR6rGl6rG56rKN6rKh6rK16rOJ6rOd6rOx6rSF6rSZ6rSt6rWB6rWV6rWp6rW96raR6ral6ra56reN6reh6re16riJ6rid6rix6rmF6rmZ6rmt6rqB6rqV6rqp6rq96ruR6rul6ru56ryN6ryh6ry16r2J6r2d6r2x6r6F6r6Z6r6t6r+B6r+V6r+p6r+964CR64Cl64C564GN64Gh64G164KJ64Kd64Kx64OF64OZ"
	},
	{
		"string": "",
		"encodedString": "64Ot64SB64SV64Sp64S964WR64Wl64W564aN64ah64a164eJ64ed64ex64iF64iZ64it64mB64mV64mp64m964qR64ql64q564uN64uh64u164yJ64yd64yx642F642Z642t646B646V646p646964+R64+l64+565CN65Ch65C165GJ65Gd65Gx65KF65KZ65Kt65OB65OV65Op65O965SR65Sl65S565WN65Wh65W165aJ65ad65ax65eF65eZ65et65iB65iV65ip65i965mR65ml65m565qN65qh65q165uJ65ud65ux65yF65yZ65yt652B652V652p6529656R656l656565+N65+h65+166CJ66Cd66Cx66GF66GZ66Gt66KB66KV66Kp"
	},
	{
		"string": "",
		"encodedString": "66K966OR66Ol66O566SN66Sh66S166WJ66Wd66Wx66aF66aZ66at66eB66eV66ep66e966iR66il66i566mN66mh66m166qJ66qd66qx66uF66uZ66ut66yB66yV66yp66y9662R662l6625666N666h666166+J66+d66+x67CF67CZ67Ct67GB67GV67Gp67G967KR67Kl67K567ON67Oh67O167SJ67Sd67Sx67WF67WZ67Wt67aB67aV67ap67a967eR67el67e567iN67ih67i167mJ67md67mx67qF67qZ67qt67uB67uV67up67u967yR67yl67y5672N672h6721676J676d676x67+F67+Z67+t7ICB7ICV7ICp7IC97IGR7IGl7IG5"
	},
	{
		"string": "",
		"encodedString": "7IKN7IKh7IK17IOJ7IOd7IOx7ISF7ISZ7ISt7IWB7IWV7IWp7IW97IaR7Ial7Ia57IeN7Ieh7Ie17IiJ7Iid7Iix7ImF7ImZ7Imt7IqB7IqV7Iqp7Iq97IuR7Iul7Iu57IyN7Iyh7Iy17I2J7I2d7I2x7I6F7I6Z7I6t7I+B7I+V7I+p7I+97JCR7JCl7JC57JGN7JGh7JG17JKJ7JKd7JKx7JOF7JOZ7JOt7JSB7JSV7JSp7JS97JWR7JWl7JW57JaN7Jah7Ja17JeJ7Jed7Jex7JiF7JiZ7Jit7JmB7JmV7Jmp7Jm97JqR7Jql7Jq57JuN7Juh7Ju17JyJ7Jyd7Jyx7J2F7J2Z7J2t7J6B7J6V7J6p7J697J+R7J+l7J+57KCN7KCh7KC17KGJ"
	},
	{
		"string": "",
		"encodedString": "7KGd7KGx7KKF7KKZ7KKt7KOB7KOV7KOp7KO97KSR7KSl7KS57KWN7KWh7KW17KaJ7Kad7Kax7KeF7KeZ7Ket7KiB7KiV7Kip7Ki97KmR7Kml7Km57KqN7Kqh7Kq17KuJ7Kud7Kux7KyF7KyZ7Kyt7K2B7K2V7K2p7K297K6R7K6l7K657K+N7K+h7K+17LCJ7LCd7LCx7LGF7LGZ7LGt7LKB7LKV7LKp7LK97LOR7LOl7LO57LSN7LSh7LS17LWJ7LWd7LWx7LaF7LaZ7Lat7LeB7LeV7Lep7Le97LiR7Lil7Li57LmN7Lmh7Lm17LqJ7Lqd7Lqx7LuF7LuZ7Lut7LyB7LyV7Lyp7Ly97L2R7L2l7L257L6N7L6h7L617L+J7L+d7L+x7YCF7YCZ"
	},
	{
		"string": "",
		"encodedString": "7YCt7YGB7YGV7YGp7YG97YKR7YKl7YK57YON7YOh7YO17YSJ7YSd7YSx7YWF7YWZ7YWt7YaB7YaV7Yap7Ya97YeR7Yel7Ye57YiN7Yih7Yi17YmJ7Ymd7Ymx7YqF7YqZ7Yqt7YuB7YuV7Yup7Yu97YyR7Yyl7Yy57Y2N7Y2h7Y217Y6J7Y6d7Y6x7Y+F7Y+Z7Y+t7ZCB7ZCV7ZCp7ZC97ZGR7ZGl7ZG57ZKN7ZKh7ZK17ZOJ7ZOd7ZOx7ZSF7ZSZ7ZSt7ZWB7ZWV7ZWp7ZW97ZaR7Zal7Za57ZeN7Zeh7Ze17ZiJ7Zid7Zix7ZmF7ZmZ7Zmt7ZqB7ZqV7Zqp7Zq97ZuR7Zul7Zu57ZyN7Zyh7Zy17Z2J7Z2d7Z2x7Z6F7Z6Z7Z657Z+R7Z+l7Z+5"
	},
	{
		"string": "",
		"encodedString": "7oCR7oCl7oC57oGN7oGh7oG17oKJ7oKd7oKx7oOF7oOZ7oOt7oSB7oSV7oSp7oS97oWR7oWl7oW57oaN7oah7oa17oeJ7oed7oex7oiF7oiZ7oit7omB7omV7omp7om97oqR7oql7oq57ouN7ouh7ou17oyJ7oyd7oyx7o2F7o2Z7o2t7o6B7o6V7o6p7o697o+R7o+l7o+57pCN7pCh7pC17pGJ7pGd7pGx7pKF7pKZ7pKt7pOB7pOV7pOp7pO97pSR7pSl7pS57pWN7pWh7pW17paJ7pad7pax7peF7peZ7pet7piB7piV7pip7pi97pmR7pml7pm57pqN7pqh7pq17puJ7pud7pux7pyF7pyZ7pyt7p2B7p2V7p2p7p297p6R7p6l7p657p+N"
	},
	{
		"string": "",
		"encodedString": "7p+h7p+17qCJ7qCd7qCx7qGF7qGZ7qGt7qKB7qKV7qKp7qK97qOR7qOl7qO57qSN7qSh7qS17qWJ7qWd7qWx7qaF7qaZ7qat7qeB7qeV7qep7qe97qiR7qil7qi57qmN7qmh7qm17qqJ7qqd7qqx7quF7quZ7qut7qyB7qyV7qyp7qy97q2R7q2l7q257q6N7q6h7q617q+J7q+d7q+x7rCF7rCZ7rCt7rGB7rGV7rGp7rG97rKR7rKl7rK57rON7rOh7rO17rSJ7rSd7rSx7rWF7rWZ7rWt7raB7raV7rap7ra97reR7rel7re57riN7rih7ri17rmJ7rmd7rmx7rqF7rqZ7rqt7ruB7ruV7rup7ru97ryR7ryl7ry57r2N7r2h7r217r6J7r6d"
	},
	{
		"string": "",
		"encodedString": "7r6x7r+F7r+Z7r+t74CB74CV74Cp74C974GR74Gl74G574KN74Kh74K174OJ74Od74Ox74SF74SZ74St74WB74WV74Wp74W974aR74al74a574eN74eh74e174iJ74id74ix74mF74mZ74mt74qB74qV74qp74q974uR74ul74u574yN74yh74y1742J742d742x746F746Z746t74+B74+V74+p74+975CR75Cl75C575GN75Gh75G175KJ75Kd75Kx75OF75OZ75Ot75SB75SV75Sp75S975WR75Wl75W575aN75ah75a175eJ75ed75ex75iF75iZ75it75mB75mV75mp75m975qR75ql75q575uN75uh75u175yJ75yd75yx752F752Z752t"
	},
	{
		"string": "",
		"encodedString": "756B756V756p756975+R75+l75+576CN76Ch76C176GJ76Gd76Gx76KF76KZ76Kt76OB76OV76Op76O976SR76Sl76S576WN76Wh76W176aJ76ad76ax76eF76eZ76et76iB76iV76ip76i976mR76ml76m776qP76qj76q376uL76yF76yq762B762X762r762/766T766n766776+f76+z77CH77Cb77Cv77GD77GX77Gr77G/77KT77Kn77K777OP77Oj77O377SL77Sf77Sz77WH77Wb77Wv77aD77aZ77at77eB77e877iQ77iq77i+77mS77mo77qB77qV77qp77q977uR77ul77u577yQ77yk77y4772M772g7720776I776c776w77+H"
	},
	{
		"string": "",
		"encodedString": "77+k8JCAhfCQgJrwkICv8JCBhfCQgZvwkIKR8JCCpfCQgrnwkION8JCDofCQg7XwkISS8JCEpvCQhL3wkIWR8JCFpfCQhbnwkIaN8JCHlPCQh6jwkIe88JCKkvCQiqnwkIq98JCLoPCQi7TwkIyM8JCMoPCQjL3wkI2W8JCNqvCQjoPwkI6X8JCOrPCQj4DwkJCC8JCQlvCQkKrwkJC+8JCRkvCQkabwkJG68JCSjvCQkqTwkJK+8JCTkvCQk6rwkJSC8JCUlvCQlLLwkJWG8JCVmvCQlbnwkJaP8JCWpvCQlrzwkJiT8JCYp/CQmLvwkJmP8JCZo/CQmbfwkJqL8JCan/CQmrPwkJuH8JCbm/CQm6/wkJyD8JCcl/CQnKvwkJ2I8JCdpvCQnpPwkJ6n8JCggfCQoJjwkKCs8JChhvCQoZvwkKGv8JCig/CQopfwkKOj8JCjvfCQpJHwkKSo8JCmgfCQppXwkKap8JCngfCQp5fwkKer8JCnv/CQqJvwkKiv8JCpkPCQqavwkKm/"
	},
	{
		"string": "",
		"encodedString": "8JCqk/CQq4fwkKub8JCrs/CQrJDwkKyk8JCsu/CQrY/wkK2l8JCtvvCQrpnwkLCJ8JCwnfCQsLHwkLGF8JCykPCQsqTwkLOF8JCzmfCQs63wkLSI8JC0nPCQtLjwkLmy8JC6h/CQupvwkLu98JC8kfCQvKXwkL2B8JC9lfCQvb/wkL658JC/ofCQv7XwkYCS8JGApvCRgLrwkYGS8JGBpvCRgoPwkYKX8JGCq/CRgr/wkYOf8JGEgPCRhJTwkYSo8JGEvfCRhZnwkYWt8JGGivCRhp7wkYay8JGHhvCRh5rwkYev8JGIjvCRiKPwkYi38JGKi/CRiqHwkYq78JGLj/CRi6PwkYyC8JGMm/CRjLDwkY2L8JGNsfCRkJDwkZCk8JGQuPCRkYzwkZGh8JGSk/CRkqfwkZK78JGTl/CRlpHwkZal8JGWu/CRl4/wkZiF8JGYmfCRmK3wkZmB8JGZpvCRmo3wkZqh8JGatfCRnIXwkZyZ8JGcs/CRoIDwkaCU8JGgqPCRoqDwkaK08JGjiA=="
	},
	{
		"string": "",
		"encodedString": "8JGjnPCRo7DwkaSV8JGkqvCRpYHwkaak8JGmuvCRp47wkaek8JGok/CRqKfwkai78JGpl/CRqavwkam/8JGqk/CRqrTwkauI8JGrnPCRq7DwkbCB8JGwlvCRsKrwkbC/8JGxnfCRsbTwkbKI8JGynvCRsrPwkbSS8JG0pvCRtL/wkbWh8JG1t/CRtovwkbao8JG7svCRvI3wkbyi8JG8tvCRvY3wkb+G8JG/mvCRv67wkoCP8JKAo/CSgLfwkoGL8JKBn/CSgbPwkoKH8JKCm/CSgq/wkoOD8JKDl/CSg6vwkoO/8JKEk/CShKfwkoS78JKFj/CShaPwkoW38JKGi/CShp/wkoaz8JKHh/CSh5vwkoev8JKIg/CSiJfwkoir8JKIv/CSiZPwkomn8JKJu/CSio/wkoqj8JKKt/CSi4vwkouf8JKLs/CSjIfwkoyb8JKMr/CSjYPwko2X8JKNq/CSjb/wko6T8JKQjfCSkKHwkpC18JKRifCSkZ3wkpGy8JKSkfCSkqXwkpK58JKTjQ=="
	},
	{
		"string": "",
		"encodedString": "8JKTofCSk7XwkpSJ8JKUnfCSlLHwkr6R8JK+pfCSvrnwkr+N8JK/ofCTgILwk4CW8JOAqvCTgL7wk4GS8JOBpvCTgbrwk4KO8JOCovCTgrbwk4OK8JODnvCTg7Lwk4SG8JOEmvCThK7wk4WC8JOFlvCTharwk4W+8JOGkvCThqbwk4a68JOHjvCTh6Lwk4e28JOIivCTiJ7wk4iy8JOJhvCTiZrwk4mu8JOKgvCTipbwk4qq8JOKvvCTi5Lwk4um8JOLuvCTjI7wk4yi8JOMtvCTjYrwk42e8JONsvCTjobwk46a8JOOrvCTj4Lwk4+W8JOPqvCTj77wk5CS8JOQpvCTkLrwk5GO8JSQjPCUkKDwlJC08JSRiPCUkZzwlJGw8JSShPCUkpjwlJKs8JSTgPCUk5TwlJOo8JSTvPCUlJDwlJSk8JSUuPCUlYzwlJWg8JSVtPCUlojwlJac8JSWsPCUl4TwlJeY8JSXrPCUmIDwlJiU8JSYqPCUmLzwlqCJ8JagnfCWoLHwlqGF8JahmQ=="
	},
	{
		"string": "",
		"encodedString": "8JahrfCWooHwlqKV8JaiqfCWor3wlqOR8JajpfCWo7nwlqSN8JakofCWpLXwlqWJ8JalnfCWpbHwlqaF8JammfCWpq3wlqeB8JanlfCWp6nwlqe98JaokfCWqKXwlqmA8JaplPCWqanwlqqB8JaqlfCWqqnwlqq98JarmPCWq6zwlqyM8JasoPCWrLTwlq2S8JatqPCWroHwlrmF8Ja5mfCWua3wlrqB8Ja6lfCWvI7wlryi8Ja8tvCWvYrwlr2i8Ja9tvCWvpHwlr+w8JeAkvCXgKbwl4C68JeBjvCXgaLwl4G28JeCivCXgp7wl4Ky8JeDhvCXg5rwl4Ou8JeEgvCXhJbwl4Sq8JeEvvCXhZLwl4Wm8JeFuvCXho7wl4ai8JeGtvCXh4rwl4ee8JeHsvCXiIbwl4ia8JeIrvCXiYLwl4mW8JeJqvCXib7wl4qS8JeKpvCXirrwl4uO8JeLovCXi7bwl4yK8JeMnvCXjLLwl42G8JeNmvCXja7wl46C8JeOlvCXjqrwl46+8JePkg=="
	},
	{
		"string": "",
		"encodedString": "8JePpvCXj7rwl5CO8JeQovCXkLbwl5GK8JeRnvCXkbLwl5KG8JeSmvCXkq7wl5OC8JeTlvCXk6rwl5O+8JeUkvCXlKbwl5S68JeVjvCXlaLwl5W28JeWivCXlp7wl5ay8JeXhvCXl5rwl5eu8JeYgvCXmJbwl5iq8JeYvvCXmZLwl5mm8JeZuvCXmo7wl5qi8JeatvCXm4rwl5ue8JebsvCXnIbwl5ya8JecrvCXnYLwl52W8JedqvCXnb7wl56S8JeepvCXnrrwl5+O8JefovCXn7bwl6CK8JegnvCXoLLwl6GG8JehmvCXoa7wl6KC8JeilvCXoqrwl6K+8JejkvCXo6bwl6O68JekjvCXpKLwl6S28JelivCXpZ7wl6Wy8JemhvCXpprwl6au8JengvCXp5bwl6eq8JenvvCXqJLwl6im8JeouvCXqY7wl6mi8JeptvCXqorwl6qe8JeqsvCXq4bwl6ua8JerrvCXrILwl6yW8JesqvCXrL7wl62S8JetpvCXrbrwl66O8Jeuog=="
	},
	{
		"string": "",
		"encodedString": "8JeutvCXr4rwl6+e8JevsvCXsIbwl7Ca8JewrvCXsYLwl7GW8JexqvCXsb7wl7KS8JeypvCXsrrwl7OO8JezovCXs7bwl7SK8Je0nvCXtLLwl7WG8Je1mvCXta7wl7aC8Je2lvCXtqrwl7a+8Je3kvCXt6bwl7e68Je4jvCXuKLwl7i28Je5ivCXuZ7wl7my8Je6hvCXuprwl7qu8Je7gvCXu5bwl7uq8Je7vvCXvJLwl7ym8Je8uvCXvY7wl72i8Je9tvCXvorwl76e8Je+svCXv4bwl7+a8Je/rvCYgILwmICW8JiAqvCYgL7wmIGS8JiBpvCYgbrwmIKO8JiCovCYgrbwmIOK8JiDnvCYg7LwmISG8JiEmvCYhK7wmIWC8JiFlvCYharwmIW+8JiGkvCYhqbwmIa68JiHjvCYh6LwmIe28JiIivCYiJ7wmIiy8JiJhvCYiZrwmImu8JiKgvCYipbwmIqq8JiKvvCYi5LwmIum8JiLuvCYjI7wmIyi8JiMtvCYjYrwmI2e8JiNsg=="
	},
	{
		"string": "",
		"encodedString": "8JiOhvCYjprwmI6u8JiPgvCYj5bwmI+q8JiPvvCYkJLwmJCm8JiQuvCYkY7wmJGi8JiRtvCYkorwmJKe8JiSsvCYk4bwmJOa8JiTrvCYlILwmJSW8JiUqvCYlL7wmJWS8JiVpvCYlbrwmJaO8JiWovCYlrbwmJeK8JiXnvCYl7LwmJiG8JiYmvCYmK7wmJmC8JiZlvCYmarwmJm+8JiakvCYmqbwmJq68JibjvCYm6LwmJu28JicivCYnJ7wmJyy8JidhvCYnZrwmJ2u8JiegvCYnpbwmJ6q8JievvCYn5LwmJ+m8JiggvCYoJbwmKCq8JigvvCYoZLwmKGm8JihuvCYoo7wmKKi8JiitvCYo4rwmKOe8JijsvCYpIbwmKSa8JikrvCYpYLwmKWW8JilqvCYpb7wmKaS8JimpvCYprrwmKeO8JinovCYp7bwmKiK8JionvCYqLLwmKmG8JipmvCYqa7wmKqC8JiqlvCYqqrwmKq+8JirkvCYq6bwmKu68JisjvCYrKLwmKy28Jitig=="
	},
	{
		"string": "",
		"encodedString": "8JitnvCYrbLwmK6G8JiumvCYrq7wmK+C8JivlvCYr6rwmK++8JiwkvCYsKbwmLC68JixjvCYsaLwmLG28JiyivCYsp7wmLKy8JizhvCYtITwm4CC8JuAlvCbgKrwm4C+8JuBkvCbgabwm4G68JuCjvCbgqLwm4K28JuDivCbg57wm4Oy8JuEhvCbhJrwm4Wy8JuGhvCbhprwm4au8JuHgvCbh5bwm4eq8JuHvvCbiJLwm4im8JuIuvCbiY7wm4mi8JuJtvCbiorwm4qe8JuKsvCbi4bwm4ua8JuLrvCbsIbwm7Ca8JuwrvCbsYLwm7GW8JuxqvCbsobwm7Kj8Jy8k/CcvKfwnLy98Jy9mvCcva7wnL6C8Jy+lvCcvqrwnL6+8J2AjvCdgKLwnYC28J2BivCdgZ7wnYGy8J2ChvCdgprwnYKu8J2DgvCdg5bwnYOq8J2EiPCdhJzwnYSy8J2FhvCdhZrwnYWu8J2GgvCdhpbwnYaq8J2GvvCdh5LwnYem8J2Ij/CdiKPwnYi38J2LhQ=="
	},
	{
		"string": "",
		"encodedString": "8J2LpfCdjIXwnYyZ8J2MrfCdjYHwnY2V8J2NsvCdkI3wnZCh8J2QtfCdkYnwnZGe8J2RsvCdkobwnZKa8J2StvCdk43wnZOh8J2TtfCdlIrwnZSi8J2UtvCdlZDwnZWl8J2VufCdlo3wnZah8J2WtfCdl4nwnZed8J2XsfCdmIXwnZiZ8J2YrfCdmYHwnZmV8J2ZqfCdmb3wnZqR8J2apfCdmrvwnZuP8J2bo/Cdm7fwnZyL8J2cn/CdnLPwnZ2H8J2dm/Cdna/wnZ6D8J2el/CdnqvwnZ6/8J2flfCdn6nwnZ+98J2gkfCdoKXwnaC58J2hjfCdoaHwnaG18J2iifCdop3wnaKx8J2jhfCdo5nwnaOt8J2kgfCdpJXwnaSp8J2kvfCdpZHwnaWl8J2lufCdpo3wnaah8J2mtfCdp4nwnaed8J2nsfCdqIXwnaiZ8J2orfCdqYHwnamV8J2pqfCdqb3wnaqh8J28hfCdvJnwnoCJ8J6An/CegLrwnoGO8J6BovCehIfwnoSb8J6Esg=="
	},
	{
		"string": "",
		"encodedString": "8J6FiPCeiqDwnouF8J6LmfCei63wnpOW8J6TqvCen6Twnp+78J6gkPCeoKTwnqC48J6hjPCeoaDwnqG08J6iiPCeopzwnqKw8J6jhPCepIPwnqSX8J6kq/CepL/wnqWX8J6ygPCespTwnrKo8J60iPCetJzwnrSw8J64h/CeuJvwnri18J65ofCeubvwnrqS8J66rfCfgIPwn4CX8J+Aq/CfgYPwn4GX8J+Bq/Cfgb/wn4KT8J+CtfCfg4rwn4Of8J+Ds/CfhJHwn4Sl8J+EufCfhY3wn4Wh8J+FtfCfhonwn4ad8J+HqfCfh73wn4ie8J+IsvCfiZHwn4yN8J+MofCfjLXwn42J8J+NnfCfjbHwn46F8J+OmfCfjq3wn4+B8J+PlfCfj6nwn4+98J+QkfCfkKXwn5C58J+RjfCfkaHwn5G18J+SifCfkp3wn5Kx8J+ThfCfk5nwn5Ot8J+UgfCflJXwn5Sp8J+UvfCflZHwn5Wl8J+VufCflo3wn5ah8J+WtfCfl4nwn5ed8J+XsQ=="
	},
	{
		"string": "",
		"encodedString": "8J+YhfCfmJnwn5it8J+ZgfCfmZXwn5mp8J+ZvfCfmpHwn5ql8J+aufCfm43wn5ul8J+bvPCfnJPwn5yn8J+cu/CfnY/wn52j8J+du/Cfno/wn56j8J+et/Cfn4vwn5+l8J+gkPCfoKTwn6C48J+hlPCfoa7wn6KC8J+invCfpILwn6SW8J+kqvCfpL7wn6WS8J+lpvCfpbrwn6aO8J+movCfprbwn6eK8J+nnvCfp7Lwn6iG8J+omvCfqK7wn6mC8J+povCfqbjwn6qW8J+qqvCfqr/wn6ub8J+sgfCfrJXwn6yp8J+svfCfrZHwn62l8J+tufCfro3wn66i8J+utvCfr4rwoICJ8KCAnfCggLHwoIGF8KCBmfCgga3woIKB8KCClfCggqnwoIK98KCDkfCgg6XwoIO58KCEjfCghKHwoIS18KCFifCghZ3woIWx8KCGhfCghpnwoIat8KCHgfCgh5XwoIep8KCHvfCgiJHwoIil8KCIufCgiY3woImh8KCJtfCgionwoIqd8KCKsQ=="
	},
	{
		"string": "",
		"encodedString": "8KCLhfCgi5nwoIut8KCMgfCgjJXwoIyp8KCMvfCgjZHwoI2l8KCNufCgjo3woI6h8KCOtfCgj4nwoI+d8KCPsfCgkIXwoJCZ8KCQrfCgkYHwoJGV8KCRqfCgkb3woJKR8KCSpfCgkrnwoJON8KCTofCgk7XwoJSJ8KCUnfCglLHwoJWF8KCVmfCgla3woJaB8KCWlfCglqnwoJa98KCXkfCgl6XwoJe58KCYjfCgmKHwoJi18KCZifCgmZ3woJmx8KCahfCgmpnwoJqt8KCbgfCgm5XwoJup8KCbvfCgnJHwoJyl8KCcufCgnY3woJ2h8KCdtfCgnonwoJ6d8KCesfCgn4XwoJ+Z8KCfrfCgoIHwoKCV8KCgqfCgoL3woKGR8KChpfCgobnwoKKN8KCiofCgorXwoKOJ8KCjnfCgo7HwoKSF8KCkmfCgpK3woKWB8KCllfCgpanwoKW98KCmkfCgpqXwoKa58KCnjfCgp6HwoKe18KCoifCgqJ3woKix8KCphfCgqZnwoKmt8KCqgQ=="
	},
	{
		"string": "",
		"encodedString": "8KCqlfCgqqnwoKq98KCrkfCgq6XwoKu58KCsjfCgrKHwoKy18KCtifCgrZ3woK2x8KCuhfCgrpnwoK6t8KCvgfCgr5XwoK+p8KCvvfCgsJHwoLCl8KCwufCgsY3woLGh8KCxtfCgsonwoLKd8KCysfCgs4XwoLOZ8KCzrfCgtIHwoLSV8KC0qfCgtL3woLWR8KC1pfCgtbnwoLaN8KC2ofCgtrXwoLeJ8KC3nfCgt7HwoLiF8KC4mfCguK3woLmB8KC5lfCguanwoLm98KC6kfCguqXwoLq58KC7jfCgu6HwoLu18KC8ifCgvJ3woLyx8KC9hfCgvZnwoL2t8KC+gfCgvpXwoL6p8KC+vfCgv5HwoL+l8KC/ufChgI3woYCh8KGAtfChgYnwoYGd8KGBsfChgoXwoYKZ8KGCrfChg4HwoYOV8KGDqfChg73woYSR8KGEpfChhLnwoYWN8KGFofChhbXwoYaJ8KGGnfChhrHwoYeF8KGHmfChh63woYiB8KGIlfChiKnwoYi98KGJkQ=="
	},
	{
		"string": "",
		"encodedString": "8KGJpfChibnwoYqN8KGKofChirXwoYuJ8KGLnfChi7HwoYyF8KGMmfChjK3woY2B8KGNlfChjanwoY298KGOkfChjqXwoY658KGPjfChj6HwoY+18KGQifChkJ3woZCx8KGRhfChkZnwoZGt8KGSgfChkpXwoZKp8KGSvfChk5HwoZOl8KGTufChlI3woZSh8KGUtfChlYnwoZWd8KGVsfChloXwoZaZ8KGWrfChl4HwoZeV8KGXqfChl73woZiR8KGYpfChmLnwoZmN8KGZofChmbXwoZqJ8KGanfChmrHwoZuF8KGbmfChm63woZyB8KGclfChnKnwoZy98KGdkfChnaXwoZ258KGejfChnqHwoZ618KGfifChn53woZ+x8KGghfChoJnwoaCt8KGhgfChoZXwoaGp8KGhvfChopHwoaKl8KGiufCho43woaOh8KGjtfChpInwoaSd8KGksfChpYXwoaWZ8KGlrfChpoHwoaaV8KGmqfChpr3woaeR8KGnpfChp7nwoaiN8KGooQ=="
	},
	{
		"string": "",
		"encodedString": "8KGotfChqYnwoamd8KGpsfChqoXwoaqZ8KGqrfChq4HwoauV8KGrqfChq73woayR8KGspfChrLnwoa2N8KGtofChrbXwoa6J8KGunfChrrHwoa+F8KGvmfChr63wobCB8KGwlfChsKnwobC98KGxkfChsaXwobG58KGyjfChsqHwobK18KGzifChs53wobOx8KG0hfChtJnwobSt8KG1gfChtZXwobWp8KG1vfChtpHwobal8KG2ufCht43wobeh8KG3tfChuInwobid8KG4sfChuYXwobmZ8KG5rfChuoHwobqV8KG6qfChur3wobuR8KG7pfChu7nwobyN8KG8ofChvLXwob2J8KG9nfChvbHwob6F8KG+mfChvq3wob+B8KG/lfChv6nwob+98KKAkfCigKXwooC58KKBjfCigaHwooG18KKCifCigp3wooKx8KKDhfCig5nwooOt8KKEgfCihJXwooSp8KKEvfCihZHwooWl8KKFufCiho3wooah8KKGtfCih4nwooed8KKHsQ=="
	},
	{
		"string": "",
		"encodedString": "8KKIhfCiiJnwooit8KKJgfCiiZXwoomp8KKJvfCiipHwooql8KKKufCii43woouh8KKLtfCijInwooyd8KKMsfCijYXwoo2Z8KKNrfCijoHwoo6V8KKOqfCijr3woo+R8KKPpfCij7nwopCN8KKQofCikLXwopGJ8KKRnfCikbHwopKF8KKSmfCikq3wopOB8KKTlfCik6nwopO98KKUkfCilKXwopS58KKVjfCilaHwopW18KKWifCilp3wopax8KKXhfCil5nwopet8KKYgfCimJXwopip8KKYvfCimZHwopml8KKZufCimo3wopqh8KKatfCim4nwopud8KKbsfCinIXwopyZ8KKcrfCinYHwop2V8KKdqfCinb3wop6R8KKepfCinrnwop+N8KKfofCin7XwoqCJ8KKgnfCioLHwoqGF8KKhmfCioa3woqKB8KKilfCioqnwoqK98KKjkfCio6XwoqO58KKkjfCipKHwoqS18KKlifCipZ3woqWx8KKmhfCippnwoqat8KKngQ=="
	},
	{
		"string": "",
		"encodedString": "8KKnlfCip6nwoqe98KKokfCiqKXwoqi58KKpjfCiqaHwoqm18KKqifCiqp3woqqx8KKrhfCiq5nwoqut8KKsgfCirJXwoqyp8KKsvfCirZHwoq2l8KKtufCiro3woq6h8KKutfCir4nwoq+d8KKvsfCisIXworCZ8KKwrfCisYHworGV8KKxqfCisb3worKR8KKypfCisrnworON8KKzofCis7XworSJ8KK0nfCitLHworWF8KK1mfCita3woraB8KK2lfCitqnwora98KK3kfCit6Xwore58KK4jfCiuKHwori18KK5ifCiuZ3wormx8KK6hfCiupnworqt8KK7gfCiu5Xworup8KK7vfCivJHworyl8KK8ufCivY3wor2h8KK9tfCivonwor6d8KK+sfCiv4Xwor+Z8KK/rfCjgIHwo4CV8KOAqfCjgL3wo4GR8KOBpfCjgbnwo4KN8KOCofCjgrXwo4OJ8KODnfCjg7Hwo4SF8KOEmfCjhK3wo4WB8KOFlfCjhanwo4W98KOGkQ=="
	},
	{
		"string": "",
		"encodedString": "8KOGpfCjhrnwo4eN8KOHofCjh7Xwo4iJ8KOInfCjiLHwo4mF8KOJmfCjia3wo4qB8KOKlfCjiqnwo4q98KOLkfCji6Xwo4u58KOMjfCjjKHwo4y18KONifCjjZ3wo42x8KOOhfCjjpnwo46t8KOPgfCjj5Xwo4+p8KOPvfCjkJHwo5Cl8KOQufCjkY3wo5Gh8KORtfCjkonwo5Kd8KOSsfCjk4Xwo5OZ8KOTrfCjlIHwo5SV8KOUqfCjlL3wo5WR8KOVpfCjlbnwo5aN8KOWofCjlrXwo5eJ8KOXnfCjl7Hwo5iF8KOYmfCjmK3wo5mB8KOZlfCjmanwo5m98KOakfCjmqXwo5q58KObjfCjm6Hwo5u18KOcifCjnJ3wo5yx8KOdhfCjnZnwo52t8KOegfCjnpXwo56p8KOevfCjn5Hwo5+l8KOfufCjoI3wo6Ch8KOgtfCjoYnwo6Gd8KOhsfCjooXwo6KZ8KOirfCjo4Hwo6OV8KOjqfCjo73wo6SR8KOkpfCjpLnwo6WN8KOloQ=="
	},
	{
		"string": "",
		"encodedString": "8KOltfCjponwo6ad8KOmsfCjp4Xwo6eZ8KOnrfCjqIHwo6iV8KOoqfCjqL3wo6mR8KOppfCjqbnwo6qN8KOqofCjqrXwo6uJ8KOrnfCjq7Hwo6yF8KOsmfCjrK3wo62B8KOtlfCjranwo6298KOukfCjrqXwo6658KOvjfCjr6Hwo6+18KOwifCjsJ3wo7Cx8KOxhfCjsZnwo7Gt8KOygfCjspXwo7Kp8KOyvfCjs5Hwo7Ol8KOzufCjtI3wo7Sh8KO0tfCjtYnwo7Wd8KO1sfCjtoXwo7aZ8KO2rfCjt4Hwo7eV8KO3qfCjt73wo7iR8KO4pfCjuLnwo7mN8KO5ofCjubXwo7qJ8KO6nfCjurHwo7uF8KO7mfCju63wo7yB8KO8lfCjvKnwo7y98KO9kfCjvaXwo7258KO+jfCjvqHwo7618KO/ifCjv53wo7+x8KSAhfCkgJnwpICt8KSBgfCkgZXwpIGp8KSBvfCkgpHwpIKl8KSCufCkg43wpIOh8KSDtfCkhInwpISd8KSEsQ=="
	},
	{
		"string": "",
		"encodedString": "8KSFhfCkhZnwpIWt8KSGgfCkhpXwpIap8KSGvfCkh5HwpIel8KSHufCkiI3wpIih8KSItfCkiYnwpImd8KSJsfCkioXwpIqZ8KSKrfCki4HwpIuV8KSLqfCki73wpIyR8KSMpfCkjLnwpI2N8KSNofCkjbXwpI6J8KSOnfCkjrHwpI+F8KSPmfCkj63wpJCB8KSQlfCkkKnwpJC98KSRkfCkkaXwpJG58KSSjfCkkqHwpJK18KSTifCkk53wpJOx8KSUhfCklJnwpJSt8KSVgfCklZXwpJWp8KSVvfCklpHwpJal8KSWufCkl43wpJeh8KSXtfCkmInwpJid8KSYsfCkmYXwpJmZ8KSZrfCkmoHwpJqV8KSaqfCkmr3wpJuR8KSbpfCkm7nwpJyN8KScofCknLXwpJ2J8KSdnfCknbHwpJ6F8KSemfCknq3wpJ+B8KSflfCkn6nwpJ+98KSgkfCkoKXwpKC58KShjfCkoaHwpKG18KSiifCkop3wpKKx8KSjhfCko5nwpKOt8KSkgQ=="
	},
	{
		"string": "",
		"encodedString": "8KSklfCkpKnwpKS98KSlkfCkpaXwpKW58KSmjfCkpqHwpKa18KSnifCkp53wpKex8KSohfCkqJnwpKit8KSpgfCkqZXwpKmp8KSpvfCkqpHwpKql8KSqufCkq43wpKuh8KSrtfCkrInwpKyd8KSssfCkrYXwpK2Z8KStrfCkroHwpK6V8KSuqfCkrr3wpK+R8KSvpfCkr7nwpLCN8KSwofCksLXwpLGJ8KSxnfCksbHwpLKF8KSymfCksq3wpLOB8KSzlfCks6nwpLO98KS0kfCktKXwpLS58KS1jfCktaHwpLW18KS2ifCktp3wpLax8KS3hfCkt5nwpLet8KS4gfCkuJXwpLip8KS4vfCkuZHwpLml8KS5ufCkuo3wpLqh8KS6tfCku4nwpLud8KS7sfCkvIXwpLyZ8KS8rfCkvYHwpL2V8KS9qfCkvb3wpL6R8KS+pfCkvrnwpL+N8KS/ofCkv7XwpYCJ8KWAnfClgLHwpYGF8KWBmfClga3wpYKB8KWClfClgqnwpYK98KWDkQ=="
	},
	{
		"string": "",
		"encodedString": "8KWDpfClg7nwpYSN8KWEofClhLXwpYWJ8KWFnfClhbHwpYaF8KWGmfClhq3wpYeB8KWHlfClh6nwpYe98KWIkfCliKXwpYi58KWJjfCliaHwpYm18KWKifClip3wpYqx8KWLhfCli5nwpYut8KWMgfCljJXwpYyp8KWMvfCljZHwpY2l8KWNufCljo3wpY6h8KWOtfClj4nwpY+d8KWPsfClkIXwpZCZ8KWQrfClkYHwpZGV8KWRqfClkb3wpZKR8KWSpfClkrnwpZON8KWTofClk7XwpZSJ8KWUnfCllLHwpZWF8KWVmfClla3wpZaB8KWWlfCllqnwpZa98KWXkfCll6XwpZe58KWYjfClmKHwpZi18KWZifClmZ3wpZmx8KWahfClmpnwpZqt8KWbgfClm5XwpZup8KWbvfClnJHwpZyl8KWcufClnY3wpZ2h8KWdtfClnonwpZ6d8KWesfCln4XwpZ+Z8KWfrfCloIHwpaCV8KWgqfCloL3wpaGR8KWhpfClobnwpaKN8KWioQ=="
	},
	{
		"string": "",
		"encodedString": "8KWitfClo4nwpaOd8KWjsfClpIXwpaSZ8KWkrfClpYHwpaWV8KWlqfClpb3wpaaR8KWmpfClprnwpaeN8KWnofClp7XwpaiJ8KWonfClqLHwpamF8KWpmfClqa3wpaqB8KWqlfClqqnwpaq98KWrkfClq6Xwpau58KWsjfClrKHwpay18KWtifClrZ3wpa2x8KWuhfClrpnwpa6t8KWvgfClr5Xwpa+p8KWvvfClsJHwpbCl8KWwufClsY3wpbGh8KWxtfClsonwpbKd8KWysfCls4XwpbOZ8KWzrfCltIHwpbSV8KW0qfCltL3wpbWR8KW1pfCltbnwpbaN8KW2ofCltrXwpbeJ8KW3nfClt7HwpbiF8KW4mfCluK3wpbmB8KW5lfCluanwpbm98KW6kfCluqXwpbq58KW7jfClu6Hwpbu18KW8ifClvJ3wpbyx8KW9hfClvZnwpb2t8KW+gfClvpXwpb6p8KW+vfClv5Hwpb+l8KW/ufCmgI3wpoCh8KaAtfCmgYnwpoGd8KaBsQ=="
	},
	{
		"string": "",
		"encodedString": "8KaChfCmgpnwpoKt8KaDgfCmg5XwpoOp8KaDvfCmhJHwpoSl8KaEufCmhY3wpoWh8KaFtfCmhonwpoad8KaGsfCmh4XwpoeZ8KaHrfCmiIHwpoiV8KaIqfCmiL3wpomR8KaJpfCmibnwpoqN8KaKofCmirXwpouJ8KaLnfCmi7HwpoyF8KaMmfCmjK3wpo2B8KaNlfCmjanwpo298KaOkfCmjqXwpo658KaPjfCmj6Hwpo+18KaQifCmkJ3wppCx8KaRhfCmkZnwppGt8KaSgfCmkpXwppKp8KaSvfCmk5HwppOl8KaTufCmlI3wppSh8KaUtfCmlYnwppWd8KaVsfCmloXwppaZ8KaWrfCml4HwppeV8KaXqfCml73wppiR8KaYpfCmmLnwppmN8KaZofCmmbXwppqJ8KaanfCmmrHwppuF8KabmfCmm63wppyB8KaclfCmnKnwppy98KadkfCmnaXwpp258KaejfCmnqHwpp618KafifCmn53wpp+x8KaghfCmoJnwpqCt8KahgQ=="
	},
	{
		"string": "",
		"encodedString": "8KahlfCmoanwpqG98KaikfCmoqXwpqK58KajjfCmo6HwpqO18KakifCmpJ3wpqSx8KalhfCmpZnwpqWt8KamgfCmppXwpqap8KamvfCmp5Hwpqel8KanufCmqI3wpqih8KaotfCmqYnwpqmd8KapsfCmqoXwpqqZ8KaqrfCmq4HwpquV8KarqfCmq73wpqyR8KaspfCmrLnwpq2N8KatofCmrbXwpq6J8KaunfCmrrHwpq+F8KavmfCmr63wprCB8KawlfCmsKnwprC98KaxkfCmsaXwprG58KayjfCmsqHwprK18KazifCms53wprOx8Ka0hfCmtJnwprSt8Ka1gfCmtZXwprWp8Ka1vfCmtpHwpral8Ka2ufCmt43wpreh8Ka3tfCmuInwprid8Ka4sfCmuYXwprmZ8Ka5rfCmuoHwprqV8Ka6qfCmur3wpruR8Ka7pfCmu7nwpryN8Ka8ofCmvLXwpr2J8Ka9nfCmvbHwpr6F8Ka+mfCmvq3wpr+B8Ka/lfCmv6nwpr+98KeAkQ=="
	},
	{
		"string": "",
		"encodedString": "8KeApfCngLnwp4GN8KeBofCngbXwp4KJ8KeCnfCngrHwp4OF8KeDmfCng63wp4SB8KeElfCnhKnwp4S98KeFkfCnhaXwp4W58KeGjfCnhqHwp4a18KeHifCnh53wp4ex8KeIhfCniJnwp4it8KeJgfCniZXwp4mp8KeJvfCnipHwp4ql8KeKufCni43wp4uh8KeLtfCnjInwp4yd8KeMsfCnjYXwp42Z8KeNrfCnjoHwp46V8KeOqfCnjr3wp4+R8KePpfCnj7nwp5CN8KeQofCnkLXwp5GJ8KeRnfCnkbHwp5KF8KeSmfCnkq3wp5OB8KeTlfCnk6nwp5O98KeUkfCnlKXwp5S58KeVjfCnlaHwp5W18KeWifCnlp3wp5ax8KeXhfCnl5nwp5et8KeYgfCnmJXwp5ip8KeYvfCnmZHwp5ml8KeZufCnmo3wp5qh8KeatfCnm4nwp5ud8KebsfCnnIXwp5yZ8KecrfCnnYHwp52V8KedqfCnnb3wp56R8KeepfCnnrnwp5+N8KefoQ=="
	},
	{
		"string": "",
		"encodedString": "8KeftfCnoInwp6Cd8KegsfCnoYXwp6GZ8KehrfCnooHwp6KV8KeiqfCnor3wp6OR8KejpfCno7nwp6SN8KekofCnpLXwp6WJ8KelnfCnpbHwp6aF8KemmfCnpq3wp6eB8KenlfCnp6nwp6e98KeokfCnqKXwp6i58KepjfCnqaHwp6m18KeqifCnqp3wp6qx8KerhfCnq5nwp6ut8KesgfCnrJXwp6yp8KesvfCnrZHwp62l8KetufCnro3wp66h8KeutfCnr4nwp6+d8KevsfCnsIXwp7CZ8KewrfCnsYHwp7GV8KexqfCnsb3wp7KR8KeypfCnsrnwp7ON8KezofCns7Xwp7SJ8Ke0nfCntLHwp7WF8Ke1mfCnta3wp7aB8Ke2lfCntqnwp7a98Ke3kfCnt6Xwp7e58Ke4jfCnuKHwp7i18Ke5ifCnuZ3wp7mx8Ke6hfCnupnwp7qt8Ke7gfCnu5Xwp7up8Ke7vfCnvJHwp7yl8Ke8ufCnvY3wp72h8Ke9tfCnvonwp76d8Ke+sQ=="
	},
	{
		"string": "",
		"encodedString": "8Ke/hfCnv5nwp7+t8KiAgfCogJXwqICp8KiAvfCogZHwqIGl8KiBufCogo3wqIKh8KiCtfCog4nwqIOd8KiDsfCohIXwqISZ8KiErfCohYHwqIWV8KiFqfCohb3wqIaR8KiGpfCohrnwqIeN8KiHofCoh7XwqIiJ8KiInfCoiLHwqImF8KiJmfCoia3wqIqB8KiKlfCoiqnwqIq98KiLkfCoi6XwqIu58KiMjfCojKHwqIy18KiNifCojZ3wqI2x8KiOhfCojpnwqI6t8KiPgfCoj5XwqI+p8KiPvfCokJHwqJCl8KiQufCokY3wqJGh8KiRtfCokonwqJKd8KiSsfCok4XwqJOZ8KiTrfColIHwqJSV8KiUqfColL3wqJWR8KiVpfColbnwqJaN8KiWofColrXwqJeJ8KiXnfCol7HwqJiF8KiYmfComK3wqJmB8KiZlfComanwqJm98KiakfComqXwqJq58KibjfCom6HwqJu18KicifConJ3wqJyx8KidhfConZnwqJ2t8KiegQ=="
	},
	{
		"string": "",
		"encodedString": "8KielfConqnwqJ698KifkfCon6XwqJ+58KigjfCooKHwqKC18KihifCooZ3wqKGx8KiihfCoopnwqKKt8KijgfCoo5XwqKOp8KijvfCopJHwqKSl8KikufCopY3wqKWh8KiltfCoponwqKad8KimsfCop4XwqKeZ8KinrfCoqIHwqKiV8KioqfCoqL3wqKmR8KippfCoqbnwqKqN8KiqofCoqrXwqKuJ8KirnfCoq7HwqKyF8KismfCorK3wqK2B8KitlfCoranwqK298KiukfCorqXwqK658KivjfCor6HwqK+18KiwifCosJ3wqLCx8KixhfCosZnwqLGt8KiygfCospXwqLKp8KiyvfCos5HwqLOl8KizufCotI3wqLSh8Ki0tfCotYnwqLWd8Ki1sfCotoXwqLaZ8Ki2rfCot4HwqLeV8Ki3qfCot73wqLiR8Ki4pfCouLnwqLmN8Ki5ofCoubXwqLqJ8Ki6nfCourHwqLuF8Ki7mfCou63wqLyB8Ki8lfCovKnwqLy98Ki9kQ=="
	},
	{
		"string": "",
		"encodedString": "8Ki9pfCovbnwqL6N8Ki+ofCovrXwqL+J8Ki/nfCov7HwqYCF8KmAmfCpgK3wqYGB8KmBlfCpganwqYG98KmCkfCpgqXwqYK58KmDjfCpg6HwqYO18KmEifCphJ3wqYSx8KmFhfCphZnwqYWt8KmGgfCphpXwqYap8KmGvfCph5HwqYel8KmHufCpiI3wqYih8KmItfCpiYnwqYmd8KmJsfCpioXwqYqZ8KmKrfCpi4HwqYuV8KmLqfCpi73wqYyR8KmMpfCpjLnwqY2N8KmNofCpjbXwqY6J8KmOnfCpjrHwqY+F8KmPmfCpj63wqZCB8KmQlfCpkKnwqZC98KmRkfCpkaXwqZG58KmSjfCpkqHwqZK18KmTifCpk53wqZOx8KmUhfCplJnwqZSt8KmVgfCplZXwqZWp8KmVvfCplpHwqZal8KmWufCpl43wqZeh8KmXtfCpmInwqZid8KmYsfCpmYXwqZmZ8KmZrfCpmoHwqZqV8KmaqfCpmr3wqZuR8KmbpfCpm7nwqZyN8KmcoQ=="
	},
	{
		"string": "",
		"encodedString": "8KmctfCpnYnwqZ2d8KmdsfCpnoXwqZ6Z8KmerfCpn4HwqZ+V8KmfqfCpn73wqaCR8KmgpfCpoLnwqaGN8KmhofCpobXwqaKJ8KminfCporHwqaOF8KmjmfCpo63wqaSB8KmklfCppKnwqaS98KmlkfCppaXwqaW58KmmjfCppqHwqaa18KmnifCpp53wqaex8KmohfCpqJnwqait8KmpgfCpqZXwqamp8KmpvfCpqpHwqaql8KmqufCpq43wqauh8KmrtfCprInwqayd8KmssfCprYXwqa2Z8KmtrfCproHwqa6V8KmuqfCprr3wqa+R8KmvpfCpr7nwqbCN8KmwofCpsLXwqbGJ8KmxnfCpsbHwqbKF8KmymfCpsq3wqbOB8KmzlfCps6nwqbO98Km0kfCptKXwqbS58Km1jfCptaHwqbW18Km2ifCptp3wqbax8Km3hfCpt5nwqbet8Km4gfCpuJXwqbip8Km4vfCpuZHwqbml8Km5ufCpuo3wqbqh8Km6tfCpu4nwqbud8Km7sQ=="
	},
	{
		"string": "",
		"encodedString": "8Km8hfCpvJnwqbyt8Km9gfCpvZXwqb2p8Km9vfCpvpHwqb6l8Km+ufCpv43wqb+h8Km/tfCqgInwqoCd8KqAsfCqgYXwqoGZ8KqBrfCqgoHwqoKV8KqCqfCqgr3wqoOR8KqDpfCqg7nwqoSN8KqEofCqhLXwqoWJ8KqFnfCqhbHwqoaF8KqGmfCqhq3wqoeB8KqHlfCqh6nwqoe98KqIkfCqiKXwqoi58KqJjfCqiaHwqom18KqKifCqip3wqoqx8KqLhfCqi5nwqout8KqMgfCqjJXwqoyp8KqMvfCqjZHwqo2l8KqNufCqjo3wqo6h8KqOtfCqj4nwqo+d8KqPsfCqkIXwqpCZ8KqQrfCqkYHwqpGV8KqRqfCqkb3wqpKR8KqSpfCqkrnwqpON8KqTofCqk7XwqpSJ8KqUnfCqlLHwqpWF8KqVmfCqla3wqpaB8KqWlfCqlqnwqpa98KqXkfCql6Xwqpe58KqYjfCqmKHwqpi18KqZifCqmZ3wqpmx8KqahfCqmpnwqpqt8KqbgQ=="
	},
	{
		"string": "",
		"encodedString": "8KqblfCqnInwqpyd8KqcsfCqnYXwqp2Z8KqdrfCqnoHwqp6V8KqeqfCqnr3wqp+R8KqfpfCqn7nwqqCN8KqgofCqoLXwqqGJ8KqhnfCqobHwqqKF8KqimfCqoq3wqqOB8KqjlfCqo6nwqqO98KqkkfCqpKXwqqS58KqljfCqpaHwqqW18KqmifCqpp3wqqax8KqnhfCqp5nwqqet8KqogfCqqJXwqqip8KqovfCqqZHwqqml8KqpufCqqo3wqqqh8KqqtfCqq4nwqqud8KqrsfCqrIXwqqyZ8KqsrfCqrYHwqq2V8KqtqfCqrb3wqq6R8KqupfCqrrnwqq+N8KqvofCqr7XwqrCJ8KqwnfCqsLHwqrGF8KqxmfCqsa3wqrKB8KqylfCqsqnwqrK98KqzkfCqs6XwqrO58Kq0jfCqtKHwqrS18Kq1ifCqtZ3wqrWx8Kq2hfCqtpnwqrat8Kq3gfCqt5Xwqrep8Kq3vfCquJHwqril8Kq4ufCquY3wqrmh8Kq5tfCquonwqrqd8Kq6sQ=="
	},
	{
		"string": "",
		"encodedString": "8Kq7hfCqu5nwqrut8Kq8gfCqvJXwqryp8Kq8vfCqvZHwqr2l8Kq9ufCqvo3wqr6h8Kq+tfCqv4nwqr+d8Kq/sfCrgIXwq4CZ8KuArfCrgYHwq4GV8KuBqfCrgb3wq4KR8KuCpfCrgrnwq4ON8KuDofCrg7Xwq4SJ8KuEnfCrhLHwq4WF8KuFmfCrha3wq4aB8KuGlfCrhqnwq4a98KuHkfCrh6Xwq4e58KuIjfCriKHwq4i18KuJifCriZ3wq4mx8KuKhfCripnwq4qt8KuLgfCri5Xwq4up8KuLvfCrjJHwq4yl8KuMufCrjY3wq42h8KuNtfCrjonwq46d8KuOsfCrj4Xwq4+Z8KuPrfCrkIHwq5CV8KuQqfCrkL3wq5GR8KuRpfCrkbnwq5KN8KuSofCrkrXwq5OJ8KuTnfCrk7Hwq5SF8KuUmfCrlK3wq5WB8KuVlfCrlanwq5W98KuWkfCrlqXwq5a58KuXjfCrl6Hwq5e18KuYifCrmJ3wq5ix8KuZhfCrmZnwq5mt8KuagQ=="
	},
	{
		"string": "",
		"encodedString": "8KualfCrmqnwq5q98KubkfCrm6Xwq5u58KucjfCrnKHwq5y18Kudj/CrnaPwq5238Kuei/Crnp/wq56z8Kufh/Crn5vwq5+v8Kugg/CroJfwq6Ct8KuhgfCroZXwq6Gp8KuhvfCropHwq6Kl8KuiufCro43wq6Oh8KujtfCrpInwq6Sd8KuksfCrpYXwq6WZ8KulrfCrpoHwq6aV8KumqfCrpr3wq6eR8KunpfCrp7nwq6iN8KuoofCrqLXwq6mJ8KupnfCrqbHwq6qF8KuqmfCrqq3wq6uB8KurlfCrq6nwq6u98KuskfCrrKXwq6y58KutjfCrraHwq6218KuuifCrrp3wq66x8KuvhfCrr5nwq6+t8KuwgfCrsJXwq7Cp8KuwvfCrsZHwq7Gl8KuxufCrso3wq7Kh8KuytfCrs4nwq7Od8KuzsfCrtIXwq7SZ8Ku0rfCrtYHwq7WV8Ku1qfCrtb3wq7aR8Ku2pfCrtrnwq7eN8Ku3ofCrt7Xwq7iJ8Ku4nfCruLHwq7mF8Ku5mQ=="
	},
	{
		"string": "",
		"encodedString": "8Ku5rfCruoHwq7qV8Ku6qfCrur3wq7uR8Ku7pfCru7nwq7yN8Ku8ofCrvLXwq72J8Ku9nfCrvbHwq76F8Ku+mfCrvq3wq7+B8Ku/lfCrv6nwq7+98KyAkfCsgKXwrIC58KyBjfCsgaHwrIG18KyCifCsgp3wrIKx8KyDhfCsg5nwrIOt8KyEgfCshJXwrISp8KyEvfCshZHwrIWl8KyFufCsho3wrIah8KyGtfCsh4nwrIed8KyHsfCsiIXwrIiZ8KyIrfCsiYHwrImV8KyJqfCsib3wrIqR8KyKpfCsirnwrIuN8KyLofCsi7XwrIyJ8KyMnfCsjLHwrI2F8KyNmfCsja3wrI6B8KyOlfCsjqnwrI698KyPkfCsj6XwrI+58KyQjfCskKHwrJC18KyRifCskZ3wrJGx8KyShfCskpnwrJKt8KyTgfCsk5XwrJOp8KyTvfCslJHwrJSl8KyUufCslY3wrJWh8KyVtfCslonwrJad8KyWsfCsl4XwrJeZ8KyXrfCsmIHwrJiV8KyYqQ=="
	},
	{
		"string": "",
		"encodedString": "8KyYvfCsmZHwrJml8KyZufCsmo3wrJqh8KyatfCsm4nwrJud8KybsfCsnIXwrJyZ8KycrfCsnYHwrJ2V8KydqfCsnb3wrJ6R8KyepfCsnrnwrJ+N8KyfofCsn7XwrKCJ8KygnfCsoLHwrKGF8KyhmfCsoa3wrKKB8KyilfCsoqnwrKK98KyjkfCso6XwrKO58KykjfCspKHwrKS18KylifCspZ3wrKWx8KymhfCsppnwrKat8KyngfCsp5XwrKep8KynvfCsqJHwrKil8KyoufCsqY3wrKmh8KyptfCsqonwrKqd8KyqsfCsq4XwrKuZ8KyrrfCsrIHwrKyV8KysqfCsrL3wrK2R8KytpfCsrbnwrK6N8KyuofCsrrXwrK+J8KyvnfCsr7HwrLCF8KywmfCssK3wrLGB8KyxlfCssanwrLG98KyykfCssqXwrLK58KyzjfCss6HwrLO18Ky0ifCstJ3wrLSx8Ky1hfCstZnwrLWt8Ky2gfCstpXwrLap8Ky2vfCst5HwrLel8Ky3uQ=="
	},
	{
		"string": "",
		"encodedString": "8Ky4jfCsuKHwrLi18Ky5ifCsuZ3wrLmx8Ky6hfCsupnwrLq78Ky7j/Csu6PwrLu38Ky8i/CsvJ/wrLyz8Ky9h/CsvZvwrL2v8Ky+g/CsvpfwrL6r8Ky+v/Csv5PwrL+n8Ky/u/CtgI/wrYCj8K2At/CtgYvwrYGf8K2Bs/CtgofwrYKb8K2Cr/Ctg4PwrYOX8K2Dq/Ctg7/wrYST8K2Ep/CthLvwrYWP8K2Fo/CthbfwrYaL8K2Gn/CthrPwrYeH8K2Hm/Cth6/wrYiD8K2Il/CtiKvwrYi/8K2Jk/CtiafwrYm78K2Kj/CtiqPwrYq38K2Li/Cti5/wrYuz8K2Mh/CtjJvwrYyv8K2Ng/CtjZfwrY2r8K2Nv/CtjpPwrY6n8K2Ou/Ctj4/wrY+j8K2Pt/CtkIvwrZCf8K2Qs/CtkYfwrZGb8K2Rr/CtkoPwrZKX8K2Sq/Ctkr/wrZOT8K2Tp/Ctk7vwrZSP8K2Uo/CtlLfwrZWL8K2Vn/CtlbPwrZaH8K2Wm/Ctlq/wrZeD8K2Xlw=="
	},
	{
		"string": "",
		"encodedString": "8K2Xq/Ctl7/wrZiT8K2Yp/CtmLvwrZmP8K2Zo/CtmbfwrZqL8K2an/CtmrPwrZuH8K2bm/Ctm6/wrZyD8K2cl/CtnKvwrZy/8K2dk/CtnafwrZ278K2ej/CtnqPwrZ638K2fi/Ctn5/wrZ+z8K2gh/CtoJvwraCv8K2hg/CtoZfwraGr8K2hv/CtopPwraKn8K2iu/Cto4/wraOj8K2jt/CtpIvwraSf8K2ks/CtpYfwraWb8K2lr/CtpoPwraaX8K2mq/Ctpr/wraeT8K2np/Ctp7vwraiP8K2oo/CtqLfwramL8K2pn/CtqbPwraqH8K2qm/Ctqq/wrauD8K2rl/Ctq6vwrau/8K2sk/CtrKfwray78K2tj/CtraPwra238K2ui/Ctrp/wra6z8K2vh/Ctr5vwra+v8K2wg/CtsJfwrbCr8K2wv/CtsZPwrbGn8K2xu/Ctso/wrbKj8K2yt/Cts4vwrbOf8K2zs/CttIfwrbSb8K20r/CttYPwrbWX8K21q/Cttb/wrbaT8K22pw=="
	},
	{
		"string": "",
		"encodedString": "8K22u/Ctt4/wrbej8K23t/CtuIvwrbif8K24s/CtuYfwrbmb8K25r/CtuoPwrbqX8K26q/Ctur/wrbuT8K27p/Ctu7vwrbyP8K28o/CtvLfwrb2L8K29n/CtvbPwrb6H8K2+m/Ctvq/wrb+D8K2/l/Ctv6vwrb+/8K6Ak/CugKfwroC78K6Bj/CugaPwroG38K6Ci/Cugp/wroKz8K6Dh/Cug5vwroOv8K6Eg/CuhJfwroSr8K6Ev/CuhZPwroWn8K6Fu/Cuho/wroaj8K6Gt/Cuh4vwroef8K6Hs/CuiIfwroib8K6Ir/CuiYPwromX8K6Jq/Cuib/wroqT8K6Kp/CuirvwrouP8K6Lo/Cui7fwroyL8K6Mn/CujLPwro2H8K6Nm/Cuja/wro6D8K6Ol/Cujqvwro6/8K6Pk/Cuj6fwro+78K6Qj/CukKPwrpC38K6Ri/CukZ/wrpGz8K6Sh/CukpvwrpKv8K6Tg/Cuk5fwrpOr8K6Tv/CulJPwrpSn8K6Uu/CulY/wrpWj8K6Vtw=="
	},
	{
		"string": "",
		"encodedString": "8K6Wi/Culp/wrpaz8K6Xh/Cul5vwrpev8K6Yg/CumJfwrpir8K6Yv/CumZPwrpmn8K6Zu/Cumo/wrpqj8K6at/Cum4vwrpuf8K6bs/CunIfwrpyb8K6cr/CunYPwrp2X8K6dq/Cunb/wrp6T8K6ep/Cunrvwrp+P8K6fo/Cun7fwrqCL8K6gn/CuoLPwrqGH8K6hm/Cuoa/wrqKD8K6il/CuoqvwrqK/8K6jk/Cuo6fwrqO78K6kj/CupKPwrqS38K6li/CupZ/wrqWz8K6mh/Cuppvwrqav8K6ng/Cup5fwrqer8K6nv/CuqJPwrqin8K6ou/CuqY/wrqmj8K6pt/Cuqovwrqqf8K6qs/Cuq4fwrqub8K6rr/CurIPwrqyX8K6sq/CurL/wrq2T8K6tp/Curbvwrq6P8K6uo/Currfwrq+L8K6vn/CvoJLwr6Cm8K+guvCvoY7wr6Gi8K+htvCvoorwr6Ke8K+isvCvo4bwr6Oa8K+jrvCvpILwr6SW8K+kqvCvpL7wr6WS8K+lpg=="
	},
	{
		"string": "",
		"encodedString": "8K+luvCvpo7wr6ai8K+mtvCvp4rwr6ee8K+nsvCvqIbwr6ia86CAr/OggYPzoIGX86CBq/Oggb/zoIST86CEp/OghLvzoIWP86CFo/OghbfzoIaL86CGn/OghrPzoIeH86CHm/Ogh6/zsICT87CAp/OwgLvzsIGP87CBo/OwgbfzsIKL87CCn/OwgrPzsIOH87CDm/Owg6/zsISD87CEl/OwhKvzsIS/87CFk/OwhafzsIW787CGj/OwhqPzsIa387CHi/Owh5/zsIez87CIh/OwiJvzsIiv87CJg/OwiZfzsImr87CJv/OwipPzsIqn87CKu/Owi4/zsIuj87CLt/OwjIvzsIyf87CMs/OwjYfzsI2b87CNr/OwjoPzsI6X87COq/Owjr/zsI+T87CPp/Owj7vzsJCP87CQo/OwkLfzsJGL87CRn/OwkbPzsJKH87CSm/Owkq/zsJOD87CTl/Owk6vzsJO/87CUk/OwlKfzsJS787CVj/OwlaPzsJW387CWi/Owlp/zsJaz87CXhw=="
	},
	{
		"string": "",
		"encodedString": "87CXm/Owl6/zsJiD87CYl/OwmKvzsJi/87CZk/OwmafzsJm787Caj/OwmqPzsJq387Cbi/Owm5/zsJuz87Cch/OwnJvzsJyv87Cdg/OwnZfzsJ2r87Cdv/OwnpPzsJ6n87Ceu/Own4/zsJ+j87Cft/OwoIvzsKCf87Cgs/OwoYfzsKGb87Chr/OwooPzsKKX87Ciq/Owor/zsKOT87Cjp/Owo7vzsKSP87Cko/OwpLfzsKWL87Cln/OwpbPzsKaH87Cmm/Owpq/zsKeD87Cnl/Owp6vzsKe/87Cok/OwqKfzsKi787Cpj/OwqaPzsKm387Cqi/Owqp/zsKqz87Crh/Owq5vzsKuv87Csg/OwrJfzsKyr87Csv/OwrZPzsK2n87Ctu/Owro/zsK6j87Cut/Owr4vzsK+f87Cvs/OwsIfzsLCb87Cwr/OwsYPzsLGX87Cxq/Owsb/zsLKT87Cyp/OwsrvzsLOP87Czo/Ows7fzsLSL87C0n/OwtLPzsLWH87C1m/Owta/zsLaD87C2lw=="
	},
	{
		"string": "",
		"encodedString": "87C2q/Owtr/zsLeT87C3p/Owt7vzsLiP87C4o/OwuLfzsLmL87C5n/OwubPzsLqH87C6m/Owuq/zsLuD87C7l/Owu6vzsLu/87C8k/OwvKfzsLy787C9j/OwvaPzsL2387C+i/Owvp/zsL6z87C/h/Owv5vzsL+v87GAg/OxgJfzsYCr87GAv/OxgZPzsYGn87GBu/Oxgo/zsYKj87GCt/Oxg4vzsYOf87GDs/OxhIfzsYSb87GEr/OxhYPzsYWX87GFq/Oxhb/zsYaT87GGp/OxhrvzsYeP87GHo/Oxh7fzsYiL87GIn/OxiLPzsYmH87GJm/Oxia/zsYqD87GKl/OxiqvzsYq/87GLk/Oxi6fzsYu787GMj/OxjKPzsYy387GNi/OxjZ/zsY2z87GOh/OxjpvzsY6v87GPg/Oxj5fzsY+r87GPv/OxkJPzsZCn87GQu/OxkY/zsZGj87GRt/OxkovzsZKf87GSs/Oxk4fzsZOb87GTr/OxlIPzsZSX87GUq/OxlL/zsZWT87GVpw=="
	},
	{
		"string": "",
		"encodedString": "87GVu/Oxlo/zsZaj87GWt/Oxl4vzsZef87GXs/OxmIfzsZib87GYr/OxmYPzsZmX87GZq/Oxmb/zsZqT87Gap/OxmrvzsZuP87Gbo/Oxm7fzsZyL87Gcn/OxnLPzsZ2H87Gdm/Oxna/zsZ6D87Gel/OxnqvzsZ6/87Gfk/Oxn6fzsZ+787Ggj/OxoKPzsaC387Ghi/OxoZ/zsaGz87Gih/OxopvzsaKv87Gjg/Oxo5fzsaOr87Gjv/OxpJPzsaSn87Gku/OxpY/zsaWj87Glt/Oxpovzsaaf87Gms/Oxp4fzsaeb87Gnr/OxqIPzsaiX87Goq/OxqL/zsamT87Gpp/OxqbvzsaqP87Gqo/OxqrfzsauL87Grn/Oxq7PzsayH87Gsm/OxrK/zsa2D87Gtl/Oxravzsa2/87Guk/Oxrqfzsa6787Gvj/Oxr6Pzsa+387Gwi/OxsJ/zsbCz87Gxh/OxsZvzsbGv87Gyg/OxspfzsbKr87Gyv/Oxs5PzsbOn87Gzu/OxtI/zsbSj87G0tw=="
	},
	{
		"string": "",
		"encodedString": "87G1i/OxtZ/zsbWz87G2h/Oxtpvzsbav87G3g/Oxt5fzsber87G3v/OxuJPzsbin87G4u/OxuY/zsbmj87G5t/Oxuovzsbqf87G6s/Oxu4fzsbub87G7r/OxvIPzsbyX87G8q/OxvL/zsb2T87G9p/Oxvbvzsb6P87G+o/Oxvrfzsb+L87G/n/Oxv7PzsoCH87KAm/OygK/zsoGD87KBl/OygavzsoG/87KCk/OygqfzsoK787KDj/Oyg6PzsoO387KEi/OyhJ/zsoSz87KFh/OyhZvzsoWv87KGg/Oyhpfzsoar87KGv/Oyh5Pzsoen87KHu/OyiI/zsoij87KIt/OyiYvzsomf87KJs/Oyiofzsoqb87KKr/Oyi4PzsouX87KLq/Oyi7/zsoyT87KMp/OyjLvzso2P87KNo/Oyjbfzso6L87KOn/OyjrPzso+H87KPm/Oyj6/zspCD87KQl/OykKvzspC/87KRk/OykafzspG787KSj/OykqPzspK387KTi/Oyk5/zspOz87KUhw=="
	},
	{
		"string": "",
		"encodedString": "87KUm/OylK/zspWD87KVl/OylavzspW/87KWk/Oylqfzspa787KXj/Oyl6Pzspe387KYi/OymJ/zspiz87KZh/OymZvzspmv87Kag/Oympfzspqr87Kav/Oym5Pzspun87Kbu/OynI/zspyj87Kct/OynYvzsp2f87Kds/Oynofzsp6b87Ker/Oyn4Pzsp+X87Kfq/Oyn7/zsqCT87Kgp/OyoLvzsqGP87Kho/OyobfzsqKL87Kin/OyorPzsqOH87Kjm/Oyo6/zsqSD87Kkl/OypKvzsqS/87Klk/OypafzsqW787Kmj/OypqPzsqa387Kni/Oyp5/zsqez87Koh/OyqJvzsqiv87Kpg/OyqZfzsqmr87Kpv/OyqpPzsqqn87Kqu/Oyq4/zsquj87Krt/OyrIvzsqyf87Kss/OyrYfzsq2b87Ktr/OyroPzsq6X87Kuq/Oyrr/zsq+T87Kvp/Oyr7vzsrCP87Kwo/OysLfzsrGL87Kxn/OysbPzsrKH87Kym/Oysq/zsrOD87Kzlw=="
	},
	{
		"string": "",
		"encodedString": "87Kzq/Oys7/zsrST87K0p/OytLvzsrWP87K1o/OytbfzsraL87K2n/OytrPzsreH87K3m/Oyt6/zsriD87K4l/OyuKvzsri/87K5k/Oyuafzsrm787K6j/OyuqPzsrq387K7i/Oyu5/zsruz87K8h/OyvJvzsryv87K9g/OyvZfzsr2r87K9v/OyvpPzsr6n87K+u/Oyv4/zsr+j87K/t/OzgIvzs4Cf87OAs/OzgYfzs4Gb87OBr/OzgoPzs4KX87OCq/Ozgr/zs4OT87ODp/Ozg7vzs4SP87OEo/OzhLfzs4WL87OFn/OzhbPzs4aH87OGm/Ozhq/zs4eD87OHl/Ozh6vzs4e/87OIk/OziKfzs4i787OJj/OziaPzs4m387OKi/Ozip/zs4qz87OLh/Ozi5vzs4uv87OMg/OzjJfzs4yr87OMv/OzjZPzs42n87ONu/Ozjo/zs46j87OOt/Ozj4vzs4+f87OPs/OzkIfzs5Cb87OQr/OzkYPzs5GX87ORq/Ozkb/zs5KT87OSpw=="
	},
	{
		"string": "",
		"encodedString": "87OSu/Ozk4/zs5Oj87OTt/OzlIvzs5Sf87OUs/OzlYfzs5Wb87OVr/OzloPzs5aX87OWq/Ozlr/zs5eT87OXp/Ozl7vzs5iP87OYo/OzmLfzs5mL87OZn/OzmbPzs5qH87Oam/Ozmq/zs5uD87Obl/Ozm6vzs5u/87Ock/OznKfzs5y787Odj/OznaPzs52387Oei/Oznp/zs56z87Ofh/Ozn5vzs5+v87Ogg/OzoJfzs6Cr87Ogv/OzoZPzs6Gn87Ohu/Ozoo/zs6Kj87Oit/Ozo4vzs6Of87Ojs/OzpIfzs6Sb87Okr/OzpYPzs6WX87Olq/Ozpb/zs6aT87Omp/Ozprvzs6eP87Ono/Ozp7fzs6iL87Oon/OzqLPzs6mH87Opm/Ozqa/zs6qD87Oql/Ozqqvzs6q/87Ork/Ozq6fzs6u787Osj/OzrKPzs6y387Oti/OzrZ/zs62z87Ouh/Ozrpvzs66v87Ovg/Ozr5fzs6+r87Ovv/OzsJPzs7Cn87Owu/OzsY/zs7Gj87Oxtw=="
	},
	{
		"string": "",
		"encodedString": "87Oyi/Ozsp/zs7Kz87Ozh/Ozs5vzs7Ov87O0g/OztJfzs7Sr87O0v/OztZPzs7Wn87O1u/Ozto/zs7aj87O2t/Ozt4vzs7ef87O3s/OzuIfzs7ib87O4r/OzuYPzs7mX87O5q/Ozub/zs7qT87O6p/Ozurvzs7uP87O7o/Ozu7fzs7yL87O8n/OzvLPzs72H87O9m/Ozva/zs76D87O+l/Ozvqvzs76/87O/k/Ozv6fzs7+787SAj/O0gKPztIC387SBi/O0gZ/ztIGz87SCh/O0gpvztIKv87SDg/O0g5fztIOr87SDv/O0hJPztISn87SEu/O0hY/ztIWj87SFt/O0hovztIaf87SGs/O0h4fztIeb87SHr/O0iIPztIiX87SIq/O0iL/ztImT87SJp/O0ibvztIqP87SKo/O0irfztIuL87SLn/O0i7PztIyH87SMm/O0jK/ztI2D87SNl/O0javztI2/87SOk/O0jqfztI6787SPj/O0j6PztI+387SQi/O0kJ/ztJCz87SRhw=="
	},
	{
		"string": "",
		"encodedString": "87SRm/O0ka/ztJKD87SSl/O0kqvztJK/87STk/O0k6fztJO787SUj/O0lKPztJS387SVi/O0lZ/ztJWz87SWh/O0lpvztJav87SXg/O0l5fztJer87SXv/O0mJPztJin87SYu/O0mY/ztJmj87SZt/O0movztJqf87Sas/O0m4fztJub87Sbr/O0nIPztJyX87Scq/O0nL/ztJ2T87Sdp/O0nbvztJ6P87Seo/O0nrfztJ+L87Sfn/O0n7PztKCH87Sgm/O0oK/ztKGD87Shl/O0oavztKG/87Sik/O0oqfztKK787Sjj/O0o6PztKO387Ski/O0pJ/ztKSz87Slh/O0pZvztKWv87Smg/O0ppfztKar87Smv/O0p5PztKen87Snu/O0qI/ztKij87Sot/O0qYvztKmf87Sps/O0qofztKqb87Sqr/O0q4PztKuX87Srq/O0q7/ztKyT87Ssp/O0rLvztK2P87Sto/O0rbfztK6L87Sun/O0rrPztK+H87Svm/O0r6/ztLCD87Swlw=="
	},
	{
		"string": "",
		"encodedString": "87Swq/O0sL/ztLGT87Sxp/O0sbvztLKP87Syo/O0srfztLOL87Szn/O0s7PztLSH87S0m/O0tK/ztLWD87S1l/O0tavztLW/87S2k/O0tqfztLa787S3j/O0t6PztLe387S4i/O0uJ/ztLiz87S5h/O0uZvztLmv87S6g/O0upfztLqr87S6v/O0u5PztLun87S7u/O0vI/ztLyj87S8t/O0vYvztL2f87S9s/O0vofztL6b87S+r/O0v4PztL+X87S/q/O0v7/ztYCT87WAp/O1gLvztYGP87WBo/O1gbfztYKL87WCn/O1grPztYOH87WDm/O1g6/ztYSD87WEl/O1hKvztYS/87WFk/O1hafztYW787WGj/O1hqPztYa387WHi/O1h5/ztYez87WIh/O1iJvztYiv87WJg/O1iZfztYmr87WJv/O1ipPztYqn87WKu/O1i4/ztYuj87WLt/O1jIvztYyf87WMs/O1jYfztY2b87WNr/O1joPztY6X87WOq/O1jr/ztY+T87WPpw=="
	},
	{
		"string": "",
		"encodedString": "87WPu/O1kI/ztZCj87WQt/O1kYvztZGf87WRs/O1kofztZKb87WSr/O1k4PztZOX87WTq/O1k7/ztZST87WUp/O1lLvztZWP87WVo/O1lbfztZaL87WWn/O1lrPztZeH87WXm/O1l6/ztZiD87WYl/O1mKvztZi/87WZk/O1mafztZm787Waj/O1mqPztZq387Wbi/O1m5/ztZuz87Wch/O1nJvztZyv87Wdg/O1nZfztZ2r87Wdv/O1npPztZ6n87Weu/O1n4/ztZ+j87Wft/O1oIvztaCf87Wgs/O1oYfztaGb87Whr/O1ooPztaKX87Wiq/O1or/ztaOT87Wjp/O1o7vztaSP87Wko/O1pLfztaWL87Wln/O1pbPztaaH87Wmm/O1pq/ztaeD87Wnl/O1p6vztae/87Wok/O1qKfztai787Wpj/O1qaPztam387Wqi/O1qp/ztaqz87Wrh/O1q5vztauv87Wsg/O1rJfztayr87Wsv/O1rZPzta2n87Wtu/O1ro/zta6j87Wutw=="
	},
	{
		"string": "",
		"encodedString": "87Wvi/O1r5/zta+z87Wwh/O1sJvztbCv87Wxg/O1sZfztbGr87Wxv/O1spPztbKn87Wyu/O1s4/ztbOj87Wzt/O1tIvztbSf87W0s/O1tYfztbWb87W1r/O1toPztbaX87W2q/O1tr/ztbeT87W3p/O1t7vztbiP87W4o/O1uLfztbmL87W5n/O1ubPztbqH87W6m/O1uq/ztbuD87W7l/O1u6vztbu/87W8k/O1vKfztby787W9j/O1vaPztb2387W+i/O1vp/ztb6z87W/h/O1v5vztb+v87aAg/O2gJfztoCr87aAv/O2gZPztoGn87aBu/O2go/ztoKj87aCt/O2g4vztoOf87aDs/O2hIfztoSb87aEr/O2hYPztoWX87aFq/O2hb/ztoaT87aGp/O2hrvztoeP87aHo/O2h7fztoiL87aIn/O2iLPztomH87aJm/O2ia/ztoqD87aKl/O2iqvztoq/87aLk/O2i6fztou787aMj/O2jKPztoy387aNi/O2jZ/zto2z87aOhw=="
	},
	{
		"string": "",
		"encodedString": "87aOm/O2jq/zto+D87aPl/O2j6vzto+/87aQk/O2kKfztpC787aRj/O2kaPztpG387aSi/O2kp/ztpKz87aTh/O2k5vztpOv87aUg/O2lJfztpSr87aUv/O2lZPztpWn87aVu/O2lo/ztpaj87aWt/O2l4vztpef87aXs/O2mIfztpib87aYr/O2mYPztpmX87aZq/O2mb/ztpqT87aap/O2mrvztpuP87abo/O2m7fztpyL87acn/O2nLPztp2H87adm/O2na/ztp6D87ael/O2nqvztp6/87afk/O2n6fztp+787agj/O2oKPztqC387ahi/O2oZ/ztqGz87aih/O2opvztqKv87ajg/O2o5fztqOr87ajv/O2pJPztqSn87aku/O2pY/ztqWj87alt/O2povztqaf87ams/O2p4fztqeb87anr/O2qIPztqiX87aoq/O2qL/ztqmT87app/O2qbvztqqP87aqo/O2qrfztquL87arn/O2q7PztqyH87asm/O2rK/ztq2D87atlw=="
	},
	{
		"string": "",
		"encodedString": "87atq/O2rb/ztq6T87aup/O2rrvztq+P87avo/O2r7fztrCL87awn/O2sLPztrGH87axm/O2sa/ztrKD87ayl/O2sqvztrK/87azk/O2s6fztrO787a0j/O2tKPztrS387a1i/O2tZ/ztrWz87a2h/O2tpvztrav87a3g/O2t5fztrer87a3v/O2uJPztrin87a4u/O2uY/ztrmj87a5t/O2uovztrqf87a6s/O2u4fztrub87a7r/O2vIPztryX87a8q/O2vL/ztr2T87a9p/O2vbvztr6P87a+o/O2vrfztr+L87a/n/O2v7Pzt4CH87eAm/O3gK/zt4GD87eBl/O3gavzt4G/87eCk/O3gqfzt4K787eDj/O3g6Pzt4O387eEi/O3hJ/zt4Sz87eFh/O3hZvzt4Wv87eGg/O3hpfzt4ar87eGv/O3h5Pzt4en87eHu/O3iI/zt4ij87eIt/O3iYvzt4mf87eJs/O3iofzt4qb87eKr/O3i4Pzt4uX87eLq/O3i7/zt4yT87eMpw=="
	},
	{
		"string": "",
		"encodedString": "87eMu/O3jY/zt42j87eNt/O3jovzt46f87eOs/O3j4fzt4+b87ePr/O3kIPzt5CX87eQq/O3kL/zt5GT87eRp/O3kbvzt5KP87eSo/O3krfzt5OL87eTn/O3k7Pzt5SH87eUm/O3lK/zt5WD87eVl/O3lavzt5W/87eWk/O3lqfzt5a787eXj/O3l6Pzt5e387eYi/O3mJ/zt5iz87eZh/O3mZvzt5mv87eag/O3mpfzt5qr87eav/O3m5Pzt5un87ebu/O3nI/zt5yj87ect/O3nYvzt52f87eds/O3nofzt56b87eer/O3n4Pzt5+X87efq/O3n7/zt6CT87egp/O3oLvzt6GP87eho/O3obfzt6KL87ein/O3orPzt6OH87ejm/O3o6/zt6SD87ekl/O3pKvzt6S/87elk/O3pafzt6W787emj/O3pqPzt6a387eni/O3p5/zt6ez87eoh/O3qJvzt6iv87epg/O3qZfzt6mr87epv/O3qpPzt6qn87equ/O3q4/zt6uj87ertw=="
	},
	{
		"string": "",
		"encodedString": "87esi/O3rJ/zt6yz87eth/O3rZvzt62v87eug/O3rpfzt66r87euv/O3r5Pzt6+n87evu/O3sI/zt7Cj87ewt/O3sYvzt7Gf87exs/O3sofzt7Kb87eyr/O3s4Pzt7OX87ezq/O3s7/zt7ST87e0p/O3tLvzt7WP87e1o/O3tbfzt7aL87e2n/O3trPzt7eH87e3m/O3t6/zt7iD87e4l/O3uKvzt7i/87e5k/O3uafzt7m787e6j/O3uqPzt7q387e7i/O3u5/zt7uz87e8h/O3vJvzt7yv87e9g/O3vZfzt72r87e9v/O3vpPzt76n87e+u/O3v4/zt7+j87e/t/O4gIvzuICf87iAs/O4gYfzuIGb87iBr/O4goPzuIKX87iCq/O4gr/zuIOT87iDp/O4g7vzuISP87iEo/O4hLfzuIWL87iFn/O4hbPzuIaH87iGm/O4hq/zuIeD87iHl/O4h6vzuIe/87iIk/O4iKfzuIi787iJj/O4iaPzuIm387iKi/O4ip/zuIqz87iLhw=="
	},
	{
		"string": "",
		"encodedString": "87iLm/O4i6/zuIyD87iMl/O4jKvzuIy/87iNk/O4jafzuI2787iOj/O4jqPzuI6387iPi/O4j5/zuI+z87iQh/O4kJvzuJCv87iRg/O4kZfzuJGr87iRv/O4kpPzuJKn87iSu/O4k4/zuJOj87iTt/O4lIvzuJSf87iUs/O4lYfzuJWb87iVr/O4loPzuJaX87iWq/O4lr/zuJeT87iXp/O4l7vzuJiP87iYo/O4mLfzuJmL87iZn/O4mbPzuJqH87iam/O4mq/zuJuD87ibl/O4m6vzuJu/87ick/O4nKfzuJy787idj/O4naPzuJ2387iei/O4np/zuJ6z87ifh/O4n5vzuJ+v87igg/O4oJfzuKCr87igv/O4oZPzuKGn87ihu/O4oo/zuKKj87iit/O4o4vzuKOf87ijs/O4pIfzuKSb87ikr/O4pYPzuKWX87ilq/O4pb/zuKaT87imp/O4prvzuKeP87ino/O4p7fzuKiL87ion/O4qLPzuKmH87ipm/O4qa/zuKqD87iqlw=="
	},
	{
		"string": "",
		"encodedString": "87iqq/O4qr/zuKuT87irp/O4q7vzuKyP87iso/O4rLfzuK2L87itn/O4rbPzuK6H87ium/O4rq/zuK+D87ivl/O4r6vzuK+/87iwk/O4sKfzuLC787ixj/O4saPzuLG387iyi/O4sp/zuLKz87izh/O4s5vzuLOv87i0g/O4tJfzuLSr87i0v/O4tZPzuLWn87i1u/O4to/zuLaj87i2t/O4t4vzuLef87i3s/O4uIfzuLib87i4r/O4uYPzuLmX87i5q/O4ub/zuLqT87i6p/O4urvzuLuP87i7o/O4u7fzuLyL87i8n/O4vLPzuL2H87i9m/O4va/zuL6D87i+l/O4vqvzuL6/87i/k/O4v6fzuL+787mAj/O5gKPzuYC387mBi/O5gZ/zuYGz87mCh/O5gpvzuYKv87mDg/O5g5fzuYOr87mDv/O5hJPzuYSn87mEu/O5hY/zuYWj87mFt/O5hovzuYaf87mGs/O5h4fzuYeb87mHr/O5iIPzuYiX87mIq/O5iL/zuYmT87mJpw=="
	},
	{
		"string": "",
		"encodedString": "87mJu/O5io/zuYqj87mKt/O5i4vzuYuf87mLs/O5jIfzuYyb87mMr/O5jYPzuY2X87mNq/O5jb/zuY6T87mOp/O5jrvzuY+P87mPo/O5j7fzuZCL87mQn/O5kLPzuZGH87mRm/O5ka/zuZKD87mSl/O5kqvzuZK/87mTk/O5k6fzuZO787mUj/O5lKPzuZS387mVi/O5lZ/zuZWz87mWh/O5lpvzuZav87mXg/O5l5fzuZer87mXv/O5mJPzuZin87mYu/O5mY/zuZmj87mZt/O5movzuZqf87mas/O5m4fzuZub87mbr/O5nIPzuZyX87mcq/O5nL/zuZ2T87mdp/O5nbvzuZ6P87meo/O5nrfzuZ+L87mfn/O5n7PzuaCH87mgm/O5oK/zuaGD87mhl/O5oavzuaG/87mik/O5oqfzuaK787mjj/O5o6PzuaO387mki/O5pJ/zuaSz87mlh/O5pZvzuaWv87mmg/O5ppfzuaar87mmv/O5p5Pzuaen87mnu/O5qI/zuaij87motw=="
	},
	{
		"string": "",
		"encodedString": "87mpi/O5qZ/zuamz87mqh/O5qpvzuaqv87mrg/O5q5fzuaur87mrv/O5rJPzuayn87msu/O5rY/zua2j87mtt/O5rovzua6f87mus/O5r4fzua+b87mvr/O5sIPzubCX87mwq/O5sL/zubGT87mxp/O5sbvzubKP87myo/O5srfzubOL87mzn/O5s7PzubSH87m0m/O5tK/zubWD87m1l/O5tavzubW/87m2k/O5tqfzuba787m3j/O5t6Pzube387m4i/O5uJ/zubiz87m5h/O5uZvzubmv87m6g/O5upfzubqr87m6v/O5u5Pzubun87m7u/O5vI/zubyj87m8t/O5vYvzub2f87m9s/O5vofzub6b87m+r/O5v4Pzub+X87m/q/O5v7/zuoCT87qAp/O6gLvzuoGP87qBo/O6gbfzuoKL87qCn/O6grPzuoOH87qDm/O6g6/zuoSD87qEl/O6hKvzuoS/87qFk/O6hafzuoW787qGj/O6hqPzuoa387qHi/O6h5/zuoez87qIhw=="
	},
	{
		"string": "",
		"encodedString": "87qIm/O6iK/zuomD87qJl/O6iavzuom/87qKk/O6iqfzuoq787qLj/O6i6Pzuou387qMi/O6jJ/zuoyz87qNh/O6jZvzuo2v87qOg/O6jpfzuo6r87qOv/O6j5Pzuo+n87qPu/O6kI/zupCj87qQt/O6kYvzupGf87qRs/O6kofzupKb87qSr/O6k4PzupOX87qTq/O6k7/zupST87qUp/O6lLvzupWP87qVo/O6lbfzupaL87qWn/O6lrPzupeH87qXm/O6l6/zupiD87qYl/O6mKvzupi/87qZk/O6mafzupm787qaj/O6mqPzupq387qbi/O6m5/zupuz87qch/O6nJvzupyv87qdg/O6nZfzup2r87qdv/O6npPzup6n87qeu/O6n4/zup+j87qft/O6oIvzuqCf87qgs/O6oYfzuqGb87qhr/O6ooPzuqKX87qiq/O6or/zuqOT87qjp/O6o7vzuqSP87qko/O6pLfzuqWL87qln/O6pbPzuqaH87qmm/O6pq/zuqeD87qnlw=="
	},
	{
		"string": "",
		"encodedString": "87qnq/O6p7/zuqiT87qop/O6qLvzuqmP87qpo/O6qbfzuqqL87qqn/O6qrPzuquH87qrm/O6q6/zuqyD87qsl/O6rKvzuqy/87qtk/O6rafzuq2787quj/O6rqPzuq6387qvi/O6r5/zuq+z87qwh/O6sJvzurCv87qxg/O6sZfzurGr87qxv/O6spPzurKn87qyu/O6s4/zurOj87qzt/O6tIvzurSf87q0s/O6tYfzurWb87q1r/O6toPzuraX87q2q/O6tr/zureT87q3p/O6t7vzuriP87q4o/O6uLfzurmL87q5n/O6ubPzurqH87q6m/O6uq/zuruD87q7l/O6u6vzuru/87q8k/O6vKfzury787q9j/O6vaPzur2387q+i/O6vp/zur6z87q/h/O6v5vzur+v87uAg/O7gJfzu4Cr87uAv/O7gZPzu4Gn87uBu/O7go/zu4Kj87uCt/O7g4vzu4Of87uDs/O7hIfzu4Sb87uEr/O7hYPzu4WX87uFq/O7hb/zu4aT87uGpw=="
	},
	{
		"string": "",
		"encodedString": "87uGu/O7h4/zu4ej87uHt/O7iIvzu4if87uIs/O7iYfzu4mb87uJr/O7ioPzu4qX87uKq/O7ir/zu4uT87uLp/O7i7vzu4yP87uMo/O7jLfzu42L87uNn/O7jbPzu46H87uOm/O7jq/zu4+D87uPl/O7j6vzu4+/87uQk/O7kKfzu5C787uRj/O7kaPzu5G387uSi/O7kp/zu5Kz87uTh/O7k5vzu5Ov87uUg/O7lJfzu5Sr87uUv/O7lZPzu5Wn87uVu/O7lo/zu5aj87uWt/O7l4vzu5ef87uXs/O7mIfzu5ib87uYr/O7mYPzu5mX87uZq/O7mb/zu5qT87uap/O7mrvzu5uP87ubo/O7m7fzu5yL87ucn/O7nLPzu52H87udm/O7na/zu56D87uel/O7nqvzu56/87ufk/O7n6fzu5+787ugj/O7oKPzu6C387uhi/O7oZ/zu6Gz87uih/O7opvzu6Kv87ujg/O7o5fzu6Or87ujv/O7pJPzu6Sn87uku/O7pY/zu6Wj87ultw=="
	},
	{
		"string": "",
		"encodedString": "87umi/O7pp/zu6az87unh/O7p5vzu6ev87uog/O7qJfzu6ir87uov/O7qZPzu6mn87upu/O7qo/zu6qj87uqt/O7q4vzu6uf87urs/O7rIfzu6yb87usr/O7rYPzu62X87utq/O7rb/zu66T87uup/O7rrvzu6+P87uvo/O7r7fzu7CL87uwn/O7sLPzu7GH87uxm/O7sa/zu7KD87uyl/O7sqvzu7K/87uzk/O7s6fzu7O787u0j/O7tKPzu7S387u1i/O7tZ/zu7Wz87u2h/O7tpvzu7av87u3g/O7t5fzu7er87u3v/O7uJPzu7in87u4u/O7uY/zu7mj87u5t/O7uovzu7qf87u6s/O7u4fzu7ub87u7r/O7vIPzu7yX87u8q/O7vL/zu72T87u9p/O7vbvzu76P87u+o/O7vrfzu7+L87u/n/O7v7PzvICH87yAm/O8gK/zvIGD87yBl/O8gavzvIG/87yCk/O8gqfzvIK787yDj/O8g6PzvIO387yEi/O8hJ/zvISz87yFhw=="
	},
	{
		"string": "",
		"encodedString": "87yFm/O8ha/zvIaD87yGl/O8hqvzvIa/87yHk/O8h6fzvIe787yIj/O8iKPzvIi387yJi/O8iZ/zvImz87yKh/O8ipvzvIqv87yLg/O8i5fzvIur87yLv/O8jJPzvIyn87yMu/O8jY/zvI2j87yNt/O8jovzvI6f87yOs/O8j4fzvI+b87yPr/O8kIPzvJCX87yQq/O8kL/zvJGT87yRp/O8kbvzvJKP87ySo/O8krfzvJOL87yTn/O8k7PzvJSH87yUm/O8lK/zvJWD87yVl/O8lavzvJW/87yWk/O8lqfzvJa787yXj/O8l6PzvJe387yYi/O8mJ/zvJiz87yZh/O8mZvzvJmv87yag/O8mpfzvJqr87yav/O8m5PzvJun87ybu/O8nI/zvJyj87yct/O8nYvzvJ2f87yds/O8nofzvJ6b87yer/O8n4PzvJ+X87yfq/O8n7/zvKCT87ygp/O8oLvzvKGP87yho/O8obfzvKKL87yin/O8orPzvKOH87yjm/O8o6/zvKSD87yklw=="
	},
	{
		"string": "",
		"encodedString": "87ykq/O8pL/zvKWT87ylp/O8pbvzvKaP87ymo/O8prfzvKeL87ynn/O8p7PzvKiH87yom/O8qK/zvKmD87ypl/O8qavzvKm/87yqk/O8qqfzvKq787yrj/O8q6PzvKu387ysi/O8rJ/zvKyz87yth/O8rZvzvK2v87yug/O8rpfzvK6r87yuv/O8r5PzvK+n87yvu/O8sI/zvLCj87ywt/O8sYvzvLGf87yxs/O8sofzvLKb87yyr/O8s4PzvLOX87yzq/O8s7/zvLST87y0p/O8tLvzvLWP87y1o/O8tbfzvLaL87y2n/O8trPzvLeH87y3m/O8t6/zvLiD87y4l/O8uKvzvLi/87y5k/O8uafzvLm787y6j/O8uqPzvLq387y7i/O8u5/zvLuz87y8h/O8vJvzvLyv87y9g/O8vZfzvL2r87y9v/O8vpPzvL6n87y+u/O8v4/zvL+j87y/t/O9gIvzvYCf872As/O9gYfzvYGb872Br/O9goPzvYKX872Cq/O9gr/zvYOT872Dpw=="
	},
	{
		"string": "",
		"encodedString": "872Du/O9hI/zvYSj872Et/O9hYvzvYWf872Fs/O9hofzvYab872Gr/O9h4PzvYeX872Hq/O9h7/zvYiT872Ip/O9iLvzvYmP872Jo/O9ibfzvYqL872Kn/O9irPzvYuH872Lm/O9i6/zvYyD872Ml/O9jKvzvYy/872Nk/O9jafzvY27872Oj/O9jqPzvY63872Pi/O9j5/zvY+z872Qh/O9kJvzvZCv872Rg/O9kZfzvZGr872Rv/O9kpPzvZKn872Su/O9k4/zvZOj872Tt/O9lIvzvZSf872Us/O9lYfzvZWb872Vr/O9loPzvZaX872Wq/O9lr/zvZeT872Xp/O9l7vzvZiP872Yo/O9mLfzvZmL872Zn/O9mbPzvZqH872am/O9mq/zvZuD872bl/O9m6vzvZu/872ck/O9nKfzvZy7872dj/O9naPzvZ23872ei/O9np/zvZ6z872fh/O9n5vzvZ+v872gg/O9oJfzvaCr872gv/O9oZPzvaGn872hu/O9oo/zvaKj872itw=="
	},
	{
		"string": "",
		"encodedString": "872ji/O9o5/zvaOz872kh/O9pJvzvaSv872lg/O9pZfzvaWr872lv/O9ppPzvaan872mu/O9p4/zvaej872nt/O9qIvzvaif872os/O9qYfzvamb872pr/O9qoPzvaqX872qq/O9qr/zvauT872rp/O9q7vzvayP872so/O9rLfzva2L872tn/O9rbPzva6H872um/O9rq/zva+D872vl/O9r6vzva+/872wk/O9sKfzvbC7872xj/O9saPzvbG3872yi/O9sp/zvbKz872zh/O9s5vzvbOv8720g/O9tJfzvbSr8720v/O9tZPzvbWn8721u/O9to/zvbaj8722t/O9t4vzvbef8723s/O9uIfzvbib8724r/O9uYPzvbmX8725q/O9ub/zvbqT8726p/O9urvzvbuP8727o/O9u7fzvbyL8728n/O9vLPzvb2H8729m/O9va/zvb6D872+l/O9vqvzvb6/872/k/O9v6fzvb+7876Aj/O+gKPzvoC3876Bi/O+gZ/zvoGz876Chw=="
	},
	{
		"string": "",
		"encodedString": "876Cm/O+gq/zvoOD876Dl/O+g6vzvoO/876Ek/O+hKfzvoS7876Fj/O+haPzvoW3876Gi/O+hp/zvoaz876Hh/O+h5vzvoev876Ig/O+iJfzvoir876Iv/O+iZPzvomn876Ju/O+io/zvoqj876Kt/O+i4vzvouf876Ls/O+jIfzvoyb876Mr/O+jYPzvo2X876Nq/O+jb/zvo6T876Op/O+jrvzvo+P876Po/O+j7fzvpCL876Qn/O+kLPzvpGH876Rm/O+ka/zvpKD876Sl/O+kqvzvpK/876Tk/O+k6fzvpO7876Uj/O+lKPzvpS3876Vi/O+lZ/zvpWz876Wh/O+lpvzvpav876Xg/O+l5fzvper876Xv/O+mJPzvpin876Yu/O+mY/zvpmj876Zt/O+movzvpqf876as/O+m4fzvpub876br/O+nIPzvpyX876cq/O+nL/zvp2T876dp/O+nbvzvp6P876eo/O+nrfzvp+L876fn/O+n7PzvqCH876gm/O+oK/zvqGD876hlw=="
	},
	{
		"string": "",
		"encodedString": "876hq/O+ob/zvqKT876ip/O+orvzvqOP876jo/O+o7fzvqSL876kn/O+pLPzvqWH876lm/O+pa/zvqaD876ml/O+pqvzvqa/876nk/O+p6fzvqe7876oj/O+qKPzvqi3876pi/O+qZ/zvqmz876qh/O+qpvzvqqv876rg/O+q5fzvqur876rv/O+rJPzvqyn876su/O+rY/zvq2j876tt/O+rovzvq6f876us/O+r4fzvq+b876vr/O+sIPzvrCX876wq/O+sL/zvrGT876xp/O+sbvzvrKP876yo/O+srfzvrOL876zn/O+s7PzvrSH8760m/O+tK/zvrWD8761l/O+tavzvrW/8762k/O+tqfzvra78763j/O+t6Pzvre38764i/O+uJ/zvriz8765h/O+uZvzvrmv8766g/O+upfzvrqr8766v/O+u5Pzvrun8767u/O+vI/zvryj8768t/O+vYvzvr2f8769s/O+vofzvr6b876+r/O+v4Pzvr+X876/q/O+v7/zv4CT87+Apw=="
	},
	{
		"string": "",
		"encodedString": "87+Au/O/gY/zv4Gj87+Bt/O/govzv4Kf87+Cs/O/g4fzv4Ob87+Dr/O/hIPzv4SX87+Eq/O/hL/zv4WT87+Fp/O/hbvzv4aP87+Go/O/hrfzv4eL87+Hn/O/h7Pzv4iH87+Im/O/iK/zv4mD87+Jl/O/iavzv4m/87+Kk/O/iqfzv4q787+Lj/O/i6Pzv4u387+Mi/O/jJ/zv4yz87+Nh/O/jZvzv42v87+Og/O/jpfzv46r87+Ov/O/j5Pzv4+n87+Pu/O/kI/zv5Cj87+Qt/O/kYvzv5Gf87+Rs/O/kofzv5Kb87+Sr/O/k4Pzv5OX87+Tq/O/k7/zv5ST87+Up/O/lLvzv5WP87+Vo/O/lbfzv5aL87+Wn/O/lrPzv5eH87+Xm/O/l6/zv5iD87+Yl/O/mKvzv5i/87+Zk/O/mafzv5m787+aj/O/mqPzv5q387+bi/O/m5/zv5uz87+ch/O/nJvzv5yv87+dg/O/nZfzv52r87+dv/O/npPzv56n87+eu/O/n4/zv5+j87+ftw=="
	},
	{
		"string": "",
		"encodedString": "87+gi/O/oJ/zv6Cz87+hh/O/oZvzv6Gv87+ig/O/opfzv6Kr87+iv/O/o5Pzv6On87+ju/O/pI/zv6Sj87+kt/O/pYvzv6Wf87+ls/O/pofzv6ab87+mr/O/p4Pzv6eX87+nq/O/p7/zv6iT87+op/O/qLvzv6mP87+po/O/qbfzv6qL87+qn/O/qrPzv6uH87+rm/O/q6/zv6yD87+sl/O/rKvzv6y/87+tk/O/rafzv62787+uj/O/rqPzv66387+vi/O/r5/zv6+z87+wh/O/sJvzv7Cv87+xg/O/sZfzv7Gr87+xv/O/spPzv7Kn87+yu/O/s4/zv7Oj87+zt/O/tIvzv7Sf87+0s/O/tYfzv7Wb87+1r/O/toPzv7aX87+2q/O/tr/zv7eT87+3p/O/t7vzv7iP87+4o/O/uLfzv7mL87+5n/O/ubPzv7qH87+6m/O/uq/zv7uD87+7l/O/u6vzv7u/87+8k/O/vKfzv7y787+9j/O/vaPzv72387++i/O/vp/zv76z87+/hw=="
	},
	{
		"string": "",
		"encodedString": "87+/m/O/v6/0gICF9ICAmfSAgK30gIGB9ICBlfSAgan0gIG99ICCkfSAgqX0gIK59ICDjfSAg6H0gIO19ICEifSAhJ30gISx9ICFhfSAhZn0gIWt9ICGgfSAhpX0gIap9ICGvfSAh5H0gIel9ICHufSAiI30gIih9ICItfSAiYn0gImd9ICJsfSAioX0gIqZ9ICKrfSAi4H0gIuV9ICLqfSAi730gIyR9ICMpfSAjLn0gI2N9ICNofSAjbX0gI6J9ICOnfSAjrH0gI+F9ICPmfSAj630gJCB9ICQlfSAkKn0gJC99ICRkfSAkaX0gJG59ICSjfSAkqH0gJK19ICTifSAk530gJOx9ICUhfSAlJn0gJSt9ICVgfSAlZX0gJWp9ICVvfSAlpH0gJal9ICWufSAl430gJeh9ICXtfSAmIn0gJid9ICYsfSAmYX0gJmZ9ICZrfSAmoH0gJqV9ICaqfSAmr30gJuR9ICbpfSAm7n0gJyN9ICcofSAnLX0gJ2J9ICdnfSAnbH0gJ6F9ICemQ=="
	},
	{
		"string": "",
		"encodedString": "9ICerfSAn4H0gJ+V9ICfqfSAn730gKCR9ICgpfSAoLn0gKGN9IChofSAobX0gKKJ9ICinfSAorH0gKOF9ICjmfSAo630gKSB9ICklfSApKn0gKS99IClkfSApaX0gKW59ICmjfSApqH0gKa19ICnifSAp530gKex9ICohfSAqJn0gKit9ICpgfSAqZX0gKmp9ICpvfSAqpH0gKql9ICqufSAq430gKuh9ICrtfSArIn0gKyd9ICssfSArYX0gK2Z9ICtrfSAroH0gK6V9ICuqfSArr30gK+R9ICvpfSAr7n0gLCN9ICwofSAsLX0gLGJ9ICxnfSAsbH0gLKF9ICymfSAsq30gLOB9ICzlfSAs6n0gLO99IC0kfSAtKX0gLS59IC1jfSAtaH0gLW19IC2ifSAtp30gLax9IC3hfSAt5n0gLet9IC4gfSAuJX0gLip9IC4vfSAuZH0gLml9IC5ufSAuo30gLqh9IC6tfSAu4n0gLud9IC7sfSAvIX0gLyZ9IC8rfSAvYH0gL2V9IC9qQ=="
	},
	{
		"string": "",
		"encodedString": "9IC9vfSAvpH0gL6l9IC+ufSAv430gL+h9IC/tfSBgIn0gYCd9IGAsfSBgYX0gYGZ9IGBrfSBgoH0gYKV9IGCqfSBgr30gYOR9IGDpfSBg7n0gYSN9IGEofSBhLX0gYWJ9IGFnfSBhbH0gYaF9IGGmfSBhq30gYeB9IGHlfSBh6n0gYe99IGIkfSBiKX0gYi59IGJjfSBiaH0gYm19IGKifSBip30gYqx9IGLhfSBi5n0gYut9IGMgfSBjJX0gYyp9IGMvfSBjZH0gY2l9IGNufSBjo30gY6h9IGOtfSBj4n0gY+d9IGPsfSBkIX0gZCZ9IGQrfSBkYH0gZGV9IGRqfSBkb30gZKR9IGSpfSBkrn0gZON9IGTofSBk7X0gZSJ9IGUnfSBlLH0gZWF9IGVmfSBla30gZaB9IGWlfSBlqn0gZa99IGXkfSBl6X0gZe59IGYjfSBmKH0gZi19IGZifSBmZ30gZmx9IGahfSBmpn0gZqt9IGbgfSBm5X0gZup9IGbvfSBnJH0gZyl9IGcuQ=="
	},
	{
		"string": "",
		"encodedString": "9IGdjfSBnaH0gZ219IGeifSBnp30gZ6x9IGfhfSBn5n0gZ+t9IGggfSBoJX0gaCp9IGgvfSBoZH0gaGl9IGhufSBoo30gaKh9IGitfSBo4n0gaOd9IGjsfSBpIX0gaSZ9IGkrfSBpYH0gaWV9IGlqfSBpb30gaaR9IGmpfSBprn0gaeN9IGnofSBp7X0gaiJ9IGonfSBqLH0gamF9IGpmfSBqa30gaqB9IGqlfSBqqn0gaq99IGrkfSBq6X0gau59IGsjfSBrKH0gay19IGtifSBrZ30ga2x9IGuhfSBrpn0ga6t9IGvgfSBr5X0ga+p9IGvvfSBsJH0gbCl9IGwufSBsY30gbGh9IGxtfSBson0gbKd9IGysfSBs4X0gbOZ9IGzrfSBtIH0gbSV9IG0qfSBtL30gbWR9IG1pfSBtbn0gbaN9IG2ofSBtrX0gbeJ9IG3nfSBt7H0gbiF9IG4mfSBuK30gbmB9IG5lfSBuan0gbm99IG6kfSBuqX0gbq59IG7jfSBu6H0gbu19IG8iQ=="
	},
	{
		"string": "",
		"encodedString": "9IG8nfSBvLH0gb2F9IG9mfSBva30gb6B9IG+lfSBvqn0gb699IG/kfSBv6X0gb+59IKAjfSCgKH0goC19IKBifSCgZ30goGx9IKChfSCgpn0goKt9IKDgfSCg5X0goOp9IKDvfSChJH0goSl9IKEufSChY30goWh9IKFtfSChon0goad9IKGsfSCh4X0goeZ9IKHrfSCiIH0goiV9IKIqfSCiL30gomR9IKJpfSCibn0goqN9IKKofSCirX0gouJ9IKLnfSCi7H0goyF9IKMmfSCjK30go2B9IKNlfSCjan0go299IKOkfSCjqX0go659IKPjfSCj6H0go+19IKQifSCkJ30gpCx9IKRhfSCkZn0gpGt9IKSgfSCkpX0gpKp9IKSvfSCk5H0gpOl9IKTufSClI30gpSh9IKUtfSClYn0gpWd9IKVsfSCloX0gpaZ9IKWrfSCl4H0gpeV9IKXqfSCl730gpiR9IKYpfSCmLn0gpmN9IKZofSCmbX0gpqJ9IKanfSCmrH0gpuF9IKbmQ=="
	},
	{
		"string": "",
		"encodedString": "9IKbrfSCnIH0gpyV9IKcqfSCnL30gp2R9IKdpfSCnbn0gp6N9IKeofSCnrX0gp+J9IKfnfSCn7H0gqCF9IKgmfSCoK30gqGB9IKhlfSCoan0gqG99IKikfSCoqX0gqK59IKjjfSCo6H0gqO19IKkifSCpJ30gqSx9IKlhfSCpZn0gqWt9IKmgfSCppX0gqap9IKmvfSCp5H0gqel9IKnufSCqI30gqih9IKotfSCqYn0gqmd9IKpsfSCqoX0gqqZ9IKqrfSCq4H0gquV9IKrqfSCq730gqyR9IKspfSCrLn0gq2N9IKtofSCrbX0gq6J9IKunfSCrrH0gq+F9IKvmfSCr630grCB9IKwlfSCsKn0grC99IKxkfSCsaX0grG59IKyjfSCsqH0grK19IKzifSCs530grOx9IK0hfSCtJn0grSt9IK1gfSCtZX0grWp9IK1vfSCtpH0gral9IK2ufSCt430greh9IK3tfSCuIn0grid9IK4sfSCuYX0grmZ9IK5rfSCuoH0grqV9IK6qQ=="
	},
	{
		"string": "",
		"encodedString": "9IK6vfSCu5H0grul9IK7ufSCvI30gryh9IK8tfSCvYn0gr2d9IK9sfSCvoX0gr6Z9IK+rfSCv4H0gr+V9IK/qfSCv730g4CR9IOApfSDgLn0g4GN9IOBofSDgbX0g4KJ9IOCnfSDgrH0g4OF9IODmfSDg630g4SB9IOElfSDhKn0g4S99IOFkfSDhaX0g4W59IOGjfSDhqH0g4a19IOHifSDh530g4ex9IOIhfSDiJn0g4it9IOJgfSDiZX0g4mp9IOJvfSDipH0g4ql9IOKufSDi430g4uh9IOLtfSDjIn0g4yd9IOMsfSDjYX0g42Z9IONrfSDjoH0g46V9IOOqfSDjr30g4+R9IOPpfSDj7n0g5CN9IOQofSDkLX0g5GJ9IORnfSDkbH0g5KF9IOSmfSDkq30g5OB9IOTlfSDk6n0g5O99IOUkfSDlKX0g5S59IOVjfSDlaH0g5W19IOWifSDlp30g5ax9IOXhfSDl5n0g5et9IOYgfSDmJX0g5ip9IOYvfSDmZH0g5ml9IOZuQ=="
	},
	{
		"string": "",
		"encodedString": "9IOajfSDmqH0g5q19IObifSDm530g5ux9IOchfSDnJn0g5yt9IOdgfSDnZX0g52p9IOdvfSDnpH0g56l9IOeufSDn430g5+h9IOftfSDoIn0g6Cd9IOgsfSDoYX0g6GZ9IOhrfSDooH0g6KV9IOiqfSDor30g6OR9IOjpfSDo7n0g6SN9IOkofSDpLX0g6WJ9IOlnfSDpbH0g6aF9IOmmfSDpq30g6eB9IOnlfSDp6n0g6e99IOokfSDqKX0g6i59IOpjfSDqaH0g6m19IOqifSDqp30g6qx9IOrhfSDq5n0g6ut9IOsgfSDrJX0g6yp9IOsvfSDrZH0g62l9IOtufSDro30g66h9IOutfSDr4n0g6+d9IOvsfSDsIX0g7CZ9IOwrfSDsYH0g7GV9IOxqfSDsb30g7KR9IOypfSDsrn0g7ON9IOzofSDs7X0g7SJ9IO0nfSDtLH0g7WF9IO1mfSDta30g7aB9IO2lfSDtqn0g7a99IO3kfSDt6X0g7e59IO4jfSDuKH0g7i19IO5iQ=="
	},
	{
		"string": "",
		"encodedString": "9IO5nfSDubH0g7qF9IO6mfSDuq30g7uB9IO7lfSDu6n0g7u99IO8kfSDvKX0g7y59IO9jfSDvaH0g7219IO+ifSDvp30g76x9IO/hfSDv5n0g7+t9ISAgfSEgJX0hICp9ISAvfSEgZH0hIGl9ISBufSEgo30hIKh9ISCtfSEg4n0hIOd9ISDsfSEhIX0hISZ9ISErfSEhYH0hIWV9ISFqfSEhb30hIaR9ISGpfSEhrn0hIeN9ISHofSEh7X0hIiJ9ISInfSEiLH0hImF9ISJmfSEia30hIqB9ISKlfSEiqn0hIq99ISLkfSEi6X0hIu59ISMjfSEjKH0hIy19ISNifSEjZ30hI2x9ISOhfSEjpn0hI6t9ISPgfSEj5X0hI+p9ISPvfSEkJH0hJCl9ISQufSEkY30hJGh9ISRtfSEkon0hJKd9ISSsfSEk4X0hJOZ9ISTrfSElIH0hJSV9ISUqfSElL30hJWR9ISVpfSElbn0hJaN9ISWofSElrX0hJeJ9ISXnfSEl7H0hJiF9ISYmQ=="
	},
	{
		"string": "",
		"encodedString": "9ISYrfSEmYH0hJmV9ISZqfSEmb30hJqR9ISapfSEmrn0hJuN9ISbofSEm7X0hJyJ9IScnfSEnLH0hJ2F9ISdmfSEna30hJ6B9ISelfSEnqn0hJ699ISfkfSEn6X0hJ+59ISgjfSEoKH0hKC19IShifSEoZ30hKGx9ISihfSEopn0hKKt9ISjgfSEo5X0hKOp9ISjvfSEpJH0hKSl9ISkufSEpY30hKWh9ISltfSEpon0hKad9ISmsfSEp4X0hKeZ9ISnrfSEqIH0hKiV9ISoqfSEqL30hKmR9ISppfSEqbn0hKqN9ISqofSEqrX0hKuJ9ISrnfSEq7H0hKyF9ISsmfSErK30hK2B9IStlfSEran0hK299ISukfSErqX0hK659ISvjfSEr6H0hK+19ISwifSEsJ30hLCx9ISxhfSEsZn0hLGt9ISygfSEspX0hLKp9ISyvfSEs5H0hLOl9ISzufSEtI30hLSh9IS0tfSEtYn0hLWd9IS1sfSEtoX0hLaZ9IS2rfSEt4H0hLeV9IS3qQ=="
	},
	{
		"string": "",
		"encodedString": "9IS3vfSEuJH0hLil9IS4ufSEuY30hLmh9IS5tfSEuon0hLqd9IS6sfSEu4X0hLuZ9IS7rfSEvIH0hLyV9IS8qfSEvL30hL2R9IS9pfSEvbn0hL6N9IS+ofSEvrX0hL+J9IS/nfSEv7H0hYCF9IWAmfSFgK30hYGB9IWBlfSFgan0hYG99IWCkfSFgqX0hYK59IWDjfSFg6H0hYO19IWEifSFhJ30hYSx9IWFhfSFhZn0hYWt9IWGgfSFhpX0hYap9IWGvfSFh5H0hYel9IWHufSFiI30hYih9IWItfSFiYn0hYmd9IWJsfSFioX0hYqZ9IWKrfSFi4H0hYuV9IWLqfSFi730hYyR9IWMpfSFjLn0hY2N9IWNofSFjbX0hY6J9IWOnfSFjrH0hY+F9IWPmfSFj630hZCB9IWQlfSFkKn0hZC99IWRkfSFkaX0hZG59IWSjfSFkqH0hZK19IWTifSFk530hZOx9IWUhfSFlJn0hZSt9IWVgfSFlZX0hZWp9IWVvfSFlpH0hZal9IWWuQ=="
	},
	{
		"string": "",
		"encodedString": "9IWXjfSFl6H0hZe19IWYifSFmJ30hZix9IWZhfSFmZn0hZmt9IWagfSFmpX0hZqp9IWavfSFm5H0hZul9IWbufSFnI30hZyh9IWctfSFnYn0hZ2d9IWdsfSFnoX0hZ6Z9IWerfSFn4H0hZ+V9IWfqfSFn730haCR9IWgpfSFoLn0haGN9IWhofSFobX0haKJ9IWinfSForH0haOF9IWjmfSFo630haSB9IWklfSFpKn0haS99IWlkfSFpaX0haW59IWmjfSFpqH0haa19IWnifSFp530haex9IWohfSFqJn0hait9IWpgfSFqZX0hamp9IWpvfSFqpH0haql9IWqufSFq430hauh9IWrtfSFrIn0hayd9IWssfSFrYX0ha2Z9IWtrfSFroH0ha6V9IWuqfSFrr30ha+R9IWvpfSFr7n0hbCN9IWwofSFsLX0hbGJ9IWxnfSFsbH0hbKF9IWymfSFsq30hbOB9IWzlfSFs6n0hbO99IW0kfSFtKX0hbS59IW1jfSFtaH0hbW19IW2iQ=="
	},
	{
		"string": "",
		"encodedString": "9IW2nfSFtrH0hbeF9IW3mfSFt630hbiB9IW4lfSFuKn0hbi99IW5kfSFuaX0hbm59IW6jfSFuqH0hbq19IW7ifSFu530hbux9IW8hfSFvJn0hbyt9IW9gfSFvZX0hb2p9IW9vfSFvpH0hb6l9IW+ufSFv430hb+h9IW/tfSGgIn0hoCd9IaAsfSGgYX0hoGZ9IaBrfSGgoH0hoKV9IaCqfSGgr30hoOR9IaDpfSGg7n0hoSN9IaEofSGhLX0hoWJ9IaFnfSGhbH0hoaF9IaGmfSGhq30hoeB9IaHlfSGh6n0hoe99IaIkfSGiKX0hoi59IaJjfSGiaH0hom19IaKifSGip30hoqx9IaLhfSGi5n0hout9IaMgfSGjJX0hoyp9IaMvfSGjZH0ho2l9IaNufSGjo30ho6h9IaOtfSGj4n0ho+d9IaPsfSGkIX0hpCZ9IaQrfSGkYH0hpGV9IaRqfSGkb30hpKR9IaSpfSGkrn0hpON9IaTofSGk7X0hpSJ9IaUnfSGlLH0hpWF9IaVmQ=="
	},
	{
		"string": "",
		"encodedString": "9IaVrfSGloH0hpaV9IaWqfSGlr30hpeR9IaXpfSGl7n0hpiN9IaYofSGmLX0hpmJ9IaZnfSGmbH0hpqF9IaamfSGmq30hpuB9IablfSGm6n0hpu99IackfSGnKX0hpy59IadjfSGnaH0hp219IaeifSGnp30hp6x9IafhfSGn5n0hp+t9IaggfSGoJX0hqCp9IagvfSGoZH0hqGl9IahufSGoo30hqKh9IaitfSGo4n0hqOd9IajsfSGpIX0hqSZ9IakrfSGpYH0hqWV9IalqfSGpb30hqaR9IampfSGprn0hqeN9IanofSGp7X0hqiJ9IaonfSGqLH0hqmF9IapmfSGqa30hqqB9IaqlfSGqqn0hqq99IarkfSGq6X0hqu59IasjfSGrKH0hqy19IatifSGrZ30hq2x9IauhfSGrpn0hq6t9IavgfSGr5X0hq+p9IavvfSGsJH0hrCl9IawufSGsY30hrGh9IaxtfSGson0hrKd9IaysfSGs4X0hrOZ9IazrfSGtIH0hrSV9Ia0qQ=="
	},
	{
		"string": "",
		"encodedString": "9Ia0vfSGtZH0hrWl9Ia1ufSGto30hrah9Ia2tfSGt4n0hred9Ia3sfSGuIX0hriZ9Ia4rfSGuYH0hrmV9Ia5qfSGub30hrqR9Ia6pfSGurn0hruN9Ia7ofSGu7X0hryJ9Ia8nfSGvLH0hr2F9Ia9mfSGva30hr6B9Ia+lfSGvqn0hr699Ia/kfSGv6X0hr+59IeAjfSHgKH0h4C19IeBifSHgZ30h4Gx9IeChfSHgpn0h4Kt9IeDgfSHg5X0h4Op9IeDvfSHhJH0h4Sl9IeEufSHhY30h4Wh9IeFtfSHhon0h4ad9IeGsfSHh4X0h4eZ9IeHrfSHiIH0h4iV9IeIqfSHiL30h4mR9IeJpfSHibn0h4qN9IeKofSHirX0h4uJ9IeLnfSHi7H0h4yF9IeMmfSHjK30h42B9IeNlfSHjan0h4299IeOkfSHjqX0h4659IePjfSHj6H0h4+19IeQifSHkJ30h5Cx9IeRhfSHkZn0h5Gt9IeSgfSHkpX0h5Kp9IeSvfSHk5H0h5Ol9IeTuQ=="
	},
	{
		"string": "",
		"encodedString": "9IeUjfSHlKH0h5S19IeVifSHlZ30h5Wx9IeWhfSHlpn0h5at9IeXgfSHl5X0h5ep9IeXvfSHmJH0h5il9IeYufSHmY30h5mh9IeZtfSHmon0h5qd9IeasfSHm4X0h5uZ9IebrfSHnIH0h5yV9IecqfSHnL30h52R9IedpfSHnbn0h56N9IeeofSHnrX0h5+J9IefnfSHn7H0h6CF9IegmfSHoK30h6GB9IehlfSHoan0h6G99IeikfSHoqX0h6K59IejjfSHo6H0h6O19IekifSHpJ30h6Sx9IelhfSHpZn0h6Wt9IemgfSHppX0h6ap9IemvfSHp5H0h6el9IenufSHqI30h6ih9IeotfSHqYn0h6md9IepsfSHqoX0h6qZ9IeqrfSHq4H0h6uV9IerqfSHq730h6yR9IespfSHrLn0h62N9IetofSHrbX0h66J9IeunfSHrrH0h6+F9IevmfSHr630h7CB9IewlfSHsKn0h7C99IexkfSHsaX0h7G59IeyjfSHsqH0h7K19IeziQ=="
	},
	{
		"string": "",
		"encodedString": "9IeznfSHs7H0h7SF9Ie0mfSHtK30h7WB9Ie1lfSHtan0h7W99Ie2kfSHtqX0h7a59Ie3jfSHt6H0h7e19Ie4ifSHuJ30h7ix9Ie5hfSHuZn0h7mt9Ie6gfSHupX0h7qp9Ie6vfSHu5H0h7ul9Ie7ufSHvI30h7yh9Ie8tfSHvYn0h72d9Ie9sfSHvoX0h76Z9Ie+rfSHv4H0h7+V9Ie/qfSHv730iICR9IiApfSIgLn0iIGN9IiBofSIgbX0iIKJ9IiCnfSIgrH0iIOF9IiDmfSIg630iISB9IiElfSIhKn0iIS99IiFkfSIhaX0iIW59IiGjfSIhqH0iIa19IiHifSIh530iIex9IiIhfSIiJn0iIit9IiJgfSIiZX0iImp9IiJvfSIipH0iIql9IiKufSIi430iIuh9IiLtfSIjIn0iIyd9IiMsfSIjYX0iI2Z9IiNrfSIjoH0iI6V9IiOqfSIjr30iI+R9IiPpfSIj7n0iJCN9IiQofSIkLX0iJGJ9IiRnfSIkbH0iJKF9IiSmQ=="
	},
	{
		"string": "",
		"encodedString": "9IiSrfSIk4H0iJOV9IiTqfSIk730iJSR9IiUpfSIlLn0iJWN9IiVofSIlbX0iJaJ9IiWnfSIlrH0iJeF9IiXmfSIl630iJiB9IiYlfSImKn0iJi99IiZkfSImaX0iJm59IiajfSImqH0iJq19IibifSIm530iJux9IichfSInJn0iJyt9IidgfSInZX0iJ2p9IidvfSInpH0iJ6l9IieufSIn430iJ+h9IiftfSIoIn0iKCd9IigsfSIoYX0iKGZ9IihrfSIooH0iKKV9IiiqfSIor30iKOR9IijpfSIo7n0iKSN9IikofSIpLX0iKWJ9IilnfSIpbH0iKaF9IimmfSIpq30iKeB9IinlfSIp6n0iKe99IiokfSIqKX0iKi59IipjfSIqaH0iKm19IiqifSIqp30iKqx9IirhfSIq5n0iKut9IisgfSIrJX0iKyp9IisvfSIrZH0iK2l9IitufSIro30iK6h9IiutfSIr4n0iK+d9IivsfSIsIX0iLCZ9IiwrfSIsYH0iLGV9IixqQ=="
	},
	{
		"string": "",
		"encodedString": "9IixvfSIspH0iLKl9IiyufSIs430iLOh9IiztfSItIn0iLSd9Ii0sfSItYX0iLWZ9Ii1rfSItoH0iLaV9Ii2qfSItr30iLeR9Ii3pfSIt7n0iLiN9Ii4ofSIuLX0iLmJ9Ii5nfSIubH0iLqF9Ii6mfSIuq30iLuB9Ii7lfSIu6n0iLu99Ii8kfSIvKX0iLy59Ii9jfSIvaH0iL219Ii+ifSIvp30iL6x9Ii/hfSIv5n0iL+t9ImAgfSJgJX0iYCp9ImAvfSJgZH0iYGl9ImBufSJgo30iYKh9ImCtfSJg4n0iYOd9ImDsfSJhIX0iYSZ9ImErfSJhYH0iYWV9ImFqfSJhb30iYaR9ImGpfSJhrn0iYeN9ImHofSJh7X0iYiJ9ImInfSJiLH0iYmF9ImJmfSJia30iYqB9ImKlfSJiqn0iYq99ImLkfSJi6X0iYu59ImMjfSJjKH0iYy19ImNifSJjZ30iY2x9ImOhfSJjpn0iY6t9ImPgfSJj5X0iY+p9ImPvfSJkJH0iZCl9ImQuQ=="
	},
	{
		"string": "",
		"encodedString": "9ImRjfSJkaH0iZG19ImSifSJkp30iZKx9ImThfSJk5n0iZOt9ImUgfSJlJX0iZSp9ImUvfSJlZH0iZWl9ImVufSJlo30iZah9ImWtfSJl4n0iZed9ImXsfSJmIX0iZiZ9ImYrfSJmYH0iZmV9ImZqfSJmb30iZqR9ImapfSJmrn0iZuN9ImbofSJm7X0iZyJ9ImcnfSJnLH0iZ2F9ImdmfSJna30iZ6B9ImelfSJnqn0iZ699ImfkfSJn6X0iZ+59ImgjfSJoKH0iaC19ImhifSJoZ30iaGx9ImihfSJopn0iaKt9ImjgfSJo5X0iaOp9ImjvfSJpJH0iaSl9ImkufSJpY30iaWh9ImltfSJpon0iaad9ImmsfSJp4X0iaeZ9ImnrfSJqIH0iaiV9ImoqfSJqL30iamR9ImppfSJqbn0iaqN9ImqofSJqrX0iauJ9ImrnfSJq7H0iayF9ImsmfSJrK30ia2B9ImtlfSJran0ia299ImukfSJrqX0ia659ImvjfSJr6H0ia+19ImwiQ=="
	},
	{
		"string": "",
		"encodedString": "9ImwnfSJsLH0ibGF9ImxmfSJsa30ibKB9ImylfSJsqn0ibK99ImzkfSJs6X0ibO59Im0jfSJtKH0ibS19Im1ifSJtZ30ibWx9Im2hfSJtpn0ibat9Im3gfSJt5X0ibep9Im3vfSJuJH0ibil9Im4ufSJuY30ibmh9Im5tfSJuon0ibqd9Im6sfSJu4X0ibuZ9Im7rfSJvIH0ibyV9Im8qfSJvL30ib2R9Im9pfSJvbn0ib6N9Im+ofSJvrX0ib+J9Im/nfSJv7H0ioCF9IqAmfSKgK30ioGB9IqBlfSKgan0ioG99IqCkfSKgqX0ioK59IqDjfSKg6H0ioO19IqEifSKhJ30ioSx9IqFhfSKhZn0ioWt9IqGgfSKhpX0ioap9IqGvfSKh5H0ioel9IqHufSKiI30ioih9IqItfSKiYn0iomd9IqJsfSKioX0ioqZ9IqKrfSKi4H0iouV9IqLqfSKi730ioyR9IqMpfSKjLn0io2N9IqNofSKjbX0io6J9IqOnfSKjrH0io+F9IqPmQ=="
	},
	{
		"string": "",
		"encodedString": "9IqPrfSKkIH0ipCV9IqQqfSKkL30ipGR9IqRpfSKkbn0ipKN9IqSofSKkrX0ipOJ9IqTnfSKk7H0ipSF9IqUmfSKlK30ipWB9IqVlfSKlan0ipW99IqWkfSKlqX0ipa59IqXjfSKl6H0ipe19IqYifSKmJ30ipix9IqZhfSKmZn0ipmt9IqagfSKmpX0ipqp9IqavfSKm5H0ipul9IqbufSKnI30ipyh9IqctfSKnYn0ip2d9IqdsfSKnoX0ip6Z9IqerfSKn4H0ip+V9IqfqfSKn730iqCR9IqgpfSKoLn0iqGN9IqhofSKobX0iqKJ9IqinfSKorH0iqOF9IqjmfSKo630iqSB9IqklfSKpKn0iqS99IqlkfSKpaX0iqW59IqmjfSKpqH0iqa19IqnifSKp530iqex9IqohfSKqJn0iqit9IqpgfSKqZX0iqmp9IqpvfSKqpH0iqql9IqqufSKq430iquh9IqrtfSKrIn0iqyd9IqssfSKrYX0iq2Z9IqtrfSKroH0iq6V9IquqQ=="
	},
	{
		"string": "",
		"encodedString": "9IquvfSKr5H0iq+l9IqvufSKsI30irCh9IqwtfSKsYn0irGd9IqxsfSKsoX0irKZ9IqyrfSKs4H0irOV9IqzqfSKs730irSR9Iq0pfSKtLn0irWN9Iq1ofSKtbX0iraJ9Iq2nfSKtrH0ireF9Iq3mfSKt630iriB9Iq4lfSKuKn0iri99Iq5kfSKuaX0irm59Iq6jfSKuqH0irq19Iq7ifSKu530irux9Iq8hfSKvJn0iryt9Iq9gfSKvZX0ir2p9Iq9vfSKvpH0ir6l9Iq+ufSKv430ir+h9Iq/tfSLgIn0i4Cd9IuAsfSLgYX0i4GZ9IuBrfSLgoH0i4KV9IuCqfSLgr30i4OR9IuDpfSLg7n0i4SN9IuEofSLhLX0i4WJ9IuFnfSLhbH0i4aF9IuGmfSLhq30i4eB9IuHlfSLh6n0i4e99IuIkfSLiKX0i4i59IuJjfSLiaH0i4m19IuKifSLip30i4qx9IuLhfSLi5n0i4ut9IuMgfSLjJX0i4yp9IuMvfSLjZH0i42l9IuNuQ=="
	},
	{
		"string": "",
		"encodedString": "9IuOjfSLjqH0i4619IuPifSLj530i4+x9IuQhfSLkJn0i5Ct9IuRgfSLkZX0i5Gp9IuRvfSLkpH0i5Kl9IuSufSLk430i5Oh9IuTtfSLlIn0i5Sd9IuUsfSLlYX0i5WZ9IuVrfSLloH0i5aV9IuWqfSLlr30i5eR9IuXpfSLl7n0i5iN9IuYofSLmLX0i5mJ9IuZnfSLmbH0i5qF9IuamfSLmq30i5uB9IublfSLm6n0i5u99IuckfSLnKX0i5y59IudjfSLnaH0i5219IueifSLnp30i56x9IufhfSLn5n0i5+t9IuggfSLoJX0i6Cp9IugvfSLoZH0i6Gl9IuhufSLoo30i6Kh9IuitfSLo4n0i6Od9IujsfSLpIX0i6SZ9IukrfSLpYH0i6WV9IulqfSLpb30i6aR9IumpfSLprn0i6eN9IunofSLp7X0i6iJ9IuonfSLqLH0i6mF9IupmfSLqa30i6qB9IuqlfSLqqn0i6q99IurkfSLq6X0i6u59IusjfSLrKH0i6y19IutiQ=="
	},
	{
		"string": "",
		"encodedString": "9IutnfSLrbH0i66F9IuumfSLrq30i6+B9IuvlfSLr6n0i6+99IuwkfSLsKX0i7C59IuxjfSLsaH0i7G19IuyifSLsp30i7Kx9IuzhfSLs5n0i7Ot9Iu0gfSLtJX0i7Sp9Iu0vfSLtZH0i7Wl9Iu1ufSLto30i7ah9Iu2tfSLt4n0i7ed9Iu3sfSLuIX0i7iZ9Iu4rfSLuYH0i7mV9Iu5qfSLub30i7qR9Iu6pfSLurn0i7uN9Iu7ofSLu7X0i7yJ9Iu8nfSLvLH0i72F9Iu9mfSLva30i76B9Iu+lfSLvqn0i7699Iu/kfSLv6X0i7+59IyAjfSMgKH0jIC19IyBifSMgZ30jIGx9IyChfSMgpn0jIKt9IyDgfSMg5X0jIOp9IyDvfSMhJH0jISl9IyEufSMhY30jIWh9IyFtfSMhon0jIad9IyGsfSMh4X0jIeZ9IyHrfSMiIH0jIiV9IyIqfSMiL30jImR9IyJpfSMibn0jIqN9IyKofSMirX0jIuJ9IyLnfSMi7H0jIyF9IyMmQ=="
	},
	{
		"string": "",
		"encodedString": "9IyMrfSMjYH0jI2V9IyNqfSMjb30jI6R9IyOpfSMjrn0jI+N9IyPofSMj7X0jJCJ9IyQnfSMkLH0jJGF9IyRmfSMka30jJKB9IySlfSMkqn0jJK99IyTkfSMk6X0jJO59IyUjfSMlKH0jJS19IyVifSMlZ30jJWx9IyWhfSMlpn0jJat9IyXgfSMl5X0jJep9IyXvfSMmJH0jJil9IyYufSMmY30jJmh9IyZtfSMmon0jJqd9IyasfSMm4X0jJuZ9IybrfSMnIH0jJyV9IycqfSMnL30jJ2R9IydpfSMnbn0jJ6N9IyeofSMnrX0jJ+J9IyfnfSMn7H0jKCF9IygmfSMoK30jKGB9IyhlfSMoan0jKG99IyikfSMoqX0jKK59IyjjfSMo6H0jKO19IykifSMpJ30jKSx9IylhfSMpZn0jKWt9IymgfSMppX0jKap9IymvfSMp5H0jKel9IynufSMqI30jKih9IyotfSMqYn0jKmd9IypsfSMqoX0jKqZ9IyqrfSMq4H0jKuV9IyrqQ=="
	},
	{
		"string": "",
		"encodedString": "9IyrvfSMrJH0jKyl9IysufSMrY30jK2h9IyttfSMron0jK6d9IyusfSMr4X0jK+Z9IyvrfSMsIH0jLCV9IywqfSMsL30jLGR9IyxpfSMsbn0jLKN9IyyofSMsrX0jLOJ9IyznfSMs7H0jLSF9Iy0mfSMtK30jLWB9Iy1lfSMtan0jLW99Iy2kfSMtqX0jLa59Iy3jfSMt6H0jLe19Iy4ifSMuJ30jLix9Iy5hfSMuZn0jLmt9Iy6gfSMupX0jLqp9Iy6vfSMu5H0jLul9Iy7ufSMvI30jLyh9Iy8tfSMvYn0jL2d9Iy9sfSMvoX0jL6Z9Iy+rfSMv4H0jL+V9Iy/qfSMv730jYCR9I2ApfSNgLn0jYGN9I2BofSNgbX0jYKJ9I2CnfSNgrH0jYOF9I2DmfSNg630jYSB9I2ElfSNhKn0jYS99I2FkfSNhaX0jYW59I2GjfSNhqH0jYa19I2HifSNh530jYex9I2IhfSNiJn0jYit9I2JgfSNiZX0jYmp9I2JvfSNipH0jYql9I2KuQ=="
	},
	{
		"string": "",
		"encodedString": "9I2LjfSNi6H0jYu19I2MifSNjJ30jYyx9I2NhfSNjZn0jY2t9I2OgfSNjpX0jY6p9I2OvfSNj5H0jY+l9I2PufSNkI30jZCh9I2QtfSNkYn0jZGd9I2RsfSNkoX0jZKZ9I2SrfSNk4H0jZOV9I2TqfSNk730jZSR9I2UpfSNlLn0jZWN9I2VofSNlbX0jZaJ9I2WnfSNlrH0jZeF9I2XmfSNl630jZiB9I2YlfSNmKn0jZi99I2ZkfSNmaX0jZm59I2ajfSNmqH0jZq19I2bifSNm530jZux9I2chfSNnJn0jZyt9I2dgfSNnZX0jZ2p9I2dvfSNnpH0jZ6l9I2eufSNn430jZ+h9I2ftfSNoIn0jaCd9I2gsfSNoYX0jaGZ9I2hrfSNooH0jaKV9I2iqfSNor30jaOR9I2jpfSNo7n0jaSN9I2kofSNpLX0jaWJ9I2lnfSNpbH0jaaF9I2mmfSNpq30jaeB9I2nlfSNp6n0jae99I2okfSNqKX0jai59I2pjfSNqaH0jam19I2qiQ=="
	},
	{
		"string": "",
		"encodedString": "9I2qnfSNqrH0jauF9I2rmfSNq630jayB9I2slfSNrKn0jay99I2tkfSNraX0ja259I2ujfSNrqH0ja619I2vifSNr530ja+x9I2whfSNsJn0jbCt9I2xgfSNsZX0jbGp9I2xvfSNspH0jbKl9I2yufSNs430jbOh9I2ztfSNtIn0jbSd9I20sfSNtYX0jbWZ9I21rfSNtoH0jbaV9I22qfSNtr30jbeR9I23pfSNt7n0jbiN9I24ofSNuLX0jbmJ9I25nfSNubH0jbqF9I26mfSNuq30jbuB9I27lfSNu6n0jbu99I28kfSNvKX0jby59I29jfSNvaH0jb219I2+ifSNvp30jb6x9I2/hfSNv5n0jb+t9I6AgfSOgJX0joCp9I6AvfSOgZH0joGl9I6BufSOgo30joKh9I6CtfSOg4n0joOd9I6DsfSOhIX0joSZ9I6ErfSOhYH0joWV9I6FqfSOhb30joaR9I6GpfSOhrn0joeN9I6HofSOh7X0joiJ9I6InfSOiLH0jomF9I6JmQ=="
	},
	{
		"string": "",
		"encodedString": "9I6JrfSOioH0joqV9I6KqfSOir30jouR9I6LpfSOi7n0joyN9I6MofSOjLX0jo2J9I6NnfSOjbH0jo6F9I6OmfSOjq30jo+B9I6PlfSOj6n0jo+99I6QkfSOkKX0jpC59I6RjfSOkaH0jpG19I6SifSOkp30jpKx9I6ThfSOk5n0jpOt9I6UgfSOlJX0jpSp9I6UvfSOlZH0jpWl9I6VufSOlo30jpah9I6WtfSOl4n0jped9I6XsfSOmIX0jpiZ9I6YrfSOmYH0jpmV9I6ZqfSOmb30jpqR9I6apfSOmrn0jpuN9I6bofSOm7X0jpyJ9I6cnfSOnLH0jp2F9I6dmfSOna30jp6B9I6elfSOnqn0jp699I6fkfSOn6X0jp+59I6gjfSOoKH0jqC19I6hifSOoZ30jqGx9I6ihfSOopn0jqKt9I6jgfSOo5X0jqOp9I6jvfSOpJH0jqSl9I6kufSOpY30jqWh9I6ltfSOpon0jqad9I6msfSOp4X0jqeZ9I6nrfSOqIH0jqiV9I6oqQ=="
	},
	{
		"string": "",
		"encodedString": "9I6ovfSOqZH0jqml9I6pufSOqo30jqqh9I6qtfSOq4n0jqud9I6rsfSOrIX0jqyZ9I6srfSOrYH0jq2V9I6tqfSOrb30jq6R9I6upfSOrrn0jq+N9I6vofSOr7X0jrCJ9I6wnfSOsLH0jrGF9I6xmfSOsa30jrKB9I6ylfSOsqn0jrK99I6zkfSOs6X0jrO59I60jfSOtKH0jrS19I61ifSOtZ30jrWx9I62hfSOtpn0jrat9I63gfSOt5X0jrep9I63vfSOuJH0jril9I64ufSOuY30jrmh9I65tfSOuon0jrqd9I66sfSOu4X0jruZ9I67rfSOvIH0jryV9I68qfSOvL30jr2R9I69pfSOvbn0jr6N9I6+ofSOvrX0jr+J9I6/nfSOv7H0j4CF9I+AmfSPgK30j4GB9I+BlfSPgan0j4G99I+CkfSPgqX0j4K59I+DjfSPg6H0j4O19I+EifSPhJ30j4Sx9I+FhfSPhZn0j4Wt9I+GgfSPhpX0j4ap9I+GvfSPh5H0j4el9I+HuQ=="
	},
	{
		"string": "",
		"encodedString": "9I+IjfSPiKH0j4i19I+JifSPiZ30j4mx9I+KhfSPipn0j4qt9I+LgfSPi5X0j4up9I+LvfSPjJH0j4yl9I+MufSPjY30j42h9I+NtfSPjon0j46d9I+OsfSPj4X0j4+Z9I+PrfSPkIH0j5CV9I+QqfSPkL30j5GR9I+RpfSPkbn0j5KN9I+SofSPkrX0j5OJ9I+TnfSPk7H0j5SF9I+UmfSPlK30j5WB9I+VlfSPlan0j5W99I+WkfSPlqX0j5a59I+XjfSPl6H0j5e19I+YifSPmJ30j5ix9I+ZhfSPmZn0j5mt9I+agfSPmpX0j5qp9I+avfSPm5H0j5ul9I+bufSPnI30j5yh9I+ctfSPnYn0j52d9I+dsfSPnoX0j56Z9I+erfSPn4H0j5+V9I+fqfSPn730j6CR9I+gpfSPoLn0j6GN9I+hofSPobX0j6KJ9I+infSPorH0j6OF9I+jmfSPo630j6SB9I+klfSPpKn0j6S99I+lkfSPpaX0j6W59I+mjfSPpqH0j6a19I+niQ=="
	}
];
var bcrypt128Tests = [
	{
		"password": "?",
		"keyHex": "23c569a93f0ac035f234cef6ba0e75c8",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	},
	{
		"password": "%",
		"keyHex": "d0826126bc730b0b56cb3916a34c2a92",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	},
	{
		"password": "uropa",
		"keyHex": "99a05f635111b1c61345a596ada2ab1c",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	},
	{
		"password": "?uropa",
		"keyHex": "c7d889fa7cfab2a6b8f8d4857c4a7729",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it",
		"keyHex": "fe79147a4a43d7818c7ab4a9015a4652",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it!",
		"keyHex": "eff5a87268689f4734241ba8167e39dc",
		"saltHex": "70a3a46809da33a4adf06c6b641d2889"
	}
];
var bcrypt256Tests = [
	{
		"password": "?",
		"keyHex": "757697e258bb8534a523480c52a413c674c2a4b315d1dd1ae4dc340e230aa281",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	},
	{
		"password": "%",
		"keyHex": "f3ab0b8e0d93f9df85a124fe4577d9d192098c2e168cb0d5bf895682d0cc04f7",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	},
	{
		"password": "uropa",
		"keyHex": "41f0026080e20d118aa9576bc80f5cc1c6bfb5f18921010375ef141f6d2b643f",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	},
	{
		"password": "?uropa",
		"keyHex": "85edd807ee13e9848c48dfec99f41800447965dd1da4252a5ec46723ca2a466a",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it",
		"keyHex": "f7261eceed9e6f19c06451bc7f0df82ef71c3963f7acae30225adcd19dac15ad",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it!",
		"keyHex": "52dfed73d1d0fe0800a3d6cdf96548ce4a478f29405569d77445a6ce5b7facef",
		"saltHex": "0cf4cb1e6e733fee1d662a1c8c124be0"
	}
];
var argon2idTests = [
	{
		"password": "?",
		"keyHex": "80b6498c2a7cfa5fe3e269b5105be923eb2e2e268877be382a7f79278408800f",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	},
	{
		"password": "%",
		"keyHex": "93e2ba40f0af9209d34ebe126ff4a2243f4eedc49f6303d4470f89c5ea338132",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	},
	{
		"password": "uropa",
		"keyHex": "3b77614ea5eb3c1e48cac2eaf22721a99dffa1ae16748c44acdd6aae51fb02f7",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	},
	{
		"password": "?uropa",
		"keyHex": "f10c316d509adaf3fe48c5ba5a95706df9d8625cb4021c5318ff2dbf6eb38242",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it",
		"keyHex": "576077f6c5ffd26def74de30d8078a057192f9c9d1e03e3d13a16e95cff9e06c",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	},
	{
		"password": "This passphrase is relatively long, I hope I won't forget it!",
		"keyHex": "9e9b7a75d26f51cc531722ea7ca6b85990f470d44754ad03ba656af9bbb7c96e",
		"saltHex": "94963f84e8297bccdd0867f4ef27902d"
	}
];
var compressionTests = [
	{
		"uncompressedText": "",
		"compressedBase64TextJava": "",
		"compressedBase64TextJavaScript": "",
		"compressedBase64TextRust": ""
	},
	{
		"uncompressedText": "a",
		"compressedBase64TextJava": "EGE=",
		"compressedBase64TextJavaScript": "EGE=",
		"compressedBase64TextRust": "EGE="
	},
	{
		"uncompressedText": "ab",
		"compressedBase64TextJava": "IGFi",
		"compressedBase64TextJavaScript": "IGFi",
		"compressedBase64TextRust": "IGFi"
	},
	{
		"uncompressedText": "aba",
		"compressedBase64TextJava": "MGFiYQ==",
		"compressedBase64TextJavaScript": "MGFiYQ==",
		"compressedBase64TextRust": "MGFiYQ=="
	},
	{
		"uncompressedText": "abab",
		"compressedBase64TextJava": "QGFiYWI=",
		"compressedBase64TextJavaScript": "QGFiYWI=",
		"compressedBase64TextRust": "QGFiYWI="
	},
	{
		"uncompressedText": "ababa",
		"compressedBase64TextJava": "UGFiYWJh",
		"compressedBase64TextJavaScript": "UGFiYWJh",
		"compressedBase64TextRust": "UGFiYWJh"
	},
	{
		"uncompressedText": "ababab",
		"compressedBase64TextJava": "YGFiYWJhYg==",
		"compressedBase64TextJavaScript": "YGFiYWJhYg==",
		"compressedBase64TextRust": "YGFiYWJhYg=="
	},
	{
		"uncompressedText": "abababa",
		"compressedBase64TextJava": "cGFiYWJhYmE=",
		"compressedBase64TextJavaScript": "cGFiYWJhYmE=",
		"compressedBase64TextRust": "cGFiYWJhYmE="
	},
	{
		"uncompressedText": "abababab",
		"compressedBase64TextJava": "gGFiYWJhYmFi",
		"compressedBase64TextJavaScript": "gGFiYWJhYmFi",
		"compressedBase64TextRust": "gGFiYWJhYmFi"
	},
	{
		"uncompressedText": "ababababa",
		"compressedBase64TextJava": "kGFiYWJhYmFiYQ==",
		"compressedBase64TextJavaScript": "kGFiYWJhYmFiYQ==",
		"compressedBase64TextRust": "kGFiYWJhYmFiYQ=="
	},
	{
		"uncompressedText": "ababababab",
		"compressedBase64TextJava": "oGFiYWJhYmFiYWI=",
		"compressedBase64TextJavaScript": "oGFiYWJhYmFiYWI=",
		"compressedBase64TextRust": "oGFiYWJhYmFiYWI="
	},
	{
		"uncompressedText": "abababababa",
		"compressedBase64TextJava": "sGFiYWJhYmFiYWJh",
		"compressedBase64TextJavaScript": "sGFiYWJhYmFiYWJh",
		"compressedBase64TextRust": "sGFiYWJhYmFiYWJh"
	},
	{
		"uncompressedText": "abababababab",
		"compressedBase64TextJava": "wGFiYWJhYmFiYWJhYg==",
		"compressedBase64TextJavaScript": "wGFiYWJhYmFiYWJhYg==",
		"compressedBase64TextRust": "wGFiYWJhYmFiYWJhYg=="
	},
	{
		"uncompressedText": "ababababababa",
		"compressedBase64TextJava": "0GFiYWJhYmFiYWJhYmE=",
		"compressedBase64TextJavaScript": "0GFiYWJhYmFiYWJhYmE=",
		"compressedBase64TextRust": "0GFiYWJhYmFiYWJhYmE="
	},
	{
		"uncompressedText": "ababababababab",
		"compressedBase64TextJava": "4GFiYWJhYmFiYWJhYmFi",
		"compressedBase64TextJavaScript": "4GFiYWJhYmFiYWJhYmFi",
		"compressedBase64TextRust": "ImFiAgBgYWJhYmFi"
	},
	{
		"uncompressedText": "abababababababa",
		"compressedBase64TextJava": "JGFiAgBQYWJhYmE=",
		"compressedBase64TextJavaScript": "8ABhYmFiYWJhYmFiYWJhYmE=",
		"compressedBase64TextRust": "I2FiAgBgYmFiYWJh"
	},
	{
		"uncompressedText": "abababababababab",
		"compressedBase64TextJava": "JWFiAgBQYmFiYWI=",
		"compressedBase64TextJavaScript": "8AFhYmFiYWJhYmFiYWJhYmFi",
		"compressedBase64TextRust": "JGFiAgBgYWJhYmFi"
	},
	{
		"uncompressedText": "ababababababababa",
		"compressedBase64TextJava": "JmFiAgBQYWJhYmE=",
		"compressedBase64TextJavaScript": "8AJhYmFiYWJhYmFiYWJhYmFiYQ==",
		"compressedBase64TextRust": "JWFiAgBgYmFiYWJh"
	},
	{
		"uncompressedText": "ababababababababab",
		"compressedBase64TextJava": "J2FiAgBQYmFiYWI=",
		"compressedBase64TextJavaScript": "8ANhYmFiYWJhYmFiYWJhYmFiYWI=",
		"compressedBase64TextRust": "JmFiAgBgYWJhYmFi"
	},
	{
		"uncompressedText": "abababababababababa",
		"compressedBase64TextJava": "KGFiAgBQYWJhYmE=",
		"compressedBase64TextJavaScript": "IWFiAgDAYmFiYWJhYmFiYWJh",
		"compressedBase64TextRust": "J2FiAgBgYmFiYWJh"
	},
	{
		"uncompressedText": "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Tempor orci eu lobortis elementum nibh. Nibh tellus molestie nunc non blandit. Varius quam quisque id diam vel quam. Sit amet aliquam id diam maecenas ultricies mi eget. Erat pellentesque adipiscing commodo elit at imperdiet dui accumsan. Suspendisse ultrices gravida dictum fusce ut placerat orci nulla. Et malesuada fames ac turpis egestas integer eget aliquet nibh. Vitae purus faucibus ornare suspendisse. Ullamcorper eget nulla facilisi etiam dignissim diam quis enim. Volutpat maecenas volutpat blandit aliquam. Cursus turpis massa tincidunt dui ut ornare. A diam maecenas sed enim ut sem viverra.\n\nSit amet nisl suscipit adipiscing bibendum est ultricies integer. Pretium vulputate sapien nec sagittis aliquam malesuada. Convallis aenean et tortor at risus viverra adipiscing at in. Euismod lacinia at quis risus sed. Dis parturient montes nascetur ridiculus mus mauris vitae ultricies. Varius duis at consectetur lorem donec. Urna nunc id cursus metus. Sed faucibus turpis in eu mi bibendum neque egestas congue. Gravida in fermentum et sollicitudin ac orci. Sed sed risus pretium quam. Nunc scelerisque viverra mauris in aliquam sem fringilla. Lectus vestibulum mattis ullamcorper velit sed. Amet commodo nulla facilisi nullam vehicula ipsum. Iaculis eu non diam phasellus vestibulum lorem. Felis bibendum ut tristique et egestas. Lobortis mattis aliquam faucibus purus in massa. Nisi vitae suscipit tellus mauris a diam maecenas sed. Velit sed ullamcorper morbi tincidunt ornare massa.\n\nUt pharetra sit amet aliquam id diam maecenas ultricies mi. Dolor sit amet consectetur adipiscing elit pellentesque habitant morbi tristique. Consectetur adipiscing elit pellentesque habitant. Vel orci porta non pulvinar. Gravida cum sociis natoque penatibus et magnis. Eget egestas purus viverra accumsan in nisl nisi scelerisque. Erat nam at lectus urna duis convallis. Bibendum est ultricies integer quis auctor. Enim ut tellus elementum sagittis vitae et leo duis. Tellus elementum sagittis vitae et leo duis. Sem fringilla ut morbi tincidunt.\n\nEgestas diam in arcu cursus euismod quis viverra. Amet luctus venenatis lectus magna fringilla urna porttitor. Egestas sed sed risus pretium quam. Turpis massa tincidunt dui ut ornare. Convallis tellus id interdum velit laoreet id donec ultrices. Egestas sed sed risus pretium quam vulputate dignissim suspendisse. Rhoncus urna neque viverra justo nec ultrices. Sapien pellentesque habitant morbi tristique senectus et. Phasellus vestibulum lorem sed risus ultricies tristique nulla aliquet. Odio ut enim blandit volutpat maecenas volutpat blandit. Vulputate eu scelerisque felis imperdiet proin fermentum leo vel. Vitae ultricies leo integer malesuada nunc vel risus. Auctor elit sed vulputate mi sit amet mauris commodo quis.\n\nTurpis in eu mi bibendum neque egestas congue quisque egestas. Tincidunt praesent semper feugiat nibh. Ante in nibh mauris cursus mattis molestie a. Urna porttitor rhoncus dolor purus. Feugiat in fermentum posuere urna nec tincidunt. Pellentesque massa placerat duis ultricies lacus sed turpis tincidunt. Amet dictum sit amet justo donec enim diam vulputate ut. Egestas purus viverra accumsan in. Elementum sagittis vitae et leo. Euismod quis viverra nibh cras pulvinar mattis nunc. Ultricies mi eget mauris pharetra et ultrices. Mauris vitae ultricies leo integer malesuada nunc vel. Justo laoreet sit amet cursus sit. Vestibulum lectus mauris ultrices eros in cursus. Nunc congue nisi vitae suscipit tellus mauris a.",
		"compressedBase64TextJava": "8ldMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXRbAPICZSBtYWduYSBhbGlxdWEuIFQ0APNgb3JjaSBldSBsb2JvcnRpcyBlbGVtZW50dW0gbmliaC4gTmliaCB0ZWxsdXMgbW9sZXN0aWUgbnVuYyBub24gYmxhbmRpdC4gVmFyaXVzIHF1YW0gcXVpc3F1ZSBpZCBkaWFtIHZlbCBxdWFtLiBT3wADhgAVbSMA8RptYWVjZW5hcyB1bHRyaWNpZXMgbWkgZWdldC4gRXJhdCBwZWxsZW50ZVkABxABUGNvbW1vCwEQbDoBkHQgaW1wZXJkafYA8wl1aSBhY2N1bXNhbi4gU3VzcGVuZGlzc2VkAOBlcyBncmF2aWRhIGRpY/EA4GZ1c2NlIHV0IHBsYWNldgABHgHwEm51bGxhLiBFdCBtYWxlc3VhZGEgZmFtZXMgYWMgdHVycDYB4Gdlc3RhcyBpbnRlZ2VyEAAD5QAjZXRJAfYOVml0YWUgcHVydXMgZmF1Y2lidXMgb3JuYXJlIHOeALQuIFVsbGFtY29ycEgAAYEAwCBmYWNpbGlzaSBldFUBgGRpZ25pc3NpCgADdAHgIGVuaW0uIFZvbHV0cGGvAANVARR2EgADrwECmgCkYW0uIEN1cnN1c8YAcW1hc3NhIHRIAgBGAjBkdWkPAQKlADIuIEHPAQVXAACGAgBzAAAkAOVzZW0gdml2ZXJyYS4KCugBQG5pc2zeADBjaXB3AAbIAsNiaWJlbmR1bSBlc3SRAQD1AQNAAfAVLiBQcmV0aXVtIHZ1bHB1dGF0ZSBzYXBpZW4gbmVjIHNhZ2l0rQICzQIAkwADmQHwDS4gQ29udmFsbGlzIGFlbmVhbiBldCB0b3J0b3IfAiByae8AA6kACJAAoWF0IGluLiBFdWlSA3BsYWNpbmlhMwABWgECOADwB3NlZC4gRGlzIHBhcnR1cmllbnQgbW+WAlEgbmFzY6wDYXJpZGljdS4DADIDQGF1cmlxAAD8AQXcAgUvAyBkdagAGXTtAxFsFQSyZG9uZWMuIFVybmFuA0JpZCBjrQGmbWV0dXMuIFNlZEgCA4cCIGluzAMmbWlfASBuZTEDBJ8Ck2Nvbmd1ZS4gR/kCY2luIGZlcvAD8ABldCBzb2xsaWNpdHVkaW7eAgAAAwJqAADsAQIFARNwmgECQQIQTgoEYnNjZWxlcvUDBFwBA/oAAEgAAXIEEW0jAmFmcmluZ2lQA4BMZWN0dXMgdlIEQGJ1bHXGAQHVAQBvAwQAAxB28AQA7wRQLiBBbWUpAQLvAwsTAwEPAFBtIHZlaHwBEmFTBWAuIElhY3UKAiFlda0EASkDYHBoYXNlbKABB3oAAXQBQC4gRmUuAAU8AZF1dCB0cmlzdGlDARB01QMA5QM0LiBMLQUDsgAEhwIF1wMC5gMiaW5SAzAuIE64AwIFAgUNAwRUBQIoAQCFBBBhAwEDswMBawIUVv4ACRQBV21vcmJppgMCnwMDawDVCgpVdCBwaGFyZXRyYU8GBYQBD3AFCjkuIESFBgmXAgd0BQGWAAmRBWFoYWJpdGEOAwGcAAQ2AQGPAw/HBgUK1AUEQwAB9gABeQJhIHBvcnRhugGGcHVsdmluYXK6AvAAY3VtIHNvY2lpcyBuYXRvogFAcGVuYUsCEHOsAQDtBlBpcy4gRYkFBP8CApcBBKICBB0GMiBpbqgEEG6mAQfMAgN7BjBuYW2kAxJssAIQdZIDAbgDFGNqBD8uIELOBAoCnQWTYXVjdG9yLiBFMgUDAAIGcAcF1gQCKQIQZXMAEG/HBhBzrgcBswIPLQATGFNpAwCdBQOWAQTYBUIuCgpFywIC0QUApAM0cmN1YAQTZQQFAfkEAy0BA38DI2x1tAMRbmwBFHMVAQBuARZh3QMCJQEAvwEidGn0AANvAABGBAAEAA9KBAESVEoHATIDBqwAAAABAMMAAuUCAVACA98FA0ABIWlkdQcQckwGAi4EcWxhb3JlZXTsAgBGBQNfBgB3BQT3AACEAAAEAA6IAAdxBgZiBwmfB1RSaG9uYwkCAl8FAyUBYSBqdXN0b6IGAusFAHMAElO3Bg8vAxJCIHNlbmYCX2V0LiBQqgQGABEFA7wAAmkAADsHBqsEAQ4FAvMDAEgAQE9kaW9DARBleQIEAggFEwgFcgQFEgADIwA1LiBWfAcoZXUYAyEgZigFBmsJOXByb0oGALgCNHZlbPQIBqQAABkAA+MHB00JEG5EBgAlCgHTADEuIEEqAwLTCQCmAQYECCZtadMEA2EGBBIGAK4CMy4KCkYCDwkHEwGZAwA7BAMhBDQuIFQkA2AgcHJhZXPhByBzZVMKcCBmZXVnaWHSCAAWC0JBbnRlOAQkYmjDBQSfBwLGBgUsCxNhxgcFDwMjIHJCAgLzCwGVBAB8BgJgAAlJAXJwb3N1ZXJlUAMA+ggFnAk4LiBQEgsCNgMFuAoBoAQHdwEQYbECAEsBAygIB0cAAVcHAwELBH4MA8kCAYQIAVUKAigEBogBEHWXCwPUAwHAAAT8CQVyCwJOCQVMDA/cBAIGbwkAvQEFQwABVAEhY3JbAAL3BQRUAQApAgAgCwsjDASBAQX3BidldPQDEk1hBwJVBQcUAQ+LAgoxLiBKzAMETAQFGgED5QERcyADBrsIBQgFAe8JAmYAYWVzIGVyb4wCAjYAAy4JAoUJAHMGDxQICVBpcyBhLg==",
		"compressedBase64TextJavaScript": "8VhMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgWwDyAmUgbWFnbmEgYWxpcXVhLiBUNADzYG9yY2kgZXUgbG9ib3J0aXMgZWxlbWVudHVtIG5pYmguIE5pYmggdGVsbHVzIG1vbGVzdGllIG51bmMgbm9uIGJsYW5kaXQuIFZhcml1cyBxdWFtIHF1aXNxdWUgaWQgZGlhbSB2ZWwgcXVhbS4gU98AA4YAFW0jAPEabWFlY2VuYXMgdWx0cmljaWVzIG1pIGVnZXQuIEVyYXQgcGVsbGVudGVZAAcQAVBjb21tbwsBEGxbAPMWdCBpbXBlcmRpZXQgZHVpIGFjY3Vtc2FuLiBTdXNwZW5kaXNzZWQA4GVzIGdyYXZpZGEgZGlj8QBQZnVzY2U7AVBwbGFjZXYAAR4B8BJudWxsYS4gRXQgbWFsZXN1YWRhIGZhbWVzIGFjIHR1cnA2AeFnZXN0YXMgaW50ZWdlcroAAuUAI2V0SQH2DlZpdGFlIHB1cnVzIGZhdWNpYnVzIG9ybmFyZSBzngC0LiBVbGxhbWNvcnBIAAGBAPAJIGZhY2lsaXNpIGV0aWFtIGRpZ25pc3NpCgADdAHgIGVuaW0uIFZvbHV0cGGvAANVARR2EgADrwECmgCkYW0uIEN1cnN1c8YAcW1hc3NhIHRIAiJ1bkMBI3V0pQBBLiBBIM8BBawBAIYCAHMAADMB8ABzZW0gdml2ZXJyYS4KClONARFt+wAgc2zeADBjaXATAAbIAsNiaWJlbmR1bSBlc3SRAQD1AQNAAfAVLiBQcmV0aXVtIHZ1bHB1dGF0ZSBzYXBpZW4gbmVjIHNhZ2l0rQICzQIWbZkB8AMuIENvbnZhbGxpcyBhZW5lYW4BA8B0b3J0b3IgYXQgcmnvAAOpAAhYA6FhdCBpbi4gRXVpUgNwbGFjaW5pYTMAQ3F1aXM4APAHc2VkLiBEaXMgcGFydHVyaWVudCBtb5YCUSBuYXNjrANhcmlkaWN1LgMAMgNxYXVyaXMgdvwBBdwCFC4vAxBkXAApYXTtAxFsFQSyZG9uZWMuIFVybmFuA0JpZCBjrQGmbWV0dXMuIFNlZEgCA4cCIGluzAM1bWkgXwFQbmVxdWWPAgGfApNjb25ndWUuIEf5AmNpbiBmZXLwA/AAZXQgc29sbGljaXR1ZGlu3gIAAAMCagAA7AECPQETcJoBAOsDMC4gTgoEcXNjZWxlcmmcAwRcARJt+gAASAABcgQgbSAjAmFmcmluZ2lQA4BMZWN0dXMgdlIEQGJ1bHXGAQHVAQBvAwQAAxB28AQA7wQwLiBBUAIE7wMLEwMBDwBQbSB2ZWh8ARJhUwVgLiBJYWN1CgIwZXUgrQQBvgJCcGhhc84EB3oAAXQBQC4gRmUuAAU8AZF1dCB0cmlzdGlDARR0RgE0LiBMLQUhbWGyAASHAgXXAwLmAzFpbiBSAwBFBSNzaQUCMnN1cw0DBFQFAigBAIUEEGEDAQOzAwFrAhRW/gAYIBQBV21vcmJppgMDRAQCawDVCgpVdCBwaGFyZXRyYU8GBPEDIyBpkwUFxAMFlAJpIG1pLiBEhQYJlwIHdAUBlgAJkQVhaGFiaXRhDgMBnAAENgEBjwMPxwYFCtQFBEMAYC4gVmVsIHkCYSBwb3J0YboBhnB1bHZpbmFyugLwAGN1bSBzb2NpaXMgbmF0b6IBUXBlbmF0VgUQZfwEAB8FVS4gRWdluQEDfQUEogIEHQaAIGluIG5pc2wFACdpIMwCA3sGMG5hbQgEEmywAhB1kgMBuAMUY2oEPy4gQs4ECgERB9AgYXVjdG9yLiBFbmltMgUDAAIGcAcF1gQCLgRgZXQgbGVvxwYQc64HAYEHDy0AE0VTZW0gaQMAawALMgJDLgoKRbAGARMDAKQDNHJjdWAEE2UEBQH5BAMtAQN/AyNsdbQDEW5sASNzIBUBAlsIB3QAACUBAL8BInRp9AADbwAARgQABAAPSgQBElRKBwHHAgfeAgDHBweEBgbfBQNAASFpZHUHEHJMBgIuBHFsYW9yZWV07AIARgUDXwYhZXMOAgEIBQCEAAAEAA6IAAdxBgZiBwmfB4FSaG9uY3VzIAkCAl8FAyUBYSBqdXN0b6IGAlcDAHMAElO3Bg8vAxJCIHNlbmYCAPgIH1CqBAYAEQUDkwYCaQAAOwcGqwQBDgUC8wMASABAT2RpbwYCAasHBAIIBRMIBQoEBRIAAyMANS4gVnwHKGV1GAMhIGYoBQZrCTlwcm9KBgC4AlJ2ZWwuIPQIBqQAABkAA+MHBrQHAuAGMnZlbNMAMS4gQSoDAesKAeoABgQIJm1p0wQDYQYEEgYArgIzLgoKRgIPCQcTAZkDADsEEmWgAjUuIFT8CFBwcmFlc+EHIHNlUwp0IGZldWdpYc0JQkFudGU4BDRiaCCKAAOfBwIUBgUsCxNhxgcFDwMjIHJCAgGYCwKVBAB8BgJgAAlJAXRwb3N1ZXJlbAIWYxgDOC4gUBILAjYDBbgKAaAEB3cBEGGxAgDxAgMoCAXjCQPYAwMBCwR+DAPJAgGECAFVCgL5CQaIARB1lwsCNAECwAAE/AkFcgsCTgkFTAwP3AQCBm8JAL0BBUMAAHgMZCBjcmFzIPcFEyBoBwB3DAAgCwsjDASBAQX3BhRlUwoAgQMSTWEHAlUFBxQBIWVvOQQArgsG2AsAYgAAsAwxLiBKzAMETAQFGgEDhAkgc2n0DAa7CAUIBQHvCQJmAGBlcyBlcm8UDANaBQMuCQKFCQJuBgKWAAkUCMB1cyBtYXVyaXMgYS4=",
		"compressedBase64TextRust": "8ldMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXRbAPICZSBtYWduYSBhbGlxdWEuIFQ0APNgb3JjaSBldSBsb2JvcnRpcyBlbGVtZW50dW0gbmliaC4gTmliaCB0ZWxsdXMgbW9sZXN0aWUgbnVuYyBub24gYmxhbmRpdC4gVmFyaXVzIHF1YW0gcXVpc3F1ZSBpZCBkaWFtIHZlbCBxdWFtLiBT3wADhgAVbSMA8RptYWVjZW5hcyB1bHRyaWNpZXMgbWkgZWdldC4gRXJhdCBwZWxsZW50ZVkABxABUGNvbW1vCwEQbFsAkHQgaW1wZXJkafYA8wl1aSBhY2N1bXNhbi4gU3VzcGVuZGlzc2VkAOBlcyBncmF2aWRhIGRpY/EAUGZ1c2NlOwFQcGxhY2V2AAEeAfEkbnVsbGEuIEV0IG1hbGVzdWFkYSBmYW1lcyBhYyB0dXJwaXMgZWdlc3RhcyBpbnRlZ2VyugAC5QAjZXRJAfYOVml0YWUgcHVydXMgZmF1Y2lidXMgb3JuYXJlIHOeALQuIFVsbGFtY29ycEgAAYEAwCBmYWNpbGlzaSBldFUBgGRpZ25pc3NpCgBQYW0gcXW8AcBuaW0uIFZvbHV0cGGvAANVARR2EgADrwECmgCkYW0uIEN1cnN1c8YAcW1hc3NhIHRIAiJ1bkMBEHUGAQClADIuIEHPAQVXAACGAkBlbmltMwHwAHNlbSB2aXZlcnJhLgoKU2QAEW37ACBzbN4AMGNpcBMABrgBw2JpYmVuZHVtIGVzdJEBAPUBA0AB8BUuIFByZXRpdW0gdnVscHV0YXRlIHNhcGllbiBuZWMgc2FnaXStAgLNAgCTAAOZAfANLiBDb252YWxsaXMgYWVuZWFuIGV0IHRvcnRvch8CIHJp7wADqQAISAKhYXQgaW4uIEV1aVIDcGxhY2luaWEzAAFaAQI4APAHc2VkLiBEaXMgcGFydHVyaWVudCBtb5YC8QEgbmFzY2V0dXIgcmlkaWN1LgMABABAYXVyaXEAAPwBBdwCBS8DEGS2ASlhdO0DEWwVBPIGZG9uZWMuIFVybmEgbnVuYyBpZCBjrQGmbWV0dXMuIFNlZEgCA4cCIGluzAMmbWlfASBuZTEDBJ8Ck2Nvbmd1ZS4gR/kCY2luIGZlcvAD8ABldCBzb2xsaWNpdHVkaW7eAgAAAwJqAADsAQIFARNwmgECQQIQTpwAYnNjZWxlcvUDBFwBA/oAAEgAAXIEEW0jAmFmcmluZ2lQA4BMZWN0dXMgdlIEQGJ1bHXGAQHVAQBvAwQAAxB28AQCeAEQQVACBO8DCxMDAQ8AUG0gdmVofAESYVMFYC4gSWFjdQoCYmV1IG5vbr4CYHBoYXNlbKABB3oAAXQBQC4gRmUuAAU8AZF1dCB0cmlzdGlDARB0jwR0c3Rhcy4gTC0FA7IABIcCBdcDAuYDImluUgMwLiBOuAMCBQIFDQMEVAUCKAEAhQQQYQMBA7MDAfMAFFb+AAkUAVdtb3JiaaYDAp8DA2sA1QoKVXQgcGhhcmV0cmFPBgWEAQ9wBQo5LiBEhQYJlwIHLAMBlgAJkQVhaGFiaXRhDgMBnAAENgEBjwMPxwYFCtQFBEMAAfYAAXkCYSBwb3J0YboBhnB1bHZpbmFyugLwAGN1bSBzb2NpaXMgbmF0b6IBQHBlbmFLAhBzrAEA7QZmaXMuIEVnuQEDfQUEogIEHQYyIGluqAQQbqYBB8wCA3sGMG5hbQgEEmywAhB1kgMBuAMUY2oEPy4gQs4ECgKdBZNhdWN0b3IuIEUyBQMAAgZwBwXWBAIpAhBlcwAQb4QFEHOuBwGzAg8tABMYU2kDAJ0FA5YBBNgFQi4KCkXLAgITAwCkAzRyY3VgBBNlBAUB+QQDLQEDfwMjbHW0AxFubAEUcxUBAG4BFmHdAwIlAQC/ASJ0afQAA28AAEYEAAQAD0oEARJUSgcBMgMGrAAAAAEAwwAC5QIBUAID3wUDQAEhaWQ1BhByTAYCLgRwbGFvcmVldDIFAUYFA18GAHcFBPcAAIQAAAQADogAB3EGBmIHCZ8HVFJob25jCQICXwUDJQFhIGp1c3RvogYC6wUAcwASU7cGDy8DEkIgc2VuZgJfZXQuIFCqBAYAEQUDvAACaQAAOwcGqwQBDgUC8wMASABAT2Rpb0MBEGV5AgQCCAUTCAVyBAUSAAMjADUuIFZ8ByhldRgDISBmKAUGawk5cHJvSgYAuAI0dmVs9AgGpAAAGQAArgEAIwkFtAcC4AYydmVs0wAxLiBBKgMC0wkApgEGBAgmbWnTBANhBgQSBgCuAjMuCgpGAg8JBxMBmQMAOwQDIAc0LiBUJANgIHByYWVz4Qcgc2VTCnQgZmV1Z2lhzQlCQW50ZTgEJGJowwUEnwcCxgYFLAsTYcYHBQ8DIyByQgIRZG4FASwGAHwGAmAACUkBcnBvc3VlcmVQAwD6CAWcCTguIFCBBQI2AwW4CgGgBAd3ARBhsQIASwEDKAgHRwABVwcDAQsEfgwDyQICPgMBNwIBnQYGiAEQdZcLA9QDAcAABPwJBXILAk4JBUwMD9wEAgZvCQC9AQVDAAFUASFjcrAFAvcFBFQBACkCACALCyMMBIEBBfcGJ2V09AMfTYMJAg+LAgwxLiBKzAMETAQFGgED5QERcyADBrsIBQgFAWwAAnoBYWVzIGVyb4wCAjYAAy4JAoUJAHMGDxQICGByaXMgYS4="
	},
	{
		"uncompressedText": "()     ()     ()     ",
		"compressedBase64TextJava": "8AfDtigp4oKsIM6kzr/Pjc+EzrHOvc6/CADQINCi0YPRgtCw0YHQvggA/xQg5Zu+5aGU6K+65aGUIOODhOOCv+ODjuOCvyDZhtiu2KfYuU4AMw9GADMElACA2YbYrtin2Lk=",
		"compressedBase64TextJavaScript": "8AfDtigp4oKsIM6kzr/Pjc+EzrHOvc6/CADQINCi0YPRgtCw0YHQvggA/xQg5Zu+5aGU6K+65aGUIOODhOOCv+ODjuOCvyDZhtiu2KfYuU4AMw9GADPwAdmG2K7Yp9i52YbYrtin2Lk=",
		"compressedBase64TextRust": "8AfDtigp4oKsIM6kzr/Pjc+EzrHOvc6/CADQINCi0YPRgtCw0YHQvggA/xQg5Zu+5aGU6K+65aGUIOODhOOCv+ODjuOCvyDZhtiu2KfYuU4AMw+UADuA2YbYrtin2Lk="
	}
];
var byteArrayEncodingTests = [
	{
		"encodedByteArrayAsHex": "000101",
		"byteArraysAsHex": ["01"],
		"encodingError": null
	},
	{
		"encodedByteArrayAsHex": "000102000202020003020202000402020202",
		"byteArraysAsHex": [
			"02",
			"0202",
			"020202",
			"02020202"
		],
		"encodingError": null
	},
	{
		"encodedByteArrayAsHex": "00ff050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505",
		"byteArraysAsHex": ["050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505050505"],
		"encodingError": null
	},
	{
		"encodedByteArrayAsHex": "010006060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606",
		"byteArraysAsHex": ["06060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606060606"],
		"encodingError": null
	},
	{
		"encodedByteArrayAsHex": "ffff070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707",
		"byteArraysAsHex": ["070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707"],
		"encodingError": null
	},
	{
		"encodedByteArrayAsHex": null,
		"byteArraysAsHex": ["08080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808080808"],
		"encodingError": "byte array is to long for encoding"
	}
];
var hkdfTests = [
	{
		"saltHex": "1a3abce2a90efad29126cc993edc96e4",
		"inputKeyMaterialHex": "9bdac8dd34deeb8b5fed52be033b78239f1a526ac691aba6afb0ae72007d58ad1ada230906608612a01845dba044c9692f5260cb9195f6ead786cc1879cc26d8",
		"infoHex": "25b2f8c3d1380704",
		"lengthInBytes": 8,
		"hkdfHex": "3488f295d4242605"
	},
	{
		"saltHex": "b27d36b958ece733277afa2b04e0bb57",
		"inputKeyMaterialHex": "b9086c2dcfc54e392cd0f96fed4516fcb628d46af02f785c9c77735a04a5cc22358af23a9318cc97338162e7323d656fb1987d34b832e68675a3e7273f6e9386",
		"infoHex": "096ad0639d8d997a",
		"lengthInBytes": 9,
		"hkdfHex": "6f06ba0c9ea8332083"
	},
	{
		"saltHex": "94f8ed5bf13e687d2d4130360e972691",
		"inputKeyMaterialHex": "e1cf5c821defbd8622e0baa382dacaacb0d293da88eec2815746e88dc1661fd2b243f50a23e978318684ad5bf95e01ab6266e92a5bb5a9e2da90124a6f358018",
		"infoHex": "8260d3c5e403cbf4",
		"lengthInBytes": 10,
		"hkdfHex": "7ef89bee23331d23b148"
	},
	{
		"saltHex": "02253eefbdf86854c86b7efc08058c14",
		"inputKeyMaterialHex": "138ca2ac4ba26f1764638f0645ce93e26b87ca414304490121332bfe6d5b1bc654ab35407976cdcdc0833ce4c925346381191674f44f34a41dff08386a821ea0",
		"infoHex": "dba0691f8fb0f5cd",
		"lengthInBytes": 11,
		"hkdfHex": "ecaa159a84cbb5d45e656e"
	}
];
var pqcryptEncryptionTests = [{
	"privateKyberKey": "06005f0773ca36c9398a88a1d66ac7229ab33956cb48556f8c0968f4adf356014cf68ac92660fb9660b037c8b08b05d37a462aa01e8eec20bf56b352648c0148371d613ffcc137fa75c17aa2bdbd042b0eb5bd8b847669931d17cb96d6f0a21e63b0e3ea07e150cce2095817176adce74842730d6bc8b43267bf01e373bf805b158a6e8edc0712f6aaa16c233c74a9a1607da3754e6a0486c86615e308a680578db67934bfe64ae5604cb2bc52af9399baa93774c46105905c4c65639d36692ff22de72baa42d72452c3cea8131b5be0cc5792285312aed92c9a8e47b301f510893b48d6f019b6b27b40250ef17806b63220d8078850074b355864b52909a58922aa3131f31287a86a4362479e002d75ebf8a7ad037b603130fb37adfe169b67aca996c75042054d15f70768b751d3b34339850e9898173258b2e301b9f72311f5f52fe7f2198d8284e291435eb1986f1baeb5eb918261180860397e750303a39725a59af61cc1f3ab5bf92c855e4365e599abf8667679e7c88531544352817cf09624cb7238018a634c5dd7b415aab611464bc258393f2a3ab8e9e04b9c332d4f84acfdb451fb2a73bc3695ce081e2e873a52807f0043a56956951fe4b9d9b6b12ddc9735f8311a15a427b438aae69b9073687a339406e56dfec48e585c20a711b717969e1969bac7d860bba8b7890620e6f017c8363721272b6d703bb791c5a24b461648b022a535cd7acdfb140fc6a11e2f5206bdd6216877707f7c3769e33750836f34c85a376bae9e0946ecea113cb801eb6025d5e0cc0169b7a7a2c1ac310f4470c565fc2f3d08c1f8ec1d0d0aa9bffc1ff2a914a2a8bb7229a7f59ca248208c1932675ab36fadb392e297c26b9a461a326085e26b35d66107fbc23ab40b2795990f63366d440e051c3637e64885b87cc914af1fb34dc9b59a0a575a920956748646040a68e8e77210f0379af6584530b50703675774c8de7b42cd447c822334ca553d641a06ff92bb041309d225a39341c5a111525e3a1713277cd8d521dfa6cd41b661c9b181dfac327c8485c6e59f78d5b854c837c8199374049eb225085454b0fcf9aabfd65e0a7ab577e82e61c7628c7890f9647d76147f73a39f6cb15e74a1562536ba0fd1ca13679e8770707ad33e9ce30e94d1823ff040ca82c1f8aaca1e276e5762c8ed3159db4a428877667c7490348c7bae9377a339c7683880abc9a685060ce591a25089a336474b11f0a1b6528a9da003eab55f08ba628507609599a32c5706d96623429732eae09c56323b3e55869de8c1c3fa65d79891a9f1bbea841d62c6688ddb65964a4b9da60ca475cb1bfba8b48563e7b782a24c82b0939fb038930ee515b7cb5b229265cf2070399657a6e76f2ebbcc76ac2b87874c5e2a76a2c0a8abc9b46a157db3b37084a36fc7105c05e46de8d555e352cce1b2918c7c6a2c1120a50a444b607ae8611755d847d2c02e6ba61181ab4a601968175b7a9afc30a4a299115974fd8c971870c0c7b42b31d17f32f43a246206e754bad4226051ba6d3e5b9b42c802e02995688a8d0179b4324b585e0618ec31599ca781bba98ae1c350e0f0a6d46b667314b681f3860fc12696f00aa32a23763c09c3e286ffa8239eb00816fa0a10955b08950de0437f9f62b4a547ac583b8b88caa2e0014f9c79c423d0af90408dc53c7390c3942eda828607608ca0c2902b71fe2614e3f52818a25a21065c13e2c3c0981ab54b2ce3fa49cfc001d029c6afb51ac557192ed4b25c51770b422cbcdb7ed3c0c0fe7c25664608a5315b1ca2747a354c3991194b7467098b25c58b0f0075530a0c2930151253e10ab7303e9c122e99685176817d5b6c50b40899d0f78ac5372565824decb804edf5bb6055597b786a552a0034217972e239d6444006657d882cc775320187e956e3d577cf89362710aabeb756efc44fc5d3861b7549fa886be6b591979942684448f2571fad06cd1fb1b95e05bfacac379abb9c6cba44ee698c69e61270517b4192621f580c11a79366ab2b02a909e9452e01001d8bcb2672554fd3b6a121a941c24724bdd91634146271885abbd25348113248e97091293434645c4240c89f953d49a837bca9ab975107c2e07ab8d0458750b65a0b4b41d69654c091f79a4a844087a2a238d6abcd002011e241806e501cf2d0ebc5daac356d0f2bcbf51b176b4a9e78c1350499db196c002031d7acfa83d3c0fa2c05b867953870f88348fc2368d16f72ef8618fd317774fd0600063644ba7b644f43056decc4d0597f32ba80cdf25f3a92c335216c608a4b6fd4062ba2861b2628317b7f82a6794515ca2d823bf93620c1fb0f309b3bbd5b85a5281e0dd507a58392d21c6c5e845dabe693a0692e2436aadd88cbb33b805b6866ad285e722a91d432360825151890b42c2aa94da9cb2818c546bcb3bf09bb91d5a33f2a4e245313beea60f7ecaef732c897cc8f549384c0a6cac9d9c774576f604867cb592d59e2542ec82149bb7d4c55735b5585106c8524a10479b27bcea4949c5561f7132680016d42f1a249633f169433cc034d503259ab47b09c4ac8e1b36db6287423db18b02410c5cb8da4909a32c67319d86a7697b3d9b5a75ab24fc80a882c0cae384839d8ec6cc35055711159367463fa5a421cc4331416277e27c8a6f2bbf4a5931008cd49fc56325a5a4228868f72a45ff6c8f26495ba00bf5b1158b1e24e80268e467684b0b69bade8525c346e121c16927b8f0daa8582a554f0056a82306800fc1822b4bd8015628f1a5d21835c790335cd8c5d7e00a6ef2012efb5307276193c340deeca8290b136f1275a1d555cfc96a715708889bc33b3d49c5c627b98b98f3ee1240bf55270e4c8cf6155ea042606775f39c2bed4679980d1421ae03203e17d7bd341d16517333b74eb93882691af2cbc9353580d90183fb3c03cc7e091d0f192b9a6af89949213e56a86a81203ccad16d7baf1a55af5a77f00adb8b559c1d576480b3010f1a5012c49cb3d6b85234878dba266bad84a75fb81471c2d99d2060c92032fa81bd4e931bd61cc10d582a34285a20327c9b6724ad118d8c9abd7d59890724e95118fc39c38f1a9c9413b262c6b32e03abd4fb1b0e9d12f550c8bf8dc408ff565cf8a84313156e5bbc108259e4cea464625cd625767c36539844b55d28b66818b9959463aeb75ad29b446889c48fda958e7305b2f99c9208c4e2ef93213326675d860a78503226a1d7499c5f9c877752aa895e81407352cd4c45e4f2c18499b86906c94453a1fbd45a69581379bf0b403701d580188c14b46e496b018f1ca88ba5280e559f2f54cfee5aed72aa86fa80409992670464009e252a2a74fcad2ab22062b8a0283453a88b43410160972f73c948b195ebe975fa2f05852f1219fb207a1a2bbaf83b67ec6948a092ee7e3a85ab9cb72822b6285c1d0bc3561cacca6b838a05498578c51cd432c078352ca51094ad419c1da431728a5588b5f91cc125ef3b172a74d331acc7ec5b83f3c2d9f783574237c68ca25beb0667df47f8238a2c9ea74937a5f46f9360c91419137379d01a971a48f17ca1dcf02a3ab5a6a667945e0f790caa08f84169c0192401a01b10c86a38ffc1240365c6d4116e3483b6ff3637c86b462dac9a12a090c000002383c3c8057a2da2cc028a6de908b0e045a652aba96bc52fa73084cc58cec512f99948ef809b289398dd4f01b94e00219733d99a2305ba96caadc70cc257eaa1aaf08c74f9225cbce6b47c4f512d93b74ba799460fc1cb0e8ce038692ab412569e99a5fe91b5ebaa70f370a7c380910e2107ddcc82c017245c9a04383096c40699df72fbb4cb515c55734993614b931c5842648634e71957d42b1349ce5ba1247104cb65c35990924045120248738ca1b146510a86bb66bf10e5458907b731e335a09a2902b9937cd632b97f5861a4ab43f73ba495082254a15ac98909173c92e59354588117c0746b2340518529a2797a755e600c32e16a73b5b0cdfea3bd968327987126644195b1965cc3b8e2679c6a528bb58d4c749b039773a32108761e8b1cb390c245a6b07a996c7c2383c8367284e45c30a81481a124efae433800b616e4a63ce4c67aac470bde0b8f5e08183c18e18d58cdb872f01c17bf9b674d0d626fa2c49771a8e45453c2b3998872551ac4794ba2673724accc1aa3a6859a758c293506c92953817218242dbfc498ce1936ee301747709772925b3bb80bb124f89022951f62f5eca2ad868b8ec5bbc3db2c6732c30fa625c5ee68762f52dcc842e0d3a5096e75afc46411345b310933e27e72a5d4b87e4fa8fb5e85cc6818adc83253ae36ee8172b6c9bc09dcaacc83a6b9e26caab2c949050904ca4122bf72e2a483ce0e92b2ca2bc23e20b5dcb2de1cbae4be1b58caaa174c4432780c45ac24663b6800020aff9bba44ca2aa03186de9f34013fb6b4deb8a0f7abb1b4e32057c0b3572b3d1",
	"publicKyberKey": "0600063644ba7b644f43056decc4d0597f32ba80cdf25f3a92c335216c608a4b6fd4062ba2861b2628317b7f82a6794515ca2d823bf93620c1fb0f309b3bbd5b85a5281e0dd507a58392d21c6c5e845dabe693a0692e2436aadd88cbb33b805b6866ad285e722a91d432360825151890b42c2aa94da9cb2818c546bcb3bf09bb91d5a33f2a4e245313beea60f7ecaef732c897cc8f549384c0a6cac9d9c774576f604867cb592d59e2542ec82149bb7d4c55735b5585106c8524a10479b27bcea4949c5561f7132680016d42f1a249633f169433cc034d503259ab47b09c4ac8e1b36db6287423db18b02410c5cb8da4909a32c67319d86a7697b3d9b5a75ab24fc80a882c0cae384839d8ec6cc35055711159367463fa5a421cc4331416277e27c8a6f2bbf4a5931008cd49fc56325a5a4228868f72a45ff6c8f26495ba00bf5b1158b1e24e80268e467684b0b69bade8525c346e121c16927b8f0daa8582a554f0056a82306800fc1822b4bd8015628f1a5d21835c790335cd8c5d7e00a6ef2012efb5307276193c340deeca8290b136f1275a1d555cfc96a715708889bc33b3d49c5c627b98b98f3ee1240bf55270e4c8cf6155ea042606775f39c2bed4679980d1421ae03203e17d7bd341d16517333b74eb93882691af2cbc9353580d90183fb3c03cc7e091d0f192b9a6af89949213e56a86a81203ccad16d7baf1a55af5a77f00adb8b559c1d576480b3010f1a5012c49cb3d6b85234878dba266bad84a75fb81471c2d99d2060c92032fa81bd4e931bd61cc10d582a34285a20327c9b6724ad118d8c9abd7d59890724e95118fc39c38f1a9c9413b262c6b32e03abd4fb1b0e9d12f550c8bf8dc408ff565cf8a84313156e5bbc108259e4cea464625cd625767c36539844b55d28b66818b9959463aeb75ad29b446889c48fda958e7305b2f99c9208c4e2ef93213326675d860a78503226a1d7499c5f9c877752aa895e81407352cd4c45e4f2c18499b86906c94453a1fbd45a69581379bf0b403701d580188c14b46e496b018f1ca88ba5280e559f2f54cfee5aed72aa86fa80409992670464009e252a2a74fcad2ab22062b8a0283453a88b43410160972f73c948b195ebe975fa2f05852f1219fb207a1a2bbaf83b67ec6948a092ee7e3a85ab9cb72822b6285c1d0bc3561cacca6b838a05498578c51cd432c078352ca51094ad419c1da431728a5588b5f91cc125ef3b172a74d331acc7ec5b83f3c2d9f783574237c68ca25beb0667df47f8238a2c9ea74937a5f46f9360c91419137379d01a971a48f17ca1dcf02a3ab5a6a667945e0f790caa08f84169c0192401a01b10c86a38ffc1240365c6d4116e3483b6ff3637c86b462dac9a12a090c000002383c3c8057a2da2cc028a6de908b0e045a652aba96bc52fa73084cc58cec512f99948ef809b289398dd4f01b94e00219733d99a2305ba96caadc70cc257eaa1aaf08c74f9225cbce6b47c4f512d93b74ba799460fc1cb0e8ce038692ab412569e99a5fe91b5ebaa70f370a7c380910e2107ddcc82c017245c9a04383096c40699df72fbb4cb515c55734993614b931c5842648634e71957d42b1349ce5ba1247104cb65c35990924045120248738ca1b146510a86bb66bf10e5458907b731e335a09a2902b9937cd632b97f5861a4ab43f73ba495082254a15ac98909173c92e59354588117c0746b2340518529a2797a755e600c32e16a73b5b0cdfea3bd968327987126644195b1965cc3b8e2679c6a528bb58d4c749b039773a32108761e8b1cb390c245a6b07a996c7c2383c8367284e45c30a81481a124efae433800b616e4a63ce4c67aac470bde0b8f5e08183c18e18d58cdb872f01c17bf9b674d0d626fa2c49771a8e45453c2b3998872551ac4794ba2673724accc1aa3a6859a758c293506c92953817218242dbfc498ce1936ee301747709772925b3bb80bb124f89022951f62f5eca2ad868b8ec5bbc3db2c6732c30fa625c5ee68762f52dcc842e0d3a5096e75afc46411345b310933e27e72a5d4b87e4fa8fb5e85cc6818adc83253ae36ee8172b6c9bc09dcaacc83a6b9e26caab2c949050904ca4122bf72e2a483ce0e92b2ca2bc23e20b5dcb2de1cbae4be1b58caaa174c4432780c45ac24663b6800020aff9bba44ca2aa03186de9f34013fb6b4deb8a0f7abb1b4e32057c0b3572b3d1",
	"publicX25519Key": "0c4b7ca49446c5442ea66dee51446fed3f88c16e24fed22b10cb913617ebbf1c",
	"privateX25519Key": "d820c8a0e08738e3fcd2015f7d80c14b0372ada43de3f0f9f6e416c34fac077e",
	"epheremalPublicX25519Key": "2b2a6d584e0219e50835472a564d57b166e7a51477df29858db1972c8f900f64",
	"epheremalPrivateX25519Key": "f078949143f018a681c0c083512cd6ea4661ee88db2573d26a722424d7b7fd4e",
	"pqMessage": "00200c4b7ca49446c5442ea66dee51446fed3f88c16e24fed22b10cb913617ebbf1c00202b2a6d584e0219e50835472a564d57b166e7a51477df29858db1972c8f900f6406201ed00ac67c236156ef37b7083c89e826710f4f62e7258d09189803e1f9423cdc186bad163104d0991e95cbc7aa63aff8457598d3beafa82e36dc7c9778602b82f64bfcf9d934016876dce6f546803a1b412687b6f67cbcc8384fb186f686e014f2b2a01f7bd0aca5f0e9f5a4dfeee0ca79d7ac45f92e301676b2b3560a8b7ec1bfae1ababfb44c3f05e44dce04a9853e5c3bd45bb5fe45badbbb002633caf8b9570371be43a6c763918e13bcab97b3580528e760253fac7039cef51cf884d2f46cfbecb2c5f882f2ecedb7cb1606b414a4b2d94116b931f63c1642065352e6ddfa5c32e06a0a75fdb93d2f48847e4fbee4ad6a59e121c68e519a8187497d74ceaf744673e4b1a1d87b9489a7b9a29d0e5ed2a10443a517b205abeae72819ea4909e04eca51acfe8d2a9ca93433ab550d2dccd8e25ae76e5dc4e7d7a0446dd57c08e480e8750b635326340de612e9dc12dc686621f1637c574674ddcb795ed6ac4012de5b0c099bb3cfdebcf6056c5a3b984dfd6b9bf33f59b639916b97fca91635dd46006cebc5327969641230d2d4bf90b6628c8b1ebe02f9e45bd4fd1a586dced04ef4c27947d7e5e26c2e0cfe6fa12e6a9948219af8ec92519ddfcfd8cfd28c44794e44550b232baaf2e9638911a657525ee7ef79dd2864801f68f6e086c32ec3137cadb7f8f0d1c82158a03e19cdea0ed1a890143e976ca2eb9e742774f1734190f54378446c61568548c1341b3524b9b92c9b76f50fdbc7e7a9d10534839be673af7b6f3b0bd1d44af72ba8f5a847af3a5f483a311e95119d27fee9a6d204219074044821c7407ee8cfdeef0d3586d43a16cee5d5b86e031e6e83aedff36e87e1ee12b5e11fc74b43a0d44ddf84f291cd5b2bd6be34e75e7e30dec3ec58ba89dd58bd6122f0e34cf200e5e96c4af5a1f04bad698ee8af38763c17371ad4dc9799c532f560f998b716a501f43e40112e6c33c196a72f977f2b479f05566715440564ac262ce6820ceb165065bfd085bdaacfd7c887585ab03c47015af42c91e7ea0783a1fdfe602fcf0081af9c26360da4392d9e6a9ce5848f0f77ab81f04ea562622c9eb39309c00885fc39e76fd049c69417bd8de01d2c1f7a139a21040d20e68bde7bec545f5d0e07eef77c79e0904129d368ac5f38d7da740f2cb0596f5e4988af7e7cfdda762f73ba71c17d5f732c7961bc22ddd3ea9a1f7001e5b44daa60b6393bb723b7fb3388b4991da3a1de251d611a49917c393e9c9c27c80c588a1c7413ac24cc25ef1640dd3351dfd45fcd69ab6e325b251baf995eb2a905574a39cb8a39c355a4ae17dbb964f105a5606a95c4c005a78176c5a4ad536686c8ae241a3f838eeb8066aedd27a684b8ca2b51e3b3402d60722ccc69e060c8f093a34f3ee45c773f98947b28becc10f9e24c465600a4fc4a1a13a269e88725819f3ff7c9bf1535e98dc0ea00e81b31cece9d9a57da4fdfb0bba28c7177a893407d089faedcd64c70453a1e4c1a6bb891eabb7dff4a3ca213b1a7d1362adefe40337fd8bc00a2752fd6148f3147ff3dd9149e04ea3f66ee42e123f8a33f5c894f9e69d0e3b4c99587ba8d7e435b6179e1a1211c1e43f927b4f089efb276772b415142ec01d4af65fbeb98b88afe4bd26d249018343829c6d531ecc608c1354006bf03edbcc0afcc414d38e77171f8559e292398751250e9e75938123fcf287bd225069b7343beace6e06e1065bfabfa2612eab044687d8cfd08cecfd73e1265797de7dfe4d4730bf7af0019f3fb3ae522d15f37ba45bdcc71555b6c2390714a028ac14c1aa591732347b30d07d7cfe81a7d5ace37af6f3ab6b9f8cb094c424843a914a6ffd02f71eb37ba16b1564bb107e49d4ef09ac4fa7876f09f47b402fc30caab51c414cae242bb7470a29ba77bfeff07c00c35de31de204a29c956f285acc42ebf879d7f0a2ca57103c1228b325a0f6c4eb67b03b046f578c0784e4b7c76cd55ba32c5ab4751039350b89e33b901cc3cc561bbae3b418dacb19b529017fd89fec4620fd19f41e1c0ba7d6e8302a3c1ffa4998ccbb43bdd0680948d6f52c16a1ca3823b1f42fe2e787be38b86823e881a2444078c27a5c8017647a1ef1e6333b836461c5a9516c3508c5ed7dc9e605c093fa70bdecc9bace1b49bba234c192bc69e686b3804b7adf4e27e26ee5c8866fba47c94818818df8fb4327790ca0300610131d7acfa83d3c0fa2c05b867953870f81edd1d41941476814e440b57e2ef571f385425358eddc6775555f000c40974ff463aad28f918708ea6a5b2c663ade4b33267b7bea4dbbe0c88a6b6270e560d743db3e9463806d34c0f5e9e08d2242dca",
	"seed": "31d7acfa83d3c0fa2c05b867953870f88348fc2368d16f72ef8618fd317774fd",
	"bucketKey": "e64c82d846e52895fe0b06805c0534e3327f586705163afde5322f2a8ff2796a"
}];
var x25519Tests = [{
	"alicePrivateKeyHex": "10e3dbb585ca132b9ef9d30d61fa73cf708b18d7e8bbb830c0cc52f04e74d765",
	"alicePublicKeyHex": "bfd34e7839d7f227a3a8fa0f9f7bc600b90f6016be6058e1eba80c9417913c69",
	"ephemeralPrivateKeyHex": "202b4bd5e0648b0284141a5c3539223e407ab9f63edaa215be460d1265623441",
	"ephemeralPublicKeyHex": "4493ab3651a09ab84c2e9d2f268cfaed0135b36eb05cdf92fbe6668d823fd266",
	"bobPrivateKeyHex": "a00e59a9402a8c6dfeda87d06c5ae1dda2c1e97e201ef79f2afd4577e4d87454",
	"bobPublicKeyHex": "68fc5bb72c1e8df2415896fe2b2264e576eaecf390424875ea192b9b8fd86849",
	"ephemeralSharedSecretHex": "0760ab785d92c8a155ed386bb52dae6fb191e616c08c1fe9b8b53a960282a650",
	"authSharedSecretHex": "2b3fd15a9877cf44262e63bba959e26f188a730ab94d1bb0e0199741b4cd1156"
}];
var CompatibilityTestData_default = {
	rsaEncryptionTests,
	kyberEncryptionTests,
	rsaSignatureTests,
	aes256Tests,
	aes128Tests,
	aes128MacTests,
	encodingTests,
	bcrypt128Tests,
	bcrypt256Tests,
	argon2idTests,
	compressionTests,
	byteArrayEncodingTests,
	hkdfTests,
	pqcryptEncryptionTests,
	x25519Tests
};

//#endregion
//#region tests/api/worker/crypto/CompatibilityTest.ts
var import_testdouble$61 = __toESM(require_testdouble(), 1);
const originalRandom = random.generateRandomData;
const liboqs = await loadLibOQSWASM();
dist_default.spec("crypto compatibility", function() {
	dist_default.afterEach(function() {
		random.generateRandomData = originalRandom;
	});
	dist_default("rsa encryption", () => {
		for (const td$1 of CompatibilityTestData_default.rsaEncryptionTests) {
			random.generateRandomData = (number) => hexToUint8Array(td$1.seed);
			let publicKey$1 = hexToRsaPublicKey(td$1.publicKey);
			let encryptedData = rsaEncrypt(publicKey$1, hexToUint8Array(td$1.input), hexToUint8Array(td$1.seed));
			dist_default(uint8ArrayToHex(encryptedData)).equals(td$1.result);
			let privateKey$1 = hexToRsaPrivateKey(td$1.privateKey);
			let data$1 = rsaDecrypt(privateKey$1, encryptedData);
			dist_default(uint8ArrayToHex(data$1)).equals(td$1.input);
		}
	});
	dist_default("kyber", async () => {
		for (const td$1 of CompatibilityTestData_default.kyberEncryptionTests) {
			const publicKey$1 = bytesToKyberPublicKey(hexToUint8Array(td$1.publicKey));
			const privateKey$1 = bytesToKyberPrivateKey(hexToUint8Array(td$1.privateKey));
			dist_default(uint8ArrayToHex(kyberPublicKeyToBytes(publicKey$1))).deepEquals(td$1.publicKey);
			dist_default(uint8ArrayToHex(kyberPrivateKeyToBytes(privateKey$1))).deepEquals(td$1.privateKey);
			const seed = hexToUint8Array(td$1.seed);
			const randomizer = (0, import_testdouble$61.object)();
			(0, import_testdouble$61.when)(randomizer.generateRandomData(import_testdouble$61.matchers.anything())).thenReturn(seed);
			const encapsulation = encapsulate(liboqs, publicKey$1, randomizer);
			dist_default(encapsulation.sharedSecret).deepEquals(hexToUint8Array(td$1.sharedSecret));
			dist_default(encapsulation.ciphertext).deepEquals(hexToUint8Array(td$1.cipherText));
			const decapsulatedSharedSecret = decapsulate(liboqs, privateKey$1, hexToUint8Array(td$1.cipherText));
			dist_default(decapsulatedSharedSecret).deepEquals(hexToUint8Array(td$1.sharedSecret));
		}
	});
	dist_default("kyber - fallback", async () => {
		for (const td$1 of CompatibilityTestData_default.kyberEncryptionTests) {
			const publicKey$1 = bytesToKyberPublicKey(hexToUint8Array(td$1.publicKey));
			const privateKey$1 = bytesToKyberPrivateKey(hexToUint8Array(td$1.privateKey));
			dist_default(uint8ArrayToHex(kyberPublicKeyToBytes(publicKey$1))).deepEquals(td$1.publicKey);
			dist_default(uint8ArrayToHex(kyberPrivateKeyToBytes(privateKey$1))).deepEquals(td$1.privateKey);
			const seed = hexToUint8Array(td$1.seed);
			const randomizer = (0, import_testdouble$61.object)();
			(0, import_testdouble$61.when)(randomizer.generateRandomData(import_testdouble$61.matchers.anything())).thenReturn(seed);
			const liboqsFallback = await (await import("./_wasm-loader_liboqs-5pUs3QpW.js")).loadWasm({ forceFallback: true });
			const encapsulation = encapsulate(liboqsFallback, publicKey$1, randomizer);
			dist_default(encapsulation.sharedSecret).deepEquals(hexToUint8Array(td$1.sharedSecret));
			dist_default(encapsulation.ciphertext).deepEquals(hexToUint8Array(td$1.cipherText));
			const decapsulatedSharedSecret = decapsulate(liboqsFallback, privateKey$1, hexToUint8Array(td$1.cipherText));
			dist_default(decapsulatedSharedSecret).deepEquals(hexToUint8Array(td$1.sharedSecret));
		}
	});
	dist_default("aes 256", function() {
		for (const td$1 of CompatibilityTestData_default.aes256Tests) {
			let key = uint8ArrayToBitArray(hexToUint8Array(td$1.hexKey));
			let encryptedBytes = aesEncrypt(key, base64ToUint8Array(td$1.plainTextBase64), base64ToUint8Array(td$1.ivBase64), true);
			dist_default(uint8ArrayToBase64(encryptedBytes)).equals(td$1.cipherTextBase64);
			let decryptedBytes = uint8ArrayToBase64(aesDecrypt(key, encryptedBytes, true));
			dist_default(decryptedBytes).equals(td$1.plainTextBase64);
			const keyToEncrypt128 = uint8ArrayToBitArray(hexToUint8Array(td$1.keyToEncrypt128));
			const encryptedKey128 = aesEncrypt(key, bitArrayToUint8Array(keyToEncrypt128), base64ToUint8Array(td$1.ivBase64), false);
			dist_default(uint8ArrayToBase64(encryptedKey128)).equals(td$1.encryptedKey128);
			const decryptedKey128 = decryptKey(key, encryptedKey128);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(decryptedKey128))).equals(td$1.keyToEncrypt128);
			const keyToEncrypt256 = uint8ArrayToBitArray(hexToUint8Array(td$1.keyToEncrypt256));
			const encryptedKey256 = aesEncrypt(key, bitArrayToUint8Array(keyToEncrypt256), base64ToUint8Array(td$1.ivBase64), false);
			dist_default(uint8ArrayToBase64(encryptedKey256)).equals(td$1.encryptedKey256);
			const decryptedKey256 = decryptKey(key, encryptedKey256);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(decryptedKey256))).equals(td$1.keyToEncrypt256);
		}
	});
	dist_default("aes128 128 bit key encryption", function() {
		for (const td$1 of CompatibilityTestData_default.aes128Tests) {
			let key = uint8ArrayToBitArray(hexToUint8Array(td$1.hexKey));
			const keyToEncrypt128 = uint8ArrayToBitArray(hexToUint8Array(td$1.keyToEncrypt128));
			const encryptedKey128 = encryptKey(key, keyToEncrypt128);
			dist_default(uint8ArrayToBase64(encryptedKey128)).equals(td$1.encryptedKey128);
			const decryptedKey128 = decryptKey(key, encryptedKey128);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(decryptedKey128))).equals(td$1.keyToEncrypt128);
		}
	});
	dist_default("aes128 256 bit key encryption", function() {
		for (const td$1 of CompatibilityTestData_default.aes128Tests) {
			let key = uint8ArrayToBitArray(hexToUint8Array(td$1.hexKey));
			const keyToEncrypt256 = uint8ArrayToBitArray(hexToUint8Array(td$1.keyToEncrypt256));
			const encryptedKey256 = encryptKey(key, keyToEncrypt256);
			dist_default(uint8ArrayToBase64(encryptedKey256)).equals(td$1.encryptedKey256);
			const decryptedKey256 = decryptKey(key, encryptedKey256);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(decryptedKey256))).equals(td$1.keyToEncrypt256);
		}
	});
	dist_default("aes 128", function() {
		for (const td$1 of CompatibilityTestData_default.aes128Tests) {
			let key = uint8ArrayToBitArray(hexToUint8Array(td$1.hexKey));
			let encryptedBytes = aesEncrypt(key, base64ToUint8Array(td$1.plainTextBase64), base64ToUint8Array(td$1.ivBase64), true, false);
			dist_default(uint8ArrayToBase64(encryptedBytes)).equals(td$1.cipherTextBase64);
			let decryptedBytes = uint8ArrayToBase64(aesDecrypt(key, encryptedBytes));
			dist_default(decryptedBytes).equals(td$1.plainTextBase64);
		}
	});
	dist_default("aes 128 mac", function() {
		for (const td$1 of CompatibilityTestData_default.aes128MacTests) {
			let key = uint8ArrayToBitArray(hexToUint8Array(td$1.hexKey));
			let encryptedBytes = aesEncrypt(key, base64ToUint8Array(td$1.plainTextBase64), base64ToUint8Array(td$1.ivBase64), true, true);
			dist_default(uint8ArrayToBase64(encryptedBytes)).equals(td$1.cipherTextBase64);
			let decryptedBytes = uint8ArrayToBase64(aesDecrypt(key, encryptedBytes));
			dist_default(decryptedBytes).equals(td$1.plainTextBase64);
		}
	});
	dist_default("unicodeEncoding", function() {
		for (const td$1 of CompatibilityTestData_default.encodingTests) {
			let encoded = stringToUtf8Uint8Array(td$1.string);
			dist_default(uint8ArrayToBase64(encoded)).equals(neverNull(td$1.encodedString));
			let decoded = utf8Uint8ArrayToString(encoded);
			dist_default(decoded).equals(td$1.string);
		}
	});
	dist_default("bcrypt 128", function() {
		for (const td$1 of CompatibilityTestData_default.bcrypt128Tests) {
			let key = generateKeyFromPassphrase$1(td$1.password, hexToUint8Array(td$1.saltHex), KeyLength.b128);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(key))).equals(td$1.keyHex);
		}
	});
	dist_default("bcrypt 256", function() {
		for (const td$1 of CompatibilityTestData_default.bcrypt256Tests) {
			let key = generateKeyFromPassphrase$1(td$1.password, hexToUint8Array(td$1.saltHex), KeyLength.b256);
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(key))).equals(td$1.keyHex);
		}
	});
	dist_default("argon2id", async function() {
		const argon2 = await loadArgon2WASM();
		for (let td$1 of CompatibilityTestData_default.argon2idTests) {
			let key = await generateKeyFromPassphrase(argon2, td$1.password, hexToUint8Array(td$1.saltHex));
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(key))).equals(td$1.keyHex);
		}
	});
	dist_default("argon2id - fallback", async function() {
		const argon2 = await (await import("./_wasm-loader_argon2-CNtiolS9.js")).loadWasm({ forceFallback: true });
		for (let td$1 of CompatibilityTestData_default.argon2idTests) {
			let key = await generateKeyFromPassphrase(argon2, td$1.password, hexToUint8Array(td$1.saltHex));
			dist_default(uint8ArrayToHex(bitArrayToUint8Array(key))).equals(td$1.keyHex);
		}
	});
	dist_default("compression", function() {
		for (const td$1 of CompatibilityTestData_default.compressionTests) {
			dist_default(utf8Uint8ArrayToString(uncompress(base64ToUint8Array(td$1.compressedBase64TextJava)))).equals(td$1.uncompressedText);
			dist_default(utf8Uint8ArrayToString(uncompress(base64ToUint8Array(td$1.compressedBase64TextJavaScript)))).equals(td$1.uncompressedText);
		}
	});
	dist_default("x25519", function() {
		for (const td$1 of CompatibilityTestData_default.x25519Tests) {
			const alicePrivateKeyBytes = hexToUint8Array(td$1.alicePrivateKeyHex);
			const alicePublicKeyBytes = hexToUint8Array(td$1.alicePublicKeyHex);
			const aliceKeyPair = {
				priv: alicePrivateKeyBytes,
				pub: alicePublicKeyBytes
			};
			const ephemeralPrivateKeyBytes = hexToUint8Array(td$1.ephemeralPrivateKeyHex);
			const ephemeralPublicKeyBytes = hexToUint8Array(td$1.ephemeralPublicKeyHex);
			const ephemeralKeyPair = {
				priv: ephemeralPrivateKeyBytes,
				pub: ephemeralPublicKeyBytes
			};
			const bobPrivateKeyBytes = hexToUint8Array(td$1.bobPrivateKeyHex);
			const bobPublicKeyBytes = hexToUint8Array(td$1.bobPublicKeyHex);
			const bobKeyPair = {
				priv: bobPrivateKeyBytes,
				pub: bobPublicKeyBytes
			};
			const aliceToBob = eccEncapsulate(aliceKeyPair.priv, ephemeralKeyPair.priv, bobKeyPair.pub);
			const bobToAlice = eccDecapsulate(aliceKeyPair.pub, ephemeralKeyPair.pub, bobKeyPair.priv);
			dist_default(aliceToBob).deepEquals(bobToAlice);
			dist_default(td$1.ephemeralSharedSecretHex).equals(uint8ArrayToHex(aliceToBob.ephemeralSharedSecret));
			dist_default(td$1.authSharedSecretHex).equals(uint8ArrayToHex(aliceToBob.authSharedSecret));
		}
	});
	dist_default("byteArrayEncoding", function() {
		for (const td$1 of CompatibilityTestData_default.byteArrayEncodingTests) {
			const byteArrays = td$1.byteArraysAsHex.map((byteArrayAsHex) => hexToUint8Array(byteArrayAsHex));
			if (td$1.encodedByteArrayAsHex) {
				dist_default(td$1.encodedByteArrayAsHex).equals(uint8ArrayToHex(byteArraysToBytes(byteArrays)));
				const decodedByteArrays = bytesToByteArrays(hexToUint8Array(td$1.encodedByteArrayAsHex), td$1.byteArraysAsHex.length);
				for (let i = 0; i < td$1.byteArraysAsHex.length; i++) dist_default(td$1.byteArraysAsHex[i]).equals(uint8ArrayToHex(decodedByteArrays[i]));
			} else try {
				byteArraysToBytes(byteArrays);
				throw new Error(" encoding error no thrown");
			} catch (e) {
				dist_default(td$1.encodingError).equals(e.message);
			}
		}
	});
	dist_default("hkdf", function() {
		for (const td$1 of CompatibilityTestData_default.hkdfTests) {
			const salt = hexToUint8Array(td$1.saltHex);
			const inputKeyMaterialHex = hexToUint8Array(td$1.inputKeyMaterialHex);
			const info = hexToUint8Array(td$1.infoHex);
			const lengthInBytes = td$1.lengthInBytes;
			dist_default(uint8ArrayToHex(hkdf(salt, inputKeyMaterialHex, info, lengthInBytes))).equals(td$1.hkdfHex);
		}
	});
	dist_default("pqcrypt", async function() {
		for (const td$1 of CompatibilityTestData_default.pqcryptEncryptionTests) {
			random.generateRandomData = (number) => hexToUint8Array(td$1.seed).slice(0, number);
			const bucketKey = hexToUint8Array(td$1.bucketKey);
			const eccKeyPair = {
				publicKey: hexToUint8Array(td$1.publicX25519Key),
				privateKey: hexToUint8Array(td$1.privateX25519Key)
			};
			const ephemeralKeyPair = {
				publicKey: hexToUint8Array(td$1.epheremalPublicX25519Key),
				privateKey: hexToUint8Array(td$1.epheremalPrivateX25519Key)
			};
			const kyberKeyPair = {
				publicKey: bytesToKyberPublicKey(hexToUint8Array(td$1.publicKyberKey)),
				privateKey: bytesToKyberPrivateKey(hexToUint8Array(td$1.privateKyberKey))
			};
			const pqPublicKeys = {
				keyPairType: KeyPairType.TUTA_CRYPT,
				eccPublicKey: eccKeyPair.publicKey,
				kyberPublicKey: kyberKeyPair.publicKey
			};
			const pqKeyPairs = {
				keyPairType: KeyPairType.TUTA_CRYPT,
				eccKeyPair,
				kyberKeyPair
			};
			const pqFacade$1 = new PQFacade(new WASMKyberFacade(liboqs));
			const encapsulation = await pqFacade$1.encapsulateAndEncode(eccKeyPair, ephemeralKeyPair, pqPublicKeys, bucketKey);
			dist_default(encapsulation).deepEquals(hexToUint8Array(td$1.pqMessage));
			const decapsulation = await pqFacade$1.decapsulateEncoded(encapsulation, pqKeyPairs);
			dist_default(decapsulation.decryptedSymKeyBytes).deepEquals(bucketKey);
			dist_default(decapsulation.senderIdentityPubKey).deepEquals(eccKeyPair.publicKey);
		}
	});
	dist_default("pqcrypt - kyber fallback", async function() {
		for (const td$1 of CompatibilityTestData_default.pqcryptEncryptionTests) {
			random.generateRandomData = (number) => hexToUint8Array(td$1.seed).slice(0, number);
			const bucketKey = hexToUint8Array(td$1.bucketKey);
			const eccKeyPair = {
				publicKey: hexToUint8Array(td$1.publicX25519Key),
				privateKey: hexToUint8Array(td$1.privateX25519Key)
			};
			const ephemeralKeyPair = {
				publicKey: hexToUint8Array(td$1.epheremalPublicX25519Key),
				privateKey: hexToUint8Array(td$1.epheremalPrivateX25519Key)
			};
			const kyberKeyPair = {
				publicKey: bytesToKyberPublicKey(hexToUint8Array(td$1.publicKyberKey)),
				privateKey: bytesToKyberPrivateKey(hexToUint8Array(td$1.privateKyberKey))
			};
			const pqPublicKeys = {
				keyPairType: KeyPairType.TUTA_CRYPT,
				eccPublicKey: eccKeyPair.publicKey,
				kyberPublicKey: kyberKeyPair.publicKey
			};
			const pqKeyPairs = {
				keyPairType: KeyPairType.TUTA_CRYPT,
				eccKeyPair,
				kyberKeyPair
			};
			const liboqsFallback = await (await import("./_wasm-loader_liboqs-5pUs3QpW.js")).loadWasm({ forceFallback: true });
			const pqFacade$1 = new PQFacade(new WASMKyberFacade(liboqsFallback));
			const encapsulation = await pqFacade$1.encapsulateAndEncode(eccKeyPair, ephemeralKeyPair, pqPublicKeys, bucketKey);
			dist_default(encapsulation).deepEquals(hexToUint8Array(td$1.pqMessage));
			const decapsulation = await pqFacade$1.decapsulateEncoded(encapsulation, pqKeyPairs);
			dist_default(decapsulation.decryptedSymKeyBytes).deepEquals(bucketKey);
			dist_default(decapsulation.senderIdentityPubKey).deepEquals(eccKeyPair.publicKey);
		}
	});
	/**
	* Creates the Javascript compatibility test data for compression. See CompatibilityTest.writeCompressionTestData() in Java for
	* instructions how to update the test data.
	*/
});

//#endregion
//#region tests/api/common/error/RestErrorTest.ts
dist_default.spec("RestErrorTest", function() {
	dist_default("handleRestError should create the correct error classes", () => {
		dist_default(handleRestError(400) instanceof BadRequestError).equals(true);
		dist_default(handleRestError(401) instanceof NotAuthenticatedError).equals(true);
		dist_default(handleRestError(403) instanceof NotAuthorizedError).equals(true);
		dist_default(handleRestError(404) instanceof NotFoundError).equals(true);
		dist_default(handleRestError(405) instanceof MethodNotAllowedError).equals(true);
		dist_default(handleRestError(412) instanceof PreconditionFailedError).equals(true);
		dist_default(handleRestError(423) instanceof LockedError).equals(true);
		dist_default(handleRestError(429) instanceof TooManyRequestsError).equals(true);
		dist_default(handleRestError(440) instanceof SessionExpiredError).equals(true);
		dist_default(handleRestError(470) instanceof AccessDeactivatedError).equals(true);
		dist_default(handleRestError(471) instanceof AccessExpiredError).equals(true);
		dist_default(handleRestError(472) instanceof AccessBlockedError).equals(true);
		dist_default(handleRestError(473) instanceof InvalidDataError).equals(true);
		dist_default(handleRestError(474) instanceof InvalidSoftwareVersionError).equals(true);
		dist_default(handleRestError(475) instanceof LimitReachedError).equals(true);
		dist_default(handleRestError(500) instanceof InternalServerError).equals(true);
		dist_default(handleRestError(502) instanceof BadGatewayError).equals(true);
		let resourceError = handleRestError(123, "/path", "errorId");
		dist_default(resourceError instanceof ResourceError).equals(true);
		dist_default(resourceError.message).equals("123: errorId /path");
	});
	dist_default("handleRestError should correctly initialize PreconditionFailedError class", () => {
		const preconditionFailedError = handleRestError(412, "/path", null, "reason");
		dist_default(preconditionFailedError.data).equals("reason");
		dist_default(preconditionFailedError.message).equals("412: reason /path");
	});
	function createErrorTest(type, name, message) {
		dist_default(`error ${name} should have correct message and type`, () => {
			dist_default(new type().name).equals(name);
			dist_default(new type(message).message).equals(message)(`expected message '${message}' for ${name} but was '${new type().message}'`);
			dist_default(new type() instanceof type).equals(true);
			dist_default(new type() instanceof TutanotaError).equals(true);
			let thrown = false;
			try {
				throw new type();
			} catch (e) {
				thrown = true;
			}
			dist_default(thrown).equals(true)(`throws ${type}`);
		});
	}
	createErrorTest(BadRequestError, "BadRequestError", 400);
	createErrorTest(NotAuthenticatedError, "NotAuthenticatedError", 401);
	createErrorTest(NotAuthorizedError, "NotAuthorizedError", 403);
	createErrorTest(MethodNotAllowedError, "MethodNotAllowedError", 405);
	createErrorTest(NotFoundError, "NotFoundError", 404);
	createErrorTest(PreconditionFailedError, "PreconditionFailedError", 412);
	createErrorTest(LockedError, "LockedError", 423);
	createErrorTest(TooManyRequestsError, "TooManyRequestsError", 429);
	createErrorTest(SessionExpiredError, "SessionExpiredError", 440);
	createErrorTest(AccessDeactivatedError, "AccessDeactivatedError", 470);
	createErrorTest(AccessExpiredError, "AccessExpiredError", 471);
	createErrorTest(AccessBlockedError, "AccessBlockedError", 472);
	createErrorTest(InvalidDataError, "InvalidDataError", 473);
	createErrorTest(InvalidSoftwareVersionError, "InvalidSoftwareVersionError", 474);
	createErrorTest(LimitReachedError, "LimitReachedError", 475);
	createErrorTest(InternalServerError, "InternalServerError", 500);
	createErrorTest(BadGatewayError, "BadGatewayError", 502);
	createErrorTest(ResourceError, "ResourceError", undefined);
	createErrorTest(ConnectionError, "ConnectionError", undefined);
});

//#endregion
//#region tests/api/common/error/TutanotaErrorTest.ts
dist_default.spec("TutanotaErrorTest", function() {
	dist_default("error name should be correct", () => {
		dist_default(new ProgrammingError().name).equals("ProgrammingError");
		dist_default(new ProgrammingError() instanceof ProgrammingError).equals(true);
		dist_default(new ProgrammingError() instanceof TutanotaError).equals(true);
	});
});

//#endregion
//#region tests/api/worker/rest/EntityRestCacheTest.ts
var import_testdouble$60 = __toESM(require_testdouble(), 1);
const { anything: anything$9 } = import_testdouble$60.matchers;
const offlineDatabaseTestKey = new Uint8Array([
	3957386659,
	354339016,
	3786337319,
	3366334248
]);
async function getOfflineStorage(userId$1) {
	const { PerWindowSqlCipherFacade } = await import("./PerWindowSqlCipherFacade-BbbZxclZ.js");
	const { OfflineDbRefCounter } = await import("./OfflineDbRefCounter-gVnegcba.js");
	const { DesktopSqlCipher } = await import("./DesktopSqlCipher-DFDA0lbr.js");
	const odbRefCounter = new OfflineDbRefCounter({
		async create(userid, key, retry) {
			const db = new DesktopSqlCipher(__NODE_GYP_better_sqlite3, ":memory:", false);
			await db.openDb(userId$1, key);
			return db;
		},
		async delete(userId$2) {}
	});
	const migratorMock = (0, import_testdouble$60.instance)(OfflineStorageMigrator);
	const sqlCipherFacade = new PerWindowSqlCipherFacade(odbRefCounter);
	await sqlCipherFacade.openDb(userId$1, offlineDatabaseTestKey);
	const interWindowEventSender = (0, import_testdouble$60.instance)(InterWindowEventFacadeSendDispatcher);
	const offlineStorageCleanerMock = (0, import_testdouble$60.object)();
	const offlineStorage = new OfflineStorage(sqlCipherFacade, interWindowEventSender, new NoZoneDateProvider(), migratorMock, offlineStorageCleanerMock);
	await offlineStorage.init({
		userId: userId$1,
		databaseKey: offlineDatabaseTestKey,
		timeRangeDays: 42,
		forceNewDatabase: false
	});
	return offlineStorage;
}
async function getEphemeralStorage() {
	return new EphemeralCacheStorage();
}
testEntityRestCache("ephemeral", getEphemeralStorage);
node(() => testEntityRestCache("offline", getOfflineStorage))();
function testEntityRestCache(name, getStorage) {
	const groupId = "groupId";
	const batchId = "batchId";
	dist_default.spec(`EntityRestCache ${name}`, function() {
		let storage;
		let cache;
		let entityRestClient;
		let userId$1;
		let createUpdate$2 = function(typeRef, listId, id, operation) {
			let eu = createTestEntity(EntityUpdateTypeRef);
			eu.application = typeRef.app;
			eu.type = typeRef.type;
			eu.instanceListId = listId;
			eu.instanceId = id;
			eu.operation = operation;
			return eu;
		};
		let createId = function(idText) {
			return Array(13 - idText.length).join("-") + idText;
		};
		let createMailDetailsBlobInstance = function(archiveId, id, bodyText) {
			let body = createTestEntity(BodyTypeRef, { text: bodyText });
			let mailDetails = createTestEntity(MailDetailsTypeRef, {
				_id: createId(id),
				body
			});
			return createTestEntity(MailDetailsBlobTypeRef, {
				_id: [archiveId, mailDetails._id],
				details: mailDetails
			});
		};
		let createMailInstance = function(listId, id, subject) {
			let mail = createTestEntity(MailTypeRef);
			mail._id = [listId, createId(id)];
			mail.subject = subject ?? "";
			mail.mailDetails = ["mailDetailsListId", "mailDetailsElementId"];
			return mail;
		};
		function mockRestClient() {
			let notToBeCalled = function(name$1) {
				return function(...args) {
					throw new Error(name$1 + " should not have been called. arguments: " + String(args));
				};
			};
			const restClient = (0, import_testdouble$60.object)();
			(0, import_testdouble$60.when)(restClient.getServerTimestampMs()).thenReturn(Date.now());
			return downcast({
				load: notToBeCalled("load"),
				loadRange: notToBeCalled("loadRange"),
				loadMultiple: notToBeCalled("loadMultiple"),
				setup: notToBeCalled("setup"),
				setupMultiple: notToBeCalled("setupMultiple"),
				update: notToBeCalled("update"),
				erase: notToBeCalled("erase"),
				entityEventsReceived: (e) => Promise.resolve(e),
				getRestClient: () => restClient
			});
		}
		dist_default.beforeEach(async function() {
			userId$1 = "userId";
			storage = await getStorage(userId$1);
			entityRestClient = mockRestClient();
			cache = new DefaultEntityRestCache(entityRestClient, storage);
		});
		dist_default.spec("entityEventsReceived", function() {
			const path = typeRefToPath(ContactTypeRef);
			const contactListId1 = "contactListId1";
			const contactListId2 = "contactListId2";
			const id1 = "id1";
			const id2 = "id2";
			const id3 = "id3";
			const id4 = "id4";
			const id5 = "id5";
			const id6 = "id6";
			const id7 = "id7";
			const calendarEventListId = "calendarEventListId";
			let timestamp = Date.now();
			const calendarEventIds = [
				0,
				1,
				2,
				3,
				4,
				5,
				6
			].map((n) => createEventElementId(timestamp, n));
			dist_default("writes batch meta on entity update", async function() {
				const contact1 = createTestEntity(ContactTypeRef, { _id: [contactListId1, id1] });
				const contact2 = createTestEntity(ContactTypeRef, { _id: [contactListId1, id2] });
				const batch = [createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE), createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE)];
				const loadMultiple = (0, import_testdouble$60.func)();
				(0, import_testdouble$60.when)(loadMultiple(ContactTypeRef, contactListId1, [id1, id2])).thenResolve([contact1, contact2]);
				(0, import_testdouble$60.replace)(entityRestClient, "loadMultiple", loadMultiple);
				const putLastBatchIdForGroup = (0, import_testdouble$60.func)();
				(0, import_testdouble$60.when)(putLastBatchIdForGroup(groupId, batchId)).thenResolve(undefined);
				(0, import_testdouble$60.replace)(storage, "putLastBatchIdForGroup", putLastBatchIdForGroup);
				await cache.entityEventsReceived(makeBatch(batch));
				await cache.getLastEntityEventBatchForGroup(groupId);
				verify(putLastBatchIdForGroup(groupId, batchId));
			});
			dist_default.spec("postMultiple", function() {
				dist_default.beforeEach(async function() {
					await storage.setNewRangeForList(ContactTypeRef, contactListId1, id1, id7);
					await storage.setNewRangeForList(ContactTypeRef, contactListId2, id1, id7);
				});
				dist_default("entity events received should call loadMultiple when receiving updates from a postMultiple", async function() {
					const contact1 = createTestEntity(ContactTypeRef, { _id: [contactListId1, id1] });
					const contact2 = createTestEntity(ContactTypeRef, { _id: [contactListId1, id2] });
					const batch = [createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE), createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE)];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						dist_default(isSameTypeRef(typeRef, ContactTypeRef)).equals(true);
						dist_default(listId).equals(contactListId1);
						dist_default(ids).deepEquals(["id1", "id2"]);
						return Promise.resolve([contact1, contact2]);
					});
					const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const updates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(mock$1);
					dist_default(loadMultiple.callCount).equals(1)("loadMultiple is called");
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).notEquals(null);
					dist_default(updates).deepEquals(batch);
				});
				if (name === "offline") dist_default("entity events received should call loadMultiple when receiving updates from a postMultiple with CustomCacheHandler", async function() {
					const event1 = createTestEntity(CalendarEventTypeRef, { _id: [calendarEventListId, calendarEventIds[0]] });
					const event2 = createTestEntity(CalendarEventTypeRef, { _id: [calendarEventListId, calendarEventIds[1]] });
					await storage.setNewRangeForList(CalendarEventTypeRef, calendarEventListId, CUSTOM_MIN_ID, CUSTOM_MAX_ID);
					const batch = [createUpdate$2(CalendarEventTypeRef, calendarEventListId, calendarEventIds[0], OperationType.CREATE), createUpdate$2(ContactTypeRef, calendarEventListId, calendarEventIds[1], OperationType.CREATE)];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						dist_default(isSameTypeRef(typeRef, CalendarEventTypeRef)).equals(true);
						dist_default(listId).equals(calendarEventListId);
						dist_default(ids).deepEquals([calendarEventIds[0], calendarEventIds[1]]);
						return Promise.resolve([event1, event2]);
					});
					const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const updates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(mock$1);
					dist_default(loadMultiple.callCount).equals(1)("loadMultiple is called");
					dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[0])).notEquals(null);
					dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[1])).notEquals(null);
					dist_default(updates).deepEquals(batch);
				});
				dist_default("post multiple with different update type and list ids should make multiple load calls", async function() {
					const batch = [
						createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id3, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id4, OperationType.CREATE),
						createUpdate$2(CustomerTypeRef, null, id5, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.UPDATE),
						createUpdate$2(CalendarEventTypeRef, calendarEventListId, calendarEventIds[0], OperationType.CREATE),
						createUpdate$2(CalendarEventTypeRef, calendarEventListId, calendarEventIds[1], OperationType.CREATE)
					];
					const load = spy(function(typeRef, id) {
						const { listId, elementId } = expandId(id);
						if (isSameTypeRef(typeRef, ContactTypeRef)) {
							dist_default(elementId).equals(id2);
							return Promise.resolve(createTestEntity(ContactTypeRef, { _id: [neverNull(listId), elementId] }));
						} else if (isSameTypeRef(typeRef, CustomerTypeRef)) {
							dist_default([
								"id5",
								"id6",
								"id7"
							].includes(elementId)).equals(true);
							return Promise.resolve(createTestEntity(CustomerTypeRef, { _id: elementId }));
						}
						throw new Error("load: should not be reached" + typeRef);
					});
					const loadMultiple = spy(function(typeRef, listId, ids) {
						if (isSameTypeRef(typeRef, ContactTypeRef) || isSameTypeRef(typeRef, CalendarEventTypeRef)) {
							if (listId === contactListId1) {
								dist_default(ids).deepEquals(["id1", "id2"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, id1] }), createTestEntity(ContactTypeRef, { _id: [listId, id2] })]);
							} else if (listId === calendarEventListId) {
								dist_default(ids).deepEquals([calendarEventIds[0], calendarEventIds[1]]);
								return Promise.resolve([createTestEntity(CalendarEventTypeRef, { _id: [calendarEventListId, calendarEventIds[0]] }), createTestEntity(CalendarEventTypeRef, { _id: [calendarEventListId, calendarEventIds[1]] })]);
							} else if (listId === contactListId2) {
								dist_default(ids).deepEquals(["id3", "id4"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, "id3"] }), createTestEntity(ContactTypeRef, { _id: [listId, "id4"] })]);
							}
						}
						throw new Error(`load multiple: should not be reached, typeref is ${typeRef}, listid is ${listId} `);
					});
					if (name === "offline") await storage.setNewRangeForList(CalendarEventTypeRef, calendarEventListId, CUSTOM_MIN_ID, CUSTOM_MAX_ID);
					const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
					const loadMultipleMock = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const filteredUpdates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(loadMock);
					unmockAttribute(loadMultipleMock);
					dist_default(load.callCount).equals(1)("One load for the customer create");
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id3)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id4)).notEquals(null);
					if (name === "offline") {
						dist_default(loadMultiple.callCount).equals(3)("Three load multiple, one for each contact list and one for the calendar list");
						dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[0])).notEquals(null)("when using offline storage event 0 should be cached");
						dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[1])).notEquals(null)("when using offline storage event 1 should be cached");
					} else {
						dist_default(loadMultiple.callCount).equals(2)("two load multiple, one for each contact list and none for the calendar list");
						dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[0])).equals(null)("when using offline storage event 0 should not be cached");
						dist_default(await storage.get(CalendarEventTypeRef, calendarEventListId, calendarEventIds[1])).equals(null)("when using offline storage event 1 should not be cached");
					}
					dist_default(await storage.get(CustomerTypeRef, null, id5)).equals(null);
					dist_default(filteredUpdates.length).equals(batch.length);
					for (const update of batch) dist_default(filteredUpdates.includes(update)).equals(true);
				});
				dist_default("returns empty [] when loadMultiple throwing an error ", async function() {
					const batch = [
						createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id3, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id4, OperationType.CREATE)
					];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						dist_default(isSameTypeRef(typeRef, ContactTypeRef)).equals(true);
						if (listId === contactListId1) {
							dist_default(ids).deepEquals(["id1", "id2"]);
							return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, id1] }), createTestEntity(ContactTypeRef, { _id: [listId, id2] })]);
						} else if (listId === contactListId2) {
							dist_default(ids).deepEquals(["id3", "id4"]);
							return Promise.reject(new NotAuthorizedError("bam"));
						}
					});
					const loadMultipleMock = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const updates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(loadMultipleMock);
					dist_default(loadMultiple.callCount).equals(2);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id3)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id4)).equals(null);
					dist_default(updates).deepEquals(batch.slice(0, 2));
				});
			});
			dist_default.spec("post  multiple cache range", function() {
				dist_default("update is not in cache range", async function() {
					const batch = [createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE), createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE)];
					const updates = await cache.entityEventsReceived(makeBatch(batch));
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).equals(null);
					dist_default(updates).deepEquals(batch);
				});
				dist_default("updates partially not loaded by loadMultiple", async function() {
					await storage.setNewRangeForList(ContactTypeRef, contactListId1, id1, id2);
					const batch = [createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE), createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE)];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						if (isSameTypeRef(typeRef, ContactTypeRef)) {
							if (listId === contactListId1) {
								dist_default(ids).deepEquals(["id1", "id2"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, id1] })]);
							}
						}
						throw new Error("should not be reached");
					});
					const loadMultipleMock = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const filteredUpdates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(loadMultipleMock);
					dist_default(loadMultiple.callCount).equals(1);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).equals(null);
					dist_default(filteredUpdates.length).equals(batch.length - 1);
					for (const update of batch.slice(0, 1)) dist_default(filteredUpdates.includes(update)).equals(true);
				});
				dist_default("update are partially in cache range ", async function() {
					await storage.setNewRangeForList(ContactTypeRef, contactListId1, id1, id1);
					await storage.setNewRangeForList(ContactTypeRef, contactListId2, id4, id4);
					const batch = [
						createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id3, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id4, OperationType.CREATE)
					];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						if (isSameTypeRef(typeRef, ContactTypeRef)) {
							if (listId === contactListId1) {
								dist_default(ids).deepEquals(["id1"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, id1] })]);
							} else if (listId === contactListId2) {
								dist_default(ids).deepEquals(["id4"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, "id4"] })]);
							}
						}
						throw new Error("should not be reached");
					});
					const loadMultipleMock = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const filteredUpdates = await cache.entityEventsReceived(makeBatch(batch));
					unmockAttribute(loadMultipleMock);
					dist_default(loadMultiple.callCount).equals(2);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id3)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id4)).notEquals(null);
					dist_default(filteredUpdates.length).equals(batch.length);
					for (const update of batch) dist_default(filteredUpdates.includes(update)).equals(true);
				});
				dist_default("update  partially results in NotAuthorizedError ", async function() {
					await storage.setNewRangeForList(ContactTypeRef, contactListId1, id1, id1);
					await storage.setNewRangeForList(ContactTypeRef, contactListId2, id4, id4);
					const batch = [
						createUpdate$2(ContactTypeRef, contactListId1, id1, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId1, id2, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id3, OperationType.CREATE),
						createUpdate$2(ContactTypeRef, contactListId2, id4, OperationType.CREATE)
					];
					const loadMultiple = spy(function(typeRef, listId, ids) {
						if (isSameTypeRef(typeRef, ContactTypeRef)) {
							if (listId === contactListId1) {
								dist_default(ids).deepEquals(["id1"]);
								return Promise.resolve([createTestEntity(ContactTypeRef, { _id: [listId, id1] })]);
							} else if (listId === contactListId2) {
								dist_default(ids).deepEquals(["id4"]);
								return Promise.reject(new NotAuthorizedError("bam"));
							}
						}
						throw new Error("should not be reached");
					});
					const loadMultipleMock = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
					const filteredUpdates = await cache.entityEventsReceived(makeBatch(batch));
					dist_default(loadMultiple.callCount).equals(2);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id1)).notEquals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId1, id2)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id3)).equals(null);
					dist_default(await storage.get(ContactTypeRef, contactListId2, id4)).equals(null);
					dist_default(filteredUpdates.length).equals(batch.length - 1);
					for (const update of batch.slice(0, 3)) dist_default(filteredUpdates.includes(update)).equals(true);
					unmockAttribute(loadMultipleMock);
				});
			});
			dist_default("element create notifications are not loaded from server", async function() {
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailBoxTypeRef, null, "id1", OperationType.CREATE)]));
			});
			dist_default("element update notifications are not put into cache", async function() {
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailBoxTypeRef, null, "id1", OperationType.UPDATE)]));
			});
			dist_default("Update event for cached entity is received, it should be redownloaded", async function() {
				const archiveId = "archiveId";
				const mailDetailsId = "detailsId1";
				let mailDetailsBlob = createMailDetailsBlobInstance(archiveId, mailDetailsId, "hello");
				await storage.put(mailDetailsBlob);
				const load = spy(async () => createMailDetailsBlobInstance(archiveId, mailDetailsId, "goodbye"));
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailDetailsBlobTypeRef, archiveId, createId(mailDetailsId), OperationType.UPDATE)]));
				dist_default(load.callCount).equals(1);
				dist_default(isSameTypeRef(load.args[0], MailDetailsBlobTypeRef)).equals(true);
				dist_default(load.args[1]).deepEquals([archiveId, createId(mailDetailsId)]);
				const blob = await cache.load(MailDetailsBlobTypeRef, [archiveId, createId(mailDetailsId)]);
				dist_default(blob.details.body.text).equals("goodbye");
				dist_default(load.callCount).equals(1);
				unmockAttribute(loadMock);
			});
			dist_default("When update event for cached entity is received but it can't be downloaded it is removed from cache", async function() {
				const archiveId = "archiveId";
				const mailDetailsId = "detailsId1";
				let mailDetailsBlob = createMailDetailsBlobInstance(archiveId, mailDetailsId, "hello");
				await storage.put(mailDetailsBlob);
				const load = spy(async () => {
					throw new NotFoundError("test!");
				});
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailDetailsBlobTypeRef, archiveId, createId(mailDetailsId), OperationType.UPDATE)]));
				dist_default(load.callCount).equals(1);
				dist_default(await storage.get(mailDetailsBlob._type, archiveId, createId(mailDetailsId))).equals(null)("the blob is deleted from the cache");
				unmockAttribute(loadMock);
			});
			dist_default("element should be deleted from the cache when a delete event is received", async function() {
				const archiveId = "archiveId";
				const mailDetailsId = "detailsId1";
				let mailDetailsBlob = createMailDetailsBlobInstance(archiveId, mailDetailsId, "hello");
				await storage.put(mailDetailsBlob);
				const load = spy(function() {
					return Promise.reject(new NotFoundError("not found"));
				});
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailDetailsBlobTypeRef, archiveId, createId(mailDetailsId), OperationType.DELETE)]));
				dist_default(load.callCount).equals(0);
				await assertThrows(NotFoundError, () => cache.load(MailDetailsBlobTypeRef, [archiveId, createId(mailDetailsId)]));
				unmockAttribute(loadMock);
				dist_default(load.callCount).equals(1);
			});
			dist_default("Mail should not be loaded when a move event is received", async function() {
				const instance$14 = createMailInstance("listId1", "id1", "henlo");
				await storage.put(instance$14);
				const newListId = "listid2";
				const newInstance = clone(instance$14);
				newInstance._id = [newListId, getElementId(instance$14)];
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, getListId(instance$14), getElementId(instance$14), OperationType.DELETE), createUpdate$2(MailTypeRef, newListId, getElementId(instance$14), OperationType.CREATE)]));
				const load = spy(() => Promise.reject(new Error("error from test")));
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				const thrown = await assertThrows(Error, () => cache.load(MailTypeRef, [getListId(instance$14), getElementId(instance$14)]));
				dist_default(thrown.message).equals("error from test");
				dist_default(load.callCount).equals(1)("load is called once");
				const result2 = await cache.load(MailTypeRef, [newListId, getElementId(instance$14)]);
				dist_default(result2).deepEquals(newInstance)("Cached instance is a newInstance");
				unmockAttribute(loadMock);
			});
			dist_default("Mail should not be loaded when a move event is received - update bucket key", async function() {
				const instance$14 = createMailInstance("listId1", "id1", "henlo");
				instance$14.bucketKey = createTestEntity(BucketKeyTypeRef, { bucketEncSessionKeys: [createTestEntity(InstanceSessionKeyTypeRef, {
					instanceList: "listId1",
					instanceId: getElementId(instance$14)
				})] });
				await storage.put(instance$14);
				const newListId = "listId2";
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, getListId(instance$14), getElementId(instance$14), OperationType.DELETE), createUpdate$2(MailTypeRef, newListId, getElementId(instance$14), OperationType.CREATE)]));
				const load = spy(() => Promise.reject(new Error("error from test")));
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				const thrown = await assertThrows(Error, () => cache.load(MailTypeRef, [getListId(instance$14), getElementId(instance$14)]));
				dist_default(thrown.message).equals("error from test");
				dist_default(load.callCount).equals(1)("load is called once");
				const result2 = await cache.load(MailTypeRef, [newListId, getElementId(instance$14)]);
				dist_default(result2.bucketKey?.bucketEncSessionKeys[0].instanceList).deepEquals(newListId)("Cached instance has updated InstanceSessionKey");
				unmockAttribute(loadMock);
			});
			dist_default("id is in range but instance doesn't exist after moving lower range", async function() {
				const listId = "listId1";
				const mails = [
					1,
					2,
					3
				].map((i) => createMailInstance(listId, "id" + i, "mail" + i));
				const newListId = "listId2";
				const loadRange = spy(() => Promise.resolve(mails));
				const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
				storage.lockRangesDbAccess = spy(storage.lockRangesDbAccess);
				storage.unlockRangesDbAccess = spy(storage.unlockRangesDbAccess);
				await cache.loadRange(MailTypeRef, listId, GENERATED_MIN_ID, 3, false);
				dist_default(storage.lockRangesDbAccess.invocations).deepEquals([[listId]]);
				dist_default(storage.unlockRangesDbAccess.invocations).deepEquals([[listId]]);
				dist_default(loadRange.callCount).equals(1);
				unmockAttribute(loadRangeMock);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, getListId(mails[0]), getElementId(mails[0]), OperationType.DELETE), createUpdate$2(MailTypeRef, newListId, getElementId(mails[0]), OperationType.CREATE)]));
				const load = spy(() => Promise.reject(new Error("This is not the mail you're looking for")));
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				const thrown = await assertThrows(Error, () => cache.load(MailTypeRef, [listId, getElementId(mails[0])]));
				dist_default(thrown.message).equals("This is not the mail you're looking for");
				dist_default(load.callCount).equals(1);
				unmockAttribute(loadMock);
			});
			dist_default("id is in range but instance doesn't exist after moving upper range", async function() {
				const mails = [
					createMailInstance("listId1", "id1", "mail 1"),
					createMailInstance("listId1", "id2", "mail 2"),
					createMailInstance("listId1", "id3", "mail 3")
				];
				const loadRange = spy(async () => Promise.resolve(mails));
				const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
				await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 3, false);
				dist_default(loadRange.callCount).equals(1);
				unmockAttribute(loadRangeMock);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, "listId1", getElementId(mails[2]), OperationType.DELETE), createUpdate$2(MailTypeRef, "listId2", getElementId(mails[2]), OperationType.CREATE)]));
				const load = spy(async function() {
					throw new Error("This is not the mail you're looking for");
				});
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				const thrown = await assertThrows(Error, () => cache.load(MailTypeRef, ["listId1", getElementId(mails[2])]));
				dist_default(thrown.message).equals("This is not the mail you're looking for");
				dist_default(load.callCount).equals(1);
				unmockAttribute(loadMock);
			});
			dist_default("delete Mail deletes MailDetailsBlob", async function() {
				const mailDetailsBlob = createTestEntity(MailDetailsBlobTypeRef, { _id: ["archiveId", "blobId"] });
				const mail = createMailInstance("listId1", "id1", "mail 1");
				mail.mailDetails = mailDetailsBlob._id;
				await storage.put(mail);
				await storage.put(mailDetailsBlob);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, mail._id[0], mail._id[1], OperationType.DELETE)]));
				dist_default(await storage.get(MailTypeRef, mail._id[0], mail._id[1])).equals(null);
				dist_default(await storage.get(MailDetailsBlobTypeRef, mailDetailsBlob._id[0], mailDetailsBlob._id[1])).equals(null);
			});
			if (name === "offline") dist_default("when the list is not cache, list element create notifications are still put into cache", async function() {
				const mail = createMailInstance("listId1", "id1", "i am a mail");
				const load = (0, import_testdouble$60.func)();
				(0, import_testdouble$60.when)(load(MailTypeRef, mail._id)).thenResolve(mail);
				mockAttribute(entityRestClient, entityRestClient.load, load);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, getListId(mail), getElementId(mail), OperationType.CREATE)]));
				dist_default(await storage.get(MailTypeRef, getListId(mail), getElementId(mail))).deepEquals(mail);
			});
else dist_default("when the list is not cached, mail create notifications are not put into cache", async function() {
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, "listId1", createId("id1"), OperationType.CREATE)]));
			});
			dist_default("list element update notifications are not put into cache", async function() {
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, "listId1", createId("id1"), OperationType.UPDATE)]));
			});
			dist_default("list element is updated in cache", async function() {
				let initialMail = createMailInstance("listId1", createId("id1"), "hello");
				await storage.put(initialMail);
				let mailUpdate = createMailInstance("listId1", createId("id1"), "goodbye");
				const load = spy(function(typeRef, id) {
					dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
					dist_default(id).deepEquals(["listId1", createId("id1")]);
					return Promise.resolve(mailUpdate);
				});
				const loadMock = mockAttribute(entityRestClient, entityRestClient.load, load);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, "listId1", createId("id1"), OperationType.UPDATE)]));
				dist_default(load.callCount).equals(1);
				const mail = await cache.load(MailTypeRef, ["listId1", createId("id1")]);
				dist_default(mail.subject).equals("goodbye");
				dist_default(load.callCount).equals(1);
				unmockAttribute(loadMock);
			});
			dist_default("when deleted from a range, then the remaining range will still be retrieved from the cache", async function() {
				const originalMails = await setupMailList(true, true);
				await cache.entityEventsReceived(makeBatch([createUpdate$2(MailTypeRef, "listId1", createId("id2"), OperationType.DELETE)]));
				const mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 4, false);
				dist_default(mails).deepEquals([originalMails[0], originalMails[2]]);
			});
			dist_default.spec("membership changes", function() {
				dist_default("no membership change does not delete an entity and lastUpdateBatchIdPerGroup", async function() {
					const userId$2 = "userId";
					const calendarGroupId = "calendarGroupId";
					const initialUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						}), createTestEntity(GroupMembershipTypeRef, {
							_id: "calendarShipId",
							group: calendarGroupId,
							groupType: GroupType.Calendar
						})]
					});
					entityRestClient.load = (0, import_testdouble$60.func)();
					(0, import_testdouble$60.when)(entityRestClient.load(UserTypeRef, userId$2)).thenResolve(initialUser);
					await storage.put(initialUser);
					const eventId = ["eventListId", "eventId"];
					const event = createTestEntity(CalendarEventTypeRef, {
						_id: eventId,
						_ownerGroup: calendarGroupId
					});
					await storage.put(event);
					await storage.putLastBatchIdForGroup(calendarGroupId, "1");
					storage.getUserId = () => userId$2;
					await cache.entityEventsReceived(makeBatch([createUpdate$2(UserTypeRef, "", userId$2, OperationType.UPDATE)]));
					dist_default(await storage.get(CalendarEventTypeRef, listIdPart(eventId), elementIdPart(eventId))).notEquals(null)("Event has been evicted from cache");
					dist_default(await storage.getLastBatchIdForGroup(calendarGroupId)).notEquals(null);
				});
				dist_default("membership change deletes an element entity and lastUpdateBatchIdPerGroup", async function() {
					const userId$2 = "userId";
					const calendarGroupId = "calendarGroupId";
					const initialUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						}), createTestEntity(GroupMembershipTypeRef, {
							_id: "calendarShipId",
							group: calendarGroupId,
							groupType: GroupType.Calendar
						})]
					});
					await storage.put(initialUser);
					const updatedUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						})]
					});
					entityRestClient.load = (0, import_testdouble$60.func)();
					(0, import_testdouble$60.when)(entityRestClient.load(UserTypeRef, userId$2)).thenResolve(updatedUser);
					const groupRootId = "groupRootId";
					const groupRoot = createTestEntity(GroupRootTypeRef, {
						_id: groupRootId,
						_ownerGroup: calendarGroupId
					});
					await storage.put(groupRoot);
					await storage.putLastBatchIdForGroup(calendarGroupId, "1");
					storage.getUserId = () => userId$2;
					await cache.entityEventsReceived(makeBatch([createUpdate$2(UserTypeRef, "", userId$2, OperationType.UPDATE)]));
					dist_default(await storage.get(CalendarEventTypeRef, null, groupRootId)).equals(null)("GroupRoot has been evicted from cache");
					dist_default(await storage.getLastBatchIdForGroup(calendarGroupId)).equals(null);
				});
				dist_default("membership change deletes a list entity and lastUpdateBatchIdPerGroup", async function() {
					const userId$2 = "userId";
					const calendarGroupId = "calendarGroupId";
					const initialUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						}), createTestEntity(GroupMembershipTypeRef, {
							_id: "calendarShipId",
							group: calendarGroupId,
							groupType: GroupType.Calendar
						})]
					});
					await storage.put(initialUser);
					const updatedUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						})]
					});
					entityRestClient.load = (0, import_testdouble$60.func)();
					(0, import_testdouble$60.when)(entityRestClient.load(UserTypeRef, userId$2)).thenResolve(updatedUser);
					const eventId = ["eventListId", "eventId"];
					const event = createTestEntity(CalendarEventTypeRef, {
						_id: eventId,
						_ownerGroup: calendarGroupId
					});
					await storage.put(event);
					await storage.putLastBatchIdForGroup?.(calendarGroupId, "1");
					storage.getUserId = () => userId$2;
					await cache.entityEventsReceived(makeBatch([createUpdate$2(UserTypeRef, "", userId$2, OperationType.UPDATE)]));
					dist_default(await storage.get(CalendarEventTypeRef, listIdPart(eventId), elementIdPart(eventId))).equals(null)("Event has been evicted from cache");
					const deletedRange = await storage.getRangeForList(CalendarEventTypeRef, listIdPart(eventId));
					dist_default(deletedRange).equals(null);
					if (storage.getLastBatchIdForGroup) dist_default(await storage.getLastBatchIdForGroup(calendarGroupId)).equals(null);
				});
				dist_default("membership change but for another user does nothing", async function() {
					const userId$2 = "userId";
					const calendarGroupId = "calendarGroupId";
					const initialUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						}), createTestEntity(GroupMembershipTypeRef, {
							_id: "calendarShipId",
							group: calendarGroupId,
							groupType: GroupType.Calendar
						})]
					});
					await storage.put(initialUser);
					const updatedUser = createTestEntity(UserTypeRef, {
						_id: userId$2,
						memberships: [createTestEntity(GroupMembershipTypeRef, {
							_id: "mailShipId",
							groupType: GroupType.Mail
						})]
					});
					entityRestClient.load = (0, import_testdouble$60.func)();
					(0, import_testdouble$60.when)(entityRestClient.load(UserTypeRef, userId$2)).thenResolve(updatedUser);
					const eventId = ["eventListId", "eventId"];
					const event = createTestEntity(CalendarEventTypeRef, {
						_id: eventId,
						_ownerGroup: calendarGroupId
					});
					await storage.put(event);
					storage.getUserId = () => "anotherUserId";
					await cache.entityEventsReceived(makeBatch([createUpdate$2(UserTypeRef, "", userId$2, OperationType.UPDATE)]));
					dist_default(await storage.get(CalendarEventTypeRef, listIdPart(eventId), elementIdPart(eventId))).notEquals(null)("Event has been evicted from cache");
				});
			});
		});
		dist_default("when reading from the cache, the entities will be cloned", async function() {
			const archiveId = "archiveId";
			const mailDetailsBlob = createMailDetailsBlobInstance(archiveId, "id1", "hello");
			await storage.put(mailDetailsBlob);
			const mailDetailsBlob1 = await cache.load(MailDetailsBlobTypeRef, [archiveId, createId("id1")]);
			dist_default(mailDetailsBlob1 == mailDetailsBlob).equals(false);
			const mailDetailsBlob2 = await cache.load(MailDetailsBlobTypeRef, [archiveId, createId("id1")]);
			dist_default(mailDetailsBlob1 == mailDetailsBlob2).equals(false);
		});
		dist_default("when reading from the cache, the entities will be cloned pt.2", async function() {
			let mail = createMailInstance("listId1", "id1", "hello");
			await storage.put(mail);
			const mail1 = await cache.load(MailTypeRef, ["listId1", createId("id1")]);
			dist_default(mail1 == mail).equals(false);
			const mail2 = await cache.load(MailTypeRef, ["listId1", createId("id1")]);
			dist_default(mail1 == mail2).equals(false);
		});
		async function setupMailList(loadedUntilMinId, loadedUntilMaxId) {
			let mail1 = createMailInstance("listId1", "id1", "hello1");
			let mail2 = createMailInstance("listId1", "id2", "hello2");
			let mail3 = createMailInstance("listId1", "id3", "hello3");
			let startId = loadedUntilMaxId ? GENERATED_MAX_ID : createId("id4");
			let count = loadedUntilMinId ? 4 : 3;
			const loadRange = spy(function(typeRef, listId, start, countParam, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(startId);
				dist_default(countParam).equals(count);
				dist_default(reverse).equals(true);
				return Promise.resolve([
					mail3,
					mail2,
					mail1
				]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const mails = await cache.loadRange(MailTypeRef, "listId1", startId, count, true);
			dist_default(mails).deepEquals(clone([
				mail3,
				mail2,
				mail1
			]));
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
			return clone([
				mail1,
				mail2,
				mail3
			]);
		}
		dist_default("when reading from the cache, the entities will be cloned (range requests)", async function() {
			const originalMails = await setupMailList(true, true);
			const mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 3, false);
			dist_default(mails).deepEquals(originalMails);
			dist_default(mails[0] == originalMails[0]).equals(false);
			dist_default(mails[1] == originalMails[1]).equals(false);
			dist_default(mails[2] == originalMails[2]).equals(false);
		});
		dist_default("list elements are provided from cache - range min to max loaded", async function() {
			const originalMails = await setupMailList(true, true);
			let mails;
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 3, false);
			dist_default(mails).deepEquals(originalMails);
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 1, false);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 4, false);
			dist_default(mails).deepEquals(originalMails);
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id1"), 2, false);
			dist_default(mails).deepEquals(originalMails.slice(1, 3));
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MAX_ID, 3, true);
			dist_default(mails).deepEquals([
				originalMails[2],
				originalMails[1],
				originalMails[0]
			]);
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 1, true);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 3, true);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
		});
		dist_default("list elements are provided from cache - range min to id3 loaded", async function() {
			const originalMails = await setupMailList(true, false);
			let mails;
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 3, false);
			dist_default(mails).deepEquals(originalMails);
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 1, false);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id1"), 2, false);
			dist_default(mails).deepEquals(originalMails.slice(1, 3));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 1, true);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 3, true);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id0"), 3, true);
			dist_default(mails).deepEquals([]);
		});
		dist_default("list elements are provided from cache - range max to id1 loaded", async function() {
			const originalMails = await setupMailList(false, true);
			let mails;
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MAX_ID, 3, true);
			dist_default(mails).deepEquals([
				originalMails[2],
				originalMails[1],
				originalMails[0]
			]);
			mails = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MAX_ID, 2, true);
			dist_default(mails).deepEquals([originalMails[2], originalMails[1]]);
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id5"), 1, false);
			dist_default(mails).deepEquals([]);
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 1, true);
			dist_default(mails).deepEquals(originalMails.slice(0, 1));
			mails = await cache.loadRange(MailTypeRef, "listId1", createId("id1"), 2, false);
			dist_default(mails).deepEquals(originalMails.slice(1, 3));
		});
		dist_default("load list elements partly from server - range min to id3 loaded", async function() {
			let mail4 = createMailInstance("listId1", "id4", "subject4");
			const cachedMails = await setupMailList(true, false);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(getElementId(cachedMails[2]));
				dist_default(count).equals(1);
				dist_default(reverse).equals(false);
				return Promise.resolve([mail4]);
			});
			const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MIN_ID, 4, false);
			dist_default(result).deepEquals([
				cachedMails[0],
				cachedMails[1],
				cachedMails[2],
				clone(mail4)
			]);
			dist_default(await storage.get(MailTypeRef, getListId(mail4), getElementId(mail4))).deepEquals(mail4);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(loadRangeMock);
		});
		dist_default("load list elements partly from server - range min to id3 loaded - range request id2 count 2", async function() {
			let mail4 = createMailInstance("listId1", "id4", "subject4");
			const cachedMails = await setupMailList(true, false);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(getElementId(cachedMails[2]));
				dist_default(count).equals(1);
				dist_default(reverse).equals(false);
				return Promise.resolve([mail4]);
			});
			const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 2, false);
			dist_default(result).deepEquals([cachedMails[2], clone(mail4)]);
			dist_default(await storage.get(MailTypeRef, getListId(mail4), getElementId(mail4))).deepEquals(mail4);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(loadRangeMock);
		});
		dist_default("when part of a range is already in cache, load range should only try to load what it doesn't have already", async function() {
			let mail0 = createMailInstance("listId1", "id0", "subject0");
			const cachedMails = await setupMailList(false, true);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(getElementId(cachedMails[0]));
				dist_default(count).equals(3);
				dist_default(reverse).equals(true);
				return Promise.resolve([mail0]);
			});
			const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", createId("id2"), 4, true);
			dist_default(await storage.get(MailTypeRef, getListId(mail0), getElementId(mail0))).deepEquals(mail0);
			dist_default(result).deepEquals([cachedMails[0], clone(mail0)]);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(loadRangeMock);
		});
		dist_default("load list elements partly from server - range max to id2 loaded - loadMore", async function() {
			let mail0 = createMailInstance("listId1", "id0", "subject0");
			const cachedMails = await setupMailList(false, true);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(cachedMails[0]._id[1]);
				dist_default(count).equals(4);
				dist_default(reverse).equals(true);
				return Promise.resolve([mail0]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", createId("id1"), 4, true);
			dist_default(await storage.get(MailTypeRef, getListId(mail0), getElementId(mail0))).deepEquals(mail0);
			dist_default(result).deepEquals([clone(mail0)]);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("load range starting outside of stored range - not reverse", async function() {
			const listId = "listId1";
			const mail5 = createMailInstance(listId, "id5", "subject5");
			const mail6 = createMailInstance(listId, "id6", "subject6");
			const cachedMails = await setupMailList(true, false);
			const loadRange = spy(function(typeRef, listId$1, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId$1).equals(listId$1);
				dist_default(start).equals(createId("id4"));
				dist_default(count).equals(EXTEND_RANGE_MIN_CHUNK_SIZE);
				dist_default(reverse).equals(false);
				return Promise.resolve([mail5, mail6]);
			});
			const loadRangeMock = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, listId, createId("id5"), 4, false);
			dist_default(loadRange.callCount).equals(1);
			dist_default(result).deepEquals([clone(mail6)]);
			const result2 = await cache.loadRange(MailTypeRef, listId, createId("id1"), 4, false);
			dist_default(loadRange.callCount).equals(1);
			dist_default(result2).deepEquals([
				cachedMails[1],
				cachedMails[2],
				clone(mail5),
				clone(mail6)
			]);
			unmockAttribute(loadRangeMock);
		});
		dist_default("load range starting outside of stored range - reverse", async function() {
			let mailFirst = createMailInstance("listId1", "ic5", "subject");
			let mailSecond = createMailInstance("listId1", "ic8", "subject");
			await setupMailList(false, false);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(createId("id1"));
				dist_default(count).equals(EXTEND_RANGE_MIN_CHUNK_SIZE);
				dist_default(reverse).equals(true);
				return Promise.resolve([mailSecond, mailFirst]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", createId("ic6"), 4, true);
			dist_default(result).deepEquals([clone(mailFirst)]);
			dist_default(await storage.get(MailTypeRef, getListId(mailFirst), getElementId(mailFirst))).deepEquals(mailFirst);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("reverse load range starting outside of stored range - no new elements", async function() {
			await setupMailList(false, false);
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(createId("id1"));
				dist_default(count).equals(EXTEND_RANGE_MIN_CHUNK_SIZE);
				dist_default(reverse).equals(true);
				return Promise.resolve([]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", createId("ic6"), 4, true);
			dist_default(result).deepEquals([]);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("no elements in range", async function() {
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, MailTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(GENERATED_MAX_ID);
				dist_default(count).equals(100);
				dist_default(reverse).equals(true);
				return Promise.resolve([]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MAX_ID, 100, true);
			dist_default(result).deepEquals([]);
			const result2 = await cache.loadRange(MailTypeRef, "listId1", GENERATED_MAX_ID, 100, true);
			dist_default(result2).deepEquals([]);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("custom id range is not stored", async function() {
			let ref = clone(createTestEntity(ExternalUserReferenceTypeRef));
			ref._id = ["listId1", stringToCustomId("custom")];
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, ExternalUserReferenceTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(CUSTOM_MIN_ID);
				dist_default(count).equals(1);
				dist_default(reverse).equals(false);
				return Promise.resolve([ref]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result1 = await cache.loadRange(ExternalUserReferenceTypeRef, "listId1", CUSTOM_MIN_ID, 1, false);
			dist_default(result1).deepEquals([ref]);
			const result2 = await cache.loadRange(ExternalUserReferenceTypeRef, "listId1", CUSTOM_MIN_ID, 1, false);
			dist_default(result2).deepEquals([ref]);
			dist_default(loadRange.callCount).equals(2);
			unmockAttribute(mock$1);
		});
		dist_default("when custom id type is cacheable, the range is cached", async function() {
			let ref = clone(createTestEntity(GroupKeyTypeRef));
			ref._id = ["listId1", stringToCustomId("1")];
			const loadRange = spy(function(typeRef, listId, start, count, reverse) {
				dist_default(isSameTypeRef(typeRef, GroupKeyTypeRef)).equals(true);
				dist_default(listId).equals("listId1");
				dist_default(start).equals(CUSTOM_MIN_ID);
				dist_default(count).equals(1);
				dist_default(reverse).equals(false);
				return Promise.resolve([ref]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result1 = await cache.loadRange(GroupKeyTypeRef, "listId1", CUSTOM_MIN_ID, 1, false);
			dist_default(loadRange.callCount).equals(1);
			dist_default(result1).deepEquals([ref]);
			const result2 = await cache.loadRange(GroupKeyTypeRef, "listId1", CUSTOM_MIN_ID, 1, false);
			dist_default(result2).deepEquals([ref]);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("Load towards the range with start being before the existing range. Range will be extended. Reverse. ", async function() {
			const ids = [
				createId("1"),
				createId("2"),
				createId("3"),
				createId("4"),
				createId("5")
			];
			const listId1 = "listId1";
			const mail1 = createMailInstance(listId1, ids[0], "hello1");
			const mail2 = createMailInstance(listId1, ids[1], "hello2");
			const mail3 = createMailInstance(listId1, ids[2], "hello3");
			await storage.setNewRangeForList(MailTypeRef, listId1, ids[0], ids[2]);
			for (const mail of [
				mail1,
				mail2,
				mail3
			]) await storage.put(mail);
			const moreMails = new Map();
			moreMails.set(ids[3], createMailInstance(listId1, ids[3], "hello4"));
			moreMails.set(ids[4], createMailInstance(listId1, ids[4], "hello5"));
			const loadRange = spy(function(...an) {
				return Promise.resolve([moreMails.get(ids[3]), moreMails.get(ids[4])]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const originalUpper = (await storage.getRangeForList(MailTypeRef, listId1))?.upper;
			const result1 = await cache.loadRange(MailTypeRef, listId1, GENERATED_MAX_ID, 5, true);
			dist_default(loadRange.callCount).equals(1)("entities are provided from server");
			dist_default(loadRange.args[2]).equals(originalUpper)("starts extending range beginning with upperId");
			dist_default(await storage.isElementIdInCacheRange(MailTypeRef, listId1, GENERATED_MAX_ID)).equals(true)("MAX ID is in cache range");
			const expectedResult = [
				moreMails.get(ids[4]),
				moreMails.get(ids[3]),
				mail3,
				mail2,
				mail1
			];
			dist_default(result1).deepEquals(expectedResult)("Returns all elements in reverse order");
			const result2 = await cache.loadRange(MailTypeRef, listId1, GENERATED_MAX_ID, 5, true);
			dist_default(result2).deepEquals(expectedResult);
			dist_default(loadRange.callCount).equals(1);
			unmockAttribute(mock$1);
		});
		dist_default("Load towards the range with start being before the existing range. Range will be extended. Not Reverse.", async function() {
			const ids = [
				createId("1"),
				createId("2"),
				createId("3"),
				createId("4"),
				createId("5")
			];
			const listId1 = "listId1";
			const mail1 = createMailInstance(listId1, ids[0], "hello1");
			const mail2 = createMailInstance(listId1, ids[1], "hello2");
			const mail3 = createMailInstance(listId1, ids[2], "hello3");
			const mail4 = createMailInstance(listId1, ids[3], "hello4");
			const mail5 = createMailInstance(listId1, ids[4], "hello5");
			await storage.setNewRangeForList(MailTypeRef, listId1, ids[2], ids[4]);
			for (const mail of [
				mail3,
				mail4,
				mail5
			]) await storage.put(mail);
			const loadRange = spy(function(...any) {
				return Promise.resolve([mail2, mail1]);
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const originalLower = (await storage.getRangeForList(MailTypeRef, listId1))?.lower;
			const result1 = await cache.loadRange(MailTypeRef, listId1, GENERATED_MIN_ID, 5, false);
			dist_default(loadRange.callCount).equals(1)("entities are provided from server");
			dist_default(loadRange.args[2]).equals(originalLower)("starts extending range beginning with lowerId");
			dist_default(await storage.isElementIdInCacheRange(MailTypeRef, listId1, GENERATED_MIN_ID)).equals(true)("MIN ID is in cache range");
			const expectedResult = [
				mail1,
				mail2,
				mail3,
				mail4,
				mail5
			];
			dist_default(result1).deepEquals(expectedResult)("Returns all elements in reverse order");
			const result2 = await cache.loadRange(MailTypeRef, listId1, GENERATED_MIN_ID, 5, false);
			dist_default(result2).deepEquals(expectedResult);
			dist_default(loadRange.callCount).equals(1)("server is called only once at the end");
			unmockAttribute(mock$1);
		});
		dist_default("When there is a non-reverse range request that loads away from the existing range, the range will grow to include startId + the rest from the server", async function() {
			const clientMock = (0, import_testdouble$60.object)();
			const cache$1 = new DefaultEntityRestCache(clientMock, storage);
			const listId = "listId";
			const id1 = createId("1");
			const id2 = createId("2");
			const id3 = createId("3");
			const id4 = createId("4");
			const id5 = createId("5");
			const id6 = createId("6");
			const mail1 = createMailInstance(listId, id1, "hello1");
			const mail2 = createMailInstance(listId, id2, "hello2");
			const mail3 = createMailInstance(listId, id3, "hello3");
			const mail4 = createMailInstance(listId, id4, "hello4");
			const mail5 = createMailInstance(listId, id5, "hello5");
			const mail6 = createMailInstance(listId, id6, "hello6");
			await storage.setNewRangeForList(MailTypeRef, listId, id1, id2);
			await storage.put(mail1);
			await storage.put(mail2);
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, id2, EXTEND_RANGE_MIN_CHUNK_SIZE, false, {})).thenResolve([
				mail3,
				mail4,
				mail5,
				mail6
			]);
			const result = await cache$1.loadRange(MailTypeRef, listId, id3, 2, false);
			dist_default(result).deepEquals([mail4, mail5]);
			dist_default(await storage.getRangeForList(MailTypeRef, listId)).deepEquals({
				lower: id1,
				upper: GENERATED_MAX_ID
			});
			dist_default(await storage.getIdsInRange(MailTypeRef, listId)).deepEquals([
				id1,
				id2,
				id3,
				id4,
				id5,
				id6
			]);
		});
		dist_default("When there is a non-reverse range request that loads in the direction of the existing range, the range will grow to include the startId", async function() {
			const clientMock = (0, import_testdouble$60.object)();
			const cache$1 = new DefaultEntityRestCache(clientMock, storage);
			const listId = "listId1";
			const mails = arrayOf(100, (idx) => createMailInstance(listId, createId(`${idx}`), `hola ${idx}`));
			await storage.setNewRangeForList(MailTypeRef, listId, getElementId(mails[98]), getElementId(mails[99]));
			await storage.put(mails[98]);
			await storage.put(mails[99]);
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[98]), EXTEND_RANGE_MIN_CHUNK_SIZE, true, {})).thenResolve(mails.slice(58, 98).reverse());
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[58]), EXTEND_RANGE_MIN_CHUNK_SIZE, true, {})).thenResolve(mails.slice(18, 58).reverse());
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[18]), EXTEND_RANGE_MIN_CHUNK_SIZE, true, {})).thenResolve(mails.slice(0, 18).reverse());
			const result = await cache$1.loadRange(MailTypeRef, listId, GENERATED_MIN_ID, 2, false);
			dist_default(result).deepEquals([mails[0], mails[1]]);
			dist_default(await storage.getRangeForList(MailTypeRef, listId)).deepEquals({
				lower: GENERATED_MIN_ID,
				upper: getElementId(mails[99])
			});
			dist_default(await storage.getIdsInRange(MailTypeRef, listId)).deepEquals(mails.map(getElementId));
		});
		dist_default("When there is a reverse range request that loads in the direction of the existing range, the range will grow to include the startId", async function() {
			const clientMock = (0, import_testdouble$60.object)();
			const cache$1 = new DefaultEntityRestCache(clientMock, storage);
			const listId = "listId1";
			const mails = arrayOf(100, (idx) => createMailInstance(listId, createId(`${idx}`), `hola ${idx}`));
			await storage.setNewRangeForList(MailTypeRef, listId, getElementId(mails[0]), getElementId(mails[1]));
			await storage.put(mails[0]);
			await storage.put(mails[1]);
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[1]), EXTEND_RANGE_MIN_CHUNK_SIZE, false, {})).thenResolve(mails.slice(2, 42));
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[41]), EXTEND_RANGE_MIN_CHUNK_SIZE, false, {})).thenResolve(mails.slice(42, 82));
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, getElementId(mails[81]), EXTEND_RANGE_MIN_CHUNK_SIZE, false, {})).thenResolve(mails.slice(82));
			const result = await cache$1.loadRange(MailTypeRef, listId, GENERATED_MAX_ID, 2, true);
			dist_default(result).deepEquals([mails[mails.length - 1], mails[mails.length - 2]]);
			dist_default(await storage.getRangeForList(MailTypeRef, listId)).deepEquals({
				lower: getElementId(mails[0]),
				upper: GENERATED_MAX_ID
			});
			dist_default(await storage.getIdsInRange(MailTypeRef, listId)).deepEquals(mails.map(getElementId));
		});
		dist_default("The range request starts on one end of the existing range, and would finish on the other end, so it loads from either direction of the range", async function() {
			const clientMock = (0, import_testdouble$60.object)();
			const cache$1 = new DefaultEntityRestCache(clientMock, storage);
			const id1 = createId("1");
			const id2 = createId("2");
			const id3 = createId("3");
			const id4 = createId("4");
			const id5 = createId("5");
			const id6 = createId("6");
			const listId = "listId";
			const mail1 = createMailInstance(listId, id1, "ok");
			const mail2 = createMailInstance(listId, id2, "ok");
			const mail3 = createMailInstance(listId, id3, "ok");
			const mail4 = createMailInstance(listId, id4, "ok");
			const mail5 = createMailInstance(listId, id5, "ok");
			await storage.setNewRangeForList(MailTypeRef, listId, id2, id3);
			await storage.put(mail2);
			await storage.put(mail3);
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, id2, EXTEND_RANGE_MIN_CHUNK_SIZE, true, {})).thenResolve([mail1]);
			(0, import_testdouble$60.when)(clientMock.loadRange(anything$9(), listId, id3, 7, false, {})).thenResolve([mail4, mail5]);
			const result = await cache$1.loadRange(MailTypeRef, listId, GENERATED_MIN_ID, 10, false);
			dist_default(await storage.getRangeForList(MailTypeRef, listId)).deepEquals({
				lower: GENERATED_MIN_ID,
				upper: GENERATED_MAX_ID
			});
			dist_default(await storage.getIdsInRange(MailTypeRef, listId)).deepEquals([
				id1,
				id2,
				id3,
				id4,
				id5
			]);
			dist_default(result).deepEquals([
				mail1,
				mail2,
				mail3,
				mail4,
				mail5
			]);
		});
		dist_default("loadMultiple should load necessary elements from the server, and get the rest from the cache", async function() {
			const listId = "listId";
			const inCache = [createMailInstance(listId, "1", "1"), createMailInstance(listId, "3", "3")];
			const notInCache = [createMailInstance(listId, "2", "2"), createMailInstance(listId, "5", "5")];
			await Promise.all(inCache.map(async (i) => await storage.put(i)));
			const ids = inCache.concat(notInCache).map(getElementId);
			const loadMultiple = spy((...any) => Promise.resolve(notInCache));
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadMultiple, loadMultiple);
			const result = await cache.loadMultiple(MailTypeRef, listId, ids);
			dist_default(result).deepEquals(notInCache.concat(inCache))("all mails are in cache");
			dist_default(loadMultiple.callCount).equals(1)("load multiple is called once");
			dist_default(loadMultiple.args).deepEquals([
				MailTypeRef,
				listId,
				notInCache.map(getElementId),
				undefined,
				{}
			])("load multiple is called for mails not in cache");
			for (const item of inCache.concat(notInCache)) dist_default(await storage.get(MailTypeRef, listId, getElementId(item))).notEquals(null)("element is in cache " + getElementId(item));
			unmockAttribute(mock$1);
		});
		dist_default("loadRange from server and provide cached entities from the cache", async function() {
			const listId = "listId";
			const inCache = [
				createMailInstance(listId, "0", "0"),
				createMailInstance(listId, "1", "1"),
				createMailInstance(listId, "3", "3")
			];
			const serverMails = [
				...inCache,
				createMailInstance(listId, "4", "4"),
				createMailInstance(listId, "5", "5"),
				createMailInstance(listId, "6", "6")
			];
			await storage.setNewRangeForList(MailTypeRef, listId, GENERATED_MIN_ID, createId("3"));
			await Promise.all(inCache.map(async (i) => await storage.put(i)));
			const loadRange = spy(async (typeRef, listIdToLoad, startId, count, reverse) => {
				if (listId !== listIdToLoad) throw new NotFoundError("unknown list id");
				return serverMails.filter((mail) => firstBiggerThanSecond(getElementId(mail), startId)).slice(0, count);
			});
			const mockLoadRange = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(MailTypeRef, listId, createId("1"), 3, false);
			dist_default(loadRange.invocations[0][3]).equals(2);
			dist_default(loadRange.invocations[0][2]).equals(createId("3"));
			for (let i = 0; i++; i < result.length) dist_default(result[i]).deepEquals(serverMails[i])(`result ${i} does not match`);
			for (const item of serverMails.slice(0, -1)) {
				const mail = await storage.get(MailTypeRef, listId, getElementId(item));
				dist_default(mail).notEquals(null);
			}
			const lastId = getElementId(last(serverMails));
			dist_default(await storage.get(MailTypeRef, listId, lastId)).equals(null);
			unmockAttribute(mockLoadRange);
		});
		dist_default("load passes same parameters to entityRestClient", async function() {
			const contactId = [createId("0"), createId("1")];
			const contact = createTestEntity(ContactTypeRef, {
				_id: contactId,
				firstName: "greg"
			});
			const client$1 = downcast({ load: spy(() => contact) });
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			await cache$1.load(ContactTypeRef, contactId, {
				queryParams: { myParam: "param" },
				extraHeaders: { myHeader: "header" }
			});
			const [typeRef, id, opts] = client$1.load.args;
			dist_default(isSameTypeRef(typeRef, ContactTypeRef)).equals(true);
			dist_default(id).deepEquals(contactId);
			dist_default(opts).deepEquals({
				queryParams: { myParam: "param" },
				extraHeaders: { myHeader: "header" }
			});
		});
		dist_default("single entity is cached after being loaded", async function() {
			const contactId = [createId("0"), createId("1")];
			const contactOnTheServer = createTestEntity(ContactTypeRef, {
				_id: contactId,
				firstName: "greg"
			});
			const client$1 = downcast({ load: spy(async () => {
				return contactOnTheServer;
			}) });
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			const firstLoaded = await cache$1.load(ContactTypeRef, contactId);
			dist_default(firstLoaded).deepEquals(contactOnTheServer);
			dist_default(client$1.load.callCount).equals(1)("The entity rest client was called because the contact isn't in cache");
			const secondLoaded = await cache$1.load(ContactTypeRef, contactId);
			dist_default(secondLoaded).deepEquals(contactOnTheServer);
			dist_default(client$1.load.callCount).equals(1)("The rest client was not called again, because the contact was loaded from the cache");
		});
		dist_default("A new range request for a nonexistent range should initialize that range", async function() {
			const loadRange = spy(function(typeRef, listId, ...an) {
				return [
					createTestEntity(ContactTypeRef, { _id: [listId, createId("1")] }),
					createTestEntity(ContactTypeRef, { _id: [listId, createId("2")] }),
					createTestEntity(ContactTypeRef, { _id: [listId, createId("3")] }),
					createTestEntity(ContactTypeRef, { _id: [listId, createId("4")] }),
					createTestEntity(ContactTypeRef, { _id: [listId, createId("5")] }),
					createTestEntity(ContactTypeRef, { _id: [listId, createId("6")] })
				];
			});
			const mock$1 = mockAttribute(entityRestClient, entityRestClient.loadRange, loadRange);
			const result = await cache.loadRange(ContactTypeRef, createId("0"), GENERATED_MIN_ID, 1e3, false);
			dist_default(result.length).equals(6);
			unmockAttribute(mock$1);
		});
		dist_default("single entity is not cached if it is an ignored entity", async function() {
			const permissionId = [createId("0"), createId("1")];
			const permissionOnTheServer = createTestEntity(PermissionTypeRef, { _id: permissionId });
			const client$1 = downcast({ load: spy(async () => {
				return permissionOnTheServer;
			}) });
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			await cache$1.load(PermissionTypeRef, permissionId);
			await cache$1.load(PermissionTypeRef, permissionId);
			dist_default(client$1.load.callCount).equals(2)("The permission was loaded both times from the server");
		});
		dist_default.test("when loading single ET custom id entity it is cached", async function() {
			const id = stringToCustomId("1");
			const client$1 = (0, import_testdouble$60.object)();
			const entity = createTestEntity(MailAddressToGroupTypeRef, { _id: id });
			(0, import_testdouble$60.when)(client$1.load(MailAddressToGroupTypeRef, id, anything$9())).thenResolve(entity);
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			const loadedEntity = await cache$1.load(MailAddressToGroupTypeRef, id);
			await cache$1.load(MailAddressToGroupTypeRef, id);
			dist_default(loadedEntity).deepEquals(entity);
			verify(client$1.load(MailAddressToGroupTypeRef, id), {
				ignoreExtraArgs: true,
				times: 1
			});
		});
		dist_default.test("when loading single LET custom id entity it is cached", async function() {
			const id = [createId("0"), stringToCustomId("1")];
			const client$1 = (0, import_testdouble$60.object)();
			const entity = createTestEntity(RootInstanceTypeRef, { _id: id });
			(0, import_testdouble$60.when)(client$1.load(RootInstanceTypeRef, id, anything$9())).thenResolve(entity);
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			const loadedEntity = await cache$1.load(RootInstanceTypeRef, id);
			await cache$1.load(RootInstanceTypeRef, id);
			dist_default(loadedEntity).deepEquals(entity);
			verify(client$1.load(RootInstanceTypeRef, id), {
				ignoreExtraArgs: true,
				times: 1
			});
		});
		dist_default.test("when loading multiple ET custom id entities are cached", async function() {
			const ids = [stringToCustomId("1"), stringToCustomId("2")];
			const client$1 = (0, import_testdouble$60.object)();
			const firstEntity = createTestEntity(MailAddressToGroupTypeRef, { _id: ids[0] });
			const secondEntity = createTestEntity(MailAddressToGroupTypeRef, { _id: ids[1] });
			(0, import_testdouble$60.when)(client$1.loadMultiple(MailAddressToGroupTypeRef, null, ids), { ignoreExtraArgs: true }).thenResolve([firstEntity, secondEntity]);
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			const loadedEntity = await cache$1.loadMultiple(MailAddressToGroupTypeRef, null, ids);
			await cache$1.loadMultiple(MailAddressToGroupTypeRef, null, ids);
			dist_default(loadedEntity).deepEquals([firstEntity, secondEntity]);
			verify(client$1.loadMultiple(MailAddressToGroupTypeRef, null, ids), {
				ignoreExtraArgs: true,
				times: 1
			});
		});
		dist_default.test("when loading multiple LET custom id entities are cached", async function() {
			const listId = createId("0");
			const ids = [[listId, stringToCustomId("1")], [listId, stringToCustomId("2")]];
			const client$1 = (0, import_testdouble$60.object)();
			const firstEntity = createTestEntity(RootInstanceTypeRef, { _id: ids[0] });
			const secondEntity = createTestEntity(RootInstanceTypeRef, { _id: ids[1] });
			(0, import_testdouble$60.when)(client$1.loadMultiple(RootInstanceTypeRef, listId, [elementIdPart(ids[0]), elementIdPart(ids[1])], anything$9()), { ignoreExtraArgs: true }).thenResolve([firstEntity, secondEntity]);
			const cache$1 = new DefaultEntityRestCache(client$1, storage);
			const loadedEntity = await cache$1.loadMultiple(RootInstanceTypeRef, listId, [elementIdPart(ids[0]), elementIdPart(ids[1])]);
			await cache$1.loadMultiple(RootInstanceTypeRef, listId, [elementIdPart(ids[0]), elementIdPart(ids[1])]);
			dist_default(loadedEntity).deepEquals([firstEntity, secondEntity]);
			verify(client$1.loadMultiple(RootInstanceTypeRef, listId, [elementIdPart(ids[0]), elementIdPart(ids[1])]), {
				ignoreExtraArgs: true,
				times: 1
			});
		});
		dist_default.spec("no user id", function() {
			dist_default("get", async function() {
				userId$1 = null;
				entityRestClient.load = spy(async () => createTestEntity(ContactTypeRef, { _id: ["listId", "id"] }));
				await cache.load(ContactTypeRef, ["listId", "id"]);
				dist_default(entityRestClient.load.callCount).equals(1);
			});
			dist_default("put", async function() {
				userId$1 = null;
				entityRestClient.setup = spy(async () => "id");
				await cache.setup("listId", createTestEntity(ContactTypeRef, { _id: ["listId", "id"] }));
				dist_default(entityRestClient.setup.callCount).equals(1);
			});
		});
		dist_default.spec("CacheMode.Bypass", () => {
			const listId = createId("0");
			dist_default("load", async function() {
				const contactId = [listId, createId("1")];
				const contactOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactId,
					firstName: "greg"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.load(ContactTypeRef, contactId, anything$9())).thenResolve(contactOnTheServer);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheBypassed1 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed1).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 1 });
				const cacheBypassed2 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed2).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 2 });
				const cached = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(cached).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 2 });
				const cacheBypassed3 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed3).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 3 });
			});
			dist_default("loadMultiple", async function() {
				const contactAId = [listId, createId("1")];
				const contactAOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactAId,
					firstName: "greg"
				});
				const contactBId = [listId, createId("2")];
				const contactBOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactBId,
					firstName: "bob"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], anything$9(), anything$9())).thenResolve([contactAOnTheServer]);
				(0, import_testdouble$60.when)(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactBId)], anything$9(), anything$9())).thenResolve([contactBOnTheServer]);
				(0, import_testdouble$60.when)(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId), elementIdPart(contactBId)], anything$9(), anything$9())).thenResolve([contactAOnTheServer, contactBOnTheServer]);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheBypassed1 = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed1).deepEquals([contactAOnTheServer]);
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 1 });
				const cacheBypassed2 = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed2).deepEquals([contactAOnTheServer]);
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 2 });
				const cached = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId), elementIdPart(contactBId)], undefined, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(true).equals(cached.some((a) => deepEqual(a, contactAOnTheServer)));
				dist_default(true).equals(cached.some((b) => deepEqual(b, contactBOnTheServer)));
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 2 });
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactBId)], undefined, anything$9()), { times: 1 });
				const cacheBypassed3 = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId), elementIdPart(contactBId)], undefined, { cacheMode: CacheMode.WriteOnly });
				dist_default(cacheBypassed3).deepEquals([contactAOnTheServer, contactBOnTheServer]);
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId), elementIdPart(contactBId)], undefined, anything$9()), { times: 1 });
			});
		});
		dist_default.spec("CacheMode.ReadOnly", () => {
			const listId = createId("0");
			dist_default("load", async function() {
				const contactId = [listId, createId("1")];
				const contactOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactId,
					firstName: "greg"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.load(ContactTypeRef, contactId, anything$9())).thenResolve(contactOnTheServer);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheReadonly1 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly1).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 1 });
				const cacheReadonly2 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly2).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 2 });
				const cached = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(cached).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 3 });
				const cacheReadonly3 = await cache$1.load(ContactTypeRef, contactId, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly3).deepEquals(contactOnTheServer);
				verify(client$1.load(ContactTypeRef, contactId, anything$9()), { times: 3 });
			});
			dist_default("loadMultiple", async function() {
				const contactAId = [listId, createId("1")];
				const contactAOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactAId,
					firstName: "greg"
				});
				const contactBId = [listId, createId("2")];
				const contactBOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactBId,
					firstName: "bob"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], anything$9(), anything$9())).thenResolve([contactAOnTheServer]);
				(0, import_testdouble$60.when)(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactBId)], anything$9(), anything$9())).thenResolve([contactBOnTheServer]);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheReadOnly1 = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadOnly1).deepEquals([contactAOnTheServer]);
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 1 });
				const cached = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(cached).deepEquals([contactAOnTheServer]);
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 2 });
				const cacheReadOnly2 = await cache$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId), elementIdPart(contactBId)], undefined, { cacheMode: CacheMode.ReadOnly });
				dist_default(true).equals(cacheReadOnly2.some((a) => deepEqual(a, contactAOnTheServer)));
				dist_default(true).equals(cacheReadOnly2.some((b) => deepEqual(b, contactBOnTheServer)));
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactAId)], undefined, anything$9()), { times: 2 });
				verify(client$1.loadMultiple(ContactTypeRef, listId, [elementIdPart(contactBId)], undefined, anything$9()), { times: 1 });
			});
			dist_default("loadRange - full list", async function() {
				const contactAId = [listId, createId("1")];
				const contactAOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactAId,
					firstName: "greg"
				});
				const contactBId = [listId, createId("2")];
				const contactBOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactBId,
					firstName: "bob"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, anything$9())).thenResolve([contactAOnTheServer, contactBOnTheServer]);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheReadonly1 = await cache$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly1).deepEquals([contactAOnTheServer, contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, anything$9()), { times: 1 });
				const cached = await cache$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(cached).deepEquals([contactAOnTheServer, contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, anything$9()), { times: 2 });
				const cacheReadonly2 = await cache$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly2).deepEquals([contactAOnTheServer, contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, anything$9()), { times: 2 });
			});
			dist_default("loadRange - partial list", async function() {
				const contactAId = [listId, createId("1")];
				const contactAOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactAId,
					firstName: "greg"
				});
				const contactBId = [listId, createId("2")];
				const contactBOnTheServer = createTestEntity(ContactTypeRef, {
					_id: contactBId,
					firstName: "bob"
				});
				const client$1 = (0, import_testdouble$60.object)();
				(0, import_testdouble$60.when)(client$1.loadRange(ContactTypeRef, listId, createId("0"), anything$9(), false, anything$9())).thenResolve([contactAOnTheServer, contactBOnTheServer]);
				(0, import_testdouble$60.when)(client$1.loadRange(ContactTypeRef, listId, createId("1"), anything$9(), false, anything$9())).thenResolve([contactBOnTheServer]);
				const cache$1 = new DefaultEntityRestCache(client$1, storage);
				const cacheReadonly1 = await cache$1.loadRange(ContactTypeRef, listId, createId("1"), 2, false, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly1).deepEquals([contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("1"), 2, false, anything$9()), { times: 1 });
				const cached = await cache$1.loadRange(ContactTypeRef, listId, createId("1"), 2, false, { cacheMode: CacheMode.ReadAndWrite });
				dist_default(cached).deepEquals([contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("1"), 2, false, anything$9()), { times: 2 });
				const cacheReadonly2 = await cache$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, { cacheMode: CacheMode.ReadOnly });
				dist_default(cacheReadonly2).deepEquals([contactAOnTheServer, contactBOnTheServer]);
				verify(client$1.loadRange(ContactTypeRef, listId, createId("1"), 2, false, anything$9()), { times: 2 });
				verify(client$1.loadRange(ContactTypeRef, listId, createId("0"), 2, false, anything$9()), { times: 1 });
			});
		});
	});
	function makeBatch(updates) {
		return {
			events: updates,
			groupId,
			batchId: "batchId"
		};
	}
}

//#endregion
//#region tests/api/worker/rest/EphemeralCacheStorageTest.ts
dist_default.spec("EphemeralCacheStorageTest", function() {
	const userId$1 = "userId";
	const archiveId = "archiveId";
	const blobElementId = "blobElementId1";
	const storage = new EphemeralCacheStorage();
	dist_default.spec("BlobElementType", function() {
		dist_default("cache roundtrip: put, get, delete", async function() {
			storage.init({ userId: userId$1 });
			const storableMailDetailsBlob = createTestEntity(MailDetailsBlobTypeRef, {
				_id: [archiveId, blobElementId],
				details: createTestEntity(MailDetailsTypeRef)
			});
			let mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
			dist_default(mailDetailsBlob).equals(null);
			await storage.put(storableMailDetailsBlob);
			mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
			dist_default(mailDetailsBlob).deepEquals(storableMailDetailsBlob);
			await storage.deleteIfExists(MailDetailsBlobTypeRef, archiveId, blobElementId);
			mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
			dist_default(mailDetailsBlob).equals(null);
		});
		dist_default("cache roundtrip: put, get, deleteAllOwnedBy", async function() {
			const _ownerGroup = "owenerGroup";
			storage.init({ userId: userId$1 });
			const storableMailDetailsBlob = createTestEntity(MailDetailsBlobTypeRef, {
				_id: [archiveId, blobElementId],
				_ownerGroup,
				details: createTestEntity(MailDetailsTypeRef)
			});
			await storage.put(storableMailDetailsBlob);
			await storage.deleteAllOwnedBy(_ownerGroup);
			const mailDetailsBlob = await storage.get(MailDetailsBlobTypeRef, archiveId, blobElementId);
			dist_default(mailDetailsBlob).equals(null);
		});
	});
});

//#endregion
//#region tests/api/worker/rest/EntityRestClientMock.ts
const authDataProvider = {
	createAuthHeaders() {
		return {};
	},
	isFullyLoggedIn() {
		return true;
	}
};
var EntityRestClientMock = class extends EntityRestClient {
	_entities = {};
	_listEntities = {};
	_blobEntities = {};
	_lastIdTimestamp;
	constructor() {
		super(authDataProvider, downcast({}), () => downcast({}), new InstanceMapper(), downcast({}));
		this._lastIdTimestamp = Date.now();
	}
	getNextId() {
		this._lastIdTimestamp++;
		return timestampToGeneratedId(this._lastIdTimestamp, 1);
	}
	addElementInstances(...instances) {
		for (const instance$14 of instances) this._entities[instance$14._id] = instance$14;
	}
	addListInstances(...instances) {
		for (const instance$14 of instances) {
			if (!this._listEntities[getListId(instance$14)]) this._listEntities[getListId(instance$14)] = {};
			this._listEntities[getListId(instance$14)][getElementId(instance$14)] = instance$14;
		}
	}
	addBlobInstances(...instances) {
		for (const instance$14 of instances) {
			if (!this._blobEntities[getListId(instance$14)]) this._blobEntities[getListId(instance$14)] = {};
			this._blobEntities[getListId(instance$14)][getElementId(instance$14)] = instance$14;
		}
	}
	setElementException(id, error) {
		this._entities[id] = error;
	}
	setListElementException(id, error) {
		if (!this._listEntities[listIdPart(id)]) this._listEntities[listIdPart(id)] = {};
		this._listEntities[listIdPart(id)][elementIdPart(id)] = error;
	}
	_getListEntry(listId, elementId) {
		if (!this._listEntities[listId]) throw new NotFoundError(`Not list ${listId}`);
		try {
			return this._handleMockElement(this._listEntities[listId][elementId], [listId, elementId]);
		} catch (e) {
			if (e instanceof NotFoundError) return null;
else throw e;
		}
	}
	_getBlobEntry(listId, elementId) {
		if (!this._blobEntities[listId]) throw new NotFoundError(`Not list ${listId}`);
		try {
			return this._handleMockElement(this._blobEntities[listId][elementId], [listId, elementId]);
		} catch (e) {
			if (e instanceof NotFoundError) return null;
else throw e;
		}
	}
	async load(_typeRef, id, _opts = {}) {
		if (id instanceof Array && id.length === 2) {
			const listId = id[0];
			const elementId = id[1];
			const listElement = this._getListEntry(listId, elementId);
			if (listElement == null) throw new NotFoundError(`List element ${listId} ${elementId} not found`);
			return downcast(listElement);
		} else if (typeof id === "string") return this._handleMockElement(this._entities[id], id);
else throw new Error("Illegal Id for ET: " + id);
	}
	async loadRange(typeRef, listId, start, count, reverse) {
		let entriesForListId = this._listEntities[listId];
		if (!entriesForListId) return [];
		let filteredIds;
		if (reverse) filteredIds = Object.keys(entriesForListId).sort(compareNewestFirst).filter((id) => firstBiggerThanSecond(start, id));
else filteredIds = Object.keys(entriesForListId).sort(compareOldestFirst).filter((id) => firstBiggerThanSecond(id, start));
		return filteredIds.map((id) => this._handleMockElement(entriesForListId[id], id));
	}
	async loadMultiple(typeRef, listId, elementIds) {
		const lid = listId;
		if (lid) {
			const typeModule = await resolveTypeReference(typeRef);
			if (typeModule.type === Type.ListElement.valueOf()) return elementIds.map((id) => {
				return downcast(this._getListEntry(lid, id));
			}).filter(Boolean);
else return elementIds.map((id) => {
				return downcast(this._getBlobEntry(lid, id));
			}).filter(Boolean);
		} else return elementIds.map((id) => {
			try {
				return this._handleMockElement(this._entities[id], id);
			} catch (e) {
				if (e instanceof NotFoundError) return null;
else throw e;
			}
		}).filter(Boolean);
	}
	async erase(instance$14) {
		const typeModel = await resolveTypeReference(instance$14._type);
		_verifyType(typeModel);
		const ids = getIds(instance$14, typeModel);
		this._handleDelete(ids.id, ids.listId);
		return Promise.resolve();
	}
	setup(listId, instance$14, extraHeaders) {
		return Promise.reject("Illegal method: setup");
	}
	setupMultiple(listId, instances) {
		return Promise.reject("Illegal method: setupMultiple");
	}
	update(instance$14) {
		return Promise.reject("Illegal method: update");
	}
	_handleDelete(id, listId) {
		if (id && listId) if (this._getListEntry(listId, id)) delete this._listEntities[listId][id];
else throw new NotFoundError(`List element ${listId} ${id} not found`);
else if (id) if (this._entities[id]) delete this._listEntities[id];
else throw new NotFoundError(`Element ${id} not found`);
else throw new Error("Illegal arguments for DELETE");
	}
	_handleMockElement(element, id) {
		if (element instanceof Error) throw element;
else if (element != null) return element;
else throw new NotFoundError(`element with id ${id.toString()} does not exists`);
	}
};

//#endregion
//#region tests/api/worker/EventBusClientTest.ts
var import_testdouble$59 = __toESM(require_testdouble(), 1);
dist_default.spec("EventBusClientTest", function() {
	let ebc;
	let cacheMock;
	let restClient;
	let userMock;
	let socket;
	let user;
	let sleepDetector;
	let listenerMock;
	let progressTrackerMock;
	let socketFactory;
	function initEventBus() {
		const entityClient$1 = new EntityClient(restClient);
		const instanceMapper = new InstanceMapper();
		ebc = new EventBusClient(listenerMock, cacheMock, userMock, entityClient$1, instanceMapper, socketFactory, sleepDetector, progressTrackerMock);
	}
	dist_default.before(function() {
		if (!globalThis.isBrowser) {
			WebSocket.CONNECTING = WebSocket.CONNECTING ?? 0;
			WebSocket.OPEN = WebSocket.OPEN ?? 1;
			WebSocket.CLOSING = WebSocket.CLOSING ?? 2;
			WebSocket.CLOSED = WebSocket.CLOSED ?? 3;
		}
	});
	dist_default.beforeEach(async function() {
		listenerMock = (0, import_testdouble$59.object)();
		progressTrackerMock = (0, import_testdouble$59.object)();
		cacheMock = (0, import_testdouble$59.object)({
			async entityEventsReceived(batch) {
				return batch.events.slice();
			},
			async getLastEntityEventBatchForGroup(groupId) {
				return null;
			},
			async recordSyncTime() {
				return;
			},
			async timeSinceLastSyncMs() {
				return null;
			},
			async purgeStorage() {},
			async setLastEntityEventBatchForGroup(groupId, batchId) {
				return;
			},
			async isOutOfSync() {
				return false;
			}
		});
		user = createTestEntity(UserTypeRef, { userGroup: createTestEntity(GroupMembershipTypeRef, { group: "userGroupId" }) });
		userMock = (0, import_testdouble$59.object)("user");
		(0, import_testdouble$59.when)(userMock.getLoggedInUser()).thenReturn(user);
		(0, import_testdouble$59.when)(userMock.isFullyLoggedIn()).thenReturn(true);
		(0, import_testdouble$59.when)(userMock.createAuthHeaders()).thenReturn({});
		restClient = new EntityRestClientMock();
		socket = (0, import_testdouble$59.object)();
		sleepDetector = (0, import_testdouble$59.object)();
		socketFactory = () => socket;
		initEventBus();
	});
	dist_default.spec("initEntityEvents ", function() {
		const mailGroupId = "mailGroupId";
		dist_default.beforeEach(function() {
			user.memberships = [createTestEntity(GroupMembershipTypeRef, {
				groupType: GroupType.Mail,
				group: mailGroupId
			})];
		});
		dist_default("initial connect: when the cache is clean it downloads one batch and initializes cache", async function() {
			(0, import_testdouble$59.when)(cacheMock.getLastEntityEventBatchForGroup(mailGroupId)).thenResolve(null);
			(0, import_testdouble$59.when)(cacheMock.timeSinceLastSyncMs()).thenResolve(null);
			const batch = createTestEntity(EntityEventBatchTypeRef, { _id: [mailGroupId, "-----------1"] });
			restClient.addListInstances(batch);
			await ebc.connect(ConnectMode.Initial);
			await socket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(cacheMock.recordSyncTime());
			(0, import_testdouble$59.verify)(restClient.loadRange(EntityEventBatchTypeRef, mailGroupId, import_testdouble$59.matchers.anything(), import_testdouble$59.matchers.not(1), import_testdouble$59.matchers.anything()), { times: 0 });
			(0, import_testdouble$59.verify)(cacheMock.setLastEntityEventBatchForGroup(mailGroupId, getElementId(batch)));
		});
		dist_default("initial connect: when the cache is initialized, missed events are loaded", async function() {
			(0, import_testdouble$59.when)(cacheMock.getLastEntityEventBatchForGroup(mailGroupId)).thenResolve("------------");
			(0, import_testdouble$59.when)(cacheMock.timeSinceLastSyncMs()).thenResolve(1);
			const update = createTestEntity(EntityUpdateTypeRef, {
				type: "Mail",
				application: "tutanota",
				instanceListId: mailGroupId,
				instanceId: "newBatchId"
			});
			const batch = createTestEntity(EntityEventBatchTypeRef, {
				_id: [mailGroupId, "-----------1"],
				events: [update]
			});
			restClient.addListInstances(batch);
			const eventsReceivedDefer = defer();
			(0, import_testdouble$59.when)(cacheMock.entityEventsReceived({
				events: [update],
				batchId: getElementId(batch),
				groupId: mailGroupId
			})).thenDo(() => eventsReceivedDefer.resolve(undefined));
			await ebc.connect(ConnectMode.Initial);
			await socket.onopen?.(new Event("open"));
			await eventsReceivedDefer.promise;
			(0, import_testdouble$59.verify)(cacheMock.purgeStorage(), { times: 0 });
			(0, import_testdouble$59.verify)(cacheMock.recordSyncTime());
		});
		dist_default("reconnect: when the cache is out of sync with the server, the cache is purged", async function() {
			(0, import_testdouble$59.when)(cacheMock.getLastEntityEventBatchForGroup(mailGroupId)).thenResolve("lastBatchId");
			await ebc.connect(ConnectMode.Initial);
			await socket.onopen?.(new Event("open"));
			(0, import_testdouble$59.when)(cacheMock.isOutOfSync()).thenResolve(true);
			await ebc.connect(ConnectMode.Reconnect);
			await socket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(cacheMock.purgeStorage(), { times: 1 });
			(0, import_testdouble$59.verify)(listenerMock.onError(import_testdouble$59.matchers.isA(OutOfSyncError)));
		});
		dist_default("initial connect: when the cache is out of sync with the server, the cache is purged", async function() {
			(0, import_testdouble$59.when)(cacheMock.getLastEntityEventBatchForGroup(mailGroupId)).thenResolve("lastBatchId");
			(0, import_testdouble$59.when)(cacheMock.isOutOfSync()).thenResolve(true);
			await ebc.connect(ConnectMode.Reconnect);
			await socket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(cacheMock.purgeStorage(), { times: 1 });
			(0, import_testdouble$59.verify)(listenerMock.onError(import_testdouble$59.matchers.isA(OutOfSyncError)));
		});
	});
	dist_default("parallel received event batches are passed sequentially to the entity rest cache", async function() {
		dist_default.timeout(500);
		ebc.connect(ConnectMode.Initial);
		await socket.onopen?.(new Event("open"));
		const messageData1 = createEntityMessage(1);
		const messageData2 = createEntityMessage(2);
		(0, import_testdouble$59.when)(cacheMock.entityEventsReceived(import_testdouble$59.matchers.anything())).thenReturn(new Promise(noOp));
		const p1 = socket.onmessage?.({ data: messageData1 });
		const p2 = socket.onmessage?.({ data: messageData2 });
		await Promise.all([p1, p2]);
		(0, import_testdouble$59.verify)(cacheMock.entityEventsReceived(import_testdouble$59.matchers.anything()), { times: 1 });
	});
	dist_default("received event batch is filtered for unknown types", async function() {
		dist_default.timeout(500);
		ebc.connect(ConnectMode.Initial);
		await socket.onopen?.(new Event("open"));
		const messageData = createEntityMessageWithUnknownEntity(1);
		const updateCaptor = import_testdouble$59.matchers.captor();
		(0, import_testdouble$59.when)(cacheMock.entityEventsReceived(updateCaptor.capture())).thenReturn(Promise.resolve([]));
		await socket.onmessage?.({ data: messageData });
		dist_default(updateCaptor.values?.length).equals(1);
		dist_default(updateCaptor.value.events).deepEquals([createTestEntity(EntityUpdateTypeRef, {
			_id: "eventBatchId",
			application: "tutanota",
			type: "Mail",
			instanceListId: "listId1",
			instanceId: "id1",
			operation: OperationType.UPDATE
		})]);
	});
	dist_default("missed entity events are processed in order", async function() {
		const membershipGroupId = "membershipGroupId";
		user.memberships = [createTestEntity(GroupMembershipTypeRef, { group: membershipGroupId })];
		const now$1 = Date.now();
		const batchId1 = timestampToGeneratedId(now$1 - 1);
		const batchId2 = timestampToGeneratedId(now$1 - 2);
		const batchId3 = timestampToGeneratedId(now$1 - 3);
		const batchId4 = timestampToGeneratedId(now$1 - 4);
		const batches = [
			createTestEntity(EntityEventBatchTypeRef, { _id: [membershipGroupId, batchId1] }),
			createTestEntity(EntityEventBatchTypeRef, { _id: [user.userGroup.group, batchId3] }),
			createTestEntity(EntityEventBatchTypeRef, { _id: [membershipGroupId, batchId4] }),
			createTestEntity(EntityEventBatchTypeRef, { _id: [user.userGroup.group, batchId2] })
		];
		restClient.addListInstances(...batches);
		const eventQueue = (0, import_testdouble$59.object)();
		const addedBatchIds = [];
		(0, import_testdouble$59.when)(eventQueue.add(import_testdouble$59.matchers.anything(), import_testdouble$59.matchers.anything(), import_testdouble$59.matchers.anything())).thenDo((batchId, groupId, newEvents) => addedBatchIds.push(batchId));
		await ebc.loadMissedEntityEvents(eventQueue);
		dist_default(addedBatchIds).deepEquals([
			batchId4,
			batchId3,
			batchId2,
			batchId1
		]);
	});
	dist_default("missed entity events are filtered for unknown types", async function() {
		const membershipGroupId = "membershipGroupId";
		user.memberships = [createTestEntity(GroupMembershipTypeRef, { group: membershipGroupId })];
		const now$1 = Date.now();
		const batchId = timestampToGeneratedId(now$1 - 1);
		const mailEntityUpdate = createTestEntity(EntityUpdateTypeRef, {
			_id: "eventBatchId",
			application: "tutanota",
			type: "Mail",
			instanceListId: "listId1",
			instanceId: "id1",
			operation: OperationType.UPDATE
		});
		const unknownEntityUpdate = createTestEntity(EntityUpdateTypeRef, {
			_id: "eventBatchId",
			application: "sys",
			type: "UnknownType",
			instanceListId: "listId2",
			instanceId: "id1",
			operation: OperationType.UPDATE
		});
		const batch = createTestEntity(EntityEventBatchTypeRef, {
			_id: [membershipGroupId, batchId],
			events: [mailEntityUpdate, unknownEntityUpdate]
		});
		restClient.addListInstances(batch);
		const eventQueue = (0, import_testdouble$59.object)();
		const addedBatches = [];
		(0, import_testdouble$59.when)(eventQueue.add(import_testdouble$59.matchers.anything(), import_testdouble$59.matchers.anything(), import_testdouble$59.matchers.anything())).thenDo((batchId$1, groupId, newEvents) => addedBatches.push(newEvents));
		await ebc.loadMissedEntityEvents(eventQueue);
		dist_default(addedBatches).deepEquals([[mailEntityUpdate]]);
	});
	dist_default("on counter update it send message to the main thread", async function() {
		const counterUpdate = createCounterData({
			mailGroupId: "group1",
			counterValue: 4,
			counterId: "list1"
		});
		await ebc.connect(ConnectMode.Initial);
		await socket.onmessage?.({ data: createCounterMessage(counterUpdate) });
		(0, import_testdouble$59.verify)(listenerMock.onCounterChanged(counterUpdate));
	});
	dist_default.spec("sleep detection", function() {
		dist_default("on connect it starts", async function() {
			(0, import_testdouble$59.verify)(sleepDetector.start(import_testdouble$59.matchers.anything()), { times: 0 });
			ebc.connect(ConnectMode.Initial);
			await socket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(sleepDetector.start(import_testdouble$59.matchers.anything()), { times: 1 });
		});
		dist_default("on disconnect it stops", async function() {
			ebc.connect(ConnectMode.Initial);
			await socket.onopen?.(new Event("open"));
			await socket.onclose?.(new Event("close"));
			(0, import_testdouble$59.verify)(sleepDetector.stop());
		});
		dist_default("on sleep it reconnects", async function() {
			let passedCb;
			(0, import_testdouble$59.when)(sleepDetector.start(import_testdouble$59.matchers.anything())).thenDo((cb) => passedCb = cb);
			const firstSocket = socket;
			ebc.connect(ConnectMode.Initial);
			firstSocket.readyState = WebSocket.OPEN;
			await firstSocket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(socket.close(), {
				ignoreExtraArgs: true,
				times: 0
			});
			const secondSocket = socket = (0, import_testdouble$59.object)();
			passedCb();
			(0, import_testdouble$59.verify)(firstSocket.close(), {
				ignoreExtraArgs: true,
				times: 1
			});
			(0, import_testdouble$59.verify)(listenerMock.onWebsocketStateChanged(WsConnectionState.connecting));
			await secondSocket.onopen?.(new Event("open"));
			(0, import_testdouble$59.verify)(listenerMock.onWebsocketStateChanged(WsConnectionState.connected));
		});
	});
	function createUnknownEntity() {
		const unknownTypeModel = {
			id: Number.MAX_SAFE_INTEGER,
			since: 1,
			app: "sys",
			version: "1",
			name: "Unknown",
			type: "LIST_ELEMENT_TYPE",
			versioned: false,
			encrypted: false,
			rootId: "someId",
			values: {},
			associations: {}
		};
		const unknownTypeRef = new TypeRef("sys", "Unknown");
		return create(unknownTypeModel, unknownTypeRef);
	}
	function createEntityMessageWithUnknownEntity(eventBatchId) {
		const event = createTestEntity(WebsocketEntityDataTypeRef, {
			eventBatchId: String(eventBatchId),
			eventBatchOwner: "ownerId",
			eventBatch: [createTestEntity(EntityUpdateTypeRef, {
				_id: "eventBatchId",
				application: "tutanota",
				type: "Mail",
				instanceListId: "listId1",
				instanceId: "id1",
				operation: OperationType.UPDATE
			}), createTestEntity(EntityUpdateTypeRef, {
				_id: "eventBatchId",
				application: "sys",
				type: "UnknownType",
				instanceListId: "listId2",
				instanceId: "id1",
				operation: OperationType.UPDATE
			})]
		});
		return "entityUpdate;" + JSON.stringify(event);
	}
	function createEntityMessage(eventBatchId) {
		const event = createTestEntity(WebsocketEntityDataTypeRef, {
			eventBatchId: String(eventBatchId),
			eventBatchOwner: "ownerId",
			eventBatch: [createTestEntity(EntityUpdateTypeRef, {
				_id: "eventbatchid",
				application: "tutanota",
				type: "Mail",
				instanceListId: "listId1",
				instanceId: "id1",
				operation: OperationType.UPDATE
			})]
		});
		return "entityUpdate;" + JSON.stringify(event);
	}
	function createCounterData({ mailGroupId, counterValue, counterId }) {
		return createTestEntity(WebsocketCounterDataTypeRef, {
			_format: "0",
			mailGroup: mailGroupId,
			counterValues: [createTestEntity(WebsocketCounterValueTypeRef, {
				_id: "counterupdateid",
				count: String(counterValue),
				counterId
			})]
		});
	}
	function createCounterMessage(event) {
		return "unreadCounterUpdate;" + JSON.stringify(event);
	}
});

//#endregion
//#region tests/api/worker/EventBusEventCoordinatorTest.ts
var import_testdouble$58 = __toESM(require_testdouble(), 1);
dist_default.spec("EventBusEventCoordinatorTest", () => {
	let eventBusEventCoordinator;
	let userId$1 = "userId";
	let userGroupId$1 = "userGroupId";
	let user;
	let userGroupKeyDistribution;
	let userFacade;
	let entityClient$1;
	let mailFacade;
	let eventController;
	let keyRotationFacadeMock;
	let cacheManagementFacade;
	dist_default.beforeEach(function() {
		user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef, { group: userGroupId$1 }),
			_id: userId$1
		});
		userFacade = (0, import_testdouble$58.object)();
		(0, import_testdouble$58.when)(userFacade.getUser()).thenReturn(user);
		entityClient$1 = (0, import_testdouble$58.object)();
		(0, import_testdouble$58.when)(entityClient$1.load(UserTypeRef, userId$1)).thenResolve(user);
		userGroupKeyDistribution = createTestEntity(UserGroupKeyDistributionTypeRef, { _id: userGroupId$1 });
		(0, import_testdouble$58.when)(entityClient$1.load(UserGroupKeyDistributionTypeRef, userGroupId$1)).thenResolve(userGroupKeyDistribution);
		mailFacade = (0, import_testdouble$58.object)();
		let lazyMailFacade = lazyMemoized(async () => mailFacade);
		eventController = (0, import_testdouble$58.object)();
		keyRotationFacadeMock = (0, import_testdouble$58.object)();
		cacheManagementFacade = (0, import_testdouble$58.object)();
		eventBusEventCoordinator = new EventBusEventCoordinator((0, import_testdouble$58.object)(), lazyMailFacade, userFacade, entityClient$1, eventController, (0, import_testdouble$58.object)(), keyRotationFacadeMock, async () => cacheManagementFacade, async (error) => {}, (queuedBatch) => {});
	});
	dist_default("updateUser and UserGroupKeyDistribution", async function() {
		const updates = [createTestEntity(EntityUpdateTypeRef, {
			application: UserTypeRef.app,
			type: UserTypeRef.type,
			instanceId: userId$1,
			operation: OperationType.UPDATE
		}), createTestEntity(EntityUpdateTypeRef, {
			application: UserGroupKeyDistributionTypeRef.app,
			type: UserGroupKeyDistributionTypeRef.type,
			instanceId: userGroupId$1,
			operation: OperationType.CREATE
		})];
		await eventBusEventCoordinator.onEntityEventsReceived(updates, "batchId", "groupId");
		(0, import_testdouble$58.verify)(userFacade.updateUser(user));
		(0, import_testdouble$58.verify)(cacheManagementFacade.tryUpdatingUserGroupKey());
		(0, import_testdouble$58.verify)(eventController.onEntityUpdateReceived(updates, "groupId"));
		(0, import_testdouble$58.verify)(mailFacade.entityEventsReceived(updates));
	});
	dist_default("updatUser only user update", async function() {
		const updates = [createTestEntity(EntityUpdateTypeRef, {
			application: UserTypeRef.app,
			type: UserTypeRef.type,
			instanceId: userId$1,
			operation: OperationType.UPDATE
		})];
		await eventBusEventCoordinator.onEntityEventsReceived(updates, "batchId", "groupId");
		(0, import_testdouble$58.verify)(userFacade.updateUser(user));
		(0, import_testdouble$58.verify)(cacheManagementFacade.tryUpdatingUserGroupKey(), { times: 0 });
		(0, import_testdouble$58.verify)(eventController.onEntityUpdateReceived(updates, "groupId"));
		(0, import_testdouble$58.verify)(mailFacade.entityEventsReceived(updates));
	});
	dist_default("groupKeyUpdate", async function() {
		const instanceListId = "updateListId";
		const instanceId = "updateElementId";
		const updates = [createTestEntity(EntityUpdateTypeRef, {
			application: GroupKeyUpdateTypeRef.app,
			type: GroupKeyUpdateTypeRef.type,
			instanceListId,
			instanceId,
			operation: OperationType.CREATE
		})];
		await eventBusEventCoordinator.onEntityEventsReceived(updates, "batchId", "groupId");
		(0, import_testdouble$58.verify)(keyRotationFacadeMock.updateGroupMemberships([[instanceListId, instanceId]]));
		(0, import_testdouble$58.verify)(userFacade.updateUser(user), { times: 0 });
		(0, import_testdouble$58.verify)(cacheManagementFacade.tryUpdatingUserGroupKey(), { times: 0 });
		(0, import_testdouble$58.verify)(eventController.onEntityUpdateReceived(updates, "groupId"));
		(0, import_testdouble$58.verify)(mailFacade.entityEventsReceived(updates));
	});
	dist_default.spec("onLeaderStatusChanged", function() {
		dist_default("If we are not the leader client, delete the passphrase key", function() {
			env.mode = "Desktop";
			const leaderStatus = createTestEntity(WebsocketLeaderStatusTypeRef, { leaderStatus: false });
			eventBusEventCoordinator.onLeaderStatusChanged(leaderStatus);
			(0, import_testdouble$58.verify)(keyRotationFacadeMock.reset());
			(0, import_testdouble$58.verify)(keyRotationFacadeMock.processPendingKeyRotationsAndUpdates(import_testdouble$58.matchers.anything()), { times: 0 });
		});
		dist_default("If we are the leader client of an internal user, execute key rotations", function() {
			env.mode = "Desktop";
			const leaderStatus = createTestEntity(WebsocketLeaderStatusTypeRef, { leaderStatus: true });
			eventBusEventCoordinator.onLeaderStatusChanged(leaderStatus);
			(0, import_testdouble$58.verify)(keyRotationFacadeMock.processPendingKeyRotationsAndUpdates(user));
		});
		dist_default("If we are the leader client of an external user, delete the passphrase key", function() {
			env.mode = "Desktop";
			const leaderStatus = createTestEntity(WebsocketLeaderStatusTypeRef, { leaderStatus: true });
			user.accountType = AccountType.EXTERNAL;
			eventBusEventCoordinator.onLeaderStatusChanged(leaderStatus);
			(0, import_testdouble$58.verify)(keyRotationFacadeMock.reset());
			(0, import_testdouble$58.verify)(keyRotationFacadeMock.processPendingKeyRotationsAndUpdates(import_testdouble$58.matchers.anything()), { times: 0 });
		});
	});
});

//#endregion
//#region tests/api/worker/search/IndexerTest.ts
var import_testdouble$57 = __toESM(require_testdouble(), 1);
const SERVER_TIME = new Date("1994-06-08").getTime();
let contactList = createTestEntity(ContactListTypeRef);
contactList._ownerGroup = "ownerGroupId";
contactList.contacts = "contactListId";
dist_default.spec("IndexerTest", () => {
	const OUT_OF_DATE_SERVER_TIME = SERVER_TIME - daysToMillis(ENTITY_EVENT_BATCH_TTL_DAYS) - 864e5;
	const restClientMock = downcast({ getRestClient() {
		return { getServerTimestampMs() {
			return SERVER_TIME;
		} };
	} });
	const entityRestCache = downcast({});
	const keyLoaderFacade = (0, import_testdouble$57.object)();
	let mailIndexer;
	dist_default.beforeEach(function() {
		mailIndexer = (0, import_testdouble$57.object)();
		mailIndexer.mailIndexingEnabled = false;
	});
	dist_default("init new db", async function() {
		let metadata = {};
		const expectedKeys = Object.keys(Metadata);
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(MetaDataOS);
				dist_default(key).equals(expectedKeys.shift());
				return Promise.resolve(null);
			},
			getAll: (os) => {
				return Promise.resolve([{
					key: "key",
					value: "value"
				}]);
			},
			put: (os, key, value) => {
				dist_default(os).equals(MetaDataOS);
				metadata[key] = value;
			},
			wait: () => Promise.resolve()
		};
		let groupBatches = [{
			groupId: "user-group-id",
			groupData: {}
		}];
		let persistentGroupData = [{ persistentGroupData: "dummy" }];
		const infoMessageHandler = (0, import_testdouble$57.object)();
		(0, import_testdouble$57.when)(mailIndexer.indexMailboxes(import_testdouble$57.matchers.anything(), import_testdouble$57.matchers.anything())).thenResolve();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._loadGroupData = spy(() => Promise.resolve(groupBatches));
			mock$1._initGroupData = spy((batches) => Promise.resolve());
			mock$1.db.dbFacade = {
				open: spy(() => Promise.resolve()),
				createTransaction: () => Promise.resolve(transaction)
			};
			mock$1._contact.indexFullContactList = spy(() => Promise.resolve());
			mock$1._contact.getIndexTimestamp = spy(() => Promise.resolve(NOTHING_INDEXED_TIMESTAMP));
			mock$1._loadPersistentGroupData = spy(() => Promise.resolve(persistentGroupData));
			mock$1._loadNewEntities = spy(async () => {});
			mock$1._entity.loadRoot = spy(() => Promise.resolve(contactList));
		});
		let user = createTestEntity(UserTypeRef);
		user.userGroup = createTestEntity(GroupMembershipTypeRef);
		user.userGroup.group = "user-group-id";
		let userGroupKey = freshVersioned(aes256RandomKey());
		(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
		await indexer.init({
			user,
			keyLoaderFacade
		});
		dist_default(indexer._loadGroupData.args).deepEquals([user]);
		dist_default(indexer._initGroupData.args[0]).deepEquals(groupBatches);
		dist_default(metadata[Metadata.mailIndexingEnabled]).equals(false);
		dist_default(decryptKey(userGroupKey.object, metadata[Metadata.userEncDbKey])).deepEquals(indexer.db.key);
		dist_default(indexer._entity.loadRoot.args).deepEquals([ContactListTypeRef, user.userGroup.group]);
		dist_default(indexer._contact.indexFullContactList.callCount).equals(1);
		dist_default(indexer._contact.indexFullContactList.args).deepEquals([contactList]);
		(0, import_testdouble$57.verify)(mailIndexer.indexMailboxes(import_testdouble$57.matchers.anything(), import_testdouble$57.matchers.anything()), { times: 1 });
		dist_default(indexer._loadPersistentGroupData.args).deepEquals([user]);
		dist_default(indexer._loadNewEntities.args).deepEquals([persistentGroupData]);
	});
	dist_default("init existing db", async function() {
		let userGroupKey = freshVersioned(aes256RandomKey());
		let dbKey$1 = aes256RandomKey();
		let encDbIv = aesEncrypt(dbKey$1, fixedIv, random.generateRandomData(IV_BYTE_LENGTH), true);
		let userEncDbKey = encryptKey(userGroupKey.object, dbKey$1);
		const userGroupKeyVersion = 0;
		let transaction = {
			get: (os, key) => {
				if (os == MetaDataOS && key == Metadata.userEncDbKey) return Promise.resolve(userEncDbKey);
				if (os == MetaDataOS && key == Metadata.mailIndexingEnabled) return Promise.resolve(true);
				if (os == MetaDataOS && key == Metadata.excludedListIds) return Promise.resolve(["excluded-list-id"]);
				if (os == MetaDataOS && key == Metadata.encDbIv) return Promise.resolve(encDbIv);
				if (os == MetaDataOS && key == Metadata.userGroupKeyVersion) return Promise.resolve(userGroupKeyVersion);
				return Promise.resolve(null);
			},
			getAll: (os) => {
				return Promise.resolve([{
					key: "key",
					value: "value"
				}]);
			},
			wait: () => Promise.resolve()
		};
		let persistentGroupData = [{ persistentGroupData: "dummy" }];
		let groupDiff = [{ groupDiff: "dummy" }];
		const infoMessageHandler = (0, import_testdouble$57.object)();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.dbFacade = {
				open: spy(() => Promise.resolve()),
				createTransaction: () => Promise.resolve(transaction)
			};
			mock$1._loadGroupDiff = spy(() => Promise.resolve(groupDiff));
			mock$1._updateGroups = spy(() => Promise.resolve());
			mock$1._mail.updateCurrentIndexTimestamp = spy(() => Promise.resolve());
			mock$1._contact.indexFullContactList = spy(() => Promise.resolve());
			mock$1._contact.getIndexTimestamp = spy(() => Promise.resolve(FULL_INDEXED_TIMESTAMP));
			mock$1._contact.suggestionFacade.load = spy(() => Promise.resolve());
			mock$1._loadPersistentGroupData = spy(() => Promise.resolve(persistentGroupData));
			mock$1._loadNewEntities = spy(async () => {});
			mock$1._entity.loadRoot = spy(() => Promise.resolve(contactList));
		});
		let user = createTestEntity(UserTypeRef);
		user.userGroup = createTestEntity(GroupMembershipTypeRef);
		user.userGroup.group = "user-group-id";
		(0, import_testdouble$57.when)(keyLoaderFacade.loadSymUserGroupKey(userGroupKeyVersion)).thenResolve(userGroupKey.object);
		await indexer.init({
			user,
			keyLoaderFacade
		});
		dist_default(indexer.db.key).deepEquals(dbKey$1);
		dist_default(indexer._loadGroupDiff.args).deepEquals([user]);
		dist_default(indexer._updateGroups.args).deepEquals([user, groupDiff]);
		dist_default(indexer._entity.loadRoot.args).deepEquals([ContactListTypeRef, user.userGroup.group]);
		dist_default(indexer._contact.indexFullContactList.callCount).equals(0);
		dist_default(indexer._loadPersistentGroupData.args).deepEquals([user]);
		dist_default(indexer._loadNewEntities.args).deepEquals([persistentGroupData]);
		dist_default(indexer._contact.suggestionFacade.load.callCount).equals(1);
	});
	dist_default("init existing db out of sync", async () => {
		let userGroupKey = freshVersioned(aes256RandomKey());
		let dbKey$1 = aes256RandomKey();
		let userEncDbKey = encryptKey(userGroupKey.object, dbKey$1);
		const userGroupKeyVersion = 0;
		let encDbIv = aesEncrypt(dbKey$1, fixedIv, random.generateRandomData(IV_BYTE_LENGTH), true);
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.userEncDbKey) return userEncDbKey;
				if (os == MetaDataOS && key == Metadata.userGroupKeyVersion) return userGroupKeyVersion;
				if (os == MetaDataOS && key == Metadata.mailIndexingEnabled) return true;
				if (os == MetaDataOS && key == Metadata.excludedListIds) return ["excluded-list-id"];
				if (os == MetaDataOS && key == Metadata.encDbIv) return encDbIv;
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			wait: () => Promise.resolve(),
			getAll: () => Promise.resolve([{
				key: "key",
				value: "value"
			}])
		};
		let groupDiff = [{ groupDiff: "dummy" }];
		let persistentGroupData = [{ persistentGroupData: "dummy" }];
		const infoMessageHandler = (0, import_testdouble$57.object)();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1.db.dbFacade = {
				open: spy(() => Promise.resolve()),
				createTransaction: () => Promise.resolve(transaction)
			};
			mock$1._loadGroupDiff = spy(() => Promise.resolve(groupDiff));
			mock$1._updateGroups = spy(() => Promise.resolve());
			mock$1._mail.updateCurrentIndexTimestamp = spy(() => Promise.resolve());
			mock$1._contact.indexFullContactList = spy(() => Promise.resolve());
			mock$1._contact.getIndexTimestamp = spy(() => Promise.resolve(FULL_INDEXED_TIMESTAMP));
			mock$1._loadPersistentGroupData = spy(() => Promise.resolve(persistentGroupData));
			mock$1._loadNewEntities = spy(() => Promise.reject(new OutOfSyncError("is out of sync ;-)")));
			mock$1.disableMailIndexing = spy();
			mock$1._entity.loadRoot = spy(() => Promise.resolve(contactList));
		});
		let user = createTestEntity(UserTypeRef);
		user.userGroup = createTestEntity(GroupMembershipTypeRef);
		user.userGroup.group = "user-group-id";
		(0, import_testdouble$57.when)(keyLoaderFacade.loadSymUserGroupKey(userGroupKeyVersion)).thenResolve(userGroupKey.object);
		await indexer.init({
			user,
			keyLoaderFacade
		});
		dist_default(indexer.db.key).deepEquals(dbKey$1);
		dist_default(indexer._loadGroupDiff.args).deepEquals([user]);
		dist_default(indexer._updateGroups.args).deepEquals([user, groupDiff]);
		dist_default(indexer._entity.loadRoot.args).deepEquals([ContactListTypeRef, user.userGroup.group]);
		dist_default(indexer._contact.indexFullContactList.callCount).equals(0);
		dist_default(indexer._loadPersistentGroupData.args).deepEquals([user]);
		dist_default(indexer._loadNewEntities.args).deepEquals([persistentGroupData]);
	});
	dist_default("_loadGroupDiff", async function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef)
		];
		user.memberships[0].groupType = GroupType.Mail;
		user.memberships[0].group = "new-group-id";
		user.memberships[1].groupType = GroupType.Contact;
		user.memberships[1].group = "constant-group-id";
		let deletedGroupId = "deleted-group-id";
		let groupData = { groupType: GroupType.MailingList };
		let transaction = { getAll: (os) => {
			dist_default(os).equals(GroupDataOS);
			return Promise.resolve([{
				key: deletedGroupId,
				value: groupData
			}, {
				key: user.memberships[1].group,
				value: { groupType: GroupType.Mail }
			}]);
		} };
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer);
		indexer.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		const result = await indexer._loadGroupDiff(user);
		dist_default(result).deepEquals({
			deletedGroups: [{
				id: "deleted-group-id",
				type: GroupType.MailingList
			}],
			newGroups: [{
				id: "new-group-id",
				type: GroupType.Mail
			}]
		});
	});
	dist_default("_updateGroups disable MailIndexing in case of a deleted mail group", async function() {
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.disableMailIndexing = spy(() => Promise.resolve());
		});
		let user = createTestEntity(UserTypeRef);
		let groupDiff = {
			deletedGroups: [{
				id: "groupId",
				type: GroupType.Mail
			}],
			newGroups: []
		};
		await dist_default(() => indexer._updateGroups(user, groupDiff)).asyncThrows(MembershipRemovedError);
	});
	dist_default("_updateGroups disable MailIndexing in case of a deleted contact group", async function() {
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.disableMailIndexing = spy(() => Promise.resolve());
		});
		let user = createTestEntity(UserTypeRef);
		let groupDiff = {
			deletedGroups: [{
				id: "groupId",
				type: GroupType.Contact
			}],
			newGroups: []
		};
		const e = await assertThrows(MembershipRemovedError, () => indexer._updateGroups(user, groupDiff));
	});
	dist_default("_updateGroups don't disable MailIndexing in case no mail or contact group has been deleted", async function() {
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.disableMailIndexing = spy();
		});
		let user = createTestEntity(UserTypeRef);
		let groupDiff = {
			deletedGroups: [{
				id: "groupId",
				type: GroupType.MailingList
			}],
			newGroups: []
		};
		await indexer._updateGroups(user, groupDiff);
	});
	dist_default("_updateGroups do not index new mail groups", async function() {
		let transaction = "transaction";
		let groupBatches = "groupBatches";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._loadGroupData = spy(() => Promise.resolve(groupBatches));
			mock$1._initGroupData = spy(() => Promise.resolve());
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
			mock$1._mail.indexMailboxes = spy();
			mock$1._mail.currentIndexTimestamp = new Date().getTime();
		});
		let user = createTestEntity(UserTypeRef);
		let groupDiff = {
			deletedGroups: [],
			newGroups: [{
				id: "groupId",
				type: GroupType.Mail
			}]
		};
		await indexer._updateGroups(user, groupDiff);
		dist_default(indexer._loadGroupData.callCount).equals(1);
		dist_default(indexer._loadGroupData.args[0]).equals(user);
		dist_default(indexer._initGroupData.callCount).equals(1);
		dist_default(indexer._initGroupData.args).deepEquals([groupBatches, transaction]);
		dist_default(indexer._mail.indexMailboxes.callCount).equals(0);
	});
	dist_default("_updateGroups only init group data for non mail groups (do not index)", async function() {
		let transaction = "transaction";
		let groupBatches = "groupBatches";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._loadGroupData = spy(() => Promise.resolve(groupBatches));
			mock$1._initGroupData = spy(() => Promise.resolve());
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
			mock$1._mail.indexMailboxes = spy();
		});
		let user = createTestEntity(UserTypeRef);
		let groupDiff = {
			deletedGroups: [],
			newGroups: [{
				id: "groupId",
				type: GroupType.Contact
			}]
		};
		await indexer._updateGroups(user, groupDiff);
		dist_default(indexer._loadGroupData.callCount).equals(1);
		dist_default(indexer._loadGroupData.args[0]).equals(user);
		dist_default(indexer._initGroupData.callCount).equals(1);
		dist_default(indexer._initGroupData.args).deepEquals([groupBatches, transaction]);
		dist_default(indexer._mail.indexMailboxes.callCount).equals(0);
	});
	dist_default("_loadGroupData", async function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef)
		];
		user.memberships[0].groupType = GroupType.Mail;
		user.memberships[0].group = "group-mail";
		user.memberships[1].groupType = GroupType.MailingList;
		user.memberships[1].group = "group-team";
		user.memberships[2].groupType = GroupType.Contact;
		user.memberships[2].group = "group-contact";
		user.memberships[3].groupType = GroupType.Customer;
		user.memberships[3].group = "group-customer";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._entity = { loadRange: (type, listId, startId, count, reverse) => {
				dist_default(type).equals(EntityEventBatchTypeRef);
				dist_default(startId).equals(GENERATED_MAX_ID);
				dist_default(count).equals(1);
				dist_default(reverse).equals(true);
				return Promise.resolve([{ _id: [null, "event-batch-id"] }]);
			} };
		});
		const result = await indexer._loadGroupData(user);
		dist_default(result).deepEquals([
			{
				groupId: "group-mail",
				groupData: {
					lastBatchIds: ["event-batch-id"],
					indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
					groupType: GroupType.Mail
				}
			},
			{
				groupId: "group-contact",
				groupData: {
					lastBatchIds: ["event-batch-id"],
					indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
					groupType: GroupType.Contact
				}
			},
			{
				groupId: "group-customer",
				groupData: {
					lastBatchIds: ["event-batch-id"],
					indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
					groupType: GroupType.Customer
				}
			}
		]);
	});
	dist_default("_loadGroupData not authorized", async function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [createTestEntity(GroupMembershipTypeRef), createTestEntity(GroupMembershipTypeRef)];
		user.memberships[0].groupType = GroupType.Mail;
		user.memberships[0].group = "group-mail";
		user.memberships[1].groupType = GroupType.MailingList;
		user.memberships[1].group = "group-team";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			let count = 0;
			mock$1._entity = { loadRange: (type, listId, startId, count$1, reverse) => {
				if (count$1 == 0) {
					console.log("EEE");
					count$1++;
					return Promise.reject(new NotAuthorizedError("test"));
				} else return Promise.resolve([{ _id: [null, "event-batch-id"] }]);
			} };
		});
		const result = await indexer._loadGroupData(user);
		dist_default(result).deepEquals([{
			groupId: "group-mail",
			groupData: {
				lastBatchIds: ["event-batch-id"],
				indexTimestamp: NOTHING_INDEXED_TIMESTAMP,
				groupType: GroupType.Mail
			}
		}]);
	});
	dist_default("_initGroupData", async function() {
		let groupBatches = [{
			groupId: "groupId",
			groupData: {
				groupType: GroupType.Mail,
				lastBatchIds: [],
				indexTimestamp: 1
			}
		}];
		let transaction = downcast({
			put: (os, key, value) => {
				dist_default(os).equals(GroupDataOS);
				dist_default(key).equals(groupBatches[0].groupId);
				dist_default(value).deepEquals(groupBatches[0].groupData);
				stored = true;
				return Promise.resolve();
			},
			wait: () => Promise.resolve()
		});
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer);
		let stored = false;
		await indexer._initGroupData(groupBatches, transaction);
		dist_default(stored).equals(true);
	});
	dist_default("_loadNewEntities", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		const groupId = "group-mail";
		let groupIdToEventBatches = [{
			groupId,
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef), createTestEntity(EntityEventBatchTypeRef)];
		batches[0]._id = ["group-mail", "L0JcCmw----1"];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		batches[1]._id = ["group-mail", oldestBatchId];
		batches[1].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		});
		indexer._entity = { loadAll: (type, groupIdA, startId) => {
			dist_default(type).deepEquals(EntityEventBatchTypeRef);
			dist_default(groupIdA).equals(groupId);
			let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1);
			dist_default(startId).equals(expectedStartId);
			return Promise.resolve(batches);
		} };
		downcast(indexer)._processEntityEvents = spy(() => Promise.resolve());
		const queue = indexer._core.queue;
		downcast(queue).addBatches = spy();
		await indexer._loadNewEntities(groupIdToEventBatches);
		dist_default(queue.addBatches.invocations.length).equals(1);
		dist_default(queue.addBatches.invocations[0]).deepEquals([[{
			groupId,
			batchId: getElementId(batches[0]),
			events: batches[0].events
		}]]);
		dist_default(transaction.put.args).deepEquals([
			MetaDataOS,
			Metadata.lastEventIndexTimeMs,
			SERVER_TIME
		]);
	});
	dist_default("load events and then receive latest again", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		const groupId = "group-mail";
		let groupIdToEventBatches = [{
			groupId,
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef), createTestEntity(EntityEventBatchTypeRef)];
		const loadedNewBatchId = "L0JcCmw----1";
		batches[0]._id = ["group-mail", loadedNewBatchId];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		batches[1]._id = ["group-mail", oldestBatchId];
		batches[1].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		});
		indexer._entity = { loadAll: (type, groupIdA, startId) => Promise.resolve(batches) };
		downcast(indexer)._processEntityEvents = spy(() => Promise.resolve());
		const queue = indexer._core.queue;
		downcast(queue).addBatches = spy();
		await indexer._loadNewEntities(groupIdToEventBatches);
		dist_default(queue.addBatches.invocations.length).equals(1);
		dist_default(queue.addBatches.invocations[0]).deepEquals([[{
			groupId,
			batchId: getElementId(batches[0]),
			events: batches[0].events
		}]]);
		dist_default(transaction.put.args).deepEquals([
			MetaDataOS,
			Metadata.lastEventIndexTimeMs,
			SERVER_TIME
		]);
		const realtimeEvents = [createTestEntity(EntityUpdateTypeRef)];
		indexer.addBatchesToQueue([{
			groupId,
			events: realtimeEvents,
			batchId: loadedNewBatchId
		}]);
		dist_default(queue.addBatches.invocations.length).equals(1);
	});
	dist_default("load events and then receive older again", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		const groupId = "group-mail";
		let groupIdToEventBatches = [{
			groupId,
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef), createTestEntity(EntityEventBatchTypeRef)];
		const loadedNewBatchId = "L0JcCmy-----";
		batches[0]._id = ["group-mail", loadedNewBatchId];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		batches[1]._id = ["group-mail", oldestBatchId];
		batches[1].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		});
		indexer._entity = { loadAll: (type, groupIdA, startId) => Promise.resolve(batches) };
		downcast(indexer)._processEntityEvents = spy(() => Promise.resolve());
		const queue = indexer._core.queue;
		downcast(queue).addBatches = spy();
		await indexer._loadNewEntities(groupIdToEventBatches);
		dist_default(queue.addBatches.invocations.length).equals(1);
		dist_default(queue.addBatches.invocations[0]).deepEquals([[{
			groupId,
			batchId: getElementId(batches[0]),
			events: batches[0].events
		}]]);
		dist_default(transaction.put.args).deepEquals([
			MetaDataOS,
			Metadata.lastEventIndexTimeMs,
			SERVER_TIME
		]);
		indexer.addBatchesToQueue([{
			groupId,
			events: [],
			batchId: newestBatchId
		}]);
		dist_default(queue.addBatches.invocations.length).equals(1);
	});
	dist_default("receive realtime events before init finishes", async function() {
		const oldestBatchId = "L0JcCmw----0";
		const loadedNewBatchId = "L0JcCmw----1";
		const realtimeBatchId = "L0JcCmx----0";
		const groupId = "group-mail";
		let groupIdToEventBatches = [{
			groupId,
			eventBatchIds: [oldestBatchId]
		}];
		let loadedBatches = [createTestEntity(EntityEventBatchTypeRef, {
			_id: ["group-mail", loadedNewBatchId],
			events: [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)]
		}), createTestEntity(EntityEventBatchTypeRef, { _id: ["group-mail", oldestBatchId] })];
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		});
		const loadCompleted = defer();
		indexer._entity = { loadAll: (type, groupIdA, startId) => loadCompleted.promise };
		downcast(indexer)._processEntityEvents = spy(() => Promise.resolve());
		const queue = indexer._core.queue;
		downcast(queue).addBatches = spy();
		const loadPromise = indexer._loadNewEntities(groupIdToEventBatches);
		const realtimeUpdates = [createTestEntity(EntityUpdateTypeRef, { instanceId: "realtime" })];
		indexer.addBatchesToQueue([{
			groupId,
			events: realtimeUpdates,
			batchId: realtimeBatchId
		}]);
		loadCompleted.resolve(loadedBatches);
		await loadPromise;
		dist_default(queue.addBatches.invocations.length).equals(2);
		dist_default(queue.addBatches.invocations[0]).deepEquals([[{
			groupId,
			batchId: getElementId(loadedBatches[0]),
			events: loadedBatches[0].events
		}]]);
		dist_default(queue.addBatches.invocations[1]).deepEquals([[{
			groupId,
			batchId: realtimeBatchId,
			events: realtimeUpdates
		}]]);
		dist_default(transaction.put.args).deepEquals([
			MetaDataOS,
			Metadata.lastEventIndexTimeMs,
			SERVER_TIME
		]);
	});
	dist_default("_loadNewEntities batch already processed", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		let groupIdToEventBatches = [{
			groupId: "group-mail",
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef)];
		batches[0]._id = ["group-mail", oldestBatchId];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				if (os == MetaDataOS && key == Metadata.lastEventIndexTimeMs) return SERVER_TIME;
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._entity = { loadAll: (type, groupId, startId) => {
				dist_default(type).deepEquals(EntityEventBatchTypeRef);
				dist_default(groupId).equals("group-mail");
				let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1);
				dist_default(startId).equals(expectedStartId);
				return Promise.resolve(batches);
			} };
			mock$1._processEntityEvents = spy();
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
			mock$1.db.initialized = Promise.resolve();
		});
		await indexer._loadNewEntities(groupIdToEventBatches);
		dist_default(indexer._processEntityEvents.callCount).equals(0);
		dist_default(transaction.put.args).deepEquals([
			MetaDataOS,
			Metadata.lastEventIndexTimeMs,
			SERVER_TIME
		]);
	});
	dist_default("_loadNewEntities out of sync", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		let groupIdToEventBatches = [{
			groupId: "group-mail",
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef)];
		batches[0]._id = ["group-mail", "L0JcCmw----1"];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				return null;
			},
			put: spy(async (os, key, value) => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._entity = { loadAll: (type, groupId, startId) => {
				dist_default(type).deepEquals(EntityEventBatchTypeRef);
				dist_default(groupId).equals("group-mail");
				let expectedStartId = timestampToGeneratedId(generatedIdToTimestamp(oldestBatchId) - 1);
				dist_default(startId).equals(expectedStartId);
				return Promise.resolve(batches);
			} };
			mock$1._processEntityEvents = spy(() => Promise.resolve());
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
			mock$1.db.initialized = Promise.resolve();
		});
		await assertThrows(OutOfSyncError, () => indexer._loadNewEntities(groupIdToEventBatches));
		dist_default(indexer._processEntityEvents.callCount).equals(0);
		dist_default(transaction.put.callCount).equals(0);
	});
	dist_default("_loadNewEntities out of date", async function() {
		const newestBatchId = "L0JcCmx----0";
		const oldestBatchId = "L0JcCmw----0";
		let groupIdToEventBatches = [{
			groupId: "group-mail",
			eventBatchIds: [newestBatchId, oldestBatchId]
		}];
		let batches = [createTestEntity(EntityEventBatchTypeRef)];
		batches[0]._id = ["group-mail", "L0JcCmw----1"];
		batches[0].events = [createTestEntity(EntityUpdateTypeRef), createTestEntity(EntityUpdateTypeRef)];
		let transaction = {
			get: async (os, key) => {
				if (os === MetaDataOS && key === Metadata.lastEventIndexTimeMs) return OUT_OF_DATE_SERVER_TIME;
				return null;
			},
			put: spy(async () => {})
		};
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1._processEntityEvents = spy(() => Promise.resolve());
			mock$1.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
			mock$1.db.initialized = Promise.resolve();
		});
		await assertThrows(OutOfSyncError, () => indexer._loadNewEntities(groupIdToEventBatches));
		dist_default(indexer._processEntityEvents.callCount).equals(0);
		dist_default(transaction.put.callCount).equals(0);
	});
	dist_default("_loadPersistentGroupData", async function() {
		let groupData = { lastBatchIds: ["last-batch-id"] };
		let transaction = { get: (os, groupId) => {
			dist_default(os).equals(GroupDataOS);
			return Promise.resolve(groupData);
		} };
		let user = createTestEntity(UserTypeRef);
		user.memberships = [
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef)
		];
		user.memberships[0].groupType = GroupType.Mail;
		user.memberships[0].group = "group-mail";
		user.memberships[1].groupType = GroupType.MailingList;
		user.memberships[1].group = "group-team";
		user.memberships[2].groupType = GroupType.Contact;
		user.memberships[2].group = "group-contact";
		user.memberships[3].groupType = GroupType.Customer;
		user.memberships[3].group = "group-customer";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer);
		indexer.db.dbFacade = { createTransaction: () => Promise.resolve(transaction) };
		const groupIdToEventBatches = await indexer._loadPersistentGroupData(user);
		dist_default(groupIdToEventBatches).deepEquals([
			{
				groupId: "group-mail",
				eventBatchIds: ["last-batch-id"]
			},
			{
				groupId: "group-contact",
				eventBatchIds: ["last-batch-id"]
			},
			{
				groupId: "group-customer",
				eventBatchIds: ["last-batch-id"]
			}
		]);
	});
	dist_default("_processEntityEvents_1", async function() {
		const groupId = "group-id";
		const batchId = "batch-id";
		let user = createTestEntity(UserTypeRef);
		user.memberships = [createTestEntity(GroupMembershipTypeRef)];
		user.memberships[0].groupType = GroupType.Mail;
		user.memberships[0].group = groupId;
		const infoMessageHandler = (0, import_testdouble$57.object)();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (indexerMock) => {
			indexerMock.db.initialized = Promise.resolve();
			indexerMock._mail = { processEntityEvents: spy(() => Promise.resolve()) };
			indexerMock._contact = { processEntityEvents: spy(() => Promise.resolve()) };
			indexerMock._processUserEntityEvents = spy(() => Promise.resolve());
			indexerMock._initParams = { user: createTestEntity(UserTypeRef) };
			indexerMock._core.writeIndexUpdateWithBatchId = spy(() => Promise.resolve());
			indexerMock._initParams = { user };
		});
		function newUpdate(typeRef) {
			let u = createTestEntity(EntityUpdateTypeRef);
			u.application = typeRef.app;
			u.type = typeRef.type;
			return u;
		}
		let events = [
			newUpdate(MailTypeRef),
			newUpdate(ContactTypeRef),
			newUpdate(UserTypeRef)
		];
		indexer._indexedGroupIds = [groupId];
		const batch = {
			events,
			groupId,
			batchId
		};
		await indexer._processEntityEvents(batch);
		dist_default(indexer._core.writeIndexUpdateWithBatchId.invocations.length).equals(2);
		let indexUpdateMail = indexer._core.writeIndexUpdateWithBatchId.invocations[0][2];
		dist_default(indexer._mail.processEntityEvents.callCount).equals(1);
		dist_default(indexer._mail.processEntityEvents.args).deepEquals([
			[events[0]],
			groupId,
			batchId,
			indexUpdateMail
		]);
		let indexUpdateContact = indexer._core.writeIndexUpdateWithBatchId.invocations[1][2];
		dist_default(indexer._contact.processEntityEvents.callCount).equals(1);
		dist_default(indexer._contact.processEntityEvents.args).deepEquals([
			[events[1]],
			groupId,
			batchId,
			indexUpdateContact
		]);
	});
	dist_default("processEntityEvents non indexed group", async function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [createTestEntity(GroupMembershipTypeRef)];
		user.memberships[0].groupType = GroupType.MailingList;
		user.memberships[0].group = "group-id";
		const infoMessageHandler = (0, import_testdouble$57.object)();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1._mail = { processEntityEvents: spy(() => Promise.resolve()) };
			mock$1._contact = { processEntityEvents: spy(() => Promise.resolve()) };
			mock$1._processUserEntityEvents = spy(() => Promise.resolve());
			mock$1._initParams = { user: createTestEntity(UserTypeRef) };
			mock$1._core.writeIndexUpdate = spy(() => Promise.resolve());
			mock$1._initParams = { user };
		});
		function update(typeRef) {
			let u = createTestEntity(EntityUpdateTypeRef);
			u.application = typeRef.app;
			u.type = typeRef.type;
			return u;
		}
		let events = [
			update(MailTypeRef),
			update(ContactTypeRef),
			update(UserTypeRef)
		];
		const batch = {
			events,
			groupId: "group-id",
			batchId: "batch-id"
		};
		indexer._indexedGroupIds = ["group-id"];
		await indexer._processEntityEvents(batch);
		dist_default(indexer._core.writeIndexUpdate.callCount).equals(0);
		dist_default(indexer._mail.processEntityEvents.callCount).equals(0);
		dist_default(indexer._contact.processEntityEvents.callCount).equals(0);
		dist_default(indexer._processUserEntityEvents.callCount).equals(0);
	});
	dist_default("_processEntityEvents_2", async function() {
		const doneDeferred = defer();
		const infoMessageHandler = (0, import_testdouble$57.object)();
		const indexer = mock(new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer), (mock$1) => {
			mock$1.db.initialized = Promise.resolve();
			mock$1._mail = { processEntityEvents: spy(() => Promise.resolve()) };
			mock$1._contact = { processEntityEvents: spy(() => Promise.resolve()) };
			mock$1._processUserEntityEvents = spy(() => Promise.resolve());
			mock$1._initParams = { user: createTestEntity(UserTypeRef) };
			mock$1._core.writeIndexUpdateWithBatchId = spy(() => Promise.resolve());
			let user = createTestEntity(UserTypeRef);
			user.memberships = [createTestEntity(GroupMembershipTypeRef)];
			user.memberships[0].groupType = GroupType.Mail;
			user.memberships[0].group = "group-id";
			mock$1._initParams = { user };
			const _processNext = mock$1._core.queue.processNext.bind(mock$1._core.queue);
			mock$1._core.queue.processNext = spy(() => {
				if (mock$1._core.queue.eventQueue.length === 0) doneDeferred.resolve(null);
				_processNext();
			});
		});
		const events1 = [createTestEntity(EntityUpdateTypeRef, {
			application: MailTypeRef.app,
			type: MailTypeRef.type,
			operation: OperationType.CREATE,
			instanceId: "id-1"
		})];
		indexer._indexedGroupIds = ["group-id"];
		const batch1 = {
			events: events1,
			groupId: "group-id",
			batchId: "batch-id-1"
		};
		const events2 = [createTestEntity(EntityUpdateTypeRef, {
			application: MailTypeRef.app,
			type: MailTypeRef.type,
			operation: OperationType.CREATE,
			instanceId: "id-2"
		})];
		indexer._indexedGroupIds = ["group-id"];
		const batch2 = {
			events: events2,
			groupId: "group-id",
			batchId: "batch-id-2"
		};
		indexer.addBatchesToQueue([batch1, batch2]);
		indexer._realtimeEventQueue.resume();
		indexer.startProcessing();
		await doneDeferred.promise;
		dist_default(indexer._core.writeIndexUpdateWithBatchId.callCount).equals(2);
		dist_default(indexer._mail.processEntityEvents.callCount).equals(2);
		dist_default(indexer._contact.processEntityEvents.callCount).equals(0);
	});
	dist_default("_getStartIdForLoadingMissedEventBatches", function() {
		const infoMessageHandler = (0, import_testdouble$57.object)();
		let indexer = new Indexer(restClientMock, infoMessageHandler, browserDataStub, entityRestCache, () => mailIndexer);
		dist_default(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1-----"])).equals("L0JcCm0-----");
		dist_default(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm2-----", "L0JcCm1-----"])).equals("L0JcCm0-----");
		let oneMinuteOld = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 6e4);
		let oneMinuteOldMinusOneMS = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 6e4 - 1);
		dist_default(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", oneMinuteOld])).equals(oneMinuteOldMinusOneMS);
		let olderThanOneMinute = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 6e4 - 1);
		let newestMinusOneMinute = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 6e4);
		dist_default(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", olderThanOneMinute])).equals(newestMinusOneMinute);
		let veryOld = timestampToGeneratedId(generatedIdToTimestamp("L0JcCm1-----") - 6e5);
		dist_default(indexer._getStartIdForLoadingMissedEventBatches(["L0JcCm1----", veryOld])).equals(newestMinusOneMinute);
	});
	dist_default.spec("Contact indexing and caching", function() {
		let indexer;
		let user = createTestEntity(UserTypeRef);
		user.userGroup = createTestEntity(GroupMembershipTypeRef);
		user.userGroup.group = "user-group-id";
		let userGroupKey;
		function makeIndexer() {
			userGroupKey = freshVersioned(aes256RandomKey());
			const infoMessageHandlerDouble = (0, import_testdouble$57.object)();
			const entityRestClientDouble = (0, import_testdouble$57.instance)(EntityRestClient);
			const restClientDouble = (0, import_testdouble$57.instance)(RestClient);
			(0, import_testdouble$57.when)(restClientDouble.getServerTimestampMs()).thenReturn(SERVER_TIME);
			(0, import_testdouble$57.when)(entityRestClientDouble.getRestClient()).thenReturn(restClientDouble);
			indexer = new Indexer(entityRestClientDouble, infoMessageHandlerDouble, browserDataStub, (0, import_testdouble$57.instance)(DefaultEntityRestCache), () => mailIndexer);
			const transactionDouble = (0, import_testdouble$57.object)();
			(0, import_testdouble$57.when)(transactionDouble.getAll(import_testdouble$57.matchers.anything())).thenResolve([{
				key: "key",
				value: "value"
			}]);
			(0, import_testdouble$57.when)(transactionDouble.put(import_testdouble$57.matchers.anything(), import_testdouble$57.matchers.anything(), import_testdouble$57.matchers.anything())).thenResolve(null);
			const dbFacadeDouble = (0, import_testdouble$57.instance)(DbFacade);
			(0, import_testdouble$57.when)(dbFacadeDouble.createTransaction(import_testdouble$57.matchers.anything(), import_testdouble$57.matchers.anything())).thenResolve(transactionDouble);
			(0, import_testdouble$57.replace)(indexer.db, "dbFacade", dbFacadeDouble);
			const entityDouble = (0, import_testdouble$57.instance)(EntityClient);
			(0, import_testdouble$57.when)(entityDouble.loadRoot(ContactListTypeRef, user.userGroup.group)).thenResolve(contactList);
			(0, import_testdouble$57.replace)(indexer, "_entity", entityDouble);
			const contactDouble = (0, import_testdouble$57.instance)(ContactIndexer);
			(0, import_testdouble$57.replace)(indexer, "_contact", contactDouble);
		}
		dist_default.beforeEach(function() {
			makeIndexer();
		});
		dist_default.afterEach(function() {
			(0, import_testdouble$57.reset)();
		});
		dist_default("When init() is called and contacts have already been indexed they are not indexed again", async function() {
			(0, import_testdouble$57.when)(indexer._contact.getIndexTimestamp(contactList)).thenResolve(FULL_INDEXED_TIMESTAMP);
			(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
			await indexer.init({
				user,
				keyLoaderFacade
			});
			(0, import_testdouble$57.verify)(indexer._contact.indexFullContactList(contactList), { times: 0 });
		});
		dist_default("When init() is called and contacts have not been indexed before, they are indexed", async function() {
			(0, import_testdouble$57.when)(indexer._contact.getIndexTimestamp(contactList)).thenResolve(NOTHING_INDEXED_TIMESTAMP);
			(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
			await indexer.init({
				user,
				keyLoaderFacade
			});
			(0, import_testdouble$57.verify)(indexer._contact.indexFullContactList(contactList));
		});
		dist_default("When init() is called with a fresh db and contacts have not been indexed, they will be downloaded", async function() {
			(0, import_testdouble$57.when)(indexer._contact.getIndexTimestamp(contactList)).thenResolve(FULL_INDEXED_TIMESTAMP);
			const cacheInfo = {
				isPersistent: true,
				isNewOfflineDb: true,
				databaseKey: new Uint8Array([
					1,
					2,
					3
				])
			};
			indexer._mail.enableMailIndexing = (0, import_testdouble$57.func)();
			(0, import_testdouble$57.when)(indexer._mail.enableMailIndexing(import_testdouble$57.matchers.anything())).thenResolve(undefined);
			(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
			await indexer.init({
				user,
				keyLoaderFacade,
				cacheInfo
			});
			(0, import_testdouble$57.verify)(indexer._entity.loadAll(ContactTypeRef, contactList.contacts));
		});
		dist_default("When init() is called with a fresh db and contacts are not yet indexed, they will be indexed and not downloaded", async function() {
			(0, import_testdouble$57.when)(indexer._contact.getIndexTimestamp(contactList)).thenResolve(NOTHING_INDEXED_TIMESTAMP);
			const cacheInfo = {
				isPersistent: true,
				isNewOfflineDb: true,
				databaseKey: new Uint8Array([
					1,
					2,
					3
				])
			};
			indexer._mail.enableMailIndexing = (0, import_testdouble$57.func)();
			(0, import_testdouble$57.when)(indexer._mail.enableMailIndexing(import_testdouble$57.matchers.anything())).thenResolve(undefined);
			(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
			await indexer.init({
				user,
				keyLoaderFacade,
				cacheInfo
			});
			(0, import_testdouble$57.verify)(indexer._contact.indexFullContactList(contactList));
			(0, import_testdouble$57.verify)(indexer._entity.loadAll(ContactTypeRef, contactList.contacts), { times: 0 });
		});
		dist_default("When init() is called with a fresh db and the cache is not persisted the indexing is not enabled", async function() {
			(0, import_testdouble$57.when)(indexer._contact.getIndexTimestamp(contactList)).thenResolve(FULL_INDEXED_TIMESTAMP);
			const cacheInfo = {
				isPersistent: false,
				isNewOfflineDb: true,
				databaseKey: new Uint8Array([
					1,
					2,
					3
				])
			};
			indexer._mail.enableMailIndexing = (0, import_testdouble$57.func)();
			(0, import_testdouble$57.when)(indexer._mail.enableMailIndexing(import_testdouble$57.matchers.anything())).thenResolve(undefined);
			(0, import_testdouble$57.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(userGroupKey);
			await indexer.init({
				user,
				keyLoaderFacade,
				cacheInfo
			});
		});
	});
});

//#endregion
//#region tests/api/worker/search/DbStub.ts
var DbStub = class {
	_objectStores;
	indexingSupported;
	constructor() {
		this._objectStores = {};
		this.indexingSupported = true;
	}
	addObjectStore(name, autoIncrement, keyPath, index) {
		this._objectStores[osName(name)] = {
			content: {},
			autoIncrement,
			indexes: index || {},
			keyPath,
			lastId: null
		};
	}
	getObjectStore(name) {
		return this._objectStores[osName(name)];
	}
	createTransaction() {
		return new DbStubTransaction(this);
	}
};
function createSearchIndexDbStub() {
	const dbStub = new DbStub();
	dbStub.addObjectStore(SearchIndexOS, true);
	dbStub.addObjectStore(SearchIndexMetaDataOS, true, "id", { [SearchIndexWordsIndex]: "word" });
	dbStub.addObjectStore(ElementDataOS, false);
	dbStub.addObjectStore(GroupDataOS, false);
	return dbStub;
}
var DbStubTransaction = class {
	_dbStub;
	aborted;
	constructor(stub) {
		this._dbStub = stub;
		this.aborted = false;
	}
	getAll(objectStore) {
		const entries = Object.entries(this._dbStub.getObjectStore(objectStore).content).map(([key, value]) => {
			return {
				key,
				value
			};
		});
		return Promise.resolve(entries);
	}
	async get(objectStore, key, indexName) {
		return this.getSync(objectStore, key, indexName);
	}
	getSync(objectStore, key, indexName) {
		if (indexName) {
			const table = this._dbStub.getObjectStore(objectStore);
			const indexField = table.indexes[indexName];
			if (!indexField) throw new Error("No such index: " + indexName);
			const value = Object.values(table.content).map(downcast).find((value$1) => value$1[indexField] === key);
			return neverNull(value);
		} else return this._dbStub.getObjectStore(objectStore).content[key];
	}
	async getAsList(objectStore, key, indexName) {
		const result = await this.get(objectStore, key, indexName);
		return result ?? [];
	}
	put(objectStore, key, value) {
		const table = this._dbStub.getObjectStore(objectStore);
		if (table.keyPath) key = value[table.keyPath];
		if (key == null && table.autoIncrement) {
			const lastId = (table.lastId || 0) + 1;
			table.lastId = lastId;
			table.content[lastId] = value;
			if (table.keyPath) value[table.keyPath] = lastId;
			return Promise.resolve(lastId);
		} else if (key != null) {
			if (table.keyPath && table.autoIncrement) table.lastId = Math.max(table.lastId || 0, Number(key));
			table.content[key] = value;
			return Promise.resolve(key);
		} else return Promise.reject("Cannot put: no key provided, os: " + osName(objectStore) + ", value: " + JSON.stringify(value));
	}
	delete(objectStore, key) {
		delete this._dbStub.getObjectStore(objectStore).content[key];
		return Promise.resolve();
	}
	abort() {}
	wait() {
		return Promise.resolve();
	}
};

//#endregion
//#region tests/api/worker/search/IndexerCoreTest.ts
const mailTypeInfo$1 = typeRefToTypeInfo(MailTypeRef);
const contactTypeInfo$2 = typeRefToTypeInfo(ContactTypeRef);
function makeEntries(key, iv, n, baseTimestamp = 0) {
	const newEntries = [];
	for (let i = 0; i < n; i++) {
		const timestamp = baseTimestamp + i;
		const instanceIdB64 = timestampToGeneratedId(timestamp);
		const encId = encryptIndexKeyUint8Array(key, instanceIdB64, iv);
		newEntries.push({
			entry: concat(encId, new Uint8Array(0)),
			timestamp
		});
	}
	return newEntries;
}
function compareBinaryBlocks(actual, expected) {
	dist_default(Array.from(expected)).deepEquals(Array.from(actual));
}
dist_default.spec("IndexerCore test", () => {
	dist_default("createIndexEntriesForAttributes", async function() {
		let core = makeCore();
		let contact = createTestEntity(ContactTypeRef);
		contact._id = ["", "L-dNNLe----0"];
		contact.firstName = "Max Tim";
		contact.lastName = "Meier";
		contact.company = undefined;
		contact.comment = "Friend of Tim";
		const ContactModel = await resolveTypeReference(ContactTypeRef);
		let entries = core.createIndexEntriesForAttributes(contact, [
			{
				attribute: ContactModel.values["firstName"],
				value: () => contact.firstName
			},
			{
				attribute: ContactModel.values["company"],
				value: () => contact.company
			},
			{
				attribute: ContactModel.values["comment"],
				value: () => contact.comment
			}
		]);
		dist_default(entries.size).equals(4);
		dist_default(entries.get("max")).deepEquals([{
			id: "L-dNNLe----0",
			attribute: ContactModel.values["firstName"].id,
			positions: [0]
		}]);
		dist_default(entries.get("tim")).deepEquals([{
			id: "L-dNNLe----0",
			attribute: ContactModel.values["firstName"].id,
			positions: [1]
		}, {
			id: "L-dNNLe----0",
			attribute: ContactModel.values["comment"].id,
			positions: [2]
		}]);
		dist_default(entries.get("friend")).deepEquals([{
			id: "L-dNNLe----0",
			attribute: ContactModel.values["comment"].id,
			positions: [0]
		}]);
		dist_default(entries.get("of")).deepEquals([{
			id: "L-dNNLe----0",
			attribute: ContactModel.values["comment"].id,
			positions: [1]
		}]);
	});
	dist_default("encryptSearchIndexEntries", function() {
		const core = makeCore({ db: {
			key: aes256RandomKey(),
			iv: fixedIv
		} });
		const instanceId = ["L-dNNLe----0", "L-dNNLe----1"];
		const ownerGroupId = "ownerGroupId";
		const keyToIndexEntries = new Map([["a", [{
			id: "L-dNNLe----1",
			attribute: 5,
			positions: [0]
		}]], ["b", [{
			id: "L-dNNLe----1",
			attribute: 4,
			positions: [8, 27]
		}]]]);
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		core.encryptSearchIndexEntries(instanceId, ownerGroupId, keyToIndexEntries, indexUpdate);
		dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(1);
		const encIdB64 = encryptIndexKeyBase64(core.db.key, elementIdPart(instanceId), core.db.iv);
		let elementData = neverNull(indexUpdate.create.encInstanceIdToElementData.get(encIdB64));
		const { listId, encWordsB64, ownerGroup } = elementData;
		dist_default(listId).equals(listIdPart(instanceId));
		const wordB = decryptIndexKey(core.db.key, base64ToUint8Array(encWordsB64[1]), core.db.iv);
		dist_default(wordB).equals("b");
		dist_default(ownerGroupId).equals(ownerGroup);
		dist_default(indexUpdate.create.indexMap.size).equals(2);
		const aKey = encryptIndexKeyBase64(core.db.key, "a", core.db.iv);
		let encEntriesA = neverNull(indexUpdate.create.indexMap.get(aKey));
		dist_default(encEntriesA.length).equals(1);
		let entry = decryptSearchIndexEntry(core.db.key, encEntriesA[0].entry, core.db.iv);
		delete entry.encId;
		dist_default(entry).deepEquals({
			id: elementIdPart(instanceId),
			attribute: 5,
			positions: [0]
		});
		const bKey = encryptIndexKeyBase64(core.db.key, "b", core.db.iv);
		const encEntriesB = neverNull(indexUpdate.create.indexMap.get(bKey));
		dist_default(encEntriesB.length).equals(1);
		let entry2 = decryptSearchIndexEntry(core.db.key, encEntriesB[0].entry, core.db.iv);
		delete entry2.encId;
		dist_default(entry2).deepEquals({
			id: elementIdPart(instanceId),
			attribute: 4,
			positions: [8, 27]
		});
		let id2 = ["L-dNNLe----1", "L-dNNLe----2"];
		let keyToIndexEntries2 = new Map([["a", [{
			id: elementIdPart(id2),
			attribute: 2,
			positions: [7, 62]
		}]]]);
		core.encryptSearchIndexEntries(id2, ownerGroupId, keyToIndexEntries2, indexUpdate);
		dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(2);
		const yKey = encryptIndexKeyBase64(core.db.key, elementIdPart(id2), core.db.iv);
		let elementData2 = neverNull(indexUpdate.create.encInstanceIdToElementData.get(yKey));
		let listId2 = elementData2.listId;
		dist_default(listId2).equals(id2[0]);
		let words2 = decryptIndexKey(core.db.key, base64ToUint8Array(elementData2.encWordsB64[0]), core.db.iv);
		dist_default(words2).equals("a");
		dist_default(ownerGroupId).equals(elementData2.ownerGroup);
		encEntriesA = neverNull(indexUpdate.create.indexMap.get(encryptIndexKeyBase64(core.db.key, "a", core.db.iv)));
		dist_default(encEntriesA.length).equals(2);
		entry = downcast(decryptSearchIndexEntry(core.db.key, encEntriesA[0].entry, core.db.iv));
		delete entry.encId;
		dist_default(entry).deepEquals({
			id: elementIdPart(instanceId),
			attribute: 5,
			positions: [0]
		});
		const newEntry = decryptSearchIndexEntry(core.db.key, encEntriesA[1].entry, core.db.iv);
		delete newEntry.encId;
		dist_default(newEntry).deepEquals({
			id: elementIdPart(id2),
			attribute: 2,
			positions: [7, 62]
		});
	});
	dist_default("writeIndexUpdate _moveIndexedInstance", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		let encInstanceId = uint8ArrayToBase64(new Uint8Array([8]));
		indexUpdate.move.push({
			encInstanceId,
			newListId: "new-list"
		});
		let words = new Uint8Array(0);
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(ElementDataOS);
				dist_default(key).deepEquals(encInstanceId);
				return Promise.resolve([
					"old-list",
					words,
					groupId
				]);
			},
			put: (os, key, value) => {
				dist_default(os).equals(ElementDataOS);
				dist_default(key).deepEquals(encInstanceId);
				dist_default(value).deepEquals([
					"new-list",
					words,
					groupId
				]);
			}
		};
		const core = makeCore();
		await core._moveIndexedInstance(indexUpdate, transaction);
	});
	dist_default("writeIndexUpdate _moveIndexedInstance instance already deleted", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		let encInstanceId = uint8ArrayToBase64(new Uint8Array([8]));
		indexUpdate.move.push({
			encInstanceId,
			newListId: "new-list"
		});
		let words = new Uint8Array(0);
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(ElementDataOS);
				dist_default(key).deepEquals(encInstanceId);
				return Promise.resolve(null);
			},
			put: (os, key, value) => {
				throw new Error("instance does not exist, should not be moved!");
			}
		};
		const core = makeCore();
		await neverNull(core._moveIndexedInstance(indexUpdate, transaction));
	});
	dist_default("writeIndexUpdate _deleteIndexedInstance", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const instanceId = new Uint8Array(16).fill(1);
		const metaId = 3;
		let entry = concat(instanceId, new Uint8Array([
			4,
			7,
			6
		]));
		let other1 = concat(new Uint8Array(16).fill(2), new Uint8Array([1, 12]));
		let other2 = concat(instanceId, new Uint8Array([1, 12]));
		let encWord = uint8ArrayToBase64(new Uint8Array([
			7,
			8,
			23
		]));
		let encInstanceIdB64 = uint8ArrayToBase64(instanceId);
		indexUpdate.delete.searchMetaRowToEncInstanceIds.set(metaId, [{
			encInstanceId: instanceId,
			timestamp: 5,
			appId: 1,
			typeId: 1
		}]);
		indexUpdate.delete.encInstanceIds.push(encInstanceIdB64);
		const metaData = Object.freeze({
			id: metaId,
			word: encWord,
			rows: [{
				app: 1,
				type: 1,
				key: 1,
				size: 2,
				oldestElementTimestamp: 1
			}, {
				app: 1,
				type: 1,
				key: 2,
				size: 1,
				oldestElementTimestamp: 10
			}]
		});
		const core = makeCore();
		const encodedMetaData = encryptMetaData(core.db.key, metaData);
		let transaction = {
			get: (os, key) => {
				switch (os) {
					case SearchIndexMetaDataOS: return Promise.resolve(key === metaId ? Object.assign({}, encodedMetaData) : null);
					case SearchIndexOS: return Promise.resolve(key === 1 ? appendBinaryBlocks([entry, other1]) : appendBinaryBlocks([other2]));
				}
			},
			put: spy((os, key, value) => Promise.resolve()),
			delete: spy((os, key) => Promise.resolve())
		};
		await core._deleteIndexedInstance(indexUpdate, transaction);
		const expectedMeta = Object.assign({}, metaData, { rows: [{
			app: 1,
			type: 1,
			key: 1,
			size: 1,
			oldestElementTimestamp: 1
		}, {
			app: 1,
			type: 1,
			key: 2,
			size: 1,
			oldestElementTimestamp: 10
		}] });
		const metaPutInvocation = transaction.put.invocations[1];
		dist_default(JSON.stringify([
			metaPutInvocation[0],
			metaPutInvocation[1],
			decryptMetaData(core.db.key, metaPutInvocation[2])
		])).equals(JSON.stringify([
			SearchIndexMetaDataOS,
			null,
			expectedMeta
		]));
		dist_default(transaction.delete.invocations[0]).deepEquals([ElementDataOS, encInstanceIdB64]);
	});
	dist_default("writeIndexUpdate _deleteIndexedInstance last entry for word", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const instanceId = new Uint8Array(16).fill(8);
		const metaId = 3;
		const searchIndexEntryId = 1;
		const metaData = {
			id: metaId,
			word: "asasdla",
			rows: [{
				app: 1,
				type: 1,
				key: searchIndexEntryId,
				size: 2,
				oldestElementTimestamp: 1
			}]
		};
		let entry = concat(instanceId, new Uint8Array([
			4,
			7,
			6
		]));
		let encInstanceIdB64 = uint8ArrayToBase64(instanceId);
		indexUpdate.delete.searchMetaRowToEncInstanceIds.set(metaId, [{
			encInstanceId: instanceId,
			timestamp: 5,
			appId: 1,
			typeId: 1
		}]);
		indexUpdate.delete.encInstanceIds.push(encInstanceIdB64);
		const core = makeCore();
		let transaction = {
			get: (os, key) => {
				switch (os) {
					case SearchIndexMetaDataOS: return Promise.resolve(key === metaId ? encryptMetaData(core.db.key, metaData) : null);
					case SearchIndexOS: return Promise.resolve(key === searchIndexEntryId ? appendBinaryBlocks([entry, entry]) : null);
				}
			},
			put: spy((os, key, value) => Promise.resolve()),
			delete: spy((os, key) => Promise.resolve())
		};
		await core._deleteIndexedInstance(indexUpdate, transaction);
		dist_default(transaction.put.invocations).deepEquals([]);
		dist_default(transaction.delete.invocations).deepEquals([
			[ElementDataOS, encInstanceIdB64],
			[SearchIndexOS, 1],
			[SearchIndexMetaDataOS, metaId]
		]);
	});
	dist_default("writeIndexUpdate _deleteIndexedInstance instance already deleted", function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		let entry = concat(new Uint8Array(16), new Uint8Array([
			4,
			7,
			6
		]));
		indexUpdate.delete.searchMetaRowToEncInstanceIds.set(1, [{
			encInstanceId: getIdFromEncSearchIndexEntry(entry),
			timestamp: 1,
			appId: mailTypeInfo$1.appId,
			typeId: mailTypeInfo$1.typeId
		}]);
		indexUpdate.delete.encInstanceIds.push(uint8ArrayToBase64(getIdFromEncSearchIndexEntry(entry)));
		let transaction = {
			get: (os, key) => Promise.resolve(null),
			put: (os, key, value) => {
				throw new Error("instance does not exist, should not be moved!");
			},
			delete: spy(() => Promise.resolve())
		};
		const core = makeCore();
		return neverNull(core._deleteIndexedInstance(indexUpdate, transaction)).then(() => {
			dist_default(transaction.delete.invocations).deepEquals([[ElementDataOS, uint8ArrayToBase64(getIdFromEncSearchIndexEntry(entry))]]);
		});
	});
	dist_default("writeIndexUpdate _insertNewElementData", async function() {
		const groupId = "my-group";
		const listId = "list-id";
		const core = makeCore();
		const indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const encInstanceId = uint8ArrayToBase64(new Uint8Array(16));
		const encWord = uint8ArrayToBase64(new Uint8Array([
			1,
			2,
			3
		]));
		const searchIndexRowKey = 3;
		const elementDataSurrogate = {
			listId,
			encWordsB64: [encWord],
			ownerGroup: groupId
		};
		indexUpdate.create.encInstanceIdToElementData.set(encInstanceId, elementDataSurrogate);
		const transaction = {
			get: spy(() => Promise.resolve()),
			put: spy(() => Promise.resolve())
		};
		await neverNull(core._insertNewElementData(indexUpdate, transaction, { [encWord]: searchIndexRowKey }));
		const [[os, key, value]] = transaction.put.invocations;
		dist_default(os).equals(ElementDataOS);
		dist_default(key).equals(encInstanceId);
		const [listIdValue, encRowsValue, ownerGroupValue] = value;
		dist_default(listIdValue).equals(listId);
		dist_default(Array.from(unauthenticatedAesDecrypt(core.db.key, encRowsValue, true))).deepEquals(Array.from(new Uint8Array([searchIndexRowKey])));
		dist_default(ownerGroupValue).equals(groupId);
	});
	dist_default.spec("writeIndexUpdate _insertNewIndexEntries ", function() {
		const encWord = uint8ArrayToBase64(new Uint8Array([
			77,
			83,
			2,
			23
		]));
		let indexUpdate;
		let dbStub;
		let transaction;
		let core;
		dist_default.beforeEach(function() {
			indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
			dbStub = createSearchIndexDbStub();
			transaction = dbStub.createTransaction();
			core = makeCore();
		});
		dist_default("new word", async function() {
			let encInstanceId = new Uint8Array(16);
			let entry = concat(encInstanceId, new Uint8Array(0));
			indexUpdate.create.indexMap.set(encWord, [{
				timestamp: 1,
				entry
			}]);
			await core._insertNewIndexEntries(indexUpdate, transaction);
			dist_default(Array.from(transaction.getSync(SearchIndexOS, 1))).deepEquals(Array.from(appendBinaryBlocks([entry])));
			const decodedInsertedMeta = decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, 1));
			dist_default(decodedInsertedMeta).deepEquals({
				id: 1,
				word: encWord,
				rows: [{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 1,
					oldestElementTimestamp: 1
				}]
			});
		});
		dist_default("existing word, growing the first row", async function() {
			let encInstanceId = new Uint8Array(16);
			let newEntry = concat(encInstanceId, new Uint8Array(0));
			const { appId, typeId } = indexUpdate.typeInfo;
			const metaId = 3;
			const existingBlock = appendBinaryBlocks([new Uint8Array([2, 0])]);
			const searchIndexKey = 1;
			indexUpdate.create.indexMap.set(encWord, [{
				entry: newEntry,
				timestamp: 1
			}]);
			const searchIndexMeta = {
				id: metaId,
				word: encWord,
				rows: [{
					app: appId,
					type: typeId,
					key: searchIndexKey,
					size: 1,
					oldestElementTimestamp: 2
				}]
			};
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			transaction.put(SearchIndexOS, searchIndexKey, existingBlock);
			await core._insertNewIndexEntries(indexUpdate, transaction);
			dist_default(Array.from(transaction.getSync(SearchIndexOS, searchIndexKey))).deepEquals(Array.from(appendBinaryBlocks([newEntry], existingBlock)));
			const expectedMeta = Object.assign({}, searchIndexMeta, { rows: [{
				app: appId,
				type: typeId,
				key: 1,
				size: 2,
				oldestElementTimestamp: 1
			}] });
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, metaId))).deepEquals(expectedMeta);
		});
		dist_default("add older entities to a new row", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 200);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 800,
					oldestElementTimestamp: 150
				}, {
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 200
				}]
			};
			const existingRow = appendBinaryBlocks(makeEntries(core.db.key, core.db.iv, 800, 150).map((e) => e.entry));
			await transaction.put(SearchIndexOS, 1, existingRow);
			await transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			const newKey = 3;
			dbStub.getObjectStore(SearchIndexOS).lastId = 2;
			await core._insertNewIndexEntries(indexUpdate, transaction);
			const searchIndexContent = dbStub.getObjectStore(SearchIndexOS).content[newKey];
			dist_default(Array.from(searchIndexContent)).deepEquals(Array.from(appendBinaryBlocks(newEntries.slice(0, 150).map((e) => e.entry))));
			dist_default(Array.from(transaction.getSync(SearchIndexOS, 1))).deepEquals(Array.from(appendBinaryBlocks(newEntries.slice(150).map((e) => e.entry), existingRow)));
			const searchIndexMetaContent = dbStub.getObjectStore(SearchIndexMetaDataOS).content[searchIndexMeta.id];
			const decryptedMeta = decryptMetaData(core.db.key, searchIndexMetaContent);
			searchIndexMeta.rows[0].size = 850;
			searchIndexMeta.rows.unshift({
				app: mailTypeInfo$1.appId,
				type: mailTypeInfo$1.typeId,
				key: newKey,
				size: 150,
				oldestElementTimestamp: 0
			});
			dist_default(decryptedMeta).deepEquals(searchIndexMeta);
		});
		dist_default("add newer entities to the end", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 200, 201);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 600,
					oldestElementTimestamp: 100
				}, {
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 200
				}]
			};
			const existingRow = appendBinaryBlocks(makeEntries(core.db.key, core.db.iv, 600, 100).map((e) => e.entry));
			transaction.put(SearchIndexOS, 1, existingRow);
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			await core._insertNewIndexEntries(indexUpdate, transaction);
			dist_default(Array.from(transaction.getSync(SearchIndexOS, 1))).deepEquals(Array.from(appendBinaryBlocks(newEntries.map((e) => e.entry), existingRow)));
			searchIndexMeta.rows[0].size = 800;
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, 1))).deepEquals(searchIndexMeta);
		});
		dist_default("add newer entities to the existing row in the beginning", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 200, 201);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 600,
					oldestElementTimestamp: 300
				}, {
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 200
				}]
			};
			const existingRow = appendBinaryBlocks(makeEntries(core.db.key, core.db.iv, 600, 100).map((e) => e.entry));
			transaction.put(SearchIndexOS, 1, existingRow);
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			await core._insertNewIndexEntries(indexUpdate, transaction);
			dist_default(Array.from(transaction.getSync(SearchIndexOS, 1))).deepEquals(Array.from(appendBinaryBlocks(newEntries.map((e) => e.entry), existingRow)));
			searchIndexMeta.rows[0].size = 800;
			searchIndexMeta.rows[0].oldestElementTimestamp = 201;
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, 1))).deepEquals(searchIndexMeta);
		});
		dist_default("split row", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 250, 2001);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [
					{
						app: contactTypeInfo$2.appId,
						type: contactTypeInfo$2.typeId,
						key: 2,
						size: 800,
						oldestElementTimestamp: 200
					},
					{
						app: mailTypeInfo$1.appId,
						type: mailTypeInfo$1.typeId,
						key: 1,
						size: 600,
						oldestElementTimestamp: 1e3
					},
					{
						app: mailTypeInfo$1.appId,
						type: mailTypeInfo$1.typeId,
						key: 3,
						size: 800,
						oldestElementTimestamp: 2e3
					},
					{
						app: mailTypeInfo$1.appId,
						type: mailTypeInfo$1.typeId,
						key: 4,
						size: 600,
						oldestElementTimestamp: 3e3
					}
				]
			};
			const existingEntries = makeEntries(core.db.key, core.db.iv, 800, 2e3);
			const existingRow = appendBinaryBlocks(existingEntries.map((e) => e.entry).reverse());
			transaction.put(SearchIndexOS, 3, existingRow);
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			dbStub.getObjectStore(SearchIndexOS).lastId = 4;
			await core._insertNewIndexEntries(indexUpdate, transaction);
			const allEntries = existingEntries.concat(newEntries).sort((l, r) => l.timestamp - r.timestamp);
			const firstRowEntries = allEntries.slice(0, -999);
			const secondRowEntries = allEntries.slice(-999);
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 3), appendBinaryBlocks(firstRowEntries.map((e) => e.entry)));
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 5), appendBinaryBlocks(secondRowEntries.map((e) => e.entry)));
			searchIndexMeta.rows = [
				{
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 200
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 600,
					oldestElementTimestamp: 1e3
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 3,
					size: firstRowEntries.length,
					oldestElementTimestamp: 2e3
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 5,
					size: secondRowEntries.length,
					oldestElementTimestamp: secondRowEntries[0].timestamp
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 4,
					size: 600,
					oldestElementTimestamp: 3e3
				}
			];
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, searchIndexMeta.id))).deepEquals(searchIndexMeta);
		});
		dist_default("split last row", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 250, 2001);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [
					{
						app: mailTypeInfo$1.appId,
						type: mailTypeInfo$1.typeId,
						key: 1,
						size: 600,
						oldestElementTimestamp: 1e3
					},
					{
						app: mailTypeInfo$1.appId,
						type: mailTypeInfo$1.typeId,
						key: 3,
						size: 800,
						oldestElementTimestamp: 2e3
					},
					{
						app: contactTypeInfo$2.appId,
						type: contactTypeInfo$2.typeId,
						key: 2,
						size: 800,
						oldestElementTimestamp: 3e3
					}
				]
			};
			const existingEntries = makeEntries(core.db.key, core.db.iv, 800, 2e3);
			const existingRow = appendBinaryBlocks(existingEntries.map((e) => e.entry).reverse());
			transaction.put(SearchIndexOS, 3, existingRow);
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			dbStub.getObjectStore(SearchIndexOS).lastId = 4;
			await core._insertNewIndexEntries(indexUpdate, transaction);
			const allEntries = existingEntries.concat(newEntries).sort((l, r) => l.timestamp - r.timestamp);
			const firstRowEntries = allEntries.slice(0, 1e3);
			const secondRowEntries = allEntries.slice(1e3);
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 3), appendBinaryBlocks(firstRowEntries.map((e) => e.entry)));
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 5), appendBinaryBlocks(secondRowEntries.map((e) => e.entry)));
			searchIndexMeta.rows = [
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 1,
					size: 600,
					oldestElementTimestamp: 1e3
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 3,
					size: firstRowEntries.length,
					oldestElementTimestamp: 2e3
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 5,
					size: secondRowEntries.length,
					oldestElementTimestamp: secondRowEntries[0].timestamp
				},
				{
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 3e3
				}
			];
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, searchIndexMeta.id))).deepEquals(searchIndexMeta);
		});
		dist_default("split for big new row", async function() {
			const newEntries = makeEntries(core.db.key, core.db.iv, 2500, 2001);
			indexUpdate.create.indexMap.set(encWord, newEntries);
			const searchIndexMeta = {
				id: 1,
				word: encWord,
				rows: [{
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 500
				}]
			};
			transaction.put(SearchIndexMetaDataOS, null, encryptMetaData(core.db.key, searchIndexMeta));
			dbStub.getObjectStore(SearchIndexOS).lastId = 2;
			await core._insertNewIndexEntries(indexUpdate, transaction);
			const firstRow = newEntries.slice(0, 500);
			const secondRow = newEntries.slice(500, 1500);
			const thirdRow = newEntries.slice(1500, 2500);
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 3), appendBinaryBlocks(firstRow.map((e) => e.entry)));
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 4), appendBinaryBlocks(secondRow.map((e) => e.entry)));
			compareBinaryBlocks(transaction.getSync(SearchIndexOS, 5), appendBinaryBlocks(thirdRow.map((e) => e.entry)));
			searchIndexMeta.rows = [
				{
					app: contactTypeInfo$2.appId,
					type: contactTypeInfo$2.typeId,
					key: 2,
					size: 800,
					oldestElementTimestamp: 500
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 3,
					size: firstRow.length,
					oldestElementTimestamp: firstRow[0].timestamp
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 4,
					size: secondRow.length,
					oldestElementTimestamp: secondRow[0].timestamp
				},
				{
					app: mailTypeInfo$1.appId,
					type: mailTypeInfo$1.typeId,
					key: 5,
					size: thirdRow.length,
					oldestElementTimestamp: thirdRow[0].timestamp
				}
			];
			dist_default(decryptMetaData(core.db.key, transaction.getSync(SearchIndexMetaDataOS, searchIndexMeta.id))).deepEquals(searchIndexMeta);
		});
	});
	dist_default("writeIndexUpdate _updateGroupDataBatchId abort in case batch has been indexed already", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const batchId = "last-batch-id";
		const deferred = defer();
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(GroupDataOS);
				dist_default(key).equals(groupId);
				let groupData = { lastBatchIds: [
					"1",
					"last-batch-id",
					"3"
				] };
				return Promise.resolve(groupData);
			},
			aborted: true,
			abort: () => {
				deferred.resolve();
			}
		};
		const core = makeCore();
		core._updateGroupDataBatchId(groupId, batchId, transaction);
		await deferred.promise;
	});
	dist_default("writeIndexUpdate _updateGroupDataBatchId", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const deferred = defer();
		const batchId = "2";
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(GroupDataOS);
				dist_default(key).equals(groupId);
				let groupData = { lastBatchIds: [
					"4",
					"3",
					"1"
				] };
				return Promise.resolve(groupData);
			},
			aborted: false,
			put: (os, key, value) => {
				dist_default(os).equals(GroupDataOS);
				dist_default(key).equals(groupId);
				dist_default(JSON.stringify(value)).equals(JSON.stringify({ lastBatchIds: [
					"4",
					"3",
					"2",
					"1"
				] }));
				deferred.resolve();
			}
		};
		const core = makeCore();
		core._updateGroupDataBatchId(groupId, batchId, transaction);
		await deferred.promise;
	});
	dist_default("writeIndexUpdate", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const indexTimestamp = Date.now();
		let waitForTransaction = false;
		let transaction = { wait: () => {
			waitForTransaction = true;
			return Promise.resolve();
		} };
		const encWordToMetaRow = {};
		const core = makeCore({ transaction }, (mocked) => {
			mocked._moveIndexedInstance = spy(() => PromisableWrapper.from(undefined));
			mocked._deleteIndexedInstance = spy();
			mocked._insertNewElementData = spy(() => Promise.resolve());
			mocked._insertNewIndexEntries = spy(() => Promise.resolve(encWordToMetaRow));
			mocked._updateGroupDataIndexTimestamp = spy();
		});
		const groupUpdate = [{
			groupId,
			indexTimestamp
		}];
		await core.writeIndexUpdate(groupUpdate, indexUpdate);
		dist_default(core._moveIndexedInstance.callCount).equals(1);
		dist_default(core._moveIndexedInstance.args).deepEquals([indexUpdate, transaction]);
		dist_default(core._deleteIndexedInstance.callCount).equals(1);
		dist_default(core._deleteIndexedInstance.args).deepEquals([indexUpdate, transaction]);
		dist_default(core._insertNewElementData.callCount).equals(1);
		dist_default(core._insertNewElementData.args).deepEquals([
			indexUpdate,
			transaction,
			encWordToMetaRow
		]);
		dist_default(core._insertNewIndexEntries.callCount).equals(1);
		dist_default(core._insertNewIndexEntries.args).deepEquals([indexUpdate, transaction]);
		dist_default(core._updateGroupDataIndexTimestamp.callCount).equals(1);
		dist_default(core._updateGroupDataIndexTimestamp.args).deepEquals([groupUpdate, transaction]);
		dist_default(waitForTransaction).equals(true);
	});
	dist_default("processDeleted", async function() {
		const groupId = "my-group";
		const indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		const instanceId = "L-dNNLe----1";
		const instanceIdTimestamp = generatedIdToTimestamp(instanceId);
		const event = createTestEntity(EntityUpdateTypeRef);
		event.application = MailTypeRef.app;
		event.type = MailTypeRef.type;
		const metaRowId = 3;
		const anotherMetaRowId = 4;
		event.instanceId = instanceId;
		const transaction = { get: (os, key) => {
			dist_default(os).equals(ElementDataOS);
			dist_default(Array.from(key)).deepEquals(Array.from(encInstanceId));
			return Promise.resolve(elementData);
		} };
		const core = makeCore({ transaction });
		const encInstanceId = encryptIndexKeyBase64(core.db.key, instanceId, core.db.iv);
		const listId = "list-id";
		const elementData = [
			listId,
			aesEncrypt(core.db.key, new Uint8Array([metaRowId, anotherMetaRowId]), random.generateRandomData(IV_BYTE_LENGTH), true),
			groupId
		];
		const otherId = new Uint8Array(16).fill(88);
		indexUpdate.delete.searchMetaRowToEncInstanceIds.set(metaRowId, [{
			encInstanceId: otherId,
			appId: indexUpdate.typeInfo.appId,
			typeId: indexUpdate.typeInfo.typeId,
			timestamp: 1
		}]);
		await core._processDeleted(event, indexUpdate);
		dist_default(indexUpdate.delete.encInstanceIds).deepEquals([encInstanceId]);
		dist_default(indexUpdate.delete.searchMetaRowToEncInstanceIds.size).equals(2);
		dist_default(JSON.stringify(indexUpdate.delete.searchMetaRowToEncInstanceIds.get(metaRowId))).equals(JSON.stringify([{
			encInstanceId: otherId,
			appId: indexUpdate.typeInfo.appId,
			typeId: indexUpdate.typeInfo.typeId,
			timestamp: 1
		}, {
			encInstanceId: base64ToUint8Array(encInstanceId),
			appId: indexUpdate.typeInfo.appId,
			typeId: indexUpdate.typeInfo.typeId,
			timestamp: instanceIdTimestamp
		}]));
		let ids2 = neverNull(indexUpdate.delete.searchMetaRowToEncInstanceIds.get(anotherMetaRowId));
		dist_default(ids2.length).equals(1);
		dist_default(Array.from(ids2[0].encInstanceId)).deepEquals(Array.from(base64ToUint8Array(encInstanceId)));
		dist_default(indexUpdate.delete.encInstanceIds.length).equals(1);
		dist_default(Array.from(indexUpdate.delete.encInstanceIds[0])).deepEquals(Array.from(encInstanceId));
	});
	dist_default("processDeleted already deleted", async function() {
		let groupId = "my-group";
		let indexUpdate = _createNewIndexUpdate(mailTypeInfo$1);
		let instanceId = "123";
		let event = createTestEntity(EntityUpdateTypeRef);
		event.instanceId = instanceId;
		event.application = MailTypeRef.app;
		event.type = MailTypeRef.type;
		let transaction = { get: (os, key) => {
			dist_default(os).equals(ElementDataOS);
			dist_default(Array.from(key)).deepEquals(Array.from(encInstanceId));
			return Promise.resolve();
		} };
		const core = makeCore({
			queue: downcast({ _eventQueue: [] }),
			transaction
		});
		let encInstanceId = encryptIndexKeyBase64(core.db.key, instanceId, core.db.iv);
		await core._processDeleted(event, indexUpdate);
		dist_default(indexUpdate.delete.searchMetaRowToEncInstanceIds.size).equals(0);
		dist_default(indexUpdate.delete.encInstanceIds.length).equals(0);
	});
	dist_default("stopProcessing", async function() {
		const queue = downcast({
			_eventQueue: [],
			clear: spy()
		});
		const deferred = defer();
		const transaction = { abort: noOp };
		const core = makeCore({
			queue,
			db: {
				key: aes256RandomKey(),
				iv: fixedIv,
				dbFacade: { createTransaction: () => deferred.promise },
				initialized: Promise.resolve()
			}
		});
		const result = core._writeIndexUpdate({
			move: [],
			delete: {
				searchMetaRowToEncInstanceIds: new Map(),
				encInstanceIds: []
			},
			create: {
				encInstanceIdToElementData: new Map(),
				indexMap: new Map()
			}
		}, null);
		core.stopProcessing();
		dist_default(queue.clear.invocations).deepEquals([[]])("Should clear queue");
		try {
			deferred.resolve(transaction);
			await result;
			dist_default(false).equals(true)("Should throw an error");
		} catch (e) {
			dist_default(e instanceof CancelledError).equals(true)("Should throw cancelledError");
		}
	});
	dist_default("startProcessing", async function() {
		const queue = downcast({
			_eventQueue: [
				1,
				2,
				3
			],
			clear: spy()
		});
		const transaction = downcast({
			get: () => Promise.resolve(() => ({ indexTimestamp: Date.now() })),
			put: () => Promise.resolve(null),
			wait: () => Promise.resolve()
		});
		const core = makeCore({
			queue,
			transaction
		});
		core.stopProcessing();
		core.startProcessing();
		await core.writeIndexUpdate([{
			groupId: "group-id",
			indexTimestamp: 0
		}], _createNewIndexUpdate(mailTypeInfo$1));
	});
});

//#endregion
//#region tests/api/worker/search/ContactIndexerTest.ts
const dbMock$1 = { iv: fixedIv };
const contactTypeInfo$1 = typeRefToTypeInfo(ContactTypeRef);
dist_default.spec("ContactIndexer test", () => {
	let suggestionFacadeMock;
	dist_default.beforeEach(function() {
		suggestionFacadeMock = {};
		suggestionFacadeMock.addSuggestions = spy();
		suggestionFacadeMock.store = spy(() => Promise.resolve());
	});
	dist_default("createContactIndexEntries without entries", function() {
		let c = createTestEntity(ContactTypeRef);
		let contact = new ContactIndexer(makeCore(), null, null, suggestionFacadeMock);
		let keyToIndexEntries = contact.createContactIndexEntries(c);
		dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(1);
		dist_default(suggestionFacadeMock.addSuggestions.args[0].join(",")).equals("");
		dist_default(keyToIndexEntries.size).equals(0);
	});
	dist_default("createContactIndexEntries with one entry", function() {
		let c = createTestEntity(ContactTypeRef);
		c.company = "test";
		let contact = new ContactIndexer(makeCore(), null, null, suggestionFacadeMock);
		let keyToIndexEntries = contact.createContactIndexEntries(c);
		dist_default(suggestionFacadeMock.addSuggestions.args[0].join(",")).equals("");
		dist_default(keyToIndexEntries.size).equals(1);
	});
	dist_default("createContactIndexEntries", async function() {
		let core = { createIndexEntriesForAttributes: spy() };
		const contactIndexer = new ContactIndexer(core, dbMock$1, null, suggestionFacadeMock);
		let addresses = [createTestEntity(ContactAddressTypeRef), createTestEntity(ContactAddressTypeRef)];
		addresses[0].address = "A0";
		addresses[1].address = "A1";
		let mailAddresses = [createTestEntity(ContactMailAddressTypeRef), createTestEntity(ContactMailAddressTypeRef)];
		mailAddresses[0].address = "MA0";
		mailAddresses[1].address = "MA1";
		let phoneNumbers = [createTestEntity(ContactPhoneNumberTypeRef), createTestEntity(ContactPhoneNumberTypeRef)];
		phoneNumbers[0].number = "PN0";
		phoneNumbers[1].number = "PN1";
		let socialIds = [createTestEntity(ContactSocialIdTypeRef), createTestEntity(ContactSocialIdTypeRef)];
		socialIds[0].socialId = "S0";
		socialIds[1].socialId = "S1";
		let c = createTestEntity(ContactTypeRef);
		c.firstName = "FN";
		c.lastName = "LN";
		c.nickname = "NN";
		c.role = "R";
		c.title = "T";
		c.comment = "C";
		c.company = "co";
		c.addresses = addresses;
		c.mailAddresses = mailAddresses;
		c.phoneNumbers = phoneNumbers;
		c.socialIds = [];
		contactIndexer.createContactIndexEntries(c);
		dist_default(suggestionFacadeMock.addSuggestions.args[0].join(",")).equals("fn,ln,ma0,ma1");
		let args = core.createIndexEntriesForAttributes.args;
		let attributeHandlers = core.createIndexEntriesForAttributes.args[1];
		dist_default(args[0]).equals(c);
		let attributes = attributeHandlers.map((h) => {
			return {
				attribute: h.attribute.id,
				value: h.value()
			};
		});
		const ContactModel = await resolveTypeReference(ContactTypeRef);
		dist_default(attributes).deepEquals([
			{
				attribute: ContactModel.values["firstName"].id,
				value: "FN"
			},
			{
				attribute: ContactModel.values["lastName"].id,
				value: "LN"
			},
			{
				attribute: ContactModel.values["nickname"].id,
				value: "NN"
			},
			{
				attribute: ContactModel.values["role"].id,
				value: "R"
			},
			{
				attribute: ContactModel.values["title"].id,
				value: "T"
			},
			{
				attribute: ContactModel.values["comment"].id,
				value: "C"
			},
			{
				attribute: ContactModel.values["company"].id,
				value: "co"
			},
			{
				attribute: ContactModel.associations["addresses"].id,
				value: "A0,A1"
			},
			{
				attribute: ContactModel.associations["mailAddresses"].id,
				value: "MA0,MA1"
			},
			{
				attribute: ContactModel.associations["phoneNumbers"].id,
				value: "PN0,PN1"
			},
			{
				attribute: ContactModel.associations["socialIds"].id,
				value: ""
			}
		]);
	});
	dist_default("processNewContact", async function() {
		let contact = createTestEntity(ContactTypeRef);
		let keyToIndexEntries = new Map();
		let indexer = { createIndexEntriesForAttributes: () => keyToIndexEntries };
		let entity = { load: spy(() => Promise.resolve(contact)) };
		const contactIndexer = new ContactIndexer(indexer, dbMock$1, entity, suggestionFacadeMock);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		const result = await contactIndexer.processNewContact(event);
		dist_default(result).deepEquals({
			contact,
			keyToIndexEntries
		});
		dist_default(contactIndexer._entity.load.args[0]).equals(ContactTypeRef);
		dist_default(contactIndexer._entity.load.args[1]).deepEquals([event.instanceListId, event.instanceId]);
		dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(1);
		dist_default(suggestionFacadeMock.addSuggestions.args[0].join(",")).equals("");
		dist_default(suggestionFacadeMock.store.callCount).equals(1);
	});
	dist_default("processNewContact catches NotFoundError", function() {
		let core = { createIndexEntriesForAttributes: () => {} };
		let entity = { load: () => Promise.reject(new NotFoundError("blah")) };
		const contactIndexer = new ContactIndexer(core, dbMock$1, entity, suggestionFacadeMock);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		return contactIndexer.processNewContact(event).then((result) => {
			dist_default(result).equals(null);
			dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(0);
		});
	});
	dist_default("processNewContact catches NotAuthorizedError", function() {
		let indexer = { createIndexEntriesForAttributes: () => {} };
		let entity = { load: () => Promise.reject(new NotAuthorizedError("blah")) };
		const contactIndexer = new ContactIndexer(indexer, dbMock$1, entity, suggestionFacadeMock);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		return contactIndexer.processNewContact(event).then((result) => {
			dist_default(result).equals(null);
			dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(0);
		});
	});
	dist_default("processNewContact passes other Errors", async function() {
		let core = { createIndexEntriesForAttributes: () => {} };
		let entity = { load: () => Promise.reject(new Error("blah")) };
		const contactIndexer = new ContactIndexer(core, dbMock$1, entity, suggestionFacadeMock);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		await contactIndexer.processNewContact(event).catch((e) => {
			dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(0);
		});
	});
	dist_default("indexFullContactList", function() {
		let groupData = { indexTimestamp: NOTHING_INDEXED_TIMESTAMP };
		let transaction = downcast({ get: (os, groupId) => {
			if (os != GroupDataOS || groupId != contactList$1._ownerGroup) throw new Error("unexpected params " + os + " " + groupId);
			return Promise.resolve(groupData);
		} });
		const core = makeCore({ transaction }, (mocked) => {
			mocked.writeIndexUpdate = spy();
		});
		let userGroupId$1 = "userGroupId";
		let contactList$1 = createTestEntity(ContactListTypeRef);
		contactList$1._ownerGroup = "ownerGroupId";
		contactList$1.contacts = "contactListId";
		let contacts$1 = [createTestEntity(ContactTypeRef), createTestEntity(ContactTypeRef)];
		contacts$1[0]._id = [contactList$1.contacts, "c0"];
		contacts$1[0]._ownerGroup = "c0owner";
		contacts$1[1]._id = [contactList$1.contacts, "c1"];
		contacts$1[1]._ownerGroup = "c1owner";
		let entity = {
			loadRoot: (type, groupId) => {
				if (type != ContactListTypeRef || groupId != userGroupId$1) throw new Error("unexpected params " + type + " " + groupId);
				return Promise.resolve(contactList$1);
			},
			loadAll: (type, listId) => {
				if (type != ContactTypeRef || listId != contactList$1.contacts) throw new Error("unexpected params " + type + " " + listId);
				return Promise.resolve(contacts$1);
			}
		};
		const contactIndexer = new ContactIndexer(core, core.db, entity, suggestionFacadeMock);
		return contactIndexer.indexFullContactList(contactList$1).then(() => {
			const [[{ groupId, indexTimestamp }], indexUpdate] = core.writeIndexUpdate.args;
			dist_default(indexTimestamp).equals(FULL_INDEXED_TIMESTAMP);
			dist_default(groupId).equals(contactList$1._ownerGroup);
			let expectedKeys = [encryptIndexKeyBase64(core.db.key, contacts$1[0]._id[1], fixedIv), encryptIndexKeyBase64(core.db.key, contacts$1[1]._id[1], fixedIv)];
			dist_default(Array.from(indexUpdate.create.encInstanceIdToElementData.keys())).deepEquals(expectedKeys);
			dist_default(suggestionFacadeMock.addSuggestions.callCount).equals(contacts$1.length);
			dist_default(suggestionFacadeMock.store.callCount).equals(1);
		});
	});
	dist_default("processEntityEvents new contact", async function() {
		const core = makeCore({}, (mocked) => {
			mocked.writeIndexUpdate = spy();
			mocked._processDeleted = spy();
		});
		let contact = createTestEntity(ContactTypeRef);
		contact._id = ["contact-list", "L-dNNLe----0"];
		let entity = { load: (type, id) => {
			if (type == ContactTypeRef && isSameId(id, contact._id)) return Promise.resolve(contact);
			throw new Error("Not found " + JSON.stringify(type) + " / " + JSON.stringify(id));
		} };
		const indexer = new ContactIndexer(core, core.db, entity, suggestionFacadeMock);
		let indexUpdate = _createNewIndexUpdate(contactTypeInfo$1);
		let events = [createUpdate$1(OperationType.CREATE, "contact-list", "L-dNNLe----0")];
		await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
		dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(1);
		dist_default(indexUpdate.move.length).equals(0);
		dist_default(core._processDeleted.callCount).equals(0);
	});
	dist_default("processEntityEvents update contact", function() {
		const core = makeCore({}, (mocked) => {
			mocked.writeIndexUpdate = spy();
			mocked._processDeleted = spy();
		});
		let contact = createTestEntity(ContactTypeRef);
		contact._id = ["contact-list", "L-dNNLe----0"];
		let entity = { load: (type, id) => {
			if (type == ContactTypeRef && isSameId(id, contact._id)) return Promise.resolve(contact);
			throw new Error("Not found " + JSON.stringify(type) + " / " + JSON.stringify(id));
		} };
		const indexer = new ContactIndexer(core, core.db, entity, suggestionFacadeMock);
		let indexUpdate = _createNewIndexUpdate(contactTypeInfo$1);
		let events = [createUpdate$1(OperationType.UPDATE, "contact-list", "L-dNNLe----0")];
		return indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate).then(() => {
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(1);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(core._processDeleted.callCount).equals(1);
			dist_default(core._processDeleted.args).deepEquals([events[0], indexUpdate]);
		});
	});
	dist_default("processEntityEvents delete contact", function() {
		const core = makeCore({}, (mocked) => {
			mocked.writeIndexUpdate = spy();
			mocked._processDeleted = spy();
		});
		let contact = createTestEntity(ContactTypeRef);
		contact._id = ["contact-list", "1"];
		let entity = { load: (type, id) => {
			if (type == ContactTypeRef && isSameId(id, contact._id)) return Promise.resolve(contact);
			throw new Error("Not found " + JSON.stringify(type) + " / " + JSON.stringify(id));
		} };
		const indexer = new ContactIndexer(core, core.db, entity, suggestionFacadeMock);
		let indexUpdate = _createNewIndexUpdate(contactTypeInfo$1);
		let events = [createUpdate$1(OperationType.DELETE, "contact-list", "1")];
		return indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate).then(() => {
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(0);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(core._processDeleted.callCount).equals(1);
			dist_default(core._processDeleted.args).deepEquals([events[0], indexUpdate]);
		});
	});
});
function createUpdate$1(type, listId, id) {
	let update = createTestEntity(EntityUpdateTypeRef);
	update.operation = type;
	update.instanceListId = listId;
	update.instanceId = id;
	return update;
}

//#endregion
//#region tests/api/worker/search/MailIndexerTest.ts
var import_testdouble$56 = __toESM(require_testdouble(), 1);
var FixedDateProvider = class {
	now;
	constructor(now$1) {
		this.now = now$1;
	}
	getStartOfDayShiftedBy(shiftedBy) {
		const date = getDayShifted(new Date(this.now), shiftedBy);
		date.setUTCHours(0, 0, 0, 0);
		return date;
	}
};
const dbMock = { iv: fixedIv };
const mailId = "L-dNNLe----0";
dist_default.spec("MailIndexer test", () => {
	let entityMock;
	let entityClient$1;
	let bulkMailLoader;
	let dateProvider$1;
	let mailFacade;
	dist_default.beforeEach(function() {
		entityMock = new EntityRestClientMock();
		entityClient$1 = new EntityClient(entityMock);
		bulkMailLoader = new BulkMailLoader(entityClient$1, new EntityClient(entityMock), (0, import_testdouble$56.object)());
		dateProvider$1 = new LocalTimeDateProvider();
		mailFacade = (0, import_testdouble$56.object)();
	});
	dist_default("createMailIndexEntries without entries", function() {
		let mail = createTestEntity(MailTypeRef);
		let mailDetails = createTestEntity(MailDetailsTypeRef, {
			body: createTestEntity(BodyTypeRef),
			recipients: createTestEntity(RecipientsTypeRef)
		});
		let files = [createTestEntity(FileTypeRef)];
		let indexer = new MailIndexer(new IndexerCore(dbMock, null, browserDataStub), null, null, null, null, dateProvider$1, mailFacade);
		let keyToIndexEntries = indexer.createMailIndexEntries(mail, mailDetails, files);
		dist_default(keyToIndexEntries.size).equals(0);
	});
	dist_default("createMailIndexEntries with one entry", function() {
		let mail = createTestEntity(MailTypeRef);
		mail.subject = "Hello";
		let mailDetails = createTestEntity(MailDetailsTypeRef, {
			body: createTestEntity(BodyTypeRef),
			recipients: createTestEntity(RecipientsTypeRef)
		});
		let files = [createTestEntity(FileTypeRef)];
		let indexer = new MailIndexer(new IndexerCore(dbMock, null, browserDataStub), null, null, null, null, dateProvider$1, mailFacade);
		let keyToIndexEntries = indexer.createMailIndexEntries(mail, mailDetails, files);
		dist_default(keyToIndexEntries.size).equals(1);
	});
	dist_default("createMailIndexEntries", async function() {
		let core = {
			createIndexEntriesForAttributes: spy(),
			_stats: {}
		};
		let indexer = new MailIndexer(core, dbMock, null, null, null, dateProvider$1, mailFacade);
		let toRecipients = [createTestEntity(MailAddressTypeRef), createTestEntity(MailAddressTypeRef)];
		toRecipients[0].address = "tr0A";
		toRecipients[0].name = "tr0N";
		toRecipients[1].address = "tr1A";
		toRecipients[1].name = "tr1N";
		let ccRecipients = [createTestEntity(MailAddressTypeRef), createTestEntity(MailAddressTypeRef)];
		ccRecipients[0].address = "ccr0A";
		ccRecipients[0].name = "ccr0N";
		ccRecipients[1].address = "ccr1A";
		ccRecipients[1].name = "ccr1N";
		let bccRecipients = [createTestEntity(MailAddressTypeRef), createTestEntity(MailAddressTypeRef)];
		bccRecipients[0].address = "bccr0A";
		bccRecipients[0].name = "bccr0N";
		bccRecipients[1].address = "bccr1A";
		bccRecipients[1].name = "bccr1N";
		let replyTo = createTestEntity(EncryptedMailAddressTypeRef);
		replyTo.address = "rToA";
		replyTo.address = "rToN";
		let sender = createTestEntity(MailAddressTypeRef);
		sender.address = "SA";
		sender.name = "SN";
		let mail = createTestEntity(MailTypeRef);
		mail.differentEnvelopeSender = "ES";
		mail.subject = "Su";
		const recipients = createTestEntity(RecipientsTypeRef);
		recipients.bccRecipients = bccRecipients;
		recipients.ccRecipients = ccRecipients;
		recipients.toRecipients = toRecipients;
		mail.sender = sender;
		mail.mailDetails = ["details-list-id", "details-id"];
		let mailDetails = createTestEntity(MailDetailsTypeRef, {
			_id: "details-id",
			body: createTestEntity(BodyTypeRef, { text: "BT" }),
			recipients,
			replyTos: [replyTo]
		});
		let files = [createTestEntity(FileTypeRef)];
		files[0].mimeType = "binary";
		files[0].name = "FN";
		indexer.createMailIndexEntries(mail, mailDetails, files);
		let args = core.createIndexEntriesForAttributes.args;
		dist_default(args[0]).equals(mail);
		let attributeHandlers = core.createIndexEntriesForAttributes.args[1];
		let attributes = attributeHandlers.map((h) => {
			return {
				attribute: h.attribute.id,
				value: h.value()
			};
		});
		const MailModel$1 = await resolveTypeReference(MailTypeRef);
		dist_default(JSON.stringify(attributes)).equals(JSON.stringify([
			{
				attribute: MailModel$1.values["subject"].id,
				value: "Su"
			},
			{
				attribute: LEGACY_TO_RECIPIENTS_ID,
				value: "tr0N <tr0A>,tr1N <tr1A>"
			},
			{
				attribute: LEGACY_CC_RECIPIENTS_ID,
				value: "ccr0N <ccr0A>,ccr1N <ccr1A>"
			},
			{
				attribute: LEGACY_BCC_RECIPIENTS_ID,
				value: "bccr0N <bccr0A>,bccr1N <bccr1A>"
			},
			{
				attribute: MailModel$1.associations["sender"].id,
				value: "SN <SA>"
			},
			{
				attribute: LEGACY_BODY_ID,
				value: "BT"
			},
			{
				attribute: MailModel$1.associations["attachments"].id,
				value: "FN"
			}
		]));
	});
	dist_default("processNewMail", function() {
		const [mailListId, mailElementId] = ["mail-list-id", "mail-element-id"];
		const { mail, mailDetailsBlob, files } = createMailInstances(mailFacade, [mailListId, mailElementId], ["details-list-id", "details-id"], ["file-list-id", "file-id"]);
		let keyToIndexEntries = new Map();
		let event = {
			instanceListId: mailListId,
			instanceId: mailElementId
		};
		entityMock.addListInstances(mail, ...files);
		entityMock.addBlobInstances(mailDetailsBlob);
		let indexer = mock(new MailIndexer(null, dbMock, null, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade), (mocked) => {
			mocked.createMailIndexEntries = spy((mailParam, detailsParam, filesParam) => {
				dist_default(mailParam).deepEquals(mail);
				dist_default(detailsParam).deepEquals(mailDetailsBlob.details);
				dist_default(filesParam).deepEquals(files);
				return keyToIndexEntries;
			});
		});
		return indexer.processNewMail([event.instanceListId, event.instanceId]).then((result) => {
			dist_default(indexer.createMailIndexEntries.callCount).equals(1);
			dist_default(result).deepEquals({
				mail,
				keyToIndexEntries
			});
		});
	});
	dist_default("processNewMail catches NotFoundError", async function() {
		const indexer = new MailIndexer(null, null, null, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		const result = await indexer.processNewMail([event.instanceListId, event.instanceId]);
		dist_default(result).equals(null);
	});
	dist_default("processNewMail catches NotAuthorizedError", function() {
		entityMock.setElementException("eid", new NotAuthorizedError("blah"));
		const indexer = new MailIndexer(null, null, null, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		return indexer.processNewMail([event.instanceListId, event.instanceId]).then((result) => {
			dist_default(result).equals(null);
		});
	});
	dist_default("processNewMail passes other Errors", async function() {
		entityMock.setListElementException(["lid", "eid"], new Error("blah"));
		const indexer = new MailIndexer(null, null, null, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
		let event = {
			instanceListId: "lid",
			instanceId: "eid"
		};
		await dist_default(() => indexer.processNewMail([event.instanceListId, event.instanceId])).asyncThrows(Error);
	});
	dist_default("processMovedMail", async function() {
		let event = {
			instanceListId: "new-list-id",
			instanceId: "eid"
		};
		let elementData = [
			"old-list-id",
			new Uint8Array(0),
			"owner-group-id"
		];
		let db = {
			key: aes256RandomKey(),
			iv: fixedIv,
			dbFacade: { createTransaction: () => Promise.resolve(transaction) }
		};
		let encInstanceId = encryptIndexKeyBase64(db.key, event.instanceId, fixedIv);
		let transaction = { get: (os, id) => {
			dist_default(os).equals(ElementDataOS);
			dist_default(Array.from(id)).deepEquals(Array.from(encInstanceId));
			return Promise.resolve(elementData);
		} };
		const indexer = new MailIndexer(null, db, null, null, null, dateProvider$1, mailFacade);
		let indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef));
		await indexer.processMovedMail(event, indexUpdate);
		dist_default(indexUpdate.move.length).equals(1);
		dist_default(Array.from(indexUpdate.move[0].encInstanceId)).deepEquals(Array.from(encInstanceId));
		dist_default(indexUpdate.move[0].newListId).equals(event.instanceListId);
	});
	dist_default("processMovedMail that does not exist", async function() {
		let transaction = { get: (os, id) => {
			dist_default(os).equals(ElementDataOS);
			dist_default(Array.from(id)).deepEquals(Array.from(encInstanceId));
			return Promise.resolve(null);
		} };
		let db = {
			key: aes256RandomKey(),
			iv: fixedIv,
			dbFacade: { createTransaction: () => Promise.resolve(transaction) }
		};
		let event = {
			instanceListId: "new-list-id",
			instanceId: "eid"
		};
		let encInstanceId = encryptIndexKeyBase64(db.key, event.instanceId, fixedIv);
		const core = { encryptSearchIndexEntries: spy() };
		const indexer = new MailIndexer(core, db, null, null, null, dateProvider$1, mailFacade);
		let result = {
			mail: {
				_id: "mail-id",
				_ownerGroup: "owner-group"
			},
			keyToIndexEntries: new Map()
		};
		indexer.processNewMail = spy(() => Promise.resolve(result));
		let indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef));
		await indexer.processMovedMail(event, indexUpdate);
		dist_default(indexUpdate.move.length).equals(0);
		dist_default(indexer.processNewMail.callCount).equals(1);
		dist_default(core.encryptSearchIndexEntries.callCount).equals(1);
		dist_default(core.encryptSearchIndexEntries.args).deepEquals([
			result.mail._id,
			result.mail._ownerGroup,
			result.keyToIndexEntries,
			indexUpdate
		]);
	});
	dist_default("enableMailIndexing", async function() {
		let metadata = {};
		let transaction = {
			get: (os, key) => {
				dist_default(os).equals(MetaDataOS);
				dist_default(key).equals(Metadata.mailIndexingEnabled);
				return Promise.resolve(false);
			},
			put: (os, key, value) => {
				dist_default(os).equals(MetaDataOS);
				metadata[key] = value;
			},
			wait: () => Promise.resolve()
		};
		let user = createTestEntity(UserTypeRef);
		user.memberships.push(createTestEntity(GroupMembershipTypeRef));
		user.memberships[0].groupType = GroupType.Mail;
		let spamFolder = createTestEntity(MailFolderTypeRef);
		spamFolder.mails = "mail-list-id";
		let db = {
			key: aes256RandomKey(),
			dbFacade: { createTransaction: () => Promise.resolve(transaction) }
		};
		const now$1 = 1554720827674;
		const beforeNowInterval = 15522624e5;
		const dateProvider$2 = new FixedDateProvider(now$1);
		const indexer = mock(new MailIndexer(null, db, null, null, null, dateProvider$2, mailFacade), (mocked) => {
			mocked.indexMailboxes = spy(() => Promise.resolve());
			mocked.mailIndexingEnabled = false;
			mocked._getSpamFolder = (membership) => {
				dist_default(membership).deepEquals(user.memberships[0]);
				return spamFolder;
			};
		});
		await indexer.enableMailIndexing(user);
		dist_default(indexer.indexMailboxes.invocations[0]).deepEquals([user, beforeNowInterval]);
		dist_default(indexer.mailIndexingEnabled).equals(true);
		dist_default(JSON.stringify(metadata)).equals(JSON.stringify({
			[Metadata.mailIndexingEnabled]: true,
			[Metadata.excludedListIds]: []
		}));
	});
	dist_default("enableMailIndexing already enabled", async function() {
		let transaction = { get: (os, key) => {
			dist_default(os).equals(MetaDataOS);
			if (key == Metadata.mailIndexingEnabled) return Promise.resolve(true);
else if (key == Metadata.excludedListIds) return Promise.resolve([]);
			throw new Error("wrong key / os");
		} };
		let db = {
			key: aes256RandomKey(),
			dbFacade: { createTransaction: () => Promise.resolve(transaction) }
		};
		const indexer = new MailIndexer(null, db, null, null, null, dateProvider$1, mailFacade);
		indexer.indexMailboxes = spy();
		indexer.mailIndexingEnabled = false;
		let user = createTestEntity(UserTypeRef);
		await await indexer.enableMailIndexing(user);
		dist_default(indexer.indexMailboxes.callCount).equals(0);
		dist_default(indexer.mailIndexingEnabled).equals(true);
	});
	dist_default("disableMailIndexing", function() {
		let db = {
			key: aes256RandomKey(),
			dbFacade: { deleteDatabase: spy() }
		};
		const indexer = new MailIndexer(null, db, null, null, null, dateProvider$1, mailFacade);
		indexer.mailIndexingEnabled = true;
		indexer.disableMailIndexing();
		dist_default(indexer.mailIndexingEnabled).equals(false);
		dist_default(db.dbFacade.deleteDatabase.callCount).equals(1);
	});
	dist_default("indexMailboxes disabled", async function() {
		const indexer = mock(new MailIndexer(null, null, null, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade), (mocked) => {
			mocked.mailIndexingEnabled = false;
		});
		await indexer.indexMailboxes(createTestEntity(UserTypeRef), 15129468e5);
	});
	dist_default.spec("indexMailboxes", function() {
		dist_default("initial indexing", function() {
			return indexMailboxTest(NOTHING_INDEXED_TIMESTAMP, 15129468e5, true, true);
		});
		dist_default("further indexing", function() {
			return indexMailboxTest(15130332e5, 15129468e5, false, true);
		});
		dist_default("fully indexed", function() {
			return indexMailboxTest(FULL_INDEXED_TIMESTAMP, 15129468e5, true, false);
		});
	});
	function _addFolder(mailbox) {
		const folder = createTestEntity(MailFolderTypeRef);
		folder._id = [neverNull(mailbox.folders).folders, entityMock.getNextId()];
		folder.mails = entityMock.getNextId();
		return folder;
	}
	dist_default.spec("_indexMailLists", function() {
		const rangeStart = 15544152e5;
		const rangeEnd = getDayShifted(new Date(rangeStart), -INITIAL_MAIL_INDEX_INTERVAL_DAYS).getTime() + 36e5;
		const rangeEnd2 = getDayShifted(new Date(rangeEnd), -1).getTime() - 36e5;
		const rangeEndShifted2Days = getDayShifted(new Date(rangeEnd), -2).getTime();
		const mailGroup = "mail-group-id";
		let mailbox;
		let folder1, folder2;
		let mail0, details0, mail1, details1, mail2, details2, files, mail3, details3, mail4, details4;
		let transaction, core, indexer, db;
		dist_default.beforeEach(() => {
			mailbox = createTestEntity(MailBoxTypeRef);
			mailbox._id = "mailbox-id";
			mailbox._ownerGroup = mailGroup;
			const folderRef = createTestEntity(MailFolderRefTypeRef);
			folderRef.folders = entityMock.getNextId();
			mailbox.folders = folderRef;
			folder1 = _addFolder(mailbox);
			folder2 = _addFolder(mailbox);
			({mail: mail0, mailDetailsBlob: details0} = createMailInstances(mailFacade, [folder1.mails, timestampToGeneratedId(rangeEndShifted2Days, 1)], ["details-list-id", entityMock.getNextId()]));
			({mail: mail1, mailDetailsBlob: details1} = createMailInstances(mailFacade, [folder1.mails, timestampToGeneratedId(rangeEnd - 1, 1)], ["details-list-id", entityMock.getNextId()]));
			({mail: mail2, mailDetailsBlob: details2, files} = createMailInstances(mailFacade, [folder1.mails, timestampToGeneratedId(rangeEnd + 1, 1)], ["details-list-id", entityMock.getNextId()], ["attachment-listId", entityMock.getNextId()], ["attachment-listId1", entityMock.getNextId()]));
			({mail: mail3, mailDetailsBlob: details3} = createMailInstances(mailFacade, [folder1.mails, timestampToGeneratedId(rangeEnd + 2592e5, 1)], ["details-list-id", entityMock.getNextId()]));
			({mail: mail4, mailDetailsBlob: details4} = createMailInstances(mailFacade, [folder2.mails, timestampToGeneratedId(rangeEnd + 5, 1)], ["details-list-id", entityMock.getNextId()]));
			entityMock.addBlobInstances(details0, details1, details2, details3, details4);
			entityMock.addElementInstances(mailbox);
			entityMock.addListInstances(mail0, mail1, mail2, mail3, mail4, folder1, folder2, ...files);
			transaction = createSearchIndexDbStub().createTransaction();
			db = {
				key: aes256RandomKey(),
				iv: fixedIv,
				dbFacade: { createTransaction: () => Promise.resolve(transaction) }
			};
			core = mock(new IndexerCore(db, { queueEvents: false }, browserDataStub), (mocked) => {
				mocked.writeIndexUpdate = spy(() => Promise.resolve());
			});
			const infoMessageHandler = (0, import_testdouble$56.object)();
			indexer = new MailIndexer(core, db, infoMessageHandler, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
		});
		dist_default("one mailbox until certain point", async function() {
			transaction.put(GroupDataOS, mailGroup, { indexTimestamp: NOTHING_INDEXED_TIMESTAMP });
			await indexer._indexMailLists([{
				mbox: mailbox,
				newestTimestamp: rangeStart
			}], rangeEnd);
			dist_default(core.writeIndexUpdate.callCount).equals(1);
			const [mailboxesData1, indexUpdate1] = core.writeIndexUpdate.args;
			dist_default(indexUpdate1.create.encInstanceIdToElementData.size).equals(3);
			_checkMailsInIndexUpdate(db, indexUpdate1, mail2, mail3, mail4);
			dist_default(mailboxesData1).deepEquals([{
				groupId: mailGroup,
				indexTimestamp: rangeEnd
			}]);
		});
		dist_default("one mailbox extend once", async function() {
			transaction.put(GroupDataOS, mailGroup, { indexTimestamp: rangeEnd });
			await indexer._indexMailLists([{
				mbox: mailbox,
				newestTimestamp: rangeEnd
			}], rangeEnd2);
			const [mailboxesData2, indexUpdateNew2] = core.writeIndexUpdate.args;
			_checkMailsInIndexUpdate(db, indexUpdateNew2, mail1);
			dist_default(mailboxesData2).deepEquals([{
				groupId: mailGroup,
				indexTimestamp: rangeEnd2
			}]);
		});
		dist_default("one mailbox extend till end", async function() {
			transaction.put(GroupDataOS, mailGroup, { indexTimestamp: rangeEnd2 });
			const rangeEnd3 = getDayShifted(new Date(rangeEnd2), -1).getTime();
			await indexer._indexMailLists([{
				mbox: mailbox,
				newestTimestamp: rangeEnd2
			}], rangeEnd3);
			const [mailboxesData3, indexUpdateNew3] = core.writeIndexUpdate.args;
			_checkMailsInIndexUpdate(db, indexUpdateNew3, mail0);
			dist_default(mailboxesData3).deepEquals([{
				groupId: mailGroup,
				indexTimestamp: FULL_INDEXED_TIMESTAMP
			}]);
		});
	});
	function _checkMailsInIndexUpdate(db, indexUpdate, ...includedMails) {
		for (const [index, mail] of includedMails.entries()) {
			let encInstanceId = encryptIndexKeyBase64(db.key, getElementId(mail), fixedIv);
			if (indexUpdate.create.encInstanceIdToElementData.get(encInstanceId) == null) console.error("mail is not written", mail._id, index);
			dist_default(indexUpdate.create.encInstanceIdToElementData.get(encInstanceId) != null).equals(true);
		}
	}
	dist_default.spec("processEntityEvents", function() {
		let indexUpdate;
		dist_default.beforeEach(function() {
			indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef));
		});
		dist_default("do nothing if mailIndexing is disabled", async function() {
			const indexer = _prepareProcessEntityTests(false);
			let events = [
				createUpdate(OperationType.CREATE, "mail-list", "1"),
				createUpdate(OperationType.UPDATE, "mail-list", "2"),
				createUpdate(OperationType.DELETE, "mail-list", "3")
			];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(0);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(indexUpdate.delete.encInstanceIds.length).equals(0);
		});
		dist_default("new mail", async function() {
			const indexer = _prepareProcessEntityTests(true);
			let events = [createUpdate(OperationType.CREATE, "new-mail-list", mailId)];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexer.processNewMail.invocations.length).equals(1);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(1);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(indexer._core._processDeleted.callCount).equals(0);
		});
		dist_default("moved mail", async function() {
			const indexer = _prepareProcessEntityTests(true);
			let events = [createUpdate(OperationType.CREATE, "new-mail-list", mailId), createUpdate(OperationType.DELETE, "old-mail-list", mailId)];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(0);
			dist_default(indexer.processMovedMail.invocations.length).equals(1);
			dist_default(indexer.processMovedMail.invocations[0]).deepEquals([events[0], indexUpdate]);
			dist_default(indexer._core._processDeleted.callCount).equals(0);
		});
		dist_default("deleted mail", async function() {
			const indexer = _prepareProcessEntityTests(true);
			let events = [createUpdate(OperationType.DELETE, "mail-list", mailId)];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(0);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(indexer._core._processDeleted.callCount).equals(1);
			dist_default(indexer._core._processDeleted.args).deepEquals([events[0], indexUpdate]);
		});
		dist_default("update draft", async function() {
			const indexer = _prepareProcessEntityTests(true, MailState.DRAFT);
			let events = [createUpdate(OperationType.UPDATE, "new-mail-list", mailId)];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(1);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(indexer._core._processDeleted.callCount).equals(1);
			dist_default(indexer._core._processDeleted.args).deepEquals([events[0], indexUpdate]);
		});
		dist_default("don't update non-drafts", async function() {
			const indexer = _prepareProcessEntityTests(true, MailState.RECEIVED);
			let events = [createUpdate(OperationType.UPDATE, "new-mail-list", mailId)];
			await indexer.processEntityEvents(events, "group-id", "batch-id", indexUpdate);
			dist_default(indexUpdate.create.encInstanceIdToElementData.size).equals(0);
			dist_default(indexUpdate.move.length).equals(0);
			dist_default(indexer._core._processDeleted.callCount).equals(0);
		});
	});
	dist_default("_getCurrentIndexTimestamp", () => {
		dist_default(NOTHING_INDEXED_TIMESTAMP).equals(_getCurrentIndexTimestamp([]));
		dist_default(NOTHING_INDEXED_TIMESTAMP).equals(_getCurrentIndexTimestamp([NOTHING_INDEXED_TIMESTAMP]));
		dist_default(FULL_INDEXED_TIMESTAMP).equals(_getCurrentIndexTimestamp([FULL_INDEXED_TIMESTAMP]));
		let now$1 = new Date().getTime();
		let past = now$1 - 1e3;
		dist_default(now$1).equals(_getCurrentIndexTimestamp([now$1]));
		dist_default(past).equals(_getCurrentIndexTimestamp([now$1, past]));
		dist_default(past).equals(_getCurrentIndexTimestamp([past, now$1]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([now$1, now$1]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([NOTHING_INDEXED_TIMESTAMP, now$1]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([now$1, NOTHING_INDEXED_TIMESTAMP]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([FULL_INDEXED_TIMESTAMP, now$1]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([now$1, FULL_INDEXED_TIMESTAMP]));
		dist_default(FULL_INDEXED_TIMESTAMP).equals(_getCurrentIndexTimestamp([FULL_INDEXED_TIMESTAMP, NOTHING_INDEXED_TIMESTAMP]));
		dist_default(FULL_INDEXED_TIMESTAMP).equals(_getCurrentIndexTimestamp([NOTHING_INDEXED_TIMESTAMP, FULL_INDEXED_TIMESTAMP]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([
			NOTHING_INDEXED_TIMESTAMP,
			now$1,
			FULL_INDEXED_TIMESTAMP,
			now$1
		]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([
			now$1,
			NOTHING_INDEXED_TIMESTAMP,
			now$1,
			FULL_INDEXED_TIMESTAMP
		]));
		dist_default(now$1).equals(_getCurrentIndexTimestamp([
			now$1,
			FULL_INDEXED_TIMESTAMP,
			NOTHING_INDEXED_TIMESTAMP
		]));
	});
	dist_default.spec("extendIndexIfNeeded", function() {
		dist_default("not extends if fully indexed", function() {
			const core = makeCore();
			const db = null;
			const worker = null;
			const indexer = new MailIndexer(core, db, worker, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
			const user = null;
			indexer.currentIndexTimestamp = FULL_INDEXED_TIMESTAMP;
			return indexer.extendIndexIfNeeded(user, Date.now());
		});
		dist_default("not extends if already indexed range", function() {
			const core = makeCore();
			const db = null;
			const worker = null;
			const indexer = new MailIndexer(core, db, worker, () => bulkMailLoader, entityClient$1, dateProvider$1, mailFacade);
			const user = null;
			const newOldTimestamp = Date.now();
			indexer.currentIndexTimestamp = newOldTimestamp - 1e3;
			return indexer.extendIndexIfNeeded(user, newOldTimestamp);
		});
		dist_default("extends", async function() {
			const user = createTestEntity(UserTypeRef);
			const currentIndexTimestamp = 1554720827674;
			const beforeNowInterval = 15522624e5;
			const dateProvider$2 = new FixedDateProvider(currentIndexTimestamp);
			const indexer = mock(new MailIndexer(null, null, null, () => bulkMailLoader, entityClient$1, dateProvider$2, mailFacade), (mocked) => {
				mocked.indexMailboxes = spy(() => Promise.resolve());
			});
			indexer.currentIndexTimestamp = currentIndexTimestamp;
			await indexer.extendIndexIfNeeded(user, beforeNowInterval);
			dist_default(indexer.indexMailboxes.invocations).deepEquals([[user, beforeNowInterval]]);
		});
	});
	dist_default.spec("check mail index compatibility with models", function() {
		dist_default("mail does not have an attribute with id LEGACY_TO_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.Mail.associations).filter((v) => v.id === LEGACY_TO_RECIPIENTS_ID).length).equals(0);
		});
		dist_default("recipients does not have an attribute with id LEGACY_TO_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.Recipients.associations).filter((v) => v.id === LEGACY_TO_RECIPIENTS_ID).length).equals(0);
		});
		dist_default("mail does not have an attribute with id LEGACY_BODY_ID", function() {
			dist_default(Object.values(typeModels.Mail.associations).filter((v) => v.id === LEGACY_BODY_ID).length).equals(0);
		});
		dist_default("maildetails does not have an attribute with id LEGACY_BODY_ID", function() {
			dist_default(Object.values(typeModels.MailDetails.associations).filter((v) => v.id === LEGACY_BODY_ID).length).equals(0);
		});
		dist_default("mail does not have an attribute with id LEGACY_CC_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.Mail.associations).filter((v) => v.id === LEGACY_CC_RECIPIENTS_ID).length).equals(0);
		});
		dist_default("maildetails does not have an attribute with id LEGACY_CC_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.MailDetails.associations).filter((v) => v.id === LEGACY_CC_RECIPIENTS_ID).length).equals(0);
		});
		dist_default("mail does not have an attribute with id LEGACY_BCC_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.Mail.associations).filter((v) => v.id === LEGACY_BCC_RECIPIENTS_ID).length).equals(0);
		});
		dist_default("maildetails does not have an attribute with id LEGACY_BCC_RECIPIENTS_ID", function() {
			dist_default(Object.values(typeModels.MailDetails.associations).filter((v) => v.id === LEGACY_BCC_RECIPIENTS_ID).length).equals(0);
		});
	});
});
function createUpdate(type, listId, instanceId, eventId) {
	let update = createTestEntity(EntityUpdateTypeRef);
	update.operation = type;
	update.instanceListId = listId;
	update.instanceId = instanceId;
	if (eventId) update._id = eventId;
	return update;
}
async function indexMailboxTest(startTimestamp, endIndexTimstamp, fullyIndexed, indexMailList) {
	let user = createTestEntity(UserTypeRef);
	user.memberships.push(createTestEntity(GroupMembershipTypeRef));
	user.memberships[0].groupType = GroupType.Mail;
	user.memberships[0].group = "mail-group-id";
	let mailboxGroupRoot = createTestEntity(MailboxGroupRootTypeRef);
	mailboxGroupRoot.mailbox = "mailbox-id";
	const groupId = user.memberships[0].group;
	mailboxGroupRoot._id = groupId;
	let mailbox = createTestEntity(MailBoxTypeRef);
	let mailListId = ["mail-list-id"];
	mailbox._id = "mailbox-id";
	const entityMock = new EntityRestClientMock();
	entityMock.addElementInstances(mailbox, mailboxGroupRoot);
	const dbMock$2 = createSearchIndexDbStub();
	const t = dbMock$2.createTransaction();
	let groupData = { indexTimestamp: startTimestamp };
	t.put(GroupDataOS, groupId, groupData);
	let core = downcast({
		printStatus: () => {},
		queue: mock(new EventQueue("mailindexer-queue", true, () => Promise.resolve()), (mock$1) => {
			mock$1.pause = spy(mock$1.pause.bind(mock$1));
			mock$1.resume = spy(mock$1.resume.bind(mock$1));
		}),
		_stats: {},
		resetStats: () => {}
	});
	let db = {
		key: aes256RandomKey(),
		dbFacade: { createTransaction: () => Promise.resolve(t) },
		iv: fixedIv
	};
	const infoMessageHandler = (0, import_testdouble$56.object)();
	const entityClient$1 = new EntityClient(entityMock);
	const bulkMailLoader = new BulkMailLoader(entityClient$1, entityClient$1, null);
	const indexer = mock(new MailIndexer(core, db, infoMessageHandler, () => bulkMailLoader, entityClient$1, new LocalTimeDateProvider(), null), (mock$1) => {
		mock$1.mailIndexingEnabled = true;
		mock$1._loadMailListIds = (mbox) => {
			dist_default(mbox).equals(mailbox);
			return Promise.resolve([mailListId]);
		};
		mock$1._indexMailLists = spy(() => Promise.resolve());
	});
	const indexPromise = indexer.indexMailboxes(user, endIndexTimstamp);
	dist_default(indexer.isIndexing).equals(true);
	await indexPromise;
	dist_default(indexer._core.queue.pause.invocations.length).equals(1);
	dist_default(indexer._core.queue.resume.invocations.length).equals(1);
	dist_default(indexer.isIndexing).equals(false);
	if (indexMailList) {
		dist_default(indexer._indexMailLists.callCount).equals(1);
		const [mailData, oldestTimestamp] = indexer._indexMailLists.args;
		const expectedNewestTimestamp = groupData.indexTimestamp === NOTHING_INDEXED_TIMESTAMP ? getDayShifted(getStartOfDay(new Date()), 1).getTime() : groupData.indexTimestamp;
		dist_default(mailData).deepEquals([{
			mbox: mailbox,
			newestTimestamp: expectedNewestTimestamp
		}]);
		dist_default(oldestTimestamp).deepEquals(endIndexTimstamp);
	} else dist_default(indexer._indexMailLists.callCount).equals(0);
}
function _prepareProcessEntityTests(indexingEnabled, mailState = MailState.RECEIVED) {
	let transaction = { get: (os, id) => {
		let elementData = [
			getListId(mail),
			new Uint8Array(0),
			"group-id"
		];
		return Promise.resolve(elementData);
	} };
	let db = downcast({
		key: aes256RandomKey(),
		iv: fixedIv,
		dbFacade: { createTransaction: () => Promise.resolve(transaction) }
	});
	let core = mock(new IndexerCore(db, { queueEvents: false }, browserDataStub), (mocked) => {
		mocked.writeIndexUpdate = spy();
		mocked._processDeleted = spy();
	});
	let mailFacade = (0, import_testdouble$56.object)();
	const { mail, mailDetailsBlob } = createMailInstances(mailFacade, ["new-mail-list", mailId], ["details-list-id", "details-id"]);
	mail.state = mailState;
	const entityMock = new EntityRestClientMock();
	entityMock.addBlobInstances(mailDetailsBlob);
	entityMock.addListInstances(mail);
	const entityClient$1 = new EntityClient(entityMock);
	const bulkMailLoader = new BulkMailLoader(entityClient$1, entityClient$1, null);
	return mock(new MailIndexer(core, db, null, () => bulkMailLoader, entityClient$1, new LocalTimeDateProvider(), mailFacade), (mocked) => {
		mocked.processNewMail = spy(mocked.processNewMail.bind(mocked));
		mocked.processMovedMail = spy(mocked.processMovedMail.bind(mocked));
		mocked.mailIndexingEnabled = indexingEnabled;
	});
}
function createMailInstances(mailFacade, mailId$1, mailDetailsBlobId, ...attachmentIds) {
	let mail = createTestEntity(MailTypeRef, {
		_id: mailId$1,
		_ownerEncSessionKey: new Uint8Array(),
		mailDetails: mailDetailsBlobId,
		attachments: attachmentIds
	});
	let mailDetailsBlob = createTestEntity(MailDetailsBlobTypeRef, {
		_id: mailDetailsBlobId,
		details: createTestEntity(MailDetailsTypeRef, {
			body: createTestEntity(BodyTypeRef),
			recipients: createTestEntity(RecipientsTypeRef)
		})
	});
	const files = attachmentIds.map((id) => {
		const file = createTestEntity(FileTypeRef);
		file._id = id;
		return file;
	});
	(0, import_testdouble$56.when)(mailFacade.loadAttachments(mail)).thenResolve(files);
	return {
		mail,
		mailDetailsBlob,
		files
	};
}

//#endregion
//#region tests/api/worker/search/IndexUtilsTest.ts
dist_default.spec("Index Utils", () => {
	dist_default("encryptIndexKey", function() {
		let key = aes256RandomKey();
		let encryptedKey = encryptIndexKeyBase64(key, "blubb", fixedIv);
		let decrypted = unauthenticatedAesDecrypt(key, concat(fixedIv, base64ToUint8Array(encryptedKey)), true);
		dist_default(utf8Uint8ArrayToString(decrypted)).equals("blubb");
	});
	dist_default("encryptSearchIndexEntry + decryptSearchIndexEntry", function() {
		let key = aes256RandomKey();
		let entry = {
			id: "L0YED5d----1",
			attribute: 84,
			positions: [
				12,
				536,
				3
			]
		};
		let encId = encryptIndexKeyUint8Array(key, entry.id, fixedIv);
		let encryptedEntry = encryptSearchIndexEntry(key, entry, encId);
		const encodedIndexEntry = [
			84,
			12,
			130,
			2,
			24,
			3
		];
		const result = unauthenticatedAesDecrypt(key, encryptedEntry.slice(16), true);
		dist_default(Array.from(result)).deepEquals(Array.from(encodedIndexEntry));
		let decrypted = decryptSearchIndexEntry(key, encryptedEntry, fixedIv);
		dist_default(JSON.stringify(decrypted.encId)).equals(JSON.stringify(encId));
		const withoutEncId = decrypted;
		delete withoutEncId.encId;
		dist_default(JSON.stringify(decrypted)).equals(JSON.stringify(entry));
	});
	dist_default("encryptMetaData", function() {
		const key = aes256RandomKey();
		const meta = {
			id: 3,
			word: "asdsadasds",
			rows: [{
				app: 1,
				type: 64,
				key: 3,
				size: 10,
				oldestElementTimestamp: 6
			}, {
				app: 2,
				type: 66,
				key: 4,
				size: 8,
				oldestElementTimestamp: 15
			}]
		};
		const encryptedMeta = encryptMetaData(key, meta);
		dist_default(encryptedMeta.id).equals(meta.id);
		dist_default(encryptedMeta.word).equals(meta.word);
		dist_default(Array.from(unauthenticatedAesDecrypt(key, encryptedMeta.rows, true))).deepEquals([
			1,
			64,
			3,
			10,
			6,
			2,
			66,
			4,
			8,
			15
		]);
		dist_default(decryptMetaData(key, encryptedMeta)).deepEquals(meta);
	});
	dist_default("decryptMetaData with empty rows", function() {
		dist_default(decryptMetaData(aes256RandomKey(), {
			id: 1,
			word: "tuta",
			rows: new Uint8Array(0)
		})).deepEquals({
			id: 1,
			word: "tuta",
			rows: []
		});
	});
	dist_default("typeRefToTypeInfo", async function() {
		let thrown = false;
		try {
			typeRefToTypeInfo(UserTypeRef);
		} catch (e) {
			thrown = true;
		}
		dist_default(thrown).equals(true);
		dist_default(typeRefToTypeInfo(ContactTypeRef).appId).equals(1);
		const ContactTypeModel = await resolveTypeReference(ContactTypeRef);
		dist_default(typeRefToTypeInfo(ContactTypeRef).typeId).equals(ContactTypeModel.id);
	});
	dist_default("userIsGlobalAdmin", function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships.push(createTestEntity(GroupMembershipTypeRef));
		user.memberships[0].groupType = GroupType.Admin;
		dist_default(userIsGlobalAdmin(user)).equals(true);
		user.memberships[0].groupType = GroupType.LocalAdmin;
		dist_default(userIsGlobalAdmin(user)).equals(false);
		user.memberships[0].groupType = GroupType.Mail;
		dist_default(userIsGlobalAdmin(user)).equals(false);
	});
	dist_default("filterIndexMemberships", function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef)
		];
		user.memberships[0].groupType = GroupType.Admin;
		user.memberships[1].groupType = GroupType.Contact;
		user.memberships[2].groupType = GroupType.Customer;
		user.memberships[3].groupType = GroupType.External;
		user.memberships[4].groupType = GroupType.File;
		user.memberships[5].groupType = GroupType.Mail;
		user.memberships[6].groupType = GroupType.MailingList;
		user.memberships[7].groupType = GroupType.User;
		dist_default(filterIndexMemberships(user)).deepEquals([
			user.memberships[0],
			user.memberships[1],
			user.memberships[2],
			user.memberships[5]
		]);
	});
	dist_default("filterMailMemberships", function() {
		let user = createTestEntity(UserTypeRef);
		user.memberships = [
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef),
			createTestEntity(GroupMembershipTypeRef)
		];
		user.memberships[0].groupType = GroupType.Admin;
		user.memberships[1].groupType = GroupType.Contact;
		user.memberships[2].groupType = GroupType.Customer;
		user.memberships[3].groupType = GroupType.External;
		user.memberships[4].groupType = GroupType.File;
		user.memberships[5].groupType = GroupType.Mail;
		user.memberships[6].groupType = GroupType.MailingList;
		user.memberships[7].groupType = GroupType.User;
		user.memberships[8].groupType = GroupType.Mail;
		dist_default(filterMailMemberships(user)).deepEquals([user.memberships[5], user.memberships[8]]);
	});
	dist_default("containsEventOfType", function() {
		function createUpdate$2(type, id) {
			let update = createTestEntity(EntityUpdateTypeRef);
			update.operation = type;
			update.instanceId = id;
			return update;
		}
		dist_default(containsEventOfType([], OperationType.CREATE, "1")).equals(false);
		dist_default(containsEventOfType([createUpdate$2(OperationType.CREATE, "1")], OperationType.CREATE, "1")).equals(true);
		dist_default(containsEventOfType([createUpdate$2(OperationType.DELETE, "1")], OperationType.CREATE, "1")).equals(false);
		dist_default(containsEventOfType([createUpdate$2(OperationType.DELETE, "2")], OperationType.DELETE, "1")).equals(false);
	});
	dist_default("byteLength", function() {
		dist_default(byteLength("")).equals(0);
		dist_default(byteLength("A")).equals(1);
		dist_default(byteLength("A B")).equals(3);
		dist_default(byteLength("")).equals(2);
		dist_default(byteLength("")).equals(3);
		dist_default(byteLength("")).equals(4);
	});
	dist_default("new index update", function() {
		let indexUpdate = _createNewIndexUpdate(typeRefToTypeInfo(MailTypeRef));
		dist_default(indexUpdate.create.encInstanceIdToElementData instanceof Map).equals(true);
		dist_default(indexUpdate.create.indexMap instanceof Map).equals(true);
		dist_default(indexUpdate.move).deepEquals([]);
		dist_default(indexUpdate.delete.searchMetaRowToEncInstanceIds instanceof Map).equals(true);
		dist_default(indexUpdate.delete.encInstanceIds).deepEquals([]);
	});
	dist_default("htmlToPlainText", function() {
		dist_default(htmlToText("")).equals("");
		dist_default(htmlToText("test")).equals("test");
		let html = "this string has <i>html</i> code <!-- ignore comments-->i want to <b>remove</b><br>Link Number 1 -><a href='http://www.bbc.co.uk'>BBC</a> Link Number 1<br><p>Now back to normal text and stuff</p>";
		let plain = "this string has  html  code  i want to  remove  Link Number 1 -> BBC  Link Number 1  Now back to normal text and stuff ";
		dist_default(htmlToText(html)).equals(plain);
		dist_default(htmlToText("<img src='>' >")).equals(" ' >");
		dist_default(htmlToText("&nbsp;&amp;&lt;&gt;")).equals(" &<>");
		dist_default(htmlToText("&ouml;")).equals("");
		dist_default(htmlToText("&Ouml;")).equals("");
		dist_default(htmlToText("&Phi;")).equals("");
		dist_default(htmlToText(null)).equals("");
		dist_default(htmlToText("&#10595;&#1339;")).equals("");
	});
});

//#endregion
//#region tests/api/worker/search/SearchFacadeTest.ts
var import_testdouble$55 = __toESM(require_testdouble(), 1);
let dbKey;
const contactTypeInfo = typeRefToTypeInfo(ContactTypeRef);
const mailTypeInfo = typeRefToTypeInfo(MailTypeRef);
const browserData = browserDataStub;
const entityClient = (0, import_testdouble$55.object)();
dist_default.spec("SearchFacade test", () => {
	let mail = createTestEntity(MailTypeRef);
	let user = createTestEntity(UserTypeRef);
	let id1 = "L0YED5d----1";
	let id2 = "L0YED5d----2";
	let id3 = "L0YED5d----3";
	function createSearchFacade(transaction$1, currentIndexTimestamp) {
		return new SearchFacade({ getLoggedInUser: () => user }, {
			key: dbKey,
			iv: fixedIv,
			dbFacade: { createTransaction: () => Promise.resolve(transaction$1) },
			initialized: Promise.resolve()
		}, {
			mailboxIndexingPromise: Promise.resolve(),
			currentIndexTimestamp
		}, [], browserData, entityClient);
	}
	function createDbContent(transaction$1, dbData, fullIds) {
		let counter$1 = 0;
		for (const [index, keyToIndexEntries] of dbData.entries()) {
			keyToIndexEntries.indexEntries.sort((a, b) => compareOldestFirst(a.id, b.id));
			const indexEntriesByType = groupBy(keyToIndexEntries.indexEntries, (e) => e.typeInfo);
			const metaDataRow = {
				id: index + 1,
				word: keyToIndexEntries.indexKey,
				rows: []
			};
			for (const [typeInfo, entries] of indexEntriesByType.entries()) {
				const chunks = splitInChunks(2, entries);
				for (const chunk of chunks) {
					counter$1++;
					metaDataRow.rows.push({
						app: typeInfo.appId,
						type: typeInfo.typeId,
						key: counter$1,
						size: chunk.length,
						oldestElementTimestamp: generatedIdToTimestamp(chunk[0].id)
					});
					const encSearchIndexRow = appendBinaryBlocks(chunk.map((entry) => encryptSearchIndexEntry(dbKey, entry, encryptIndexKeyUint8Array(dbKey, entry.id, fixedIv))));
					transaction$1.put(SearchIndexOS, counter$1, encSearchIndexRow);
				}
			}
			transaction$1.put(SearchIndexMetaDataOS, null, encryptMetaData(dbKey, metaDataRow));
			for (const id of fullIds) {
				let encId = encryptIndexKeyBase64(dbKey, elementIdPart(id), fixedIv);
				const elementDataEntry = [
					listIdPart(id),
					new Uint8Array(0),
					""
				];
				transaction$1.put(ElementDataOS, encId, elementDataEntry);
			}
		}
	}
	let createKeyToIndexEntries = (word, entries) => {
		return {
			indexKey: encryptIndexKeyBase64(dbKey, word, fixedIv),
			indexEntries: entries
		};
	};
	let createMailEntry = (id, attribute, positions) => {
		return {
			id,
			attribute,
			positions,
			typeInfo: mailTypeInfo
		};
	};
	let createContactEntry = (id, attribute, positions) => {
		return {
			id,
			attribute,
			positions,
			typeInfo: contactTypeInfo
		};
	};
	let createMailRestriction = (attributeIds, listId, start, end) => {
		return {
			type: MailTypeRef,
			start: start ?? null,
			end: end ?? null,
			field: null,
			attributeIds: attributeIds ?? null,
			folderIds: listId != null ? [listId] : [],
			eventSeries: true
		};
	};
	let testSearch = (dbData, dbListIds, query, restriction, expectedResult, currentIndexTimestamp = 0, minSuggestionCount = 0, maxResults) => {
		createDbContent(transaction, dbData, dbListIds);
		let s = createSearchFacade(transaction, currentIndexTimestamp);
		return s.search(query, restriction, minSuggestionCount, maxResults).then((result) => {
			dist_default(result.query).equals(query);
			dist_default(result.restriction).deepEquals(restriction);
			dist_default(result.results).deepEquals(expectedResult.sort((idTuple1, idTuple2) => firstBiggerThanSecond(idTuple1[1], idTuple2[1]) ? -1 : 1));
		});
	};
	let dbStub;
	let transaction;
	dist_default.beforeEach(() => {
		dbKey = aes256RandomKey();
		dbStub = createSearchIndexDbStub();
		transaction = dbStub.createTransaction();
	});
	dist_default("empty db", () => {
		return testSearch([], [], "test", createMailRestriction(), []);
	});
	dist_default("empty query", () => {
		return testSearch([], [], "", createMailRestriction(), []);
	});
	dist_default("no words in query", () => {
		return testSearch([], [], " %.,:", createMailRestriction(), []);
	});
	dist_default("find single entry", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0])])], [["listId1", id1]], "test", createMailRestriction(), [["listId1", id1]]);
	});
	dist_default("find two entries", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id2, 0, [0])])], [["listId1", id1], ["listId2", id2]], "test", createMailRestriction(), [["listId1", id1], ["listId2", id2]]);
	});
	dist_default("find entries from different rows", () => {
		return testSearch([createKeyToIndexEntries("test", [
			createMailEntry(id1, 0, [0]),
			createMailEntry(id2, 0, [0]),
			createMailEntry(id3, 0, [0])
		])], [
			["listId1", id1],
			["listId2", id2],
			["listId3", id3]
		], "test", createMailRestriction(), [
			["listId1", id1],
			["listId2", id2],
			["listId3", id3]
		]);
	});
	dist_default("find type", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createContactEntry(id2, 0, [0])])], [["listId1", id1], ["listId2", id2]], "test", createMailRestriction(), [["listId1", id1]]);
	});
	dist_default("find attribute", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id2, 1, [0])])], [["listId1", id1], ["listId2", id2]], "test", createMailRestriction([1]), [["listId2", id2]]);
	});
	dist_default("find folderId legacy MailFolders (non-static mail listIds)", () => {
		let mail1 = createTestEntity(MailTypeRef, { _id: ["mailListId1", id1] });
		(0, import_testdouble$55.when)(entityClient.load(MailTypeRef, mail1._id)).thenReturn(Promise.resolve(mail1));
		let mail2 = createTestEntity(MailTypeRef, { _id: ["mailListId2", id2] });
		(0, import_testdouble$55.when)(entityClient.load(MailTypeRef, mail2._id)).thenReturn(Promise.resolve(mail2));
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id2, 0, [0])])], [mail1._id, mail2._id], "test", createMailRestriction(null, listIdPart(mail2._id)), [mail2._id]);
	});
	dist_default("find folderId new MailSets (static mail listIds)", () => {
		const mail1 = createTestEntity(MailTypeRef, {
			_id: ["mailListId", id1],
			sets: [["setListId", "folderId1"]]
		});
		(0, import_testdouble$55.when)(entityClient.load(MailTypeRef, mail1._id)).thenReturn(Promise.resolve(mail1));
		const mail2 = createTestEntity(MailTypeRef, {
			_id: ["mailListId", id2],
			sets: [["setListId", "folderId2"]]
		});
		(0, import_testdouble$55.when)(entityClient.load(MailTypeRef, mail2._id)).thenReturn(Promise.resolve(mail2));
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id2, 0, [0])])], [mail1._id, mail2._id], "test", createMailRestriction(null, elementIdPart(mail2.sets[0])), [mail2._id]);
	});
	dist_default("find with start time", () => {
		let id1$1 = timestampToGeneratedId(new Date(2017, 5, 8).getTime());
		let start = new Date(2017, 5, 9).getTime();
		let id2$1 = timestampToGeneratedId(new Date(2017, 5, 10).getTime());
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1$1, 0, [0]), createMailEntry(id2$1, 0, [0])])], [["listId1", id1$1], ["listId2", id2$1]], "test", createMailRestriction(null, null, start, null), [["listId1", id1$1]]);
	});
	dist_default("find with end time", () => {
		let id1$1 = timestampToGeneratedId(new Date(2017, 5, 8).getTime());
		let end = new Date(2017, 5, 9).getTime();
		let id2$1 = timestampToGeneratedId(new Date(2017, 5, 10).getTime());
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1$1, 0, [0]), createMailEntry(id2$1, 0, [0])])], [["listId1", id1$1], ["listId2", id2$1]], "test", createMailRestriction(null, null, null, end), [["listId2", id2$1]]);
	});
	dist_default("find with start and end time", () => {
		let id1$1 = timestampToGeneratedId(new Date(2017, 5, 8).getTime());
		let end = new Date(2017, 5, 9).getTime();
		let id2$1 = timestampToGeneratedId(new Date(2017, 5, 10).getTime());
		let start = new Date(2017, 5, 11).getTime();
		let id3$1 = timestampToGeneratedId(new Date(2017, 5, 12).getTime());
		return testSearch([createKeyToIndexEntries("test", [
			createMailEntry(id1$1, 0, [0]),
			createMailEntry(id2$1, 0, [0]),
			createMailEntry(id3$1, 0, [0])
		])], [
			["listId1", id1$1],
			["listId2", id2$1],
			["listId3", id3$1]
		], "test", createMailRestriction(null, null, start, end), [["listId2", id2$1]]);
	});
	dist_default("find two search words", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id2, 0, [0])]), createKeyToIndexEntries("ja", [createMailEntry(id1, 0, [0])])], [["listId1", id1], ["listId2", id2]], "ja,test", createMailRestriction(), [["listId1", id1]]);
	});
	dist_default("find two search words in multiple rows", () => {
		const firstWordIds = numberRange(1, 1500).map((i) => ["listId1", timestampToGeneratedId(i, 1)]);
		const secondWordIds = numberRange(1, 1500).map((i) => ["listId1", timestampToGeneratedId(i, 1)]);
		const firstWordEntries = firstWordIds.map((idTuple) => createMailEntry(elementIdPart(idTuple), 0, [0]));
		const secondWordEntries = secondWordIds.map((idTuple) => createMailEntry(elementIdPart(idTuple), 0, [0]));
		return testSearch([createKeyToIndexEntries("test", firstWordEntries), createKeyToIndexEntries("ja", secondWordEntries)], firstWordIds.concat(secondWordIds), "ja,test", createMailRestriction(), secondWordIds.slice(500).reverse(), 0, 0, 1e3);
	});
	dist_default("find two search words with a time gap", () => {
		const firstWordIds = numberRange(1, 1200).map((i) => ["listId1", timestampToGeneratedId(i, 1)]);
		const secondWordIds = numberRange(1, 10).map((i) => ["listId1", timestampToGeneratedId(i, 1)]);
		const firstWordEntries = firstWordIds.map((idTuple) => createMailEntry(elementIdPart(idTuple), 0, [0]));
		const secondWordEntries = secondWordIds.map((idTuple) => createMailEntry(elementIdPart(idTuple), 0, [0]));
		return testSearch([createKeyToIndexEntries("test", firstWordEntries), createKeyToIndexEntries("ja", secondWordEntries)], firstWordIds.concat(secondWordIds), "ja,test", createMailRestriction(), secondWordIds, 0, 0, 100);
	});
	dist_default("find two search words ordered", () => {
		return testSearch([createKeyToIndexEntries("test", [
			createMailEntry(id1, 0, [6]),
			createMailEntry(id2, 0, [6]),
			createMailEntry(id3, 1, [6])
		]), createKeyToIndexEntries("ja", [
			createMailEntry(id1, 0, [5]),
			createMailEntry(id2, 0, [4]),
			createMailEntry(id3, 0, [5])
		])], [
			["listId1", id1],
			["listId2", id2],
			["listId3", id3]
		], "\"ja,test\"", createMailRestriction(), [["listId1", id1]]);
	});
	dist_default("reduce ids", () => {
		return testSearch([createKeyToIndexEntries("test", [createMailEntry(id1, 0, [0]), createMailEntry(id1, 1, [0])])], [["listId1", id1]], "test", createMailRestriction(), [["listId1", id1]]);
	});
});

//#endregion
//#region tests/api/worker/search/SuggestionFacadeTest.ts
dist_default.spec("SuggestionFacade test", () => {
	let db;
	let facade;
	dist_default.beforeEach(function() {
		db = {
			key: aes256RandomKey(),
			iv: fixedIv,
			dbFacade: {},
			initialized: Promise.resolve()
		};
		facade = new SuggestionFacade(ContactTypeRef, db);
	});
	dist_default("add and get suggestion", () => {
		dist_default(facade.getSuggestions("a").join("")).equals("");
		let words = ["a"];
		facade.addSuggestions(words);
		dist_default(facade.getSuggestions("a").join(" ")).equals("a");
		words = ["anton", "arne"];
		facade.addSuggestions(words);
		dist_default(facade.getSuggestions("a").join(" ")).equals("a anton arne");
		words = [
			"ab",
			"az",
			"arne"
		];
		facade.addSuggestions(words);
		dist_default(facade.getSuggestions("a").join(" ")).equals("a ab anton arne az");
		words = [
			"aa",
			"anne",
			"bernd"
		];
		facade.addSuggestions(words);
		dist_default(facade.getSuggestions("a").join(" ")).equals("a aa ab anne anton arne az");
		dist_default(facade.getSuggestions("an").join(" ")).equals("anne anton");
		dist_default(facade.getSuggestions("ann").join(" ")).equals("anne");
		dist_default(facade.getSuggestions("anne").join(" ")).equals("anne");
		dist_default(facade.getSuggestions("annet").join(" ")).equals("");
		dist_default(facade.getSuggestions("b").join(" ")).equals("bernd");
		dist_default(facade.getSuggestions("be").join(" ")).equals("bernd");
		dist_default(facade.getSuggestions("ben").join(" ")).equals("");
	});
	dist_default("load empty", () => {
		let transactionMock = {};
		transactionMock.get = spy(() => Promise.resolve(null));
		downcast(db.dbFacade).createTransaction = spy(() => Promise.resolve(transactionMock));
		facade.addSuggestions(["aaaaaaa"]);
		return facade.load().then(() => {
			dist_default(transactionMock.get.callCount).equals(1);
			dist_default(transactionMock.get.args[0]).equals(SearchTermSuggestionsOS);
			dist_default(transactionMock.get.args[1]).equals("contact");
			dist_default(facade.getSuggestions("a").join("")).equals("");
		});
	});
	dist_default("store and load", () => {
		let transactionMock = {};
		transactionMock.put = spy(() => Promise.resolve());
		transactionMock.wait = spy(() => Promise.resolve());
		downcast(db.dbFacade).createTransaction = spy(() => Promise.resolve(transactionMock));
		facade.addSuggestions(["aaaa"]);
		return facade.store().then(() => {
			dist_default(transactionMock.put.args[0]).equals(SearchTermSuggestionsOS);
			dist_default(transactionMock.put.args[1]).equals("contact");
			let encSuggestions = transactionMock.put.args[2];
			facade.addSuggestions(["accc", "bbbb"]);
			dist_default(facade.getSuggestions("a").join(" ")).equals("aaaa accc");
			dist_default(facade.getSuggestions("b").join(" ")).equals("bbbb");
			let transactionLoadMock = {};
			downcast(db.dbFacade).createTransaction = spy(() => Promise.resolve(transactionLoadMock));
			transactionLoadMock.get = spy(() => Promise.resolve(encSuggestions));
			return facade.load().then(() => {
				dist_default(transactionLoadMock.get.args[0]).equals(SearchTermSuggestionsOS);
				dist_default(transactionLoadMock.get.args[1]).equals("contact");
				dist_default(facade.getSuggestions("a").join(" ")).equals("aaaa");
				dist_default(facade.getSuggestions("b").join(" ")).equals("");
			});
		});
	});
});

//#endregion
//#region tests/api/worker/search/SearchIndexEncodingTest.ts
dist_default.spec("SearchIndexEncoding test", function() {
	dist_default("numberOfBytes", function() {
		const cases = [
			[0, 0],
			[128, 1],
			[255, 1],
			[256, 2],
			[257, 2],
			[511, 2],
			[512, 2],
			[Math.pow(2, 16) - 1, 2],
			[Math.pow(2, 16), 3]
		];
		for (const [num, res] of cases) dist_default(numberOfBytes(num)).equals(res)(`${num} should require ${res}`);
	});
	dist_default("calculateNeededSpaceSingleArray", function() {
		dist_default(calculateNeededSpace([new Uint8Array(32)])).equals(33);
		dist_default(calculateNeededSpace([new Uint8Array(127)])).equals(128);
		dist_default(calculateNeededSpace([new Uint8Array(128)])).equals(130);
		dist_default(calculateNeededSpace([new Uint8Array(65535)])).equals(65538);
		dist_default(calculateNeededSpace([new Uint8Array(65536)])).equals(65540);
	});
	dist_default("calculateNeededSpace", function() {
		const smallEntry = new Uint8Array(32);
		const bigEntry = new Uint8Array(512);
		dist_default(calculateNeededSpace([smallEntry, bigEntry])).equals(548);
	});
	dist_default.spec("encodeBinaryBlock", function() {
		dist_default("with short length", function() {
			const newIndexEntry = new Uint8Array([1]);
			const indexEntry = new Uint8Array(2);
			dist_default(encodeBinaryBlock(newIndexEntry, indexEntry, 0)).equals(2);
			dist_default(JSON.stringify(indexEntry)).equals(JSON.stringify(new Uint8Array([1, 1])));
		});
		dist_default("with large length", function() {
			const entityData = new Uint8Array(256);
			const destinationData = new Uint8Array(259);
			dist_default(encodeBinaryBlock(entityData, destinationData, 0)).equals(259);
			dist_default(JSON.stringify(destinationData)).equals(JSON.stringify(new Uint8Array([
				130,
				1,
				0
			].concat(new Array(256).fill(0)))));
		});
		dist_default("with large length, invalid offset", function() {
			const entityData = new Uint8Array(256);
			const destinationData = new Uint8Array(259);
			try {
				encodeBinaryBlock(entityData, destinationData, 1);
			} catch (e) {
				dist_default(e.constructor).equals(RangeError);
			}
		});
		dist_default("with large length, insufficient memory", function() {
			const entityData = new Uint8Array(256);
			const destinationData = new Uint8Array(2);
			try {
				encodeBinaryBlock(entityData, destinationData, 0);
				throw new Error();
			} catch (e) {
				dist_default(e.constructor).equals(RangeError);
			}
		});
	});
	dist_default.spec("decodeBinaryBlock", function() {
		dist_default("with short length (literal length)", function() {
			const searchIndexData = new Uint8Array([1].concat([0]));
			dist_default(JSON.stringify(decodeBinaryBlock(searchIndexData, 0))).equals(JSON.stringify(new Uint8Array([0])));
		});
		dist_default("with short length (encoded length)", function() {
			const searchIndexData = new Uint8Array([127].concat([0]));
			dist_default(JSON.stringify(decodeBinaryBlock(searchIndexData, 0))).equals(JSON.stringify(new Uint8Array([0])));
		});
		dist_default("with long length", function() {
			const searchIndexData = new Uint8Array([129, 1].concat([
				1,
				2,
				3
			]));
			dist_default(JSON.stringify(decodeBinaryBlock(searchIndexData, 0))).equals(JSON.stringify(new Uint8Array([1])));
		});
		dist_default("with long length and offset", function() {
			const searchIndexData = new Uint8Array([
				0,
				130,
				1,
				0
			].concat(new Array(256).fill(0)));
			dist_default(JSON.stringify(decodeBinaryBlock(searchIndexData, 1))).equals(JSON.stringify(new Uint8Array(256)));
		});
	});
	dist_default.spec("removeBinaryBlockRanges", function() {
		dist_default("works", function() {
			const row = new Uint8Array([
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7
			]);
			const expected = new Uint8Array([
				1,
				3,
				6
			]);
			dist_default(JSON.stringify(removeBinaryBlockRanges(row, [
				[0, 1],
				[2, 3],
				[4, 6],
				[7, 8]
			]))).equals(JSON.stringify(expected));
		});
	});
	dist_default.spec("iterateBinaryBlocks", function() {
		dist_default("works", function() {
			const shortBlock = [1, 0];
			const longBlock = [129, 128].concat(new Array(128).fill(2));
			const anotherLongBlock = [129, 129].concat(new Array(129).fill(3));
			const anotherShortBlock = [
				2,
				1,
				2
			];
			const row = new Uint8Array([
				shortBlock,
				longBlock,
				anotherLongBlock,
				anotherShortBlock
			].flat());
			const spy$1 = spy();
			iterateBinaryBlocks(row, spy$1);
			dist_default(JSON.stringify(spy$1.invocations)).equals(JSON.stringify([
				[
					new Uint8Array(shortBlock.slice(1)),
					0,
					2,
					0
				],
				[
					new Uint8Array(longBlock.slice(2)),
					2,
					132,
					1
				],
				[
					new Uint8Array(anotherLongBlock.slice(2)),
					132,
					263,
					2
				],
				[
					new Uint8Array(anotherShortBlock.slice(1)),
					263,
					266,
					3
				]
			]));
		});
	});
	dist_default.spec("appendBinaryBlocks", function() {
		dist_default("resizes when needed", function() {
			const row = new Uint8Array([1, 2]);
			const newDataOne = new Uint8Array(256).fill(2);
			const newDataTwo = new Uint8Array([1]);
			const expected = concat(new Uint8Array([1, 2]), new Uint8Array([
				130,
				1,
				0
			]), newDataOne, new Uint8Array([1, 1]));
			dist_default(JSON.stringify(appendBinaryBlocks([newDataOne, newDataTwo], row))).equals(JSON.stringify(expected));
		});
	});
	dist_default.spec("encodeNumberBlock", function() {
		dist_default("encodes small numbers", function() {
			const block = new Uint8Array(1);
			encodeNumberBlock(3, block, 0);
			dist_default(Array.from(block)).deepEquals([3]);
		});
		dist_default("encodes big numbers", function() {
			const number = 1550759936805;
			const block = new Uint8Array(7);
			encodeNumberBlock(number, block, 0);
			dist_default(Array.from(block)).deepEquals([
				134,
				1,
				105,
				16,
				126,
				195,
				37
			]);
		});
	});
});

//#endregion
//#region ../src/mail-app/ApplicationPaths.ts
function applicationPaths({ login, termination, mail, externalLogin, contact, contactList: contactList$1, search: search$1, settings, calendar, signup, giftcard, recover, webauthn, webauthnmobile }) {
	return {
		"/login": login,
		"/termination": termination,
		"/signup": signup,
		"/recover": recover,
		"/mailto": mail,
		"/mail": mail,
		"/mail/:folderId": mail,
		"/mail/:folderId/:mailId": mail,
		"/ext": externalLogin,
		"/contact": contact,
		"/contact/:listId": contact,
		"/contact/:listId/:contactId": contact,
		"/contactlist": contactList$1,
		"/contactlist/:listId": contactList$1,
		"/contactlist/:listId/:Id": contactList$1,
		"/search/:category": search$1,
		"/search/:category/:id": search$1,
		"/settings": settings,
		"/settings/:folder": settings,
		"/settings/:folder/:id": settings,
		"/calendar": calendar,
		"/calendar/:view": calendar,
		"/calendar/:view/:date": calendar,
		"/giftcard/": giftcard,
		"/webauthn": webauthn,
		"/webauthnmobile": webauthnmobile
	};
}
function getPathBases() {
	const paths = Object.keys(applicationPaths({}));
	const uniquePathBases = new Set(paths.map((path) => path.split("/")[1]));
	return Array.from(uniquePathBases);
}

//#endregion
//#region ../src/common/serviceworker/sw.ts
const versionString = typeof version === "undefined" ? "test" : version();
const isTutanotaDomain = () => {
	const hostname = self.location.hostname;
	return hostname === "tutanota.com" || hostname === "tuta.com" || hostname.endsWith(".tutanota.com") || hostname.endsWith(".tuta.com") || hostname.indexOf(".") === -1;
};
const urlWithoutQuery = (urlString) => {
	const queryIndex = urlString.indexOf("?");
	return queryIndex !== -1 ? urlString.substring(0, queryIndex) : urlString;
};
var ServiceWorker = class {
	_caches;
	_cacheName;
	_selfLocation;
	_possibleRest;
	_applicationPaths;
	_isTutanotaDomain;
	_urlsToCache;
	_isBuggyChrome;
	constructor(urlsToCache, caches$1, cacheName, selfLocation, applicationPaths$1, isTutanotaDomain$1) {
		this._urlsToCache = urlsToCache;
		this._caches = caches$1;
		this._cacheName = cacheName;
		this._selfLocation = selfLocation;
		this._possibleRest = selfLocation + "rest";
		this._applicationPaths = applicationPaths$1;
		this._isTutanotaDomain = isTutanotaDomain$1;
		this._isBuggyChrome = false;
		if (typeof navigator !== "undefined") {
			const results = navigator.userAgent.match(/Chrome\/([0-9]*)\./);
			if (results != null && results.length > 0) {
				const numberVersion = Number(results[1]);
				if (!isNaN(numberVersion) && numberVersion < 50) {
					console.log("Buggy Chrome version detected. Deferring to no-op sw.js");
					this._isBuggyChrome = true;
				}
			}
		}
	}
	respond(evt) {
		if (this._isBuggyChrome) return;
		const urlWithoutParams = urlWithoutQuery(evt.request.url);
		if (this._urlsToCache.indexOf(urlWithoutParams) !== -1 || this._isTutanotaDomain && this._selfLocation === urlWithoutParams) evt.respondWith(this._fromCache(urlWithoutParams));
else if (/translation-.+-.+\.js/.test(urlWithoutParams)) evt.respondWith(this.fromCacheOrFetchAndCache(evt.request));
else if (this._shouldRedirectToDefaultPage(urlWithoutParams)) evt.respondWith(this._redirectToDefaultPage(evt.request.url));
	}
	precache() {
		return this._caches.open(this._cacheName).then((cache) => this._addAllToCache(cache, this._urlsToCache).then(() => cache.match("index.html")).then((r) => {
			if (!r) return;
			const clonedResponse = r.clone();
			const bodyPromise = clonedResponse.body != null ? Promise.resolve(clonedResponse.body) : clonedResponse.blob();
			return bodyPromise.then((body) => new Response(body, {
				headers: clonedResponse.headers,
				status: clonedResponse.status,
				statusText: clonedResponse.statusText
			})).then((r$1) => cache.put(this._selfLocation, r$1)).then(() => cache.delete("index.html"));
		}));
	}
	deleteOldCaches() {
		return this._caches.keys().then((cacheNames) => Promise.all(cacheNames.map((cacheName) => cacheName !== this._cacheName ? caches.delete(cacheName) : Promise.resolve()))).catch((e) => {
			console.log("error while deleting old caches", e);
			throw e;
		});
	}
	fromCacheOrFetchAndCache(request) {
		return this._caches.open(this._cacheName).then((cache) => {
			return cache.match(request.url).then((response) => {
				if (response) return response;
else return fetch(request, { redirect: "error" }).then((networkResponse) => {
					return cache.put(request, networkResponse.clone()).then(() => networkResponse);
				});
			});
		});
	}
	_fromCache(requestUrl) {
		return this._caches.open(this._cacheName).then((cache) => cache.match(requestUrl)).then((r) => r || fetch(requestUrl));
	}
	_addAllToCache(cache, urlsToCache) {
		return Promise.all(urlsToCache.map((url) => cache.add(url).catch((e) => {
			console.log("failed to add", url, e);
			throw e;
		})));
	}
	_redirectToDefaultPage(url) {
		const withoutBasePath = url.substring(this._selfLocation.length);
		const params = new URLSearchParams({ r: withoutBasePath });
		return Response.redirect(`${this._selfLocation}?${params.toString()}`);
	}
	_shouldRedirectToDefaultPage(urlWithout) {
		return !urlWithout.startsWith(this._possibleRest) && urlWithout.startsWith(this._selfLocation) && urlWithout !== this._selfLocation && this._applicationPaths.includes(this._getFirstPathComponent(urlWithout));
	}
	_getFirstPathComponent(url) {
		const pathElements = url.substring(this._selfLocation.length).split("/");
		return pathElements.length > 0 ? pathElements[0] : "";
	}
};
const init$1 = (sw) => {
	console.log("sw init", versionString);
	const scope = self;
	scope.addEventListener("install", (evt) => {
		console.log("SW: being installed", versionString);
		evt.waitUntil(sw.precache().then(() => {
			if (shouldTakeOverImmediately()) scope.skipWaiting();
		}));
	});
	scope.addEventListener("activate", (event) => {
		console.log("sw activate", versionString);
		event.waitUntil(sw.deleteOldCaches().then(() => scope.clients.claim()));
	});
	scope.addEventListener("fetch", (evt) => {
		sw.respond(evt);
	});
	scope.addEventListener("message", (event) => {
		console.log("sw message", versionString, event);
		if (event.data === "update") scope.skipWaiting();
	});
	scope.addEventListener("error", ({ error }) => {
		const serializedError = {
			name: error.name,
			message: error.message,
			stack: error.stack,
			data: error.data
		};
		return scope.clients.matchAll().then((allClients) => {
			for (const c of allClients) c.postMessage({
				type: "error",
				value: serializedError
			});
		});
	});
};
if (typeof env === "undefined" || env.mode !== "Test") {
	const cacheName = "CODE_CACHE-v" + versionString;
	const selfLocation = self.location.href.substring(0, self.location.href.indexOf("sw.js"));
	const exclusions = customDomainCacheExclusions();
	const urlsToCache = (isTutanotaDomain() ? filesToCache() : filesToCache().filter((file) => !exclusions.includes(file))).map((file) => selfLocation + file);
	const applicationPaths$1 = getPathBases();
	const sw = new ServiceWorker(urlsToCache, caches, cacheName, selfLocation, applicationPaths$1, isTutanotaDomain());
	init$1(sw);
}

//#endregion
//#region tests/serviceworker/SwTest.ts
dist_default.spec("ServiveWorkerTest ", node(function() {
	const root = "https://test/";
	let caches$1 = {};
	let sw;
	let exclusions;
	let applicationPaths$1 = ["mail", "login"];
	dist_default.before(function() {
		exclusions = [];
		sw = new ServiceWorker([], caches$1, "testCache", root, applicationPaths$1, true);
	});
	dist_default("shouldNotRedirectRootFile", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "index.html")).equals(false);
	});
	dist_default("shouldNotRedirectOtherResource", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "images/test.png")).equals(false);
	});
	dist_default("shouldNotRedirectRoot", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root)).equals(false);
	});
	dist_default("shouldRedirectWithPath", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "mail/blah/someId")).equals(true);
	});
	dist_default("shouldRedirectWithMailPathComponent", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "mail")).equals(true);
	});
	dist_default("shouldNotRedirectWithUnknownPath", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "otherpath/blah/someId")).equals(false);
	});
	dist_default("shouldNotRedirectRestRequests", function() {
		dist_default(sw._shouldRedirectToDefaultPage(root + "rest/draftservice")).equals(false);
	});
	dist_default("shouldNotRedirectExclusionOnCustonDomain", function() {
		sw = new ServiceWorker([], caches$1, "testCache", root, applicationPaths$1, false);
		exclusions.push("index.html");
		exclusions.push("index.js");
		dist_default(sw._shouldRedirectToDefaultPage(root + "index.html")).equals(false);
		dist_default(sw._shouldRedirectToDefaultPage(root + "index.js")).equals(false);
	});
	dist_default("shouldRedirectOnCustonDomain", function() {
		sw = new ServiceWorker([], caches$1, "testCache", root, applicationPaths$1, false);
		exclusions.push("index.html");
		dist_default(sw._shouldRedirectToDefaultPage(root + "mail/blah")).equals(true);
	});
}));

//#endregion
//#region tests/api/worker/search/EventQueueTest.ts
dist_default.spec("EventQueueTest", function() {
	let queue;
	let processElement;
	let lastProcess;
	const newUpdate = (type, instanceId) => {
		const update = createTestEntity(EntityUpdateTypeRef);
		update.operation = type;
		update.instanceId = instanceId;
		return update;
	};
	dist_default.beforeEach(function() {
		lastProcess = defer();
		processElement = spy(() => {
			if (queue.queueSize() === 1) lastProcess.resolve();
			return Promise.resolve();
		});
		queue = new EventQueue("test!", true, processElement);
	});
	dist_default("pause and resume", async function() {
		queue.pause();
		const groupId = "groupId";
		const batchWithOnlyDelete = {
			events: [newUpdate(OperationType.DELETE, "1")],
			groupId,
			batchId: "1"
		};
		queue.addBatches([batchWithOnlyDelete]);
		await delay(5);
		dist_default(queue.queueSize()).equals(1);
		queue.resume();
		await lastProcess.promise;
		dist_default(queue.queueSize()).equals(0);
	});
	dist_default("start after pause", async function() {
		queue.pause();
		const groupId = "groupId";
		const batchWithOnlyDelete = {
			events: [newUpdate(OperationType.DELETE, "1")],
			groupId,
			batchId: "1"
		};
		queue.addBatches([batchWithOnlyDelete]);
		await delay(5);
		queue.start();
		dist_default(queue.queueSize()).equals(1);
	});
	dist_default("handle ConnectionError", async function() {
		const groupId = "groupId";
		const batchWithThrow = {
			events: [newUpdate(OperationType.CREATE, "2"), newUpdate(OperationType.DELETE, "2")],
			groupId,
			batchId: "2"
		};
		const batchWithOnlyCreate = {
			events: [newUpdate(OperationType.CREATE, "3")],
			groupId,
			batchId: "3"
		};
		lastProcess = defer();
		processElement = spy(() => {
			if (queue$1.queueSize() === 1) lastProcess.resolve();
			return Promise.resolve();
		});
		let queue$1 = new EventQueue("test 2!", true, (nextElement) => {
			if (nextElement.batchId === "2") return Promise.reject(new ConnectionError("no connection"));
else throw new Error("should not be called");
		});
		queue$1.addBatches([batchWithThrow, batchWithOnlyCreate]);
		queue$1.start();
		await delay(5);
		dist_default(queue$1.queueSize()).equals(2);
		dist_default(queue$1.__processingBatch).equals(null);
	});
	dist_default.spec("collapsing events", function() {
		dist_default.beforeEach(function() {
			queue.pause();
		});
		dist_default("create + delete == delete", async function() {
			const createEvent$1 = createUpdate$2(OperationType.CREATE, "new-mail-list", "1", "u1");
			const deleteEvent = createUpdate$2(OperationType.DELETE, createEvent$1.instanceListId, createEvent$1.instanceId, "u2");
			queue.add("batch-id-1", "group-id", [createEvent$1]);
			queue.add("batch-id-2", "group-id", [deleteEvent]);
			queue.resume();
			await lastProcess.promise;
			const expectedDelete = createUpdate$2(OperationType.DELETE, createEvent$1.instanceListId, createEvent$1.instanceId, "u2");
			dist_default(processElement.invocations).deepEquals([[{
				events: [],
				batchId: "batch-id-1",
				groupId: "group-id"
			}], [{
				events: [expectedDelete],
				batchId: "batch-id-2",
				groupId: "group-id"
			}]]);
		});
		dist_default("create + update == create", async function() {
			const createEvent$1 = createUpdate$2(OperationType.CREATE, "new-mail-list", "1", "u1");
			const updateEvent = createUpdate$2(OperationType.UPDATE, createEvent$1.instanceListId, createEvent$1.instanceId, "u2");
			queue.add("batch-id-1", "group-id", [createEvent$1]);
			queue.add("batch-id-2", "group-id", [updateEvent]);
			queue.resume();
			await lastProcess.promise;
			const expectedCreate = createUpdate$2(OperationType.CREATE, createEvent$1.instanceListId, createEvent$1.instanceId, "u1");
			dist_default(processElement.invocations).deepEquals([[{
				events: [expectedCreate],
				batchId: "batch-id-1",
				groupId: "group-id"
			}]]);
		});
		dist_default("create + create == create + create", async function() {
			const createEvent$1 = createUpdate$2(OperationType.CREATE, "new-mail-list", "1", "u1");
			const createEvent2 = createUpdate$2(OperationType.CREATE, createEvent$1.instanceListId, createEvent$1.instanceId, "u2");
			queue.add("batch-id-1", "group-id", [createEvent$1]);
			queue.add("batch-id-2", "group-id", [createEvent2]);
			queue.resume();
			await lastProcess.promise;
			const expectedCreate = createUpdate$2(OperationType.CREATE, createEvent$1.instanceListId, createEvent$1.instanceId, "u1");
			const expectedCreate2 = createUpdate$2(OperationType.CREATE, createEvent$1.instanceListId, createEvent$1.instanceId, "u2");
			dist_default(processElement.invocations).deepEquals([[{
				events: [expectedCreate],
				batchId: "batch-id-1",
				groupId: "group-id"
			}], [{
				events: [expectedCreate2],
				batchId: "batch-id-2",
				groupId: "group-id"
			}]]);
		});
		dist_default("create + update + delete == delete", async function() {
			const createEvent$1 = createUpdate$2(OperationType.CREATE, "new-mail-list", "1", "u1");
			const updateEvent = createUpdate$2(OperationType.UPDATE, "new-mail-list", "1", "u2");
			const deleteEvent = createUpdate$2(OperationType.DELETE, createEvent$1.instanceListId, createEvent$1.instanceId, "u");
			queue.add("batch-id-1", "group-id", [createEvent$1]);
			queue.add("batch-id-2", "group-id", [updateEvent]);
			queue.add("batch-id-3", "group-id", [deleteEvent]);
			queue.resume();
			await lastProcess.promise;
			const expectedDelete = createUpdate$2(OperationType.DELETE, createEvent$1.instanceListId, createEvent$1.instanceId, "u");
			dist_default(processElement.invocations).deepEquals([[{
				events: [],
				batchId: "batch-id-1",
				groupId: "group-id"
			}], [{
				events: [expectedDelete],
				batchId: "batch-id-3",
				groupId: "group-id"
			}]]);
		});
		dist_default("delete + create == delete + create", async function() {
			const deleteEvent = createUpdate$2(OperationType.DELETE, "mail-list", "1", "u0");
			const createEvent$1 = createUpdate$2(OperationType.CREATE, "mail-list", "1", "u1");
			queue.add("batch-id-0", "group-id", [deleteEvent]);
			queue.add("batch-id-1", "group-id", [createEvent$1]);
			queue.resume();
			await lastProcess.promise;
			dist_default(processElement.invocations).deepEquals([[{
				events: [deleteEvent],
				batchId: "batch-id-0",
				groupId: "group-id"
			}], [{
				events: [createEvent$1],
				batchId: "batch-id-1",
				groupId: "group-id"
			}]]);
		});
		dist_default("delete + create + delete + create == delete + create", async function() {
			const deleteEvent1 = createUpdate$2(OperationType.DELETE, "list", "1", "u1");
			const nonEmptyEventInBetween = createUpdate$2(OperationType.CREATE, "list2", "2", "u1.1");
			const createEvent1 = createUpdate$2(OperationType.CREATE, "list", "1", "u2");
			const deleteEvent2 = createUpdate$2(OperationType.DELETE, "list", "1", "u3");
			const createEvent2 = createUpdate$2(OperationType.CREATE, "list", "1", "u4");
			queue.add("batch-id-1", "group-id", [deleteEvent1]);
			queue.add("batch-id-1.1", "group-id", [nonEmptyEventInBetween]);
			queue.add("batch-id-2", "group-id", [createEvent1]);
			queue.add("batch-id-3", "group-id", [deleteEvent2]);
			queue.add("batch-id-4", "group-id", [createEvent2]);
			queue.resume();
			await lastProcess.promise;
			const expectedDelete = createUpdate$2(OperationType.DELETE, createEvent1.instanceListId, createEvent1.instanceId, "u1");
			const expectedCreate = createUpdate$2(OperationType.CREATE, createEvent1.instanceListId, createEvent1.instanceId, "u4");
			const expectedDelete2 = createUpdate$2(OperationType.DELETE, createEvent1.instanceListId, createEvent1.instanceId, "u3");
			dist_default(processElement.invocations).deepEquals([
				[{
					events: [expectedDelete],
					batchId: "batch-id-1",
					groupId: "group-id"
				}],
				[{
					events: [nonEmptyEventInBetween],
					batchId: "batch-id-1.1",
					groupId: "group-id"
				}],
				[{
					events: [],
					batchId: "batch-id-2",
					groupId: "group-id"
				}],
				[{
					events: [expectedDelete2],
					batchId: "batch-id-3",
					groupId: "group-id"
				}],
				[{
					events: [expectedCreate],
					batchId: "batch-id-4",
					groupId: "group-id"
				}]
			]);
		});
		dist_default("delete (list 1) + create (list 2) == delete (list 1) + create (list 2)", async function() {
			const deleteEvent1 = createUpdate$2(OperationType.DELETE, "list1", "1", "u1");
			const createEvent1 = createUpdate$2(OperationType.CREATE, "list2", "1", "u2");
			queue.add("batch-id-1", "group-id", [deleteEvent1]);
			queue.add("batch-id-2", "group-id", [createEvent1]);
			queue.resume();
			await lastProcess.promise;
			const expectedDelete = createUpdate$2(OperationType.DELETE, deleteEvent1.instanceListId, deleteEvent1.instanceId, "u1");
			const expectedCreate = createUpdate$2(OperationType.CREATE, createEvent1.instanceListId, createEvent1.instanceId, "u2");
			dist_default(processElement.invocations).deepEquals([[{
				events: [expectedDelete],
				batchId: "batch-id-1",
				groupId: "group-id"
			}], [{
				events: [expectedCreate],
				batchId: "batch-id-2",
				groupId: "group-id"
			}]]);
		});
		dist_default("create (list 1) + update (list 1) + delete (list 2) == create (list 1) + delete (list 2)", async function() {
			const createEvent1 = createUpdate$2(OperationType.CREATE, "list1", "1", "u1");
			const updateEvent1 = createUpdate$2(OperationType.UPDATE, "list1", "1", "u2");
			const deleteEvent1 = createUpdate$2(OperationType.DELETE, "list2", "1", "u3");
			queue.add("batch-id-1", "group-id", [createEvent1]);
			queue.add("batch-id-2", "group-id", [updateEvent1]);
			queue.add("batch-id-3", "group-id", [deleteEvent1]);
			queue.resume();
			await lastProcess.promise;
			const expectedCreate = createUpdate$2(OperationType.CREATE, createEvent1.instanceListId, createEvent1.instanceId, "u1");
			const expectedDelete = createUpdate$2(OperationType.DELETE, deleteEvent1.instanceListId, deleteEvent1.instanceId, "u3");
			dist_default(processElement.invocations).deepEquals([[{
				events: [expectedCreate],
				batchId: "batch-id-1",
				groupId: "group-id"
			}], [{
				events: [expectedDelete],
				batchId: "batch-id-3",
				groupId: "group-id"
			}]]);
		});
		dist_default("same batch in two different groups", async function() {
			const createEvent1 = createUpdate$2(OperationType.CREATE, "old-mail-list", "1", "u0");
			const createEvent2 = createUpdate$2(OperationType.CREATE, "old-mail-list", "1", "u0");
			queue.add("batch-id-1", "group-id-1", [createEvent1]);
			queue.add("batch-id-1", "group-id-2", [createEvent2]);
			queue.resume();
			await lastProcess.promise;
			dist_default(processElement.invocations).deepEquals([[{
				events: [createEvent1],
				batchId: "batch-id-1",
				groupId: "group-id-1"
			}], [{
				events: [createEvent1],
				batchId: "batch-id-1",
				groupId: "group-id-2"
			}]]);
		});
		dist_default("[delete (list 1) + create (list 2)] + delete (list 2) + create (list 2) = [delete (list 1) + create (list 2)] + delete (list 2) + create (list 2)", async function() {
			const deleteEvent1 = createUpdate$2(OperationType.DELETE, "l1", "1", "u0");
			const createEvent1 = createUpdate$2(OperationType.CREATE, "l2", "1", "u1");
			const deleteEvent2 = createUpdate$2(OperationType.DELETE, "l2", "1", "u2");
			const createEvent2 = createUpdate$2(OperationType.CREATE, "l2", "1", "u3");
			queue.add("batch-id-1", "group-id-1", [deleteEvent1, createEvent1]);
			queue.add("batch-id-2", "group-id-1", [deleteEvent2]);
			queue.add("batch-id-3", "group-id-1", [createEvent2]);
			queue.resume();
			await lastProcess.promise;
			dist_default(processElement.invocations).deepEquals([
				[{
					events: [deleteEvent1],
					batchId: "batch-id-1",
					groupId: "group-id-1"
				}],
				[{
					events: [deleteEvent2],
					batchId: "batch-id-2",
					groupId: "group-id-1"
				}],
				[{
					events: [createEvent2],
					batchId: "batch-id-3",
					groupId: "group-id-1"
				}]
			]);
		});
		dist_default("optimization does not fail when there are new events with the same id but a different type", function() {
			const batchId = "batch-id-1";
			const groupId = "group-id-1";
			const instanceId = "instance-id-1";
			const eventId = "event-id-1";
			const updateEvent1 = createUpdate$2(OperationType.UPDATE, "", instanceId, eventId);
			const updateEvent2 = createUpdate$2(OperationType.UPDATE, "", instanceId, eventId);
			updateEvent1.type = GroupTypeRef.type;
			updateEvent2.type = MailboxGroupRootTypeRef.type;
			queue.add(batchId, groupId, [updateEvent1]);
			queue.add(batchId, groupId, [updateEvent2]);
		});
		function createUpdate$2(type, listId, instanceId, eventId) {
			let update = createTestEntity(EntityUpdateTypeRef);
			update.operation = type;
			update.instanceListId = listId;
			update.instanceId = instanceId;
			update.type = MailTypeRef.type;
			update.application = MailTypeRef.app;
			if (eventId) update._id = eventId;
			return update;
		}
	});
	dist_default.spec("batchMod", function() {
		const batchId = "batchId";
		const instanceListId = "instanceListId";
		const instanceId = "instanceId";
		dist_default("one entity with the same id and type", async () => {
			dist_default(batchMod(batchId, [createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			})], createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			}))).equals(EntityModificationType.CREATE);
		});
		dist_default("there is another op with the same type but different element id", async () => {
			dist_default(batchMod(batchId, [createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.DELETE,
				instanceId: "instanceId2",
				instanceListId
			}), createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			})], createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			}))).equals(EntityModificationType.CREATE);
		});
		dist_default("there is another op with the same type but different list id", async () => {
			dist_default(batchMod(batchId, [createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.DELETE,
				instanceId,
				instanceListId: "instanceListId2"
			}), createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			})], createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			}))).equals(EntityModificationType.CREATE);
		});
		dist_default("there is another op with the id but different type", async () => {
			dist_default(batchMod(batchId, [createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "contact",
				operation: OperationType.DELETE,
				instanceId,
				instanceListId
			}), createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			})], createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			}))).equals(EntityModificationType.CREATE);
		});
		dist_default("modification is based on operation of batch, not the argument", async () => {
			dist_default(batchMod(batchId, [createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.CREATE,
				instanceId,
				instanceListId
			})], createTestEntity(EntityUpdateTypeRef, {
				application: "tutanota",
				type: "mail",
				operation: OperationType.DELETE,
				instanceId,
				instanceListId
			}))).equals(EntityModificationType.CREATE);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/MailFacadeTest.ts
var import_testdouble$54 = __toESM(require_testdouble(), 1);
dist_default.spec("MailFacade test", function() {
	let facade;
	let userFacade;
	let cryptoFacade;
	let serviceExecutor;
	let entity;
	let blobFacade;
	let fileApp;
	let loginFacade;
	let keyLoaderFacade;
	dist_default.beforeEach(function() {
		userFacade = (0, import_testdouble$54.object)();
		blobFacade = (0, import_testdouble$54.object)();
		entity = (0, import_testdouble$54.object)();
		cryptoFacade = (0, import_testdouble$54.object)();
		serviceExecutor = (0, import_testdouble$54.object)();
		fileApp = (0, import_testdouble$54.object)();
		loginFacade = (0, import_testdouble$54.object)();
		keyLoaderFacade = (0, import_testdouble$54.object)();
		facade = new MailFacade(userFacade, entity, cryptoFacade, serviceExecutor, blobFacade, fileApp, loginFacade, keyLoaderFacade);
	});
	dist_default.spec("checkMailForPhishing", function() {
		dist_default("not phishing if no markers", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("not phishing if no matching markers", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test 2") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example2.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("not phishing if only from domain matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test 2") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("not phishing if only subject matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example2.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("is phishing if subject and sender domain matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is phishing if subject with whitespaces and sender domain matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "	Test spaces \n",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Testspaces") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is not phishing if subject and sender domain matches but not authenticated", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.SOFT_FAIL,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("is phishing if subject and sender address matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_ADDRESS, "test@example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is not phishing if subject and sender address matches but not authenticated", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.SOFT_FAIL,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_ADDRESS, "test@example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(false);
		});
		dist_default("is phishing if subject and non auth sender domain matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.SOFT_FAIL,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_DOMAIN_NON_AUTH, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is phishing if subject and non auth sender address matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.SOFT_FAIL,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.FROM_ADDRESS_NON_AUTH, "test@example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is phishing if subject and link matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.LINK, "https://example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("is not phishing if just two links match", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.LINK, "https://example.com") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.LINK, "https://example2.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link1"
			}, {
				href: "https://example2.com",
				innerHTML: "link2"
			}])).equals(false);
		});
		dist_default("is phishing if subject and link domain matches", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.LINK_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "link"
			}])).equals(true);
		});
		dist_default("does not throw on invalid link", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") }), createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.LINK_DOMAIN, "example.com") })]);
			dist_default(await facade.checkMailForPhishing(mail, [
				{
					href: "/example1",
					innerHTML: "link1"
				},
				{
					href: "example2",
					innerHTML: "link2"
				},
				{
					href: "http:/",
					innerHTML: "link3"
				}
			])).equals(false);
		});
		dist_default("is phishing if subject and suspicious link", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "https://evil-domain.com"
			}])).equals(true);
		});
		dist_default("link is not suspicious if on the same domain", async function() {
			const mail = createTestEntity(MailTypeRef, {
				subject: "Test",
				authStatus: MailAuthenticationStatus.AUTHENTICATED,
				sender: createTestEntity(MailAddressTypeRef, {
					name: "a",
					address: "test@example.com"
				})
			});
			facade.phishingMarkersUpdateReceived([createTestEntity(ReportedMailFieldMarkerTypeRef, { marker: phishingMarkerValue(ReportedMailFieldType.SUBJECT, "Test") })]);
			dist_default(await facade.checkMailForPhishing(mail, [{
				href: "https://example.com",
				innerHTML: "https://example.com/test"
			}])).equals(false);
		});
	});
	dist_default.spec("verifyMimeTypesForAttachments", () => {
		function attach(mimeType, name) {
			return downcast({
				mimeType,
				name,
				_type: "DataFile"
			});
		}
		dist_default("valid mimetypes", () => {
			validateMimeTypesForAttachments([attach("application/json", "something.json")]);
			validateMimeTypesForAttachments([attach("audio/ogg; codec=opus", "something.opus")]);
			validateMimeTypesForAttachments([attach("video/webm; codecs=\"vp8, opus\"", "something.webm")]);
			validateMimeTypesForAttachments([attach("something/orrather", "something.somethingorrather")]);
			validateMimeTypesForAttachments([attach("thisisvalid/technically+this_is-ok_even-if-YOU-dont-like-it", "something.valid")]);
			validateMimeTypesForAttachments([attach("anotherthing/youcando;ishave=multiple;parameters=in;a=mimetype", "something.technicallyvalidaswell")]);
		});
		dist_default("invalid mimetypes", () => {
			dist_default(() => {
				validateMimeTypesForAttachments([attach("applicationjson", "something.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("application/json", "something.json"), attach("applicationjson", "something.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("applicationjson", "something.json"), attach("application/json", "something.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("", "bad.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("a/b/c", "no.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("a/b?c", "please stop.json")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("video/webm; codecs=\"vp8, opus oh no i forgot the quote; oops=mybad", "why.webm")]);
			}).throws(ProgrammingError);
			dist_default(() => {
				validateMimeTypesForAttachments([attach("video/webm; parameterwithoutavalue", "bad.webm")]);
			}).throws(ProgrammingError);
		});
		dist_default("isTutaCryptMail", () => {
			const pqRecipient = createTestEntity(InternalRecipientKeyDataTypeRef, { protocolVersion: CryptoProtocolVersion.TUTA_CRYPT });
			const rsaRecipient = createTestEntity(InternalRecipientKeyDataTypeRef, { protocolVersion: CryptoProtocolVersion.RSA });
			const secureExternalRecipient = createTestEntity(SecureExternalRecipientKeyDataTypeRef, {});
			const symEncInternalRecipient = createTestEntity(SymEncInternalRecipientKeyDataTypeRef, {});
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [pqRecipient],
				secureExternalRecipientKeyData: [],
				symEncInternalRecipientKeyData: []
			}))).equals(true);
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [pqRecipient, pqRecipient],
				secureExternalRecipientKeyData: [],
				symEncInternalRecipientKeyData: []
			}))).equals(true);
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [],
				secureExternalRecipientKeyData: [],
				symEncInternalRecipientKeyData: []
			}))).equals(false);
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [pqRecipient, rsaRecipient],
				secureExternalRecipientKeyData: [],
				symEncInternalRecipientKeyData: []
			}))).equals(false);
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [pqRecipient],
				secureExternalRecipientKeyData: [secureExternalRecipient],
				symEncInternalRecipientKeyData: []
			}))).equals(false);
			dist_default(facade.isTutaCryptMail(createTestEntity(SendDraftDataTypeRef, {
				internalRecipientKeyData: [pqRecipient],
				secureExternalRecipientKeyData: [],
				symEncInternalRecipientKeyData: [symEncInternalRecipient]
			}))).equals(false);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/GroupManagementFacadeTest.ts
var import_testdouble$53 = __toESM(require_testdouble(), 1);
otest_default.spec("GroupManagementFacadeTest", function() {
	let userFacade;
	let counters;
	let entityClient$1;
	let serviceExecutor;
	let pqFacade$1;
	let keyLoaderFacade;
	let cacheManagementFacade;
	let asymmetricCryptoFacade$1;
	let cryptoWrapper;
	let groupManagementFacade;
	const adminGroupId$1 = "adminGroupId";
	const groupId = "myGroupId";
	let group;
	otest_default.beforeEach(function() {
		userFacade = (0, import_testdouble$53.object)();
		counters = (0, import_testdouble$53.object)();
		entityClient$1 = (0, import_testdouble$53.object)();
		serviceExecutor = (0, import_testdouble$53.object)();
		pqFacade$1 = (0, import_testdouble$53.object)();
		keyLoaderFacade = (0, import_testdouble$53.object)();
		cacheManagementFacade = (0, import_testdouble$53.object)();
		asymmetricCryptoFacade$1 = (0, import_testdouble$53.object)();
		cryptoWrapper = (0, import_testdouble$53.object)();
		groupManagementFacade = new GroupManagementFacade(userFacade, counters, entityClient$1, serviceExecutor, pqFacade$1, keyLoaderFacade, cacheManagementFacade, asymmetricCryptoFacade$1, cryptoWrapper);
	});
	otest_default.spec("getCurrentGroupKeyViaAdminEncGKey", function() {
		const adminGroupKeyVersion = 2;
		const adminGroupKeyBytes = (0, import_testdouble$53.object)();
		const adminGroupKeyPair = (0, import_testdouble$53.object)();
		const groupKeyVersion = 1;
		const pubUserGroupEccKey = (0, import_testdouble$53.object)();
		const groupKeyBytes = (0, import_testdouble$53.object)();
		const adminGroupEncGKey = (0, import_testdouble$53.object)();
		const pubAdminGroupEncSymKey = (0, import_testdouble$53.object)();
		const pubAdminGroupEncGKey = createTestEntity(PubEncKeyDataTypeRef, {
			pubEncSymKey: pubAdminGroupEncSymKey,
			protocolVersion: CryptoProtocolVersion.TUTA_CRYPT,
			recipientIdentifier: groupId,
			recipientIdentifierType: PublicKeyIdentifierType.GROUP_ID,
			recipientKeyVersion: adminGroupKeyVersion.toString(),
			senderKeyVersion: groupKeyVersion.toString()
		});
		otest_default.beforeEach(function() {
			group = createTestEntity(GroupTypeRef, {
				_id: groupId,
				groupKeyVersion: groupKeyVersion.toString(),
				adminGroupKeyVersion: adminGroupKeyVersion.toString(),
				adminGroupEncGKey: null,
				pubAdminGroupEncGKey: null,
				admin: adminGroupId$1
			});
			(0, import_testdouble$53.when)(userFacade.hasGroup(groupId)).thenReturn(false);
			(0, import_testdouble$53.when)(userFacade.hasGroup(adminGroupId$1)).thenReturn(true);
			(0, import_testdouble$53.when)(cacheManagementFacade.reloadGroup(groupId)).thenResolve(group);
			(0, import_testdouble$53.when)(keyLoaderFacade.loadSymGroupKey(adminGroupId$1, adminGroupKeyVersion)).thenResolve(adminGroupKeyBytes);
			(0, import_testdouble$53.when)(cryptoWrapper.decryptKey(adminGroupKeyBytes, adminGroupEncGKey)).thenReturn(groupKeyBytes);
			(0, import_testdouble$53.when)(keyLoaderFacade.loadKeypair(adminGroupId$1, adminGroupKeyVersion)).thenResolve(adminGroupKeyPair);
			(0, import_testdouble$53.when)(asymmetricCryptoFacade$1.decryptSymKeyWithKeyPairAndAuthenticate(adminGroupKeyPair, pubAdminGroupEncGKey, {
				identifier: groupId,
				identifierType: PublicKeyIdentifierType.GROUP_ID
			})).thenResolve({
				decryptedAesKey: groupKeyBytes,
				senderIdentityPubKey: pubUserGroupEccKey
			});
		});
		otest_default("gets a non-cached group instance", async function() {
			group.adminGroupEncGKey = adminGroupEncGKey;
			await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId);
			(0, import_testdouble$53.verify)(cacheManagementFacade.reloadGroup(groupId));
		});
		otest_default("symmetric decryption", async function() {
			group.adminGroupEncGKey = adminGroupEncGKey;
			const groupKey = await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId);
			otest_default(groupKey.version).equals(groupKeyVersion);
			otest_default(groupKey.object).deepEquals(groupKeyBytes);
			(0, import_testdouble$53.verify)(keyLoaderFacade.loadSymGroupKey(adminGroupId$1, adminGroupKeyVersion));
			(0, import_testdouble$53.verify)(asymmetricCryptoFacade$1.decryptSymKeyWithKeyPairAndAuthenticate(import_testdouble$53.matchers.anything(), import_testdouble$53.matchers.anything(), import_testdouble$53.matchers.anything()), { times: 0 });
		});
		otest_default("asymmetric decryption", async function() {
			group.pubAdminGroupEncGKey = pubAdminGroupEncGKey;
			const groupKey = await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId);
			otest_default(groupKey.version).equals(groupKeyVersion);
			otest_default(groupKey.object).deepEquals(groupKeyBytes);
			(0, import_testdouble$53.verify)(keyLoaderFacade.loadKeypair(adminGroupId$1, adminGroupKeyVersion));
			(0, import_testdouble$53.verify)(asymmetricCryptoFacade$1.decryptSymKeyWithKeyPairAndAuthenticate(adminGroupKeyPair, pubAdminGroupEncGKey, {
				identifier: groupId,
				identifierType: PublicKeyIdentifierType.GROUP_ID
			}), { times: 1 });
		});
		otest_default("decrypt with the group membership key if the admin happens to be a member of the target group", async function() {
			(0, import_testdouble$53.when)(userFacade.hasGroup(groupId)).thenReturn(true);
			await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId);
			(0, import_testdouble$53.verify)(keyLoaderFacade.getCurrentSymGroupKey(groupId));
		});
		otest_default("throws when the group doesn't have any admin encrypted group key", async function() {
			group.adminGroupEncGKey = null;
			group.pubAdminGroupEncGKey = null;
			await assertThrows(ProgrammingError, async () => await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId));
		});
		otest_default("throws when the group only has a dummy(!) admin encrypted group key", async function() {
			group.adminGroupEncGKey = new Uint8Array(0);
			group.pubAdminGroupEncGKey = null;
			await assertThrows(ProgrammingError, async () => await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId));
		});
		otest_default("throws when the user is not an admin and tries to decrypt with the admin group key", async function() {
			(0, import_testdouble$53.when)(userFacade.hasGroup(adminGroupId$1)).thenReturn(false);
			await assertThrows(Error, async () => await groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(groupId));
		});
	});
	otest_default("replace local admin enc group key with global admin enc group key", async function() {
		const symGlobalAdminGroupKey = {
			version: 1,
			object: (0, import_testdouble$53.object)()
		};
		const symLocalAdminGroupKey = {
			version: 0,
			object: (0, import_testdouble$53.object)()
		};
		const userGroup = createTestEntity(GroupTypeRef, {
			type: GroupType.User,
			adminGroupEncGKey: (0, import_testdouble$53.object)(),
			adminGroupKeyVersion: "0",
			admin: "localAdmin"
		});
		const before = createTestEntity(GroupTypeRef, userGroup);
		const decrypted = (0, import_testdouble$53.object)();
		(0, import_testdouble$53.when)(cryptoWrapper.decryptKey(import_testdouble$53.matchers.anything(), import_testdouble$53.matchers.anything())).thenReturn(decrypted);
		const reencrypted = (0, import_testdouble$53.object)();
		(0, import_testdouble$53.when)(cryptoWrapper.encryptKey(import_testdouble$53.matchers.anything(), decrypted)).thenReturn(reencrypted);
		const groupUpdate = await groupManagementFacade.replaceLocalAdminEncGroupKeyWithGlobalAdminEncGroupKey(symGlobalAdminGroupKey, symLocalAdminGroupKey.object, userGroup);
		otest_default(groupUpdate.adminGroupKeyVersion).equals(String(symGlobalAdminGroupKey.version));
		otest_default(groupUpdate.adminGroupEncGKey).equals(reencrypted);
		otest_default(userGroup).deepEquals(before);
	});
	otest_default("traverse local admin groups", async function() {
		const globalAdminGroup = createGroupAndGroupInfo(GroupType.Admin, "adminGroups", "globalAdminId", "globalAdminId", new Uint8Array());
		const adminGroupKey = {
			object: [
				1,
				2,
				3
			],
			version: 0
		};
		const globalAdminUser = createTestEntity(UserTypeRef, {
			customer: "someCustomerId",
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				group: globalAdminGroup.group._id,
				groupType: GroupType.Admin
			})]
		});
		const customer = createTestEntity(CustomerTypeRef, {
			_id: "someCustomerId",
			adminGroup: globalAdminGroup.group._id,
			teamGroups: "teamGroupsIds"
		});
		const administratedGroupsRefs = [createTestEntity(AdministratedGroupsRefTypeRef, { items: "xs1" }), createTestEntity(AdministratedGroupsRefTypeRef, { items: "xs2" })];
		const localAdminGroup1 = createGroupAndGroupInfo(GroupType.LocalAdmin, customer.teamGroups, "localAdminGroup1Id", globalAdminGroup.group._id, new Uint8Array());
		localAdminGroup1.group.administratedGroups = administratedGroupsRefs[0];
		const localAdminGroup2 = createGroupAndGroupInfo(GroupType.LocalAdmin, customer.teamGroups, "localAdminGroup2Id", globalAdminGroup.group._id, new Uint8Array());
		localAdminGroup2.group.administratedGroups = administratedGroupsRefs[1];
		const userGroup1 = createGroupAndGroupInfo(GroupType.User, customer.userGroups, "u1", localAdminGroup1.group._id, new Uint8Array([1]));
		const userGroup2 = createGroupAndGroupInfo(GroupType.User, customer.userGroups, "u2", localAdminGroup1.group._id, new Uint8Array([1, 2]));
		const userGroup3 = createGroupAndGroupInfo(GroupType.User, customer.userGroups, "u3", localAdminGroup2.group._id, new Uint8Array([
			1,
			2,
			3
		]));
		const administratedGroupsByLocalAdmins = [
			createTestEntity(AdministratedGroupTypeRef, {
				_id: ["xs1", "1"],
				localAdminGroup: localAdminGroup1.group._id,
				groupInfo: userGroup1.groupInfo._id
			}),
			createTestEntity(AdministratedGroupTypeRef, {
				_id: ["xs1", "2"],
				localAdminGroup: localAdminGroup1.group._id,
				groupInfo: userGroup2.groupInfo._id
			}),
			createTestEntity(AdministratedGroupTypeRef, {
				_id: ["xs2", "1"],
				localAdminGroup: localAdminGroup2.group._id,
				groupInfo: userGroup3.groupInfo._id
			})
		];
		(0, import_testdouble$53.when)(userFacade.getLoggedInUser()).thenReturn(globalAdminUser);
		(0, import_testdouble$53.when)(entityClient$1.load(CustomerTypeRef, "someCustomerId")).thenResolve(customer);
		(0, import_testdouble$53.when)(entityClient$1.loadAll(GroupInfoTypeRef, "teamGroupsIds")).thenResolve([localAdminGroup1.groupInfo, localAdminGroup2.groupInfo]);
		(0, import_testdouble$53.when)(keyLoaderFacade.getCurrentSymGroupKey("globalAdminId")).thenResolve(adminGroupKey);
		(0, import_testdouble$53.when)(entityClient$1.loadAll(AdministratedGroupTypeRef, "xs1")).thenResolve([administratedGroupsByLocalAdmins[0], administratedGroupsByLocalAdmins[1]]);
		(0, import_testdouble$53.when)(entityClient$1.loadAll(AdministratedGroupTypeRef, "xs2")).thenResolve([administratedGroupsByLocalAdmins[2]]);
		const save = groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey;
		groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey = () => {
			return (0, import_testdouble$53.object)();
		};
		await groupManagementFacade.migrateLocalAdminsToGlobalAdmins();
		(0, import_testdouble$53.verify)(serviceExecutor.post(LocalAdminRemovalService, import_testdouble$53.matchers.argThat((postIn) => {
			const userWithIds = postIn.groupUpdates.map((user) => user.groupId).sort();
			otest_default(userWithIds.sort()).deepEquals([
				"u1",
				"u2",
				"u3"
			]);
			return true;
		})));
		groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey = save;
	});
	function createGroupAndGroupInfo(groupType, groupInfoListId, groupId$1, adminGroup, adminGroupEncGroupKey) {
		const groupInfo = createTestEntity(GroupInfoTypeRef, {
			_id: [groupInfoListId, `groupInfo${groupId$1}`],
			groupType,
			group: groupId$1
		});
		const group$1 = createTestEntity(GroupTypeRef, {
			type: groupType,
			admin: adminGroup,
			_id: groupId$1,
			adminGroupEncGKey: adminGroupEncGroupKey
		});
		(0, import_testdouble$53.when)(entityClient$1.load(GroupTypeRef, groupId$1)).thenResolve(group$1);
		(0, import_testdouble$53.when)(entityClient$1.load(GroupInfoTypeRef, groupInfo._id)).thenResolve(groupInfo);
		return {
			group: group$1,
			groupInfo
		};
	}
});

//#endregion
//#region tests/api/worker/facades/PQMessageTest.ts
dist_default.spec("PQMessageTest", function() {
	dist_default.spec("encodeDecodeRoundtrip", function() {
		dist_default("should lead to same result", async function() {
			const pqMessage = {
				senderIdentityPubKey: stringToUtf8Uint8Array("id"),
				ephemeralPubKey: stringToUtf8Uint8Array("eph"),
				encapsulation: {
					kyberCipherText: stringToUtf8Uint8Array("kyberCipherText"),
					kekEncBucketKey: stringToUtf8Uint8Array("bucketKeyCipherText")
				}
			};
			const encodedPqMessage = encodePQMessage(pqMessage);
			dist_default(concat(new Uint8Array([0, stringToUtf8Uint8Array("id").length]), stringToUtf8Uint8Array("id"), new Uint8Array([0, stringToUtf8Uint8Array("eph").length]), stringToUtf8Uint8Array("eph"), new Uint8Array([0, stringToUtf8Uint8Array("kyberCipherText").length]), stringToUtf8Uint8Array("kyberCipherText"), new Uint8Array([0, stringToUtf8Uint8Array("bucketKeyCipherText").length]), stringToUtf8Uint8Array("bucketKeyCipherText"))).deepEquals(encodedPqMessage);
			dist_default(pqMessage).deepEquals(decodePQMessage(encodedPqMessage));
		});
	});
});

//#endregion
//#region tests/api/worker/facades/PQFacadeTest.ts
dist_default.spec("PQFacade test", function() {
	dist_default.spec("encapsulateDecapsulateRoundtrip", function() {
		dist_default("should lead to same result", async function() {
			const kyberFacade$1 = new WASMKyberFacade(await loadLibOQSWASM());
			const pqFacade$1 = new PQFacade(kyberFacade$1);
			const senderIdentityKeyPair = generateEccKeyPair();
			const ephemeralKeyPair = generateEccKeyPair();
			const recipientKeys = await pqFacade$1.generateKeyPairs();
			const bucketKey = bitArrayToUint8Array(aes256RandomKey());
			const pqMessage = await pqFacade$1.encapsulate(senderIdentityKeyPair, ephemeralKeyPair, pqKeyPairsToPublicKeys(recipientKeys), bucketKey);
			const decryptedBucketKey = await pqFacade$1.decapsulate(pqMessage, recipientKeys);
			dist_default(bucketKey).deepEquals(decryptedBucketKey);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/CalendarFacadeTest.ts
var import_testdouble$52 = __toESM(require_testdouble(), 1);
dist_default.spec("CalendarFacadeTest", function() {
	let userAlarmInfoListId;
	let user;
	let userFacade;
	let groupManagementFacade;
	let restClientMock;
	let entityRestCache;
	let calendarFacade;
	let progressMonitor;
	let entityRequest;
	let requestSpy;
	let sendAlarmNotificationsMock;
	let loadAllMock;
	let enitityClientLoadAllMock;
	let entityRequestMock;
	let workerMock;
	let nativeMock;
	let instanceMapper;
	let serviceExecutor;
	let cryptoFacade;
	let infoMessageHandler;
	function sortEventsWithAlarmInfos(eventsWithAlarmInfos) {
		const idCompare = (el1, el2) => getLetId(el1).join("").localeCompare(getLetId(el2).join(""));
		eventsWithAlarmInfos.sort((a, b) => idCompare(a.event, b.event));
		for (let { userAlarmInfos } of eventsWithAlarmInfos) userAlarmInfos.sort(idCompare);
		return eventsWithAlarmInfos;
	}
	function assertSortedEquals(actual, expected) {
		dist_default(sortEventsWithAlarmInfos(actual)).deepEquals(sortEventsWithAlarmInfos(expected));
	}
	function makeEvent$1(listId, elementId) {
		return createTestEntity(CalendarEventTypeRef, {
			_id: [listId, elementId || restClientMock.getNextId()],
			uid: `${listId}-${elementId}`
		});
	}
	function makeUserAlarmInfo(event) {
		return createTestEntity(UserAlarmInfoTypeRef, {
			_id: [userAlarmInfoListId, restClientMock.getNextId()],
			alarmInfo: makeAlarmInfo(event)
		});
	}
	function makeAlarmInfo(event) {
		return createTestEntity(AlarmInfoTypeRef, { calendarRef: createTestEntity(CalendarEventRefTypeRef, {
			elementId: getElementId(event),
			listId: getListId(event)
		}) });
	}
	dist_default.beforeEach(async function() {
		restClientMock = new EntityRestClientMock();
		userAlarmInfoListId = restClientMock.getNextId();
		user = createTestEntity(UserTypeRef, {
			alarmInfoList: createTestEntity(UserAlarmInfoListTypeTypeRef, { alarms: userAlarmInfoListId }),
			pushIdentifierList: createTestEntity(PushIdentifierListTypeRef, { list: "pushIdentifierList" }),
			userGroup: downcast({ group: "Id" })
		});
		userFacade = downcast({ getLoggedInUser: () => user });
		groupManagementFacade = downcast({});
		entityRestCache = downcast(restClientMock);
		workerMock = downcast({ sendProgress: () => Promise.resolve() });
		nativeMock = downcast({ invokeNative: spy(() => Promise.resolve()) });
		instanceMapper = new InstanceMapper();
		serviceExecutor = (0, import_testdouble$52.object)();
		cryptoFacade = (0, import_testdouble$52.object)();
		infoMessageHandler = (0, import_testdouble$52.object)();
		calendarFacade = new CalendarFacade(userFacade, groupManagementFacade, entityRestCache, new EntityClient(entityRestCache), nativeMock, workerMock, instanceMapper, serviceExecutor, cryptoFacade, infoMessageHandler);
	});
	dist_default.spec("saveCalendarEvents", function() {
		dist_default.beforeEach(async function() {
			progressMonitor = downcast({ workDone: noOp });
			loadAllMock = function(typeRef, listId, start) {
				if (isSameTypeRef(typeRef, PushIdentifierTypeRef)) return Promise.resolve(neverNull(user.pushIdentifierList).list);
				throw new Error("should not be called with typeRef: " + typeRef);
			};
			entityRequest = async function() {
				throw new Error("not implemented");
			};
			requestSpy = spy(function(...args) {
				return entityRequest.apply(this, args);
			});
			sendAlarmNotificationsMock = mockAttribute(calendarFacade, calendarFacade.sendAlarmNotifications, () => Promise.resolve());
			enitityClientLoadAllMock = mockAttribute(calendarFacade.cachingEntityClient, calendarFacade.cachingEntityClient.loadAll, loadAllMock);
			entityRequestMock = mockAttribute(restClientMock, restClientMock.setupMultiple, requestSpy);
		});
		dist_default.afterEach(async function() {
			unmockAttribute(enitityClientLoadAllMock);
			unmockAttribute(entityRequestMock);
			unmockAttribute(sendAlarmNotificationsMock);
		});
		dist_default("save events with alarms posts all alarms in one post multiple", async function() {
			entityRequest = function(listId$1, instances) {
				const typeRef = instances[0]?._type;
				if (isSameTypeRef(typeRef, CalendarEventTypeRef)) {
					const calendarInstances = instances;
					dist_default(calendarInstances.length).equals(2);
					dist_default(calendarInstances[0].alarmInfos).deepEquals([[userAlarmInfoListId, "1"]]);
					dist_default(calendarInstances[1].alarmInfos).deepEquals([[userAlarmInfoListId, "2"], [userAlarmInfoListId, "3"]]);
					return Promise.resolve(["eventId1", "eventId2"]);
				} else if (isSameTypeRef(typeRef, UserAlarmInfoTypeRef)) {
					dist_default(instances.length).equals(3);
					return Promise.resolve([
						"1",
						"2",
						"3"
					]);
				} else throw new Error();
			};
			const listId = "listID";
			const event1 = makeEvent$1(listId, "eventId1");
			const event2 = makeEvent$1(listId, "eventId2");
			const eventsWrapper = [{
				event: event1,
				alarms: [makeAlarmInfo(event1)]
			}, {
				event: event2,
				alarms: [makeAlarmInfo(event2), makeAlarmInfo(event2)]
			}];
			await calendarFacade.saveCalendarEvents(eventsWrapper, () => Promise.resolve());
			dist_default(calendarFacade.sendAlarmNotifications.callCount).equals(1);
			dist_default(calendarFacade.sendAlarmNotifications.args[0].length).equals(3);
			dist_default(entityRestCache.setupMultiple.callCount).equals(2);
		});
		dist_default("If alarms cannot be saved a user error is thrown and events are not created", async function() {
			entityRequest = function(listId$1, instances) {
				const typeRef = instances[0]?._type;
				if (isSameTypeRef(typeRef, UserAlarmInfoTypeRef)) return Promise.reject(new SetupMultipleError("could not create alarms", [new Error("failed")], instances));
else throw new Error("Wrong typeref");
			};
			const listId = "listID";
			const event1 = makeEvent$1(listId, "eventId1");
			const event2 = makeEvent$1(listId, "eventId2");
			const eventsWrapper = [{
				event: event1,
				alarms: [makeAlarmInfo(event1)]
			}, {
				event: event2,
				alarms: [makeAlarmInfo(event2), makeAlarmInfo(event2)]
			}];
			const result = await assertThrows(ImportError, async () => await calendarFacade.saveCalendarEvents(eventsWrapper, () => Promise.resolve()));
			dist_default(result.numFailed).equals(2);
			dist_default(calendarFacade.sendAlarmNotifications.callCount).equals(0);
			dist_default(entityRestCache.setupMultiple.callCount).equals(1);
		});
		dist_default("If not all events can be saved and no connection error is present, an ImportError is thrown", async function() {
			const listId1 = "listID1";
			const listId2 = "listID2";
			entityRequest = function(listId, instances) {
				const typeRef = instances[0]?._type;
				if (isSameTypeRef(typeRef, CalendarEventTypeRef)) if (listId === listId1) return Promise.reject(new SetupMultipleError("could not save event", [new Error("failed")], instances));
else if (listId === listId2) return Promise.resolve(["eventId2"]);
else throw new Error("Unknown id");
else if (isSameTypeRef(typeRef, UserAlarmInfoTypeRef)) {
					dist_default(instances.length).equals(3);
					return Promise.resolve([
						"1",
						"2",
						"3"
					]);
				}
				throw new Error("should not be reached");
			};
			const event1 = makeEvent$1(listId1, "eventId1");
			const event2 = makeEvent$1(listId2, "eventId2");
			const eventsWrapper = [{
				event: event1,
				alarms: [makeAlarmInfo(event1)]
			}, {
				event: event2,
				alarms: [makeAlarmInfo(event2), makeAlarmInfo(event2)]
			}];
			const result = await assertThrows(ImportError, async () => await calendarFacade.saveCalendarEvents(eventsWrapper, () => Promise.resolve()));
			dist_default(result.numFailed).equals(1);
			dist_default(calendarFacade.sendAlarmNotifications.callCount).equals(1);
			dist_default(calendarFacade.sendAlarmNotifications.args[0].length).equals(2);
			dist_default(entityRestCache.setupMultiple.callCount).equals(3);
		});
		dist_default("If not all events can be saved and a connection error is present, it is thrown", async function() {
			const listId1 = "listID1";
			const listId2 = "listID2";
			entityRequest = function(listId, instances) {
				const typeRef = instances[0]?._type;
				if (isSameTypeRef(typeRef, CalendarEventTypeRef)) if (listId === listId1) return Promise.reject(new SetupMultipleError("could not save event", [new Error("failed"), new ConnectionError("no connection")], instances));
else if (listId === listId2) return Promise.resolve(["eventId2"]);
else throw new Error("Unknown id");
else if (isSameTypeRef(typeRef, UserAlarmInfoTypeRef)) {
					dist_default(instances.length).equals(3);
					return Promise.resolve([
						"1",
						"2",
						"3"
					]);
				}
				throw new Error("should not be reached");
			};
			const event1 = makeEvent$1(listId1, "eventId1");
			const event2 = makeEvent$1(listId2, "eventId2");
			const eventsWrapper = [{
				event: event1,
				alarms: [makeAlarmInfo(event1)]
			}, {
				event: event2,
				alarms: [makeAlarmInfo(event2), makeAlarmInfo(event2)]
			}];
			await assertThrows(ConnectionError, async () => await calendarFacade.saveCalendarEvents(eventsWrapper, () => Promise.resolve()));
			dist_default(calendarFacade.sendAlarmNotifications.callCount).equals(1);
			dist_default(calendarFacade.sendAlarmNotifications.args[0].length).equals(2);
			dist_default(entityRestCache.setupMultiple.callCount).equals(3);
		});
	});
	dist_default.spec("loadAlarmEvents", function() {
		dist_default("no alarms", async function() {
			dist_default(await calendarFacade.loadAlarmEvents()).deepEquals([]);
		});
		dist_default("one alarm", async function() {
			const calendarId = restClientMock.getNextId();
			const event = makeEvent$1(calendarId);
			const alarm = makeUserAlarmInfo(event);
			restClientMock.addListInstances(event, alarm);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [{
				event,
				userAlarmInfos: [alarm]
			}];
			assertSortedEquals(actual, expected);
		});
		dist_default("multiple alarms, same event", async function() {
			const calendarId = restClientMock.getNextId();
			const event = makeEvent$1(calendarId);
			const alarm1 = makeUserAlarmInfo(event);
			const alarm2 = makeUserAlarmInfo(event);
			restClientMock.addListInstances(event, alarm1, alarm2);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [{
				event,
				userAlarmInfos: [alarm1, alarm2]
			}];
			assertSortedEquals(actual, expected);
		});
		dist_default("multiple alarms, different events", async function() {
			const calendarId = restClientMock.getNextId();
			const event1 = makeEvent$1(calendarId);
			const event2 = makeEvent$1(calendarId);
			const alarm1 = makeUserAlarmInfo(event1);
			const alarm2 = makeUserAlarmInfo(event2);
			const alarm3 = makeUserAlarmInfo(event2);
			restClientMock.addListInstances(event1, event2, alarm1, alarm2, alarm3);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [{
				event: event1,
				userAlarmInfos: [alarm1]
			}, {
				event: event2,
				userAlarmInfos: [alarm2, alarm3]
			}];
			assertSortedEquals(actual, expected);
		});
		dist_default("multiple alarms, different calendar", async function() {
			const calendarId1 = restClientMock.getNextId();
			const calendarId2 = restClientMock.getNextId();
			const event1 = makeEvent$1(calendarId1);
			const event2 = makeEvent$1(calendarId2);
			const event3 = makeEvent$1(calendarId2);
			const alarm1 = makeUserAlarmInfo(event1);
			const alarm2 = makeUserAlarmInfo(event2);
			const alarm3 = makeUserAlarmInfo(event2);
			const alarm4 = makeUserAlarmInfo(event3);
			restClientMock.addListInstances(event1, event2, event3, alarm1, alarm2, alarm3, alarm4);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [
				{
					event: event1,
					userAlarmInfos: [alarm1]
				},
				{
					event: event2,
					userAlarmInfos: [alarm2, alarm3]
				},
				{
					event: event3,
					userAlarmInfos: [alarm4]
				}
			];
			assertSortedEquals(actual, expected);
		});
		dist_default("multiple alarms, different calendar, clashing event ids", async function() {
			const calendarId1 = restClientMock.getNextId();
			const calendarId2 = restClientMock.getNextId();
			const clashingEventId = restClientMock.getNextId();
			const event1 = makeEvent$1(calendarId1);
			const event2 = makeEvent$1(calendarId2);
			const clashEvent1 = makeEvent$1(calendarId1, clashingEventId);
			const clashEvent2 = makeEvent$1(calendarId2, clashingEventId);
			const alarm1 = makeUserAlarmInfo(event1);
			const alarm2 = makeUserAlarmInfo(event2);
			const alarm3 = makeUserAlarmInfo(event2);
			const alarm4 = makeUserAlarmInfo(clashEvent1);
			const alarm5 = makeUserAlarmInfo(clashEvent2);
			const alarm6 = makeUserAlarmInfo(clashEvent2);
			restClientMock.addListInstances(event1, event2, clashEvent1, clashEvent2, alarm1, alarm2, alarm3, alarm4, alarm5, alarm6);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [
				{
					event: event1,
					userAlarmInfos: [alarm1]
				},
				{
					event: event2,
					userAlarmInfos: [alarm2, alarm3]
				},
				{
					event: clashEvent1,
					userAlarmInfos: [alarm4]
				},
				{
					event: clashEvent2,
					userAlarmInfos: [alarm5, alarm6]
				}
			];
			assertSortedEquals(actual, expected);
		});
		dist_default("multiple alarms, not all events found", async function() {
			const calendarId = restClientMock.getNextId();
			const event = makeEvent$1(calendarId);
			const missingEvent = makeEvent$1(calendarId);
			const alarm = makeUserAlarmInfo(event);
			const missingAlarm = makeUserAlarmInfo(missingEvent);
			restClientMock.addListInstances(event, alarm, missingAlarm);
			const actual = await calendarFacade.loadAlarmEvents();
			const expected = [{
				event,
				userAlarmInfos: [alarm]
			}];
			assertSortedEquals(actual, expected);
		});
	});
	dist_default.spec("sortByRecurrenceId", function() {
		dist_default("sorts empty array", function() {
			const arr = [];
			sortByRecurrenceId(arr);
			dist_default(arr).deepEquals([]);
		});
		dist_default("sorts array with len 1", function() {
			const arr = [createTestEntity(CalendarEventTypeRef, { recurrenceId: new Date("2023-07-17T13:00") })];
			const expected = clone(arr);
			sortByRecurrenceId(arr);
			dist_default(arr).deepEquals(expected);
		});
		dist_default("sorts array that's not sorted", function() {
			const arr = [createTestEntity(CalendarEventTypeRef, { recurrenceId: new Date("2023-07-17T13:00") }), createTestEntity(CalendarEventTypeRef, { recurrenceId: new Date("2023-07-16T13:00") })];
			const expected = clone(arr);
			const smaller$1 = expected[1];
			expected[1] = expected[0];
			expected[0] = smaller$1;
			sortByRecurrenceId(arr);
			dist_default(arr).deepEquals(expected);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/UserFacadeTest.ts
var import_testdouble$51 = __toESM(require_testdouble(), 1);
dist_default.spec("UserFacadeTest", function() {
	let keyCache;
	let facade;
	dist_default.beforeEach(function() {
		keyCache = (0, import_testdouble$51.object)();
		facade = new UserFacade(keyCache, (0, import_testdouble$51.object)());
	});
	dist_default("a fresh UserFacade doesn't think it's logged or partially logged in", function() {
		dist_default(facade.isPartiallyLoggedIn()).equals(false);
		dist_default(facade.isFullyLoggedIn()).equals(false);
	});
	dist_default("a user facade doesn't think it's logged in after receiving an accessToken but no user or groupKeys", function() {
		facade.setAccessToken("hello.");
		dist_default(facade.isPartiallyLoggedIn()).equals(false);
		dist_default(facade.isFullyLoggedIn()).equals(false);
	});
	dist_default("a user facade doesn't think it's logged in fully after receiving a user but no groupKeys", function() {
		facade.setAccessToken("hello.");
		facade.setUser({});
		dist_default(facade.isPartiallyLoggedIn()).equals(true);
		dist_default(facade.isFullyLoggedIn()).equals(false);
	});
	dist_default("updateUserGroupKey - successfull", function() {
		const distributionKey = aes256RandomKey();
		const newUserGroupKey = aes256RandomKey();
		const distributionEncUserGroupKey = encryptKey(distributionKey, newUserGroupKey);
		const distributionUpdate = createTestEntity(UserGroupKeyDistributionTypeRef, {
			_id: "userGroupId",
			distributionEncUserGroupKey,
			userGroupKeyVersion: "1"
		});
		(0, import_testdouble$51.when)(keyCache.getUserGroupKeyDistributionKey()).thenReturn(distributionKey);
		facade.updateUserGroupKey(distributionUpdate);
		(0, import_testdouble$51.verify)(keyCache.setCurrentUserGroupKey({
			version: 1,
			object: newUserGroupKey
		}));
	});
	dist_default("updateUserGroupKey - ignore missing distribution key ", function() {
		const distributionKey = aes256RandomKey();
		const newUserGroupKey = aes256RandomKey();
		const distributionEncUserGroupKey = encryptKey(distributionKey, newUserGroupKey);
		const distributionUpdate = createTestEntity(UserGroupKeyDistributionTypeRef, {
			_id: "userGroupId",
			distributionEncUserGroupKey,
			userGroupKeyVersion: "1"
		});
		(0, import_testdouble$51.when)(keyCache.getUserGroupKeyDistributionKey()).thenReturn(null);
		facade.updateUserGroupKey(distributionUpdate);
		(0, import_testdouble$51.verify)(keyCache.setCurrentUserGroupKey(import_testdouble$51.matchers.anything()), { times: 0 });
	});
	dist_default("updateUserGroupKey - ignore decryption error", function() {
		const distributionKey = aes256RandomKey();
		const newUserGroupKey = aes256RandomKey();
		const distributionEncUserGroupKey = encryptKey(newUserGroupKey, newUserGroupKey);
		const distributionUpdate = createTestEntity(UserGroupKeyDistributionTypeRef, {
			_id: "userGroupId",
			distributionEncUserGroupKey,
			userGroupKeyVersion: "1"
		});
		(0, import_testdouble$51.when)(keyCache.getUserGroupKeyDistributionKey()).thenReturn(distributionKey);
		facade.updateUserGroupKey(distributionUpdate);
		(0, import_testdouble$51.verify)(keyCache.setCurrentUserGroupKey(import_testdouble$51.matchers.anything()), { times: 0 });
	});
});

//#endregion
//#region tests/api/worker/facades/KeyLoaderFacadeTest.ts
var import_testdouble$50 = __toESM(require_testdouble(), 1);
dist_default.spec("KeyLoaderFacadeTest", function() {
	let keyCache;
	let userFacade;
	let entityClient$1;
	let cacheManagementFacade;
	let pqFacade$1;
	let keyLoaderFacade;
	let group;
	let userGroup;
	let currentKeys = null;
	let formerKeys;
	let formerKeysDecrypted;
	let currentGroupKey;
	let userGroupKey;
	let currentGroupKeyVersion;
	let formerKeyPairsDecrypted;
	const FORMER_KEYS = 2;
	let currentKeyPair;
	let membership;
	dist_default.beforeEach(async () => {
		keyCache = new KeyCache();
		userFacade = (0, import_testdouble$50.object)();
		entityClient$1 = (0, import_testdouble$50.object)();
		cacheManagementFacade = (0, import_testdouble$50.object)();
		pqFacade$1 = new PQFacade(new WASMKyberFacade(await loadLibOQSWASM()));
		keyLoaderFacade = new KeyLoaderFacade(keyCache, userFacade, entityClient$1, async () => cacheManagementFacade);
		formerKeys = [];
		formerKeyPairsDecrypted = [];
		formerKeysDecrypted = [];
		for (let i = 0; i < FORMER_KEYS; i++) {
			formerKeysDecrypted.push(aes256RandomKey());
			formerKeyPairsDecrypted.push(await pqFacade$1.generateKeyPairs());
		}
		currentGroupKeyVersion = formerKeysDecrypted.length;
		currentGroupKey = {
			object: aes256RandomKey(),
			version: Number(currentGroupKeyVersion)
		};
		let lastKey = currentGroupKey.object;
		for (let i = formerKeysDecrypted.length - 1; i >= 0; i--) {
			const key = createTestEntity(GroupKeyTypeRef);
			key._id = ["list", stringToCustomId(i.toString())];
			key.ownerEncGKey = encryptKey(lastKey, formerKeysDecrypted[i]);
			const pqKeyPair = formerKeyPairsDecrypted[i];
			key.keyPair = createTestEntity(KeyPairTypeRef, {
				pubEccKey: pqKeyPair.eccKeyPair.publicKey,
				pubKyberKey: kyberPublicKeyToBytes(pqKeyPair.kyberKeyPair.publicKey),
				symEncPrivEccKey: encryptEccKey(formerKeysDecrypted[i], pqKeyPair.eccKeyPair.privateKey),
				symEncPrivKyberKey: aesEncrypt(formerKeysDecrypted[i], kyberPrivateKeyToBytes(pqKeyPair.kyberKeyPair.privateKey))
			});
			lastKey = formerKeysDecrypted[i];
			formerKeys.unshift(key);
		}
		currentKeyPair = await pqFacade$1.generateKeyPairs();
		currentKeys = createTestEntity(KeyPairTypeRef, {
			pubEccKey: currentKeyPair.eccKeyPair.publicKey,
			symEncPrivEccKey: encryptEccKey(currentGroupKey.object, currentKeyPair.eccKeyPair.privateKey),
			pubKyberKey: kyberPublicKeyToBytes(currentKeyPair.kyberKeyPair.publicKey),
			symEncPrivKyberKey: aesEncrypt(currentGroupKey.object, kyberPrivateKeyToBytes(currentKeyPair.kyberKeyPair.privateKey)),
			pubRsaKey: null,
			symEncPrivRsaKey: null
		});
		group = createTestEntity(GroupTypeRef, {
			_id: "my group",
			currentKeys,
			formerGroupKeys: createTestEntity(GroupKeysRefTypeRef, { list: "list" }),
			groupKeyVersion: String(currentGroupKeyVersion)
		});
		userGroupKey = freshVersioned(aes256RandomKey());
		userGroup = createTestEntity(GroupTypeRef, {
			_id: "my userGroup",
			groupKeyVersion: String(userGroupKey.version),
			formerGroupKeys: null
		});
		membership = createTestEntity(GroupMembershipTypeRef, {
			group: group._id,
			symKeyVersion: String(userGroupKey.version),
			symEncGKey: encryptKey(userGroupKey.object, currentGroupKey.object),
			groupKeyVersion: String(currentGroupKey.version)
		});
		(0, import_testdouble$50.when)(userFacade.getCurrentUserGroupKey()).thenReturn(userGroupKey);
		(0, import_testdouble$50.when)(userFacade.getMembership(group._id)).thenReturn(membership);
		(0, import_testdouble$50.when)(userFacade.getUserGroupId()).thenReturn(userGroup._id);
		(0, import_testdouble$50.when)(entityClient$1.load(GroupTypeRef, group._id)).thenResolve(group);
		for (let i = 0; i < FORMER_KEYS; i++) (0, import_testdouble$50.when)(entityClient$1.loadRange(GroupKeyTypeRef, group.formerGroupKeys.list, stringToCustomId(String(currentGroupKeyVersion)), FORMER_KEYS - i, true)).thenDo(() => formerKeys.slice(i).reverse());
	});
	dist_default.spec("getCurrentSymGroupKey", function() {
		dist_default("getting userGroup key", async function() {
			const currentUserGroupKey = await keyLoaderFacade.getCurrentSymGroupKey(userGroup._id);
			dist_default(currentUserGroupKey.version).equals(Number(userGroup.groupKeyVersion));
			dist_default(currentUserGroupKey.object).deepEquals(userGroupKey.object);
			(0, import_testdouble$50.verify)(userFacade.getMembership(import_testdouble$50.matchers.anything()), { times: 0 });
			await keyLoaderFacade.getCurrentSymGroupKey(userGroup._id);
			(0, import_testdouble$50.verify)(userFacade.getCurrentUserGroupKey(), { times: 2 });
		});
		dist_default("getting non-userGroup key", async function() {
			const groupKey = await keyLoaderFacade.getCurrentSymGroupKey(group._id);
			dist_default(groupKey.version).equals(Number(group.groupKeyVersion));
			dist_default(groupKey.object).deepEquals(currentGroupKey.object);
			(0, import_testdouble$50.verify)(userFacade.getMembership(group._id));
			(0, import_testdouble$50.reset)();
			await keyLoaderFacade.getCurrentSymGroupKey(group._id);
			(0, import_testdouble$50.verify)(userFacade.getMembership(import_testdouble$50.matchers.anything()), { times: 0 });
		});
	});
	dist_default.spec("loadKeyPair", function() {
		dist_default("loads current key.", async function() {
			for (let i = 0; i < FORMER_KEYS; i++) {
				const keypair = await keyLoaderFacade.loadKeypair(group._id, currentGroupKeyVersion);
				dist_default(keypair).deepEquals(currentKeyPair);
			}
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 0 });
		});
		dist_default("loads former key.", async function() {
			for (let i = 0; i < FORMER_KEYS; i++) {
				const keypair = await keyLoaderFacade.loadKeypair(group._id, i);
				dist_default(keypair).deepEquals(formerKeyPairsDecrypted[i]);
			}
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 0 });
		});
		dist_default("load key pair when group is updated in cache but key cache still has the old sym key", async function() {
			const requestedVersion = currentGroupKeyVersion - 1;
			(0, import_testdouble$50.when)(entityClient$1.load(GroupKeyTypeRef, [assertNotNull(group.formerGroupKeys).list, stringToCustomId(String(requestedVersion))])).thenResolve(formerKeys[requestedVersion]);
			await keyCache.getCurrentGroupKey(group._id, () => Promise.resolve({
				version: requestedVersion,
				object: formerKeysDecrypted[requestedVersion]
			}));
			const keypair = await keyLoaderFacade.loadKeypair(group._id, requestedVersion);
			dist_default(keypair).deepEquals(formerKeyPairsDecrypted[requestedVersion]);
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 0 });
		});
	});
	dist_default.spec("loadCurrentKeyPair", function() {
		dist_default("loadCurrentKeyPair success", async function() {
			const loadedCurrentKeyPair = await keyLoaderFacade.loadCurrentKeyPair(group._id);
			dist_default(loadedCurrentKeyPair.object).deepEquals(currentKeyPair);
			dist_default(loadedCurrentKeyPair.version).equals(currentGroupKeyVersion);
		});
	});
	dist_default.spec("loadSymGroupKey", function() {
		dist_default("loads and decrypts former keys.", async function() {
			for (let i = 0; i < FORMER_KEYS; i++) {
				const loadedGroupKey = await keyLoaderFacade.loadSymGroupKey(group._id, i);
				dist_default(loadedGroupKey).deepEquals(formerKeysDecrypted[i]);
			}
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 0 });
		});
		dist_default("loads and decrypts the current key", async function() {
			const loadedGroupKey = await keyLoaderFacade.loadSymGroupKey(group._id, currentGroupKeyVersion);
			dist_default(loadedGroupKey).deepEquals(currentGroupKey.object);
		});
		dist_default("outdated currentGroupKey throws", async function() {
			const outdatedCurrentGroupKeyVersion = currentGroupKeyVersion - 1;
			await assertThrows(Error, () => keyLoaderFacade.loadSymGroupKey(group._id, currentGroupKeyVersion, {
				object: formerKeysDecrypted[outdatedCurrentGroupKeyVersion],
				version: outdatedCurrentGroupKeyVersion
			}));
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 0 });
		});
	});
	dist_default.spec("loadSymUserGroupKey", function() {
		dist_default("key cache is outdated and refreshes", async function() {
			const requestedGroupKeyVersion = Number(userGroup.groupKeyVersion) + 1;
			const refreshedUserGroupKey = {
				version: requestedGroupKeyVersion,
				object: aes256RandomKey()
			};
			(0, import_testdouble$50.when)(cacheManagementFacade.refreshKeyCache(userGroup._id)).thenDo(() => {
				(0, import_testdouble$50.when)(userFacade.getCurrentUserGroupKey()).thenReturn(refreshedUserGroupKey);
				return {
					user: (0, import_testdouble$50.object)(),
					group
				};
			});
			const loadedUserGroupKey = await keyLoaderFacade.loadSymUserGroupKey(requestedGroupKeyVersion);
			dist_default(loadedUserGroupKey).deepEquals(refreshedUserGroupKey.object);
			(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 1 });
		});
	});
	dist_default.spec("retries recursively", function() {
		let outOfDateMembership;
		dist_default.beforeEach(function() {
			outOfDateMembership = createTestEntity(GroupMembershipTypeRef, {
				group: group._id,
				symKeyVersion: String(userGroupKey.version),
				symEncGKey: encryptKey(userGroupKey.object, formerKeysDecrypted[currentGroupKeyVersion - 1]),
				groupKeyVersion: String(currentGroupKeyVersion - 1)
			});
		});
		dist_default.spec("updates the user if out-of-date", function() {
			let user;
			dist_default.beforeEach(function() {
				(0, import_testdouble$50.when)(userFacade.getMembership(group._id)).thenReturn(outOfDateMembership);
				const userGroupMembership = createTestEntity(GroupMembershipTypeRef);
				user = createTestEntity(UserTypeRef, {
					_id: "userId",
					memberships: [membership],
					userGroup: userGroupMembership
				});
				(0, import_testdouble$50.when)(cacheManagementFacade.refreshKeyCache(group._id)).thenDo(async () => {
					(0, import_testdouble$50.when)(userFacade.getMembership(group._id)).thenReturn(membership);
					await keyCache.removeOutdatedGroupKeys(user);
					return {
						user,
						group
					};
				});
				keyCache.setCurrentUserGroupKey(userGroupKey);
			});
			dist_default("loadSymGroupKey", async function() {
				const loadedKey = await keyLoaderFacade.loadSymGroupKey(group._id, currentGroupKeyVersion);
				dist_default(loadedKey).deepEquals(currentGroupKey.object);
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(group._id), { times: 1 });
			});
			dist_default("loadCurrentKeyPair", async function() {
				const loadedKeyPair = await keyLoaderFacade.loadCurrentKeyPair(group._id);
				dist_default(loadedKeyPair.object).deepEquals(currentKeyPair);
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(group._id), { times: 1 });
			});
			dist_default("loadKeyPair", async function() {
				const loadedKeyPair = await keyLoaderFacade.loadKeypair(group._id, Number(membership.groupKeyVersion));
				dist_default(loadedKeyPair).deepEquals(currentKeyPair);
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(group._id), { times: 1 });
			});
		});
		dist_default.spec("does not recurse infinitely", function() {
			let user;
			dist_default.beforeEach(function() {
				(0, import_testdouble$50.when)(userFacade.getMembership(group._id)).thenReturn(outOfDateMembership);
				user = createTestEntity(UserTypeRef, {
					_id: "userId",
					memberships: [outOfDateMembership]
				});
			});
			dist_default("loadSymGroupKey", async function() {
				await assertThrows(Error, () => keyLoaderFacade.loadSymGroupKey(group._id, currentGroupKeyVersion));
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 1 });
			});
			dist_default("loadCurrentKeyPair", async function() {
				await assertThrows(Error, () => keyLoaderFacade.loadCurrentKeyPair(group._id));
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(import_testdouble$50.matchers.anything()), { times: 1 });
			});
			dist_default("loadKeyPair", async function() {
				await assertThrows(Error, () => keyLoaderFacade.loadKeypair(group._id, Number(membership.groupKeyVersion)));
				(0, import_testdouble$50.verify)(cacheManagementFacade.refreshKeyCache(group._id), { times: 1 });
			});
		});
	});
});

//#endregion
//#region tests/api/worker/SuspensionHandlerTest.ts
var import_testdouble$49 = __toESM(require_testdouble(), 1);
dist_default.spec("SuspensionHandler test", () => {
	let suspensionHandler;
	let systemTimeout;
	let messageHandlerMock;
	dist_default.beforeEach(() => {
		messageHandlerMock = (0, import_testdouble$49.object)();
		let timeoutFn = () => {};
		systemTimeout = {
			setTimeout: spy((fn) => {
				timeoutFn = fn;
			}),
			clearTimeout: spy(),
			finish: () => timeoutFn()
		};
		suspensionHandler = new SuspensionHandler(messageHandlerMock, downcast(systemTimeout));
	});
	dist_default.spec("activating suspension", function() {
		dist_default("should prepare callback when not suspended", node(async function() {
			suspensionHandler._isSuspended = false;
			suspensionHandler.activateSuspensionIfInactive(100);
			dist_default(systemTimeout.setTimeout.args[0]).notEquals(null);
			dist_default(systemTimeout.setTimeout.args[1]).equals(1e5);
			dist_default(suspensionHandler.isSuspended()).equals(true);
		}));
		dist_default("should be a no op when suspended", node(async function() {
			suspensionHandler._isSuspended = true;
			suspensionHandler._hasSentInfoMessage = false;
			suspensionHandler.activateSuspensionIfInactive(100);
			dist_default(systemTimeout.setTimeout.callCount).equals(0);
			dist_default(suspensionHandler.isSuspended()).equals(true);
			verify(messageHandlerMock.onInfoMessage(import_testdouble$49.matchers.anything()), { times: 0 });
		}));
		dist_default("should go to not suspended state when suspension is complete", node(async function() {
			suspensionHandler._isSuspended = false;
			suspensionHandler.activateSuspensionIfInactive(100);
			systemTimeout.finish();
			dist_default(suspensionHandler.isSuspended()).equals(false);
		}));
		dist_default("should send suspend notification", node(async function() {
			suspensionHandler._isSuspended = false;
			suspensionHandler._hasSentInfoMessage = false;
			suspensionHandler.activateSuspensionIfInactive(100);
			verify(messageHandlerMock.onInfoMessage(import_testdouble$49.matchers.anything()), { times: 1 });
		}));
		dist_default("should not send suspend notification", node(async function() {
			suspensionHandler._isSuspended = false;
			suspensionHandler._hasSentInfoMessage = true;
			suspensionHandler.activateSuspensionIfInactive(100);
			verify(messageHandlerMock.onInfoMessage(import_testdouble$49.matchers.anything()), { times: 0 });
		}));
	});
	dist_default.spec("defer request", function() {
		dist_default("should not defer request when not suspended", node(async function() {
			suspensionHandler._isSuspended = false;
			const request = spy(() => Promise.resolve("ok"));
			const returnValue = await suspensionHandler.deferRequest(request);
			dist_default(request.callCount).equals(1);
			dist_default(returnValue).equals("ok");
		}));
		dist_default("should defer request when suspended", node(async function() {
			suspensionHandler._isSuspended = true;
			const request = spy(() => Promise.resolve("ok"));
			const returnedPromise = suspensionHandler.deferRequest(request);
			suspensionHandler._deferredRequests[0].resolve();
			const returnValue = await returnedPromise;
			dist_default(request.callCount).equals(1);
			dist_default(returnValue).equals("ok");
		}));
	});
	dist_default.spec("suspension complete handler", node(function() {
		dist_default("should execute suspended requests in order and reset", async function() {
			const results = [];
			const request1 = spy(async () => {
				results.push("ok!");
			});
			const deferral1 = deferWithHandler(request1);
			const request2 = spy(async () => {
				results.push("wow!");
			});
			const deferral2 = deferWithHandler(request2);
			suspensionHandler._deferredRequests.push(deferral1);
			suspensionHandler._deferredRequests.push(deferral2);
			await suspensionHandler._onSuspensionComplete();
			dist_default(results).deepEquals(["ok!", "wow!"])("Requests were executed in order");
			dist_default(suspensionHandler._deferredRequests.length).equals(0)("Requests have been reset");
		});
		dist_default("should ignore rejecting requests and keep going", node(async function() {
			const requestThatRejects = spy(() => Promise.reject("oh no!"));
			const requestThatResolves = spy(() => Promise.resolve("ok!"));
			const deferralThatRejects = deferWithHandler(requestThatRejects);
			const deferralThatResolves = deferWithHandler(requestThatResolves);
			suspensionHandler._deferredRequests.push(deferralThatRejects);
			suspensionHandler._deferredRequests.push(deferralThatResolves);
			await suspensionHandler._onSuspensionComplete();
			dist_default(requestThatRejects.callCount).equals(1);
			dist_default(requestThatResolves.callCount).equals(1);
		}));
	}));
});

//#endregion
//#region tests/api/worker/facades/ConfigurationDbTest.ts
var import_testdouble$48 = __toESM(require_testdouble(), 1);
dist_default.spec("ConfigurationDbTest", function() {
	let keyLoaderFacade;
	dist_default.beforeEach(function() {
		keyLoaderFacade = (0, import_testdouble$48.object)();
	});
	function makeMocks(allowListTable) {
		const key = aes256RandomKey();
		const iv = random.generateRandomData(IV_BYTE_LENGTH);
		const logins = downcast({
			getLoggedInUser() {
				return createTestEntity(UserTypeRef);
			},
			getUserGroupKey() {}
		});
		const loadDb = downcast(async function(user, keyLoaderFacade$1) {
			const stub = new DbStub();
			stub.addObjectStore("ExternalAllowListOS", false, "address");
			for (let entry of allowListTable) {
				const transaction = stub.createTransaction();
				const encryptedAddress = await encryptItem(entry.address, key, iv);
				await transaction.put("ExternalAllowListOS", null, {
					address: encryptedAddress,
					rule: entry.rule
				});
			}
			return {
				db: stub,
				metaData: {
					key,
					iv
				}
			};
		});
		return {
			logins,
			loadDb
		};
	}
	dist_default.spec("V1: External image allow list only", function() {
		dist_default("read", async function() {
			const { logins, loadDb } = makeMocks([{ address: "fomo@server.com" }]);
			const configDb = new ConfigurationDatabase(keyLoaderFacade, logins, loadDb);
			const shouldBeAllow = await configDb.getExternalImageRule("fomo@server.com");
			dist_default(shouldBeAllow).equals(ExternalImageRule.Allow);
			const shouldBeDefault = await configDb.getExternalImageRule("notinthere@neverseen.biz");
			dist_default(shouldBeDefault).equals(ExternalImageRule.None);
		});
		dist_default("write", async function() {
			const { logins, loadDb } = makeMocks([]);
			const configDb = new ConfigurationDatabase(keyLoaderFacade, logins, loadDb);
			await configDb.addExternalImageRule("fomo@server.com", ExternalImageRule.Allow);
			dist_default(await configDb.getExternalImageRule("fomo@server.com")).equals(ExternalImageRule.Allow);
			await configDb.addExternalImageRule("fomo@server.com", ExternalImageRule.None);
			dist_default(await configDb.getExternalImageRule("fomo@server.com")).equals(ExternalImageRule.None);
		});
	});
	dist_default.spec("V2: External image rules list", function() {
		dist_default("read", async function() {
			const { logins, loadDb } = makeMocks([{
				address: "fomo@server.com",
				rule: ExternalImageRule.Allow
			}, {
				address: "lomo@server.com",
				rule: ExternalImageRule.Block
			}]);
			const configDb = new ConfigurationDatabase(keyLoaderFacade, logins, loadDb);
			const shouldBeAllow = await configDb.getExternalImageRule("fomo@server.com");
			dist_default(shouldBeAllow).equals(ExternalImageRule.Allow);
			const shouldBeBlock = await configDb.getExternalImageRule("lomo@server.com");
			dist_default(shouldBeBlock).equals(ExternalImageRule.Block);
			const shouldBeDefault = await configDb.getExternalImageRule("notinthere@neverseen.biz");
			dist_default(shouldBeDefault).equals(ExternalImageRule.None);
		});
		dist_default("write", async function() {
			const { logins, loadDb } = makeMocks([]);
			const configDb = new ConfigurationDatabase(keyLoaderFacade, logins, loadDb);
			await configDb.addExternalImageRule("fomo@server.com", ExternalImageRule.Block);
			dist_default(await configDb.getExternalImageRule("fomo@server.com")).equals(ExternalImageRule.Block);
			await configDb.addExternalImageRule("fomo@server.com", ExternalImageRule.Allow);
			dist_default(await configDb.getExternalImageRule("fomo@server.com")).equals(ExternalImageRule.Allow);
			await configDb.addExternalImageRule("fomo@server.com", ExternalImageRule.None);
			dist_default(await configDb.getExternalImageRule("fomo@server.com")).equals(ExternalImageRule.None);
		});
	});
	dist_default.spec("Group key version in meta data", function() {
		let userFacade;
		let dbFacade;
		let transaction;
		let currentUserGroupKey;
		let dbKey$1;
		let iv;
		let encIv;
		dist_default.beforeEach(function() {
			userFacade = (0, import_testdouble$48.object)();
			dbFacade = (0, import_testdouble$48.object)();
			transaction = (0, import_testdouble$48.object)();
			(0, import_testdouble$48.when)(dbFacade.createTransaction(import_testdouble$48.matchers.anything(), import_testdouble$48.matchers.anything())).thenResolve(transaction);
			currentUserGroupKey = {
				version: 42,
				object: aes256RandomKey()
			};
			(0, import_testdouble$48.when)(keyLoaderFacade.getCurrentSymUserGroupKey()).thenReturn(currentUserGroupKey);
			dbKey$1 = aes256RandomKey();
			iv = random.generateRandomData(16);
			encIv = aesEncrypt(dbKey$1, iv, undefined, true, true);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.encDbIv)).thenResolve(encIv);
		});
		dist_default("write group key version when initializing", async function() {
			(0, import_testdouble$48.when)(dbFacade.deleteDatabase(import_testdouble$48.matchers.anything())).thenResolve();
			const transaction$1 = (0, import_testdouble$48.object)();
			(0, import_testdouble$48.when)(dbFacade.createTransaction(import_testdouble$48.matchers.anything(), import_testdouble$48.matchers.anything())).thenResolve(transaction$1);
			await initializeDb(dbFacade, "dbId", keyLoaderFacade, ConfigurationMetaDataOS);
			(0, import_testdouble$48.verify)(keyLoaderFacade.getCurrentSymUserGroupKey());
			(0, import_testdouble$48.verify)(transaction$1.put(ConfigurationMetaDataOS, Metadata.userGroupKeyVersion, currentUserGroupKey.version));
		});
		dist_default("read group key version when opening database", async function() {
			const groupKeyVersion = 6;
			const groupKey = aes256RandomKey();
			const encDBKey = aesEncrypt(groupKey, bitArrayToUint8Array(dbKey$1), iv, false, true);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userGroupKeyVersion)).thenResolve(groupKeyVersion);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userEncDbKey)).thenResolve(encDBKey);
			(0, import_testdouble$48.when)(keyLoaderFacade.loadSymUserGroupKey(groupKeyVersion)).thenResolve(groupKey);
			const encryptionMetadata = await loadEncryptionMetadata(dbFacade, "dbId", keyLoaderFacade, ConfigurationMetaDataOS);
			(0, import_testdouble$48.verify)(keyLoaderFacade.loadSymUserGroupKey(groupKeyVersion));
			dist_default(encryptionMetadata?.key).deepEquals(dbKey$1);
			dist_default(encryptionMetadata?.iv).deepEquals(iv);
		});
		dist_default("write group key version when updating database", async function() {
			const oldGroupKey = {
				version: currentUserGroupKey.version - 1,
				object: aes256RandomKey()
			};
			(0, import_testdouble$48.when)(keyLoaderFacade.loadSymUserGroupKey(oldGroupKey.version)).thenResolve(oldGroupKey.object);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userGroupKeyVersion)).thenResolve(oldGroupKey.version);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userEncDbKey)).thenResolve(encryptKey(oldGroupKey.object, dbKey$1));
			await updateEncryptionMetadata(dbFacade, keyLoaderFacade, ConfigurationMetaDataOS);
			(0, import_testdouble$48.verify)(keyLoaderFacade.getCurrentSymUserGroupKey());
			(0, import_testdouble$48.verify)(transaction.put(ConfigurationMetaDataOS, Metadata.userGroupKeyVersion, currentUserGroupKey.version));
			const encDbKeyCaptor = import_testdouble$48.matchers.captor();
			(0, import_testdouble$48.verify)(transaction.put(ConfigurationMetaDataOS, Metadata.userEncDbKey, encDbKeyCaptor.capture()));
			const capturedDbKey = aesDecrypt(currentUserGroupKey.object, encDbKeyCaptor.value, false);
			dist_default(capturedDbKey).deepEquals(bitArrayToUint8Array(dbKey$1));
		});
		dist_default("read group key version when without meta data entry", async function() {
			const groupKeyVersion = 0;
			const groupKey = aes256RandomKey();
			const encDBKey = aesEncrypt(groupKey, bitArrayToUint8Array(dbKey$1), iv, false, true);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userGroupKeyVersion)).thenResolve(undefined);
			(0, import_testdouble$48.when)(transaction.get(ConfigurationMetaDataOS, Metadata.userEncDbKey)).thenResolve(encDBKey);
			(0, import_testdouble$48.when)(keyLoaderFacade.loadSymUserGroupKey(groupKeyVersion)).thenResolve(groupKey);
			const encryptionMetadata = await loadEncryptionMetadata(dbFacade, "dbId", keyLoaderFacade, ConfigurationMetaDataOS);
			(0, import_testdouble$48.verify)(keyLoaderFacade.loadSymUserGroupKey(groupKeyVersion));
			dist_default(encryptionMetadata?.key).deepEquals(dbKey$1);
			dist_default(encryptionMetadata?.iv).deepEquals(iv);
		});
	});
});

//#endregion
//#region tests/api/worker/CompressionTest.ts
dist_default.spec("Compression/Decompression", function() {
	const lowerBound = 12;
	dist_default.spec("round trip good input", function() {
		function compressibleData(n) {
			const data$1 = "wwwwoooooooooooowwwwwwwwwweeeeeeeeeeeeeeeeeeeee";
			return Uint8Array.from(new Array(n).fill(undefined).map((_, idx) => data$1.charCodeAt(idx % data$1.length) % 256));
		}
		function testGoodInput(input) {
			const a = compress(input);
			const b = uncompress(a);
			const c = compress(b);
			const result = uncompress(c);
			dist_default(Array.from(result)).deepEquals(Array.from(input));
		}
		dist_default("almost too small", function() {
			testGoodInput(compressibleData(lowerBound + 1));
		});
		dist_default("too small", function() {
			testGoodInput(compressibleData(lowerBound));
		});
		dist_default("empty", function() {
			testGoodInput(new Uint8Array(0));
		});
	});
	dist_default.spec("compatibility", function() {
		dist_default("compression", function() {
			for (const testCase of CompatibilityTestData_default.compressionTests) dist_default(uint8ArrayToBase64(compress(stringToUtf8Uint8Array(testCase.uncompressedText)))).equals(testCase.compressedBase64TextJavaScript);
		});
		dist_default("decompression", function() {
			for (const testCase of CompatibilityTestData_default.compressionTests) {
				dist_default(utf8Uint8ArrayToString(uncompress(base64ToUint8Array(testCase.compressedBase64TextJavaScript)))).equals(testCase.uncompressedText);
				dist_default(utf8Uint8ArrayToString(uncompress(base64ToUint8Array(testCase.compressedBase64TextJava)))).equals(testCase.uncompressedText);
				dist_default(utf8Uint8ArrayToString(uncompress(base64ToUint8Array(testCase.compressedBase64TextRust)))).equals(testCase.uncompressedText);
			}
		});
	});
});

//#endregion
//#region tests/api/common/utils/PlainTextSearchTest.ts
dist_default.spec("PlainTextSearchTest", function() {
	const entryWithNestedArray1 = {
		title: "Is my password strong enough?",
		tags: "password, login",
		text: "The indicator displays if the password is strong.",
		contentObject: { text: "Text content nestedEntry1 object." },
		contentArray: [{ text: "nestedEntry1 first array element" }, { text: "nestedEntry1 second array element" }]
	};
	const entryWithNestedArray2 = {
		title: "Password strength",
		tags: "password, login",
		text: "The indicator displays the password strength. Password, Password, Password, Password, Password, Password, Password Password, Password, Password.",
		contentObject: { text: "Text content nestedEntry2 object." },
		contentArray: [{ text: "nestedEntry2 first array element" }, { text: "nestedEntry2 second array element" }]
	};
	const someEntry = {
		title: "Some Title",
		tags: "tag",
		text: "Test text."
	};
	const howChoosePasswordEntry = {
		title: "How do I choose a strong password?",
		text: "Tutanota uses a password strength indicator that takes several aspects of a password into consideration to make sure your chosen password is a perfect match for your <a target=\"_blank\" rel=\"noreferrer\" href=\"https://www.tutanota.com/\">secure email</a> account. You can find additional tips on how to choose a strong password <a target=\"_blank\" rel=\"noreferrer\" href=\"https://en.wikipedia.org/wiki/Password_strength#Guidelines_for_strong_passwords\">here</a>.Tutanota has no limitations in regard to the password length or used characters; all unicode characters are respected."
	};
	const wantPasswordEntry = {
		title: "I want a stronger password?",
		tags: "password, login",
		text: "Tutanota uses a password x strength indicator. Password, Password, Password, Password, Password, Password Password, Password, Password, Password, Password, Password, Password, Password, Password, Password, Password, Password."
	};
	const entries = [
		someEntry,
		howChoosePasswordEntry,
		wantPasswordEntry,
		entryWithNestedArray1,
		entryWithNestedArray2
	];
	const _searchEntries = [{
		title: "Some Title. This test is random.",
		tags: "tag, attestation",
		text: "Test text. Their test is not ist random. Tests are easy."
	}];
	const attributeNames = [
		"title",
		"tags",
		"text"
	];
	dist_default.spec("_search helper function", function() {
		dist_default("check if completeMatch count is correct", function() {
			const searchResult = _search("test is", _searchEntries, attributeNames, false);
			dist_default(searchResult[0].completeMatch).equals(2);
		});
		dist_default("returned entry should not be modified", function() {
			const searchResult = _search("test is", _searchEntries, attributeNames, false);
			dist_default(searchResult[0].entry).deepEquals(_searchEntries[0]);
		});
		dist_default("check if fullWordMatches count is correct", function() {
			const searchResult = _search("test", _searchEntries, attributeNames, false);
			dist_default(searchResult[0].fullWordMatches).equals(3);
		});
		dist_default("check if matchedWords array is correct", function() {
			const query = "their some test notAHitForSure!";
			const searchResult = _search(query, _searchEntries, attributeNames, false);
			dist_default(searchResult[0].matchedWords.length).equals(3);
			for (const match of searchResult[0].matchedWords) dist_default(query.includes(match)).equals(true);
		});
		dist_default("check if partialWordMatches count is correct", function() {
			const query = [
				"their",
				"something",
				"tes",
				"randomness"
			];
			const searchResult = _search(query.join(" "), _searchEntries, attributeNames, false);
			dist_default(searchResult[0].partialWordMatches).equals(6);
		});
	});
	dist_default.spec("search function", function() {
		dist_default("empty query string", function() {
			dist_default(search("", entries, attributeNames, false)).deepEquals(entries);
		});
		dist_default("no entries", function() {
			dist_default(search("a", [], attributeNames, false)).deepEquals([]);
		});
		dist_default("incorrect attributeName", function() {
			dist_default(search(entries[0].text, entries, ["test", "text"], false)).deepEquals([entries[0]]);
		});
		dist_default("ignore non-given attributeNames", function() {
			dist_default(search(entries[0].title, entries, ["text"], false)).deepEquals([]);
		});
		dist_default("no search results", function() {
			dist_default(search("doesNotExistInEntries", entries, attributeNames, false)).deepEquals([]);
		});
		dist_default("basic successful search", function() {
			dist_default(search(entries[0].text, entries, attributeNames, false)).deepEquals([entries[0]]);
		});
		dist_default("check case insensitivity", function() {
			dist_default(search(entries[0].text.toUpperCase(), entries, attributeNames, false)).deepEquals([entries[0]]);
		});
		dist_default("do not check for empty words ", function() {
			dist_default(search(" How 	 \n choose  ", entries, attributeNames, false)).deepEquals([howChoosePasswordEntry]);
		});
		dist_default("test the order of results", function() {
			dist_default(search("strong password", entries, attributeNames, false)).deepEquals([
				entries[1],
				entries[2],
				entries[3],
				entries[4]
			]);
		});
		dist_default("check if markhits causes correctly marked hits", function() {
			const searchResult = search("this is a test", _searchEntries, attributeNames, true);
			dist_default(searchResult[0]).deepEquals({
				title: "Some Title. <mark>This</mark> <mark>test</mark> is random.",
				tags: "tag, at<mark>test</mark>ation",
				text: "<mark>Test</mark> text. Their <mark>test</mark> is not ist random. <mark>Test</mark>s are easy."
			});
		});
	});
	dist_default.spec("old test cases from website (modified)", function() {
		dist_default("sort by match quality", function() {
			dist_default(search("lost password", [
				{ title: "password" },
				{ title: "lost my password" },
				{ title: "lost password" }
			], ["title"])).deepEquals([
				{ title: "lost password" },
				{ title: "lost my password" },
				{ title: "password" }
			]);
		});
		dist_default("simple find", function() {
			dist_default(search("test", [{ title: "test" }], ["title"])).deepEquals([{ title: "test" }]);
			dist_default(search("test", [{ title: "test" }], [])).deepEquals([]);
			dist_default(search("testing", [{ title: "test" }], ["title"])).deepEquals([]);
			dist_default(search("test", [{
				title: "test",
				text: "dummy"
			}], ["text"])).deepEquals([]);
			dist_default(search("Test", [{ title: "test" }], ["title"])).deepEquals([{ title: "test" }]);
			dist_default(search("test", [{ title: "Test" }], ["title"])).deepEquals([{ title: "Test" }]);
			dist_default(search("mein ball", [{ title: "mein neuer ball" }], ["title"])).deepEquals([{ title: "mein neuer ball" }]);
			dist_default(search("mein stuhl", [{ title: "mein neuer ball" }], ["title"])).deepEquals([{ title: "mein neuer ball" }]);
			dist_default(search("dein ball", [{ title: "mein neuer ball" }], ["title"])).deepEquals([{ title: "mein neuer ball" }]);
		});
		dist_default("mark search hits", function() {
			dist_default(search("test", [{ title: "test" }], ["title"], true)).deepEquals([{ title: "<mark>test</mark>" }]);
			dist_default(search("test", [{ title: "my test." }], ["title"], true)).deepEquals([{ title: "my <mark>test</mark>." }]);
			dist_default(search("hr", [{ title: "<a href=\"hr-test.com\">your hr department</a>" }], ["title"], true)).deepEquals([{ title: "<a href=\"hr-test.com\">your hr department</a>" }]);
		});
		dist_default("do not modify original structure", function() {
			let original = [{ title: "test" }];
			dist_default(search("test", original, ["title"], true)).deepEquals([{ title: "<mark>test</mark>" }]);
			dist_default(original).deepEquals([{ title: "test" }]);
		});
		dist_default("find matches", function() {
			let splittedValue = [
				"my",
				"<a href='test'>",
				"link",
				"</a>",
				"to other interesting pages with Links."
			];
			dist_default(_findMatches(splittedValue, new RegExp("link|to", "gi"), false)).deepEquals({
				hits: 3,
				matchedQueryWords: ["link", "to"]
			});
			dist_default(splittedValue).deepEquals([
				"my",
				"<a href='test'>",
				"link",
				"</a>",
				"to other interesting pages with Links."
			]);
		});
		dist_default("find matches and mark", function() {
			let splittedValue = [
				"my",
				"<a href='testlink'>",
				"link",
				"</a>",
				"to other interesting pages with Links."
			];
			dist_default(_findMatches(splittedValue, new RegExp("link|to", "gi"), true)).deepEquals({
				hits: 3,
				matchedQueryWords: ["link", "to"]
			});
			dist_default(splittedValue).deepEquals([
				"my",
				"<a href='testlink'>",
				"<mark>link</mark>",
				"</a>",
				"to other interesting pages with <mark>Link</mark>s."
			]);
		});
		dist_default("full matches", function() {
			let instance$14 = {
				id: 32,
				title: "I have received an abusive email (spam, phishing) from one of your domains. What should I do?",
				text: "<p>If you would like to inform us about abusive uscontact addresses at abuse.net.</p>",
				tags: "fraud, stalker, threat, abuse, abusive, phishing",
				category: "other"
			};
			let result = _search("abuse", [instance$14], [
				"tags",
				"title",
				"text"
			], true);
			dist_default(result[0].fullWordMatches).equals(2);
		});
		dist_default("full matches 2", function() {
			let instance$14 = {
				id: 39,
				title: "Are there email limits to protect Tutanota from being abused by spammers?",
				text: `<p>Yes, Tutanota uses different variables to calculate email limits for individual accounts. This is necessary to protect our free and anonymous email service from spammers who try to abuse Tutanota. If spammers were able to abuse Tutanota, it would harm all Tutanota users - ie Tutanota domains could end up on email blacklists, which we have to prevent under all circumstances.</p><p>If you receive the following message in your Tutanota account &quot;It looks like you exceeded the number of allowed emails. Please try again later.&quot;, the anti-spam protection method has stopped your account temporarily from sending new emails. Please wait a day or two to send new emails again.</p><p>If you need to send more emails immediately, please upgrade to our affordable Premium version (1 Euro per month) as limits for Premium users are much higher. Simply click on &#39;Premium&#39; in your top menu bar of Tutanota. </p><p>Please note that Tutanota is not meant for sending out mass mailings such as newsletters. Please read our Terms &amp; Conditions for details: <a href="https://tutanota.com/terms">https://tutanota.com/terms</a></p>`,
				tags: "",
				category: "other"
			};
			let result = _search("abuse", [instance$14], [
				"tags",
				"title",
				"text"
			], true);
			dist_default(result[0].fullWordMatches).equals(2);
		});
	});
	dist_default.spec("Nested elements", function() {
		dist_default("check nested attribute object - not implemented yet", function() {
			const query = "object";
			const _searchResult = search(query, entries, ["contentObject.text"], false);
			dist_default(_searchResult).deepEquals([]);
		});
		dist_default("check nested attribute array", function() {
			const query = "array";
			const _searchResult = search(query, entries, ["contentArray.text"], false);
			dist_default(_searchResult).deepEquals([entryWithNestedArray1, entryWithNestedArray2]);
		});
		dist_default("check nested attribute array one element", function() {
			const query = "nestedEntry1";
			const _searchResult = search(query, entries, ["contentArray.text"], false);
			dist_default(_searchResult).deepEquals([entryWithNestedArray1]);
		});
		dist_default("check invalid attribute property", function() {
			const query = "nestedEntry1";
			dist_default(search(query, entries, ["nonExistingProperty.text"], false).length).equals(0);
			dist_default(search(query, entries, ["contentArray.nonExistingAttribute"], false).length).equals(0);
			dist_default(search(query, entries, ["contentArray.text.level3"], false).length).equals(0);
			dist_default(search(query, entries, ["contentArray"], false).length).equals(0);
			dist_default(search(query, entries, ["title.text"], false).length).equals(0);
		});
		dist_default("check order in nested array", function() {
			const query = "nestedEntry2 array";
			const searchResult = search(query, entries, ["contentArray.text"], false);
			dist_default(searchResult).deepEquals([entryWithNestedArray2, entryWithNestedArray1]);
		});
		dist_default("mark hits in nested array", function() {
			const query = "nestedEntry2";
			const searchResult = search(query, entries, ["contentArray.text"], true);
			const copyOfNestedEntry = JSON.parse(JSON.stringify(entryWithNestedArray2));
			copyOfNestedEntry.contentArray[0].text = "<mark>nestedEntry2</mark> first array element";
			copyOfNestedEntry.contentArray[1].text = "<mark>nestedEntry2</mark> second array element";
			dist_default(searchResult).deepEquals([copyOfNestedEntry]);
		});
	});
});

//#endregion
//#region tests/api/common/utils/EntityUtilsTest.ts
dist_default.spec("EntityUtils", function() {
	dist_default("TimestampToHexGeneratedId ", function() {
		let timestamp = 13705632e5;
		dist_default(timestampToHexGeneratedId(timestamp, 0)).equals("4fc6fbb10000000000");
	});
	dist_default("TimestampToHexGeneratedId server id 1", function() {
		let timestamp = 13705632e5;
		dist_default(timestampToHexGeneratedId(timestamp, 1)).equals("4fc6fbb10000000001");
	});
	dist_default("generatedIdToTimestamp ", function() {
		let maxTimestamp = Math.pow(2, 42) - 1;
		dist_default(generatedIdToTimestamp(GENERATED_MIN_ID)).equals(0);
		dist_default(generatedIdToTimestamp(timestampToGeneratedId(0))).equals(0);
		dist_default(generatedIdToTimestamp("zzzzzzzzzzzz")).equals(maxTimestamp);
		dist_default(generatedIdToTimestamp("IwQvgF------")).equals(13705632e5);
	});
	dist_default.spec("MailSetEntry id", function() {
		dist_default("constructMailSetEntryId", function() {
			const mailId$1 = "-----------0";
			const expected = "V7ifKQAAAAAAAAAAAQ";
			const receiveDate = new Date("2017-10-03T13:46:13Z");
			const calculatedId = constructMailSetEntryId(receiveDate, mailId$1);
			dist_default(expected).equals(calculatedId);
		});
		dist_default("deconstructMailSetEntryId", function() {
			const setEntryId = "V7ifKQAAAAAAAAAAAQ";
			const { receiveDate, mailId: mailId$1 } = deconstructMailSetEntryId(setEntryId);
			const diff = Math.abs(receiveDate.getTime() - new Date("2017-10-03T13:46:12.864Z").getTime());
			dist_default(diff < 10).equals(true)(`Expected a date near ${new Date("2017-10-03T13:46:12.864Z")}, got: ${receiveDate} with diff ${diff}`);
			dist_default(mailId$1).equals("-----------0");
		});
	});
	dist_default("create new entity without error object ", function() {
		const mailEntity = create(typeModels.Mail, MailTypeRef);
		dist_default(mailEntity._errors).equals(undefined);
		dist_default(hasError(mailEntity)).equals(false);
		dist_default(mailEntity.subject).equals("");
		dist_default(mailEntity.attachments).deepEquals([]);
		dist_default(mailEntity.firstRecipient).equals(null);
	});
	dist_default.spec("removeTechnicalFields", function() {
		const typeRef = {
			app: "testapp",
			type: "testentity"
		};
		function makeEntity() {
			return {
				_id: "test",
				_type: typeRef,
				_ownerGroup: null,
				_ownerEncSessionKey: null
			};
		}
		dist_default("it doesn't do anything when there's nothing to remove", function() {
			const originalEntity = makeEntity();
			const entityCopy = clone(originalEntity);
			removeTechnicalFields(entityCopy);
			dist_default(entityCopy).deepEquals(originalEntity);
		});
		dist_default("it removes _finalEncrypted fields directly on the entity", function() {
			const originalEntity = {
				...makeEntity(),
				_finalEncryptedThing: [
					1,
					2,
					3
				]
			};
			const entityCopy = clone(originalEntity);
			removeTechnicalFields(entityCopy);
			dist_default(entityCopy).deepEquals({
				_id: "test",
				_type: typeRef,
				_ownerGroup: null,
				_ownerEncSessionKey: null
			});
		});
		dist_default("it removes _finalEncrypted fields deeper in the entity", function() {
			const originalEntity = {
				...makeEntity(),
				nested: {
					test: "yes",
					_finalEncryptedThing: [
						1,
						2,
						3
					]
				}
			};
			const entityCopy = clone(originalEntity);
			removeTechnicalFields(entityCopy);
			dist_default(entityCopy).deepEquals({
				_id: "test",
				_type: typeRef,
				_ownerGroup: null,
				_ownerEncSessionKey: null,
				nested: { test: "yes" }
			});
		});
	});
});

//#endregion
//#region tests/api/worker/rest/CborDateEncoderTest.ts
dist_default.spec("CborDateEncoder", function() {
	dist_default("encode and decode date", function() {
		const date = new Date(2022, 0, 24, 10, 54);
		const obj = { field: date };
		const encoded = encode(obj, { typeEncoders: customTypeEncoders });
		const decoded = decode(encoded, { tags: customTypeDecoders });
		dist_default(decoded).deepEquals(obj);
	});
});

//#endregion
//#region tests/api/worker/facades/BlobFacadeTest.ts
var import_testdouble$47 = __toESM(require_testdouble(), 1);
const { anything: anything$8, captor: captor$1 } = import_testdouble$47.matchers;
dist_default.spec("BlobFacade test", function() {
	let blobFacade;
	let blobAccessTokenFacade;
	let restClientMock;
	let suspensionHandlerMock;
	let fileAppMock;
	let aesAppMock;
	let instanceMapperMock;
	const archiveId = "archiveId1";
	const blobId1 = "blobId1";
	const blobs = [
		createTestEntity(BlobTypeRef, {
			archiveId,
			blobId: blobId1
		}),
		createTestEntity(BlobTypeRef, {
			archiveId,
			blobId: "blobId2"
		}),
		createTestEntity(BlobTypeRef, { archiveId })
	];
	let archiveDataType = ArchiveDataType.Attachments;
	let cryptoFacadeMock;
	let file;
	let anotherFile;
	dist_default.beforeEach(function() {
		restClientMock = (0, import_testdouble$47.instance)(RestClient);
		suspensionHandlerMock = (0, import_testdouble$47.instance)(SuspensionHandler);
		fileAppMock = (0, import_testdouble$47.instance)(NativeFileApp);
		aesAppMock = (0, import_testdouble$47.instance)(AesApp);
		instanceMapperMock = (0, import_testdouble$47.instance)(InstanceMapper);
		cryptoFacadeMock = (0, import_testdouble$47.object)();
		blobAccessTokenFacade = (0, import_testdouble$47.instance)(BlobAccessTokenFacade);
		const mimeType = "text/plain";
		const name = "fileName";
		file = createTestEntity(FileTypeRef, {
			name,
			mimeType,
			_id: ["fileListId", "fileElementId"]
		});
		anotherFile = createTestEntity(FileTypeRef, {
			name,
			mimeType,
			_id: ["fileListId", "anotherFileElementId"]
		});
		blobFacade = new BlobFacade(restClientMock, suspensionHandlerMock, fileAppMock, aesAppMock, instanceMapperMock, cryptoFacadeMock, blobAccessTokenFacade);
	});
	dist_default.afterEach(function() {
		env.mode = Mode.Browser;
	});
	dist_default.spec("upload", function() {
		dist_default("encryptAndUpload single blob", async function() {
			const ownerGroup = "ownerId";
			const sessionKey = aes256RandomKey();
			const blobData = new Uint8Array([
				1,
				2,
				3
			]);
			const expectedReferenceTokens = [createTestEntity(BlobReferenceTokenWrapperTypeRef, { blobReferenceToken: "blobRefToken" })];
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "w1" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestWriteToken(anything$8(), anything$8())).thenResolve(blobAccessInfo);
			let blobServiceResponse = createTestEntity(BlobPostOutTypeRef, { blobReferenceToken: expectedReferenceTokens[0].blobReferenceToken });
			(0, import_testdouble$47.when)(instanceMapperMock.decryptAndMapToInstance(anything$8(), anything$8(), anything$8())).thenResolve(blobServiceResponse);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.POST, anything$8())).thenResolve(JSON.stringify(blobServiceResponse));
			const referenceTokens = await blobFacade.encryptAndUpload(archiveDataType, blobData, ownerGroup, sessionKey);
			dist_default(referenceTokens).deepEquals(expectedReferenceTokens);
			const optionsCaptor = captor$1();
			(0, import_testdouble$47.verify)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.POST, optionsCaptor.capture()));
			const encryptedData = optionsCaptor.value.body;
			const decryptedData = aesDecrypt(sessionKey, encryptedData);
			dist_default(arrayEquals(decryptedData, blobData)).equals(true);
			dist_default(optionsCaptor.value.baseUrl).equals("w1");
		});
		dist_default("encryptAndUploadNative", async function() {
			const ownerGroup = "ownerId";
			const sessionKey = aes256RandomKey();
			const expectedReferenceTokens = [createTestEntity(BlobReferenceTokenWrapperTypeRef, { blobReferenceToken: "blobRefToken" })];
			const uploadedFileUri = "rawFileUri";
			const chunkUris = ["uri1"];
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "http://w1.api.tuta.com" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestWriteToken(anything$8(), anything$8())).thenResolve(blobAccessInfo);
			let blobServiceResponse = createTestEntity(BlobPostOutTypeRef, { blobReferenceToken: expectedReferenceTokens[0].blobReferenceToken });
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({ test: "theseAreTheParamsIPromise" });
			(0, import_testdouble$47.when)(instanceMapperMock.decryptAndMapToInstance(anything$8(), anything$8(), anything$8())).thenResolve(blobServiceResponse);
			(0, import_testdouble$47.when)(fileAppMock.splitFile(uploadedFileUri, MAX_BLOB_SIZE_BYTES)).thenResolve(chunkUris);
			let encryptedFileInfo = {
				uri: "encryptedChunkUri",
				unencSize: 3
			};
			(0, import_testdouble$47.when)(aesAppMock.aesEncryptFile(sessionKey, chunkUris[0])).thenResolve(encryptedFileInfo);
			const blobHash = "blobHash";
			(0, import_testdouble$47.when)(fileAppMock.hashFile(encryptedFileInfo.uri)).thenResolve(blobHash);
			(0, import_testdouble$47.when)(fileAppMock.upload(anything$8(), anything$8(), anything$8(), anything$8())).thenResolve({
				statusCode: 201,
				responseBody: stringToUtf8Uint8Array(JSON.stringify(blobServiceResponse))
			});
			env.mode = Mode.Desktop;
			const referenceTokens = await blobFacade.encryptAndUploadNative(archiveDataType, uploadedFileUri, ownerGroup, sessionKey);
			dist_default(referenceTokens).deepEquals(expectedReferenceTokens);
			(0, import_testdouble$47.verify)(fileAppMock.upload(encryptedFileInfo.uri, `http://w1.api.tuta.com${BLOB_SERVICE_REST_PATH}?test=theseAreTheParamsIPromise`, HttpMethod.POST, {}));
		});
	});
	dist_default.spec("download", function() {
		dist_default("downloadAndDecrypt", async function() {
			const sessionKey = aes256RandomKey();
			const blobData = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId = "--------0s--";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId,
				size: String(65)
			}));
			const encryptedBlobData = aesEncrypt(sessionKey, blobData, generateIV(), true, true);
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenBlobs(anything$8(), anything$8(), import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			const requestBody = { "request-body": true };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					1
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, anything$8())).thenResolve(blobResponse);
			const decryptedData = await blobFacade.downloadAndDecrypt(archiveDataType, wrapTutanotaFile(file));
			dist_default(decryptedData).deepEquals(blobData)("decrypted data is equal");
			const optionsCaptor = captor$1();
			(0, import_testdouble$47.verify)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, optionsCaptor.capture()));
			dist_default(optionsCaptor.value.baseUrl).equals("someBaseUrl");
			dist_default(optionsCaptor.value.queryParams.blobAccessToken).deepEquals(blobAccessInfo.blobAccessToken);
			dist_default(optionsCaptor.value.body).deepEquals(JSON.stringify(requestBody));
		});
		dist_default("downloadAndDecrypt multiple", async function() {
			const sessionKey = aes256RandomKey();
			const blobData1 = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId1$1 = "--------0s-1";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId1$1,
				size: String(65)
			}));
			const encryptedBlobData1 = aesEncrypt(sessionKey, blobData1, generateIV(), true, true);
			const blobData2 = new Uint8Array([
				4,
				5,
				6,
				7,
				8,
				9
			]);
			const blobId2 = "--------0s-2";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId2,
				size: String(65)
			}));
			const encryptedBlobData2 = aesEncrypt(sessionKey, blobData2, generateIV(), true, true);
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenBlobs(anything$8(), anything$8(), import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			const requestBody = { "request-body": true };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					2
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId1$1)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData1,
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId2)),
				// blob hash
				new Uint8Array([
					6,
					5,
					4,
					3,
					2,
					1
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData2
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, anything$8())).thenResolve(blobResponse);
			const decryptedData = await blobFacade.downloadAndDecrypt(archiveDataType, wrapTutanotaFile(file));
			dist_default(decryptedData).deepEquals(concat(blobData1, blobData2))("decrypted data is equal");
		});
		dist_default("downloadAndDecryptNative", async function() {
			const sessionKey = aes256RandomKey();
			file.blobs.push(blobs[0]);
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "http://w1.api.tuta.com" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenBlobs(anything$8(), anything$8(), import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(anything$8(), anything$8(), anything$8())).thenResolve({ test: "theseAreTheParamsIPromise" });
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			const requestBody = { "request-body": true };
			const encryptedFileUri = "encryptedUri";
			const decryptedChunkUri = "decryptedChunkUri";
			const decryptedUri = "decryptedUri";
			const size = 3;
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			(0, import_testdouble$47.when)(fileAppMock.download(anything$8(), anything$8(), anything$8())).thenResolve({
				statusCode: 200,
				encryptedFileUri
			});
			(0, import_testdouble$47.when)(aesAppMock.aesDecryptFile(sessionKey, encryptedFileUri)).thenResolve(decryptedChunkUri);
			(0, import_testdouble$47.when)(fileAppMock.joinFiles(file.name, [decryptedChunkUri])).thenResolve(decryptedUri);
			(0, import_testdouble$47.when)(fileAppMock.getSize(decryptedUri)).thenResolve(size);
			env.mode = Mode.Desktop;
			const decryptedFileReference = await blobFacade.downloadAndDecryptNative(archiveDataType, wrapTutanotaFile(file), file.name, neverNull(file.mimeType));
			const expectedFileReference = {
				_type: "FileReference",
				name: file.name,
				mimeType: neverNull(file.mimeType),
				size,
				location: decryptedUri
			};
			dist_default(decryptedFileReference).deepEquals(expectedFileReference);
			(0, import_testdouble$47.verify)(fileAppMock.download(`http://w1.api.tuta.com${BLOB_SERVICE_REST_PATH}?test=theseAreTheParamsIPromise`, blobs[0].blobId + ".blob", {}));
			(0, import_testdouble$47.verify)(fileAppMock.deleteFile(encryptedFileUri));
			(0, import_testdouble$47.verify)(fileAppMock.deleteFile(decryptedChunkUri));
		});
		dist_default("downloadAndDecryptNative_delete_on_error", async function() {
			const sessionKey = aes256RandomKey();
			file.blobs.push(blobs[0]);
			file.blobs.push(blobs[1]);
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "http://w1.api.tuta.com" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenBlobs(anything$8(), anything$8(), import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			const requestBody = { "request-body": true };
			const encryptedFileUri = "encryptedUri";
			const decryptedChunkUri = "decryptedChunkUri";
			const decryptedUri = "decryptedUri";
			const size = 3;
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			(0, import_testdouble$47.when)(fileAppMock.download(anything$8(), blobs[0].blobId + ".blob", anything$8())).thenResolve({
				statusCode: 200,
				encryptedFileUri
			});
			(0, import_testdouble$47.when)(fileAppMock.download(anything$8(), blobs[1].blobId + ".blob", anything$8())).thenReject(new ProgrammingError("test download error"));
			(0, import_testdouble$47.when)(aesAppMock.aesDecryptFile(sessionKey, encryptedFileUri)).thenResolve(decryptedChunkUri);
			(0, import_testdouble$47.when)(fileAppMock.joinFiles(file.name, [decryptedChunkUri])).thenResolve(decryptedUri);
			(0, import_testdouble$47.when)(fileAppMock.getSize(decryptedUri)).thenResolve(size);
			env.mode = Mode.Desktop;
			await assertThrows(ProgrammingError, () => blobFacade.downloadAndDecryptNative(archiveDataType, wrapTutanotaFile(file), file.name, neverNull(file.mimeType)));
			(0, import_testdouble$47.verify)(fileAppMock.deleteFile(encryptedFileUri));
			(0, import_testdouble$47.verify)(fileAppMock.deleteFile(decryptedChunkUri));
		});
	});
	dist_default.spec("downloadAndDecryptBlobsOfMultipleInstances", function() {
		dist_default.test("when passed multiple instances of the same archives it downloads and decrypts the data", async function() {
			const sessionKey = aes256RandomKey();
			const anothersessionKey = aes256RandomKey();
			const blobData1 = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId1$1 = "--------0s-1";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId1$1,
				size: String(65)
			}));
			const encryptedBlobData1 = aesEncrypt(sessionKey, blobData1, generateIV(), true, true);
			const blobData2 = new Uint8Array([
				4,
				5,
				6,
				7,
				8,
				9
			]);
			const blobId2 = "--------0s-2";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId2,
				size: String(65)
			}));
			const encryptedBlobData2 = aesEncrypt(sessionKey, blobData2, generateIV(), true, true);
			const blobData3 = new Uint8Array([
				10,
				11,
				12,
				13,
				14,
				15
			]);
			const blobId3 = "--------0s-3";
			anotherFile.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId3,
				size: String(65)
			}));
			const encryptedBlobData3 = aesEncrypt(anothersessionKey, blobData3, generateIV(), true, true);
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)], import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(anotherFile)).thenResolve(anothersessionKey);
			const requestBody = { "request-body": true };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					3
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId1$1)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData1,
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId2)),
				// blob hash
				new Uint8Array([
					6,
					5,
					4,
					3,
					2,
					1
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData2,
				//blodId
				base64ToUint8Array(base64ExtToBase64(blobId3)),
				// blob hash
				new Uint8Array([
					7,
					8,
					9,
					10,
					11,
					12
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData3
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, anything$8())).thenResolve(blobResponse);
			const result = await blobFacade.downloadAndDecryptBlobsOfMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)]);
			dist_default(result).deepEquals(new Map([[getElementId(file), concat(blobData1, blobData2)], [getElementId(anotherFile), blobData3]]));
		});
		dist_default.test("when passed multiple instances of the different archives it downloads and decrypts the data", async function() {
			const sessionKey = aes256RandomKey();
			const anothersessionKey = aes256RandomKey();
			const blobData1 = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId1$1 = "--------0s-1";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId1$1,
				size: String(65),
				archiveId: "archiveId1"
			}));
			const encryptedBlobData1 = aesEncrypt(sessionKey, blobData1, generateIV(), true, true);
			const blobData2 = new Uint8Array([
				4,
				5,
				6,
				7,
				8,
				9
			]);
			const blobId2 = "--------0s-2";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId2,
				size: String(65),
				archiveId: "archiveId1"
			}));
			const encryptedBlobData2 = aesEncrypt(sessionKey, blobData2, generateIV(), true, true);
			const blobData3 = new Uint8Array([
				10,
				11,
				12,
				13,
				14,
				15
			]);
			const blobId3 = "--------0s-3";
			anotherFile.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId3,
				size: String(65),
				archiveId: "archiveId2"
			}));
			const encryptedBlobData3 = aesEncrypt(anothersessionKey, blobData3, generateIV(), true, true);
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, [wrapTutanotaFile(file)], import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, [wrapTutanotaFile(anotherFile)], import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(anotherFile)).thenResolve(anothersessionKey);
			const requestBody1 = { body: 1 };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), import_testdouble$47.matchers.argThat((inData) => inData.archiveId === "archiveId1" && inData.blobIds.length == 2), anything$8())).thenResolve(requestBody1);
			const requestBody2 = { body: 2 };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), import_testdouble$47.matchers.argThat((inData) => inData.archiveId === "archiveId2" && inData.blobIds.length == 1), anything$8())).thenResolve(requestBody2);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse1 = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					2
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId1$1)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData1,
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId2)),
				// blob hash
				new Uint8Array([
					6,
					5,
					4,
					3,
					2,
					1
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData2
);
			const blobResponse2 = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					1
				]),
				//blodId
				base64ToUint8Array(base64ExtToBase64(blobId3)),
				// blob hash
				new Uint8Array([
					7,
					8,
					9,
					10,
					11,
					12
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData3
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, import_testdouble$47.matchers.argThat((options) => options.body && JSON.parse(options.body).body === 1))).thenResolve(blobResponse1);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, import_testdouble$47.matchers.argThat((options) => options.body && JSON.parse(options.body).body === 2))).thenResolve(blobResponse2);
			const result = await blobFacade.downloadAndDecryptBlobsOfMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)]);
			dist_default(result).deepEquals(new Map([[getElementId(file), concat(blobData1, blobData2)], [getElementId(anotherFile), blobData3]]));
		});
		dist_default.test("when passed multiple instances of the same archive but one blob is missing it downloads and decrypts the rest", async function() {
			const sessionKey = aes256RandomKey();
			const anothersessionKey = aes256RandomKey();
			const blobData1 = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId1$1 = "--------0s-1";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId1$1,
				size: String(65)
			}));
			const encryptedBlobData1 = aesEncrypt(sessionKey, blobData1, generateIV(), true, true);
			const blobData2 = new Uint8Array([
				4,
				5,
				6,
				7,
				8,
				9
			]);
			const blobId2 = "--------0s-2";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId2,
				size: String(65)
			}));
			const encryptedBlobData2 = aesEncrypt(sessionKey, blobData2, generateIV(), true, true);
			const blobId3 = "--------0s-3";
			anotherFile.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId3,
				size: String(65)
			}));
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)], import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(anotherFile)).thenResolve(anothersessionKey);
			const requestBody = { "request-body": true };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					2
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId1$1)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData1,
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId2)),
				// blob hash
				new Uint8Array([
					6,
					5,
					4,
					3,
					2,
					1
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData2
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, anything$8())).thenResolve(blobResponse);
			const result = await blobFacade.downloadAndDecryptBlobsOfMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)]);
			dist_default(result).deepEquals(new Map([[getElementId(file), concat(blobData1, blobData2)]]));
		});
		dist_default.test("when passed multiple instances of the same archive but one blob is corrupted it downloads and decrypts the rest", async function() {
			const sessionKey = aes256RandomKey();
			const anothersessionKey = aes256RandomKey();
			const blobData1 = new Uint8Array([
				1,
				2,
				3
			]);
			const blobId1$1 = "--------0s-1";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId1$1,
				size: String(65)
			}));
			const encryptedBlobData1 = aesEncrypt(sessionKey, blobData1, generateIV(), true, true);
			const blobData2 = new Uint8Array([
				4,
				5,
				6,
				7,
				8,
				9
			]);
			const blobId2 = "--------0s-2";
			file.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId2,
				size: String(65)
			}));
			const encryptedBlobData2 = aesEncrypt(sessionKey, blobData2, generateIV(), true, true);
			encryptedBlobData2[16] = ~encryptedBlobData2[16];
			const blobId3 = "--------0s-3";
			anotherFile.blobs.push(createTestEntity(BlobTypeRef, {
				blobId: blobId3,
				size: String(65)
			}));
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				servers: [createTestEntity(BlobServerUrlTypeRef, { url: "someBaseUrl" })]
			});
			(0, import_testdouble$47.when)(blobAccessTokenFacade.requestReadTokenMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)], import_testdouble$47.matchers.anything())).thenResolve(blobAccessInfo);
			(0, import_testdouble$47.when)(blobAccessTokenFacade.createQueryParams(blobAccessInfo, anything$8(), anything$8())).thenResolve({
				baseUrl: "someBaseUrl",
				blobAccessToken: blobAccessInfo.blobAccessToken
			});
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(file)).thenResolve(sessionKey);
			(0, import_testdouble$47.when)(cryptoFacadeMock.resolveSessionKeyForInstance(anotherFile)).thenResolve(anothersessionKey);
			const requestBody = { "request-body": true };
			(0, import_testdouble$47.when)(instanceMapperMock.encryptAndMapToLiteral(anything$8(), anything$8(), anything$8())).thenResolve(requestBody);
			const blobSizeBinary = new Uint8Array([
				0,
				0,
				0,
				65
			]);
			const blobResponse = concat(
				// number of blobs
				new Uint8Array([
					0,
					0,
					0,
					2
				]),
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId1$1)),
				// blob hash
				new Uint8Array([
					1,
					2,
					3,
					4,
					5,
					6
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData1,
				// blob id
				base64ToUint8Array(base64ExtToBase64(blobId2)),
				// blob hash
				new Uint8Array([
					6,
					5,
					4,
					3,
					2,
					1
				]),
				// blob size
				blobSizeBinary,
				// blob data
				encryptedBlobData2
);
			(0, import_testdouble$47.when)(restClientMock.request(BLOB_SERVICE_REST_PATH, HttpMethod.GET, anything$8())).thenResolve(blobResponse);
			const result = await blobFacade.downloadAndDecryptBlobsOfMultipleInstances(archiveDataType, [wrapTutanotaFile(file), wrapTutanotaFile(anotherFile)]);
			dist_default(result).deepEquals(new Map([[getElementId(file), concat(blobData1, blobData2)]]));
		});
	});
	dist_default.spec("parseMultipleBlobsResponse", function() {
		dist_default.test("parses two blobs", function() {
			const binaryData = new Int8Array([
				0,
				0,
				0,
				2,
				100,
				-9,
				-69,
				22,
				38,
				-128,
				0,
				0,
				1,
				3,
				-112,
				88,
				-58,
				-14,
				-64,
				0,
				0,
				0,
				3,
				1,
				2,
				3,
				100,
				-9,
				-69,
				22,
				39,
				64,
				0,
				0,
				1,
				113,
				-110,
				56,
				92,
				60,
				6,
				0,
				0,
				0,
				6,
				1,
				2,
				3,
				4,
				5,
				6
			]);
			const result = parseMultipleBlobsResponse(new Uint8Array(binaryData));
			dist_default(result).deepEquals(new Map([["OETv4XP----0", new Uint8Array([
				1,
				2,
				3
			])], ["OETv4XS----0", new Uint8Array([
				1,
				2,
				3,
				4,
				5,
				6
			])]]));
		});
		dist_default.test("parses one blob", function() {
			const binaryData = new Int8Array([
				0,
				0,
				0,
				1,
				100,
				-9,
				-69,
				22,
				38,
				-128,
				0,
				0,
				1,
				3,
				-112,
				88,
				-58,
				-14,
				-64,
				0,
				0,
				0,
				3,
				1,
				2,
				3
			]);
			const result = parseMultipleBlobsResponse(new Uint8Array(binaryData));
			dist_default(result).deepEquals(new Map([["OETv4XP----0", new Uint8Array([
				1,
				2,
				3
			])]]));
		});
		dist_default.test("parses blob with big size", function() {
			const blobDataNumbers = Array(384).fill(1);
			const binaryData = new Int8Array([
				0,
				0,
				0,
				1,
				100,
				-9,
				-69,
				22,
				38,
				-128,
				0,
				0,
				1,
				3,
				-112,
				88,
				-58,
				-14,
				-64,
				0,
				0,
				1,
				128
			].concat(blobDataNumbers));
			const result = parseMultipleBlobsResponse(new Uint8Array(binaryData));
			dist_default(result).deepEquals(new Map([["OETv4XP----0", new Uint8Array(blobDataNumbers)]]));
		});
		dist_default.test("parse empty blob response", function() {
			const blobDataNumbers = Array(384).fill(1);
			const binaryData = new Int8Array([
				0,
				0,
				0,
				0
			]);
			const result = parseMultipleBlobsResponse(new Uint8Array(binaryData));
			dist_default(result).deepEquals(new Map());
		});
	});
});
function wrapTutanotaFile(tutanotaFile) {
	return {
		blobs: tutanotaFile.blobs,
		elementId: elementIdPart(tutanotaFile._id),
		listId: listIdPart(tutanotaFile._id),
		entity: tutanotaFile
	};
}

//#endregion
//#region tests/api/worker/facades/BlobAccessTokenFacadeTest.ts
var import_testdouble$46 = __toESM(require_testdouble(), 1);
const { anything: anything$7, captor } = import_testdouble$46.matchers;
dist_default.spec("BlobAccessTokenFacade", function() {
	let blobAccessTokenFacade;
	let serviceMock;
	let archiveDataType = ArchiveDataType.Attachments;
	let authDataProvider$1;
	const archiveId = "archiveId1";
	const blobId1 = "blobId1";
	const blobs = [
		createTestEntity(BlobTypeRef, {
			archiveId,
			blobId: blobId1
		}),
		createTestEntity(BlobTypeRef, {
			archiveId,
			blobId: "blobId2"
		}),
		createTestEntity(BlobTypeRef, { archiveId })
	];
	const now$1 = DateTime.fromISO("2022-11-17T00:00:00");
	const afterNow = now$1.plus({ minute: 1 });
	dist_default.beforeEach(function() {
		const dateProvider$1 = {
			now: () => now$1.toMillis(),
			timeZone: () => "Europe/Berlin"
		};
		serviceMock = (0, import_testdouble$46.object)();
		authDataProvider$1 = (0, import_testdouble$46.object)();
		blobAccessTokenFacade = new BlobAccessTokenFacade(serviceMock, authDataProvider$1, dateProvider$1);
	});
	dist_default.afterEach(function() {
		env.mode = Mode.Browser;
	});
	dist_default.spec("evict Tokens", function() {
		dist_default("evict blob specific read token", async function() {
			const file = createTestEntity(FileTypeRef, {
				blobs,
				_id: ["listId", "elementId"]
			});
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: afterNow.toJSDate(),
				tokenKind: BlobAccessTokenKind.Instances
			}) });
			const loadOptions = {};
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), loadOptions)).thenResolve(expectedToken);
			const referencingInstance = {
				blobs,
				entity: file,
				elementId: getElementId(file),
				listId: getListId(file)
			};
			await blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, loadOptions);
			blobAccessTokenFacade.evictReadBlobsToken(referencingInstance);
			const newToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, { blobAccessToken: "456" }) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), loadOptions)).thenResolve(newToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, loadOptions);
			dist_default(readToken).equals(newToken.blobAccessInfo);
		});
		dist_default("evict archive read token", async function() {
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: afterNow.toJSDate()
			});
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			blobAccessTokenFacade.evictArchiveToken(archiveId);
			const newToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, { blobAccessToken: "456" }) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(newToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			dist_default(readToken).deepEquals(newToken.blobAccessInfo);
		});
		dist_default("evict archive write token", async function() {
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: afterNow.toJSDate()
			});
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			const ownerGroupId = "ownerGroupId";
			const archiveDataType$1 = ArchiveDataType.Attachments;
			await blobAccessTokenFacade.requestWriteToken(archiveDataType$1, ownerGroupId);
			blobAccessTokenFacade.evictWriteToken(archiveDataType$1, ownerGroupId);
			const newToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, { blobAccessToken: "456" }) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(newToken);
			const readToken = await blobAccessTokenFacade.requestWriteToken(archiveDataType$1, ownerGroupId);
			dist_default(readToken).equals(newToken.blobAccessInfo);
		});
	});
	dist_default.spec("request access tokens", function() {
		dist_default.spec("read token for specific blobs", function() {
			dist_default("read token LET", async function() {
				const file = createTestEntity(FileTypeRef, {
					blobs,
					_id: ["listId", "elementId"]
				});
				const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
					blobAccessToken: "123",
					expires: afterNow.toJSDate()
				}) });
				const loadOptions = {};
				(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), loadOptions)).thenResolve(expectedToken);
				const referencingInstance = {
					blobs,
					entity: file,
					elementId: getElementId(file),
					listId: getListId(file)
				};
				const readToken = await blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, loadOptions);
				const tokenRequest = captor();
				(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture(), loadOptions));
				let instanceId = createTestEntity(InstanceIdTypeRef, { instanceId: getElementId(file) });
				dist_default(tokenRequest.value).deepEquals(createTestEntity(BlobAccessTokenPostInTypeRef, {
					archiveDataType,
					read: createTestEntity(BlobReadDataTypeRef, {
						archiveId,
						instanceListId: getListId(file),
						instanceIds: [instanceId]
					})
				}));
				dist_default(readToken).equals(expectedToken.blobAccessInfo);
			});
			dist_default("read token ET", async function() {
				const mailBox = createTestEntity(MailBoxTypeRef, { _id: "elementId" });
				const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
					blobAccessToken: "123",
					expires: new Date(now$1.toMillis() + 1e3)
				}) });
				const loadOptions = {};
				(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), loadOptions)).thenResolve(expectedToken);
				const referencingInstance = {
					blobs,
					entity: mailBox,
					listId: null,
					elementId: mailBox._id
				};
				const readToken = await blobAccessTokenFacade.requestReadTokenBlobs(archiveDataType, referencingInstance, loadOptions);
				const tokenRequest = captor();
				(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture(), loadOptions));
				let instanceId = createTestEntity(InstanceIdTypeRef, { instanceId: getEtId(mailBox) });
				dist_default(tokenRequest.value).deepEquals(createTestEntity(BlobAccessTokenPostInTypeRef, {
					archiveDataType,
					read: createTestEntity(BlobReadDataTypeRef, {
						archiveId,
						instanceListId: null,
						instanceIds: [instanceId]
					})
				}));
				dist_default(readToken).equals(expectedToken.blobAccessInfo);
			});
		});
		dist_default("request read token archive", async function() {
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3)
			});
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.value).deepEquals(createTestEntity(BlobAccessTokenPostInTypeRef, { read: createTestEntity(BlobReadDataTypeRef, {
				archiveId,
				instanceListId: null,
				instanceIds: []
			}) }));
			dist_default(readToken).equals(blobAccessInfo);
		});
		dist_default("cache read token for an entire archive", async function() {
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3)
			});
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			const readToken = await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.values.length).equals(1)("Only one call to request the token");
			dist_default(readToken).equals(blobAccessInfo);
		});
		dist_default("when requested individual blobs but the server responded with archive token, the token is cached for the archive", async function() {
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const blobLoadOptions = {};
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), blobLoadOptions)).thenResolve(expectedToken);
			const mailBox = createTestEntity(MailBoxTypeRef, { _id: "elementId" });
			const referencingInstance = {
				blobs,
				entity: mailBox,
				listId: null,
				elementId: mailBox._id
			};
			await blobAccessTokenFacade.requestReadTokenBlobs(ArchiveDataType.Attachments, referencingInstance, blobLoadOptions);
			const readToken = await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			dist_default(readToken).deepEquals(blobAccessInfo);
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, anything$7()), {
				times: 1,
				ignoreExtraArgs: true
			});
		});
		dist_default("when requested individual blobs and the server responded with instance token, the token is cached for the instances", async function() {
			const blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const blobLoadOptions = {};
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), blobLoadOptions)).thenResolve(expectedToken);
			const mailBox1 = createTestEntity(MailBoxTypeRef, { _id: "elementId1" });
			const mailBox2 = createTestEntity(MailBoxTypeRef, { _id: "elementId2" });
			const referencingInstance1 = {
				blobs,
				entity: mailBox1,
				listId: null,
				elementId: mailBox1._id
			};
			const referencingInstance2 = {
				blobs,
				entity: mailBox2,
				listId: null,
				elementId: mailBox2._id
			};
			await blobAccessTokenFacade.requestReadTokenMultipleInstances(ArchiveDataType.Attachments, [referencingInstance1, referencingInstance2], blobLoadOptions);
			const readToken = await blobAccessTokenFacade.requestReadTokenMultipleInstances(ArchiveDataType.Attachments, [referencingInstance1], blobLoadOptions);
			dist_default(readToken).deepEquals(blobAccessInfo);
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, anything$7()), {
				times: 1,
				ignoreExtraArgs: true
			});
		});
		dist_default("when requested individual blobs and the server responded with instance token that expired, new token is requested", async function() {
			const blobLoadOptions = {};
			const expiredAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() - 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const expiredToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: expiredAccessInfo });
			const newAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const newToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: newAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), blobLoadOptions)).thenResolve(expiredToken);
			const mailBox1 = createTestEntity(MailBoxTypeRef, { _id: "elementId1" });
			const mailBox2 = createTestEntity(MailBoxTypeRef, { _id: "elementId2" });
			const referencingInstance1 = {
				blobs,
				entity: mailBox1,
				listId: null,
				elementId: mailBox1._id
			};
			const referencingInstance2 = {
				blobs,
				entity: mailBox2,
				listId: null,
				elementId: mailBox2._id
			};
			await blobAccessTokenFacade.requestReadTokenMultipleInstances(ArchiveDataType.Attachments, [referencingInstance1, referencingInstance2], blobLoadOptions);
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), blobLoadOptions)).thenResolve(newToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenMultipleInstances(ArchiveDataType.Attachments, [referencingInstance1], blobLoadOptions);
			dist_default(readToken).deepEquals(newAccessInfo);
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, anything$7()), {
				times: 2,
				ignoreExtraArgs: true
			});
		});
		dist_default("when requested individual blobs but the server responded with archive token that expired, new token is requested", async function() {
			const blobLoadOptions = {};
			const expiredAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() - 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const expiredToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: expiredAccessInfo });
			const newAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3),
				tokenKind: BlobAccessTokenKind.Archive
			});
			const newToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: newAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expiredToken);
			const mailBox1 = createTestEntity(MailBoxTypeRef, { _id: "elementId1" });
			const referencingInstance = {
				blobs,
				entity: mailBox1,
				listId: null,
				elementId: mailBox1._id
			};
			await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7(), blobLoadOptions)).thenResolve(newToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenMultipleInstances(ArchiveDataType.Attachments, [referencingInstance], blobLoadOptions);
			dist_default(readToken).deepEquals(newAccessInfo);
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, anything$7()), {
				times: 2,
				ignoreExtraArgs: true
			});
		});
		dist_default("cache read token archive expired", async function() {
			let expires = new Date(now$1.toMillis() - 1);
			let blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires
			});
			let expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			blobAccessInfo = createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "456",
				expires: new Date(now$1.toMillis() + 1e3)
			});
			expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			const readToken = await blobAccessTokenFacade.requestReadTokenArchive(archiveId);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.values.length).equals(2);
			dist_default(readToken.blobAccessToken).equals("456");
		});
		dist_default("request write token", async function() {
			const ownerGroup = "ownerId";
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3)
			}) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			const writeToken = await blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroup);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.value).deepEquals(createTestEntity(BlobAccessTokenPostInTypeRef, {
				archiveDataType,
				write: createTestEntity(BlobWriteDataTypeRef, { archiveOwnerGroup: ownerGroup })
			}));
			dist_default(writeToken).equals(expectedToken.blobAccessInfo);
		});
		dist_default("cache write token", async function() {
			const ownerGroup = "ownerId";
			const expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires: new Date(now$1.toMillis() + 1e3)
			}) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			await blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroup);
			const writeToken = await blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroup);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.values.length).equals(1)("only one request for token");
			dist_default(writeToken).equals(expectedToken.blobAccessInfo);
		});
		dist_default("cache write token expired", async function() {
			let expires = new Date(now$1.toMillis() - 1);
			const ownerGroup = "ownerId";
			let expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "123",
				expires
			}) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			await blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroup);
			expectedToken = createTestEntity(BlobAccessTokenPostOutTypeRef, { blobAccessInfo: createTestEntity(BlobServerAccessInfoTypeRef, {
				blobAccessToken: "456",
				expires: new Date(now$1.toMillis() + 1e3)
			}) });
			(0, import_testdouble$46.when)(serviceMock.post(BlobAccessTokenService, anything$7())).thenResolve(expectedToken);
			const writeToken = await blobAccessTokenFacade.requestWriteToken(archiveDataType, ownerGroup);
			const tokenRequest = captor();
			(0, import_testdouble$46.verify)(serviceMock.post(BlobAccessTokenService, tokenRequest.capture()));
			dist_default(tokenRequest.values.length).equals(2)("only one request for token");
			dist_default(writeToken.blobAccessToken).equals("456");
		});
	});
});

//#endregion
//#region tests/api/worker/utils/SleepDetectorTest.ts
var import_testdouble$45 = __toESM(require_testdouble(), 1);
dist_default.spec("SleepDetector", function() {
	let scheduler;
	let dateProvider$1;
	let detector;
	dist_default.beforeEach(function() {
		scheduler = new SchedulerMock();
		dateProvider$1 = (0, import_testdouble$45.object)();
		detector = new SleepDetector(scheduler, dateProvider$1);
	});
	dist_default("on lower periods it does not report sleep", function() {
		(0, import_testdouble$45.when)(dateProvider$1.now()).thenReturn(1, 1 + CHECK_INTERVAL);
		detector.start(() => {
			throw new Error("Sleep detected while it shouldn't be");
		});
		const { thunk } = assertNotNull(scheduler.scheduledPeriodic.get(CHECK_INTERVAL));
		thunk();
	});
	dist_default("on higher periods it does report sleep", function() {
		(0, import_testdouble$45.when)(dateProvider$1.now()).thenReturn(1, 1 + SLEEP_INTERVAL + 10);
		const sleepCb = (0, import_testdouble$45.func)(() => {});
		detector.start(sleepCb);
		const { thunk } = assertNotNull(scheduler.scheduledPeriodic.get(CHECK_INTERVAL));
		thunk();
		(0, import_testdouble$45.verify)(sleepCb());
	});
	dist_default("when cancelling it unschedules", function() {
		(0, import_testdouble$45.when)(dateProvider$1.now()).thenReturn(1);
		const sleepCb = (0, import_testdouble$45.func)(() => {});
		detector.start(sleepCb);
		const { id } = assertNotNull(scheduler.scheduledPeriodic.get(CHECK_INTERVAL));
		detector.stop();
		dist_default(scheduler.cancelledPeriodic.has(id)).equals(true)("Has cancelled check task");
	});
});

//#endregion
//#region tests/api/worker/rest/ServiceExecutorTest.ts
var import_testdouble$44 = __toESM(require_testdouble(), 1);
const { anything: anything$6 } = import_testdouble$44.matchers;
dist_default.spec("ServiceExecutor", function() {
	const service = {
		app: "testapp",
		name: "testservice"
	};
	let restClient;
	let authHeaders;
	let instanceMapper;
	let cryptoFacade;
	let executor;
	let fullyLoggedIn;
	dist_default.beforeEach(function() {
		restClient = (0, import_testdouble$44.object)();
		authHeaders = {};
		fullyLoggedIn = true;
		const authDataProvider$1 = {
			createAuthHeaders() {
				return authHeaders;
			},
			isFullyLoggedIn() {
				return fullyLoggedIn;
			}
		};
		instanceMapper = (0, import_testdouble$44.object)();
		cryptoFacade = (0, import_testdouble$44.object)();
		executor = new ServiceExecutor(restClient, authDataProvider$1, instanceMapper, () => cryptoFacade);
	});
	function assertThatNoRequestsWereMade() {
		verify(restClient.request(anything$6(), anything$6()), {
			ignoreExtraArgs: true,
			times: 0
		});
	}
	function respondWith(response) {
		(0, import_testdouble$44.when)(restClient.request(anything$6(), anything$6()), { ignoreExtraArgs: true }).thenResolve(response);
	}
	dist_default.spec("GET", function() {
		dist_default("encrypts data", async function() {
			const getService = {
				...service,
				get: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(saltTypeModel, data$1, null)).thenResolve(literal);
			respondWith(undefined);
			const response = await executor.get(getService, data$1);
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((params) => params.body === `{"literal":true}`)));
		});
		dist_default("maps unencrypted response data to instance", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("maps encrypted response data to instance", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(AlarmServicePostTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("when get returns encrypted data and we are not logged in it throws an error", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => executor.get(getService, null));
			assertThatNoRequestsWereMade();
		});
		dist_default("when get returns encrypted data and we are not logged in but we have a session key it returns decrypted data", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			const sessionKey = [
				1,
				2,
				3
			];
			fullyLoggedIn = false;
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(AlarmServicePostTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, sessionKey)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null, { sessionKey });
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("when get returns unencrypted data and we are not logged in it does not throw an error", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			fullyLoggedIn = false;
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
	});
	dist_default.spec("POST", function() {
		dist_default("encrypts data", async function() {
			const postService = {
				...service,
				post: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(saltTypeModel, data$1, null)).thenResolve(literal);
			respondWith(undefined);
			const response = await executor.post(postService, data$1);
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.POST, import_testdouble$44.matchers.argThat((params) => params.body === `{"literal":true}`)));
		});
		dist_default("decrypts response data", async function() {
			const postService = {
				...service,
				post: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.post(postService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.POST, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("when post returns encrypted data and we are not logged in it throws an error", async function() {
			const postService = {
				...service,
				post: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => executor.post(postService, null));
			assertThatNoRequestsWereMade();
		});
		dist_default("when post returns encrypted data and we are not logged in but we have a session key it returns decrypted data", async function() {
			const getService = {
				...service,
				post: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			const sessionKey = [
				1,
				2,
				3
			];
			fullyLoggedIn = false;
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(AlarmServicePostTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, sessionKey)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.post(getService, null, { sessionKey });
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.POST, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
	});
	dist_default.spec("PUT", function() {
		dist_default("encrypts data", async function() {
			const putService = {
				...service,
				put: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(saltTypeModel, data$1, null)).thenResolve(literal);
			respondWith(undefined);
			const response = await executor.put(putService, data$1);
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.PUT, import_testdouble$44.matchers.argThat((params) => params.body === `{"literal":true}`)));
		});
		dist_default("decrypts response data", async function() {
			const putService = {
				...service,
				put: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.put(putService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.PUT, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("when put returns encrypted data and we are not logged in it throws an error", async function() {
			const putService = {
				...service,
				put: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => executor.put(putService, null));
			assertThatNoRequestsWereMade();
		});
	});
	dist_default.spec("DELETE", function() {
		dist_default("encrypts data", async function() {
			const deleteService = {
				...service,
				delete: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(saltTypeModel, data$1, null)).thenResolve(literal);
			respondWith(undefined);
			const response = await executor.delete(deleteService, data$1);
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.DELETE, import_testdouble$44.matchers.argThat((params) => params.body === `{"literal":true}`)));
		});
		dist_default("decrypts response data", async function() {
			const deleteService = {
				...service,
				delete: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, null)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.delete(deleteService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.DELETE, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("when delete returns encrypted data and we are not logged in it throws an error", async function() {
			const deleteService = {
				...service,
				delete: {
					data: null,
					return: AlarmServicePostTypeRef
				}
			};
			fullyLoggedIn = false;
			await assertThrows(LoginIncompleteError, () => executor.delete(deleteService, null));
			assertThatNoRequestsWereMade();
		});
	});
	dist_default.spec("params", function() {
		dist_default("adds query params", async function() {
			const getService = {
				...service,
				get: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const query = Object.freeze({ myQueryParam: "2" });
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(anything$6(), anything$6(), anything$6())).thenResolve({});
			respondWith(undefined);
			const response = await executor.get(getService, data$1, { queryParams: query });
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((opts) => deepEqual(opts.queryParams, query))));
		});
		dist_default("adds extra headers", async function() {
			const getService = {
				...service,
				get: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const headers = Object.freeze({ myHeader: "2" });
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(anything$6(), anything$6(), anything$6())).thenResolve({});
			respondWith(undefined);
			const response = await executor.get(getService, data$1, { extraHeaders: headers });
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((opts) => deepEqual(opts.headers, {
				v: saltTypeModel.version,
				myHeader: "2"
			}))));
		});
		dist_default("adds auth headers", async function() {
			const getService = {
				...service,
				get: {
					data: SaltDataTypeRef,
					return: null
				}
			};
			const data$1 = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const accessToken$1 = "myAccessToken";
			authHeaders = { accessToken: accessToken$1 };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(anything$6(), anything$6(), anything$6())).thenResolve({});
			respondWith(undefined);
			const response = await executor.get(getService, data$1);
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((opts) => deepEqual(opts.headers, {
				v: saltTypeModel.version,
				accessToken: accessToken$1
			}))));
		});
	});
	dist_default.spec("keys", function() {
		dist_default("uses resolved key to decrypt response", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			const sessionKey = [
				1,
				2,
				3
			];
			(0, import_testdouble$44.when)(cryptoFacade.resolveServiceSessionKey(literal)).thenResolve(sessionKey);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, sessionKey)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null);
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("uses passed key to decrypt response", async function() {
			const getService = {
				...service,
				get: {
					data: null,
					return: SaltDataTypeRef
				}
			};
			const returnData = createTestEntity(SaltDataTypeRef, { mailAddress: "test" });
			const literal = { literal: true };
			const saltTypeModel = await resolveTypeReference(SaltDataTypeRef);
			const sessionKey = [
				1,
				2,
				3
			];
			(0, import_testdouble$44.when)(cryptoFacade.resolveServiceSessionKey(literal)).thenResolve(null);
			(0, import_testdouble$44.when)(instanceMapper.decryptAndMapToInstance(saltTypeModel, literal, sessionKey)).thenResolve(returnData);
			respondWith(`{"literal":true}`);
			const response = await executor.get(getService, null, { sessionKey });
			dist_default(response).equals(returnData);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.responseType === MediaType.Json)));
		});
		dist_default("uses passed key to encrypt request data", async function() {
			const getService = {
				...service,
				get: {
					data: GiftCardCreateDataTypeRef,
					return: null
				}
			};
			const giftCardCreateData = createTestEntity(GiftCardCreateDataTypeRef, { message: "test" });
			const dataTypeModel = await resolveTypeReference(GiftCardCreateDataTypeRef);
			const sessionKey = [
				1,
				2,
				3
			];
			const encrypted = { encrypted: true };
			(0, import_testdouble$44.when)(instanceMapper.encryptAndMapToLiteral(dataTypeModel, giftCardCreateData, sessionKey)).thenResolve(encrypted);
			respondWith(undefined);
			const response = await executor.get(getService, giftCardCreateData, { sessionKey });
			dist_default(response).equals(undefined);
			verify(restClient.request("/rest/testapp/testservice", HttpMethod.GET, import_testdouble$44.matchers.argThat((p) => p.body === `{"encrypted":true}`)));
		});
		dist_default("when data is encrypted and the key is not passed it throws", async function() {
			const getService = {
				...service,
				get: {
					data: GiftCardCreateDataTypeRef,
					return: null
				}
			};
			const giftCardCreateData = createTestEntity(GiftCardCreateDataTypeRef, { message: "test" });
			await dist_default(() => executor.get(getService, giftCardCreateData)).asyncThrows(ProgrammingError);
			verify(restClient.request(anything$6(), anything$6()), {
				ignoreExtraArgs: true,
				times: 0
			});
		});
	});
});

//#endregion
//#region tests/api/worker/rest/CacheStorageProxyTest.ts
var import_testdouble$43 = __toESM(require_testdouble(), 1);
dist_default.spec("CacheStorageProxy", function() {
	const userId$1 = "userId";
	const databaseKey = new Uint8Array([
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
	]);
	let workerMock;
	let offlineStorageMock;
	let offlineStorageProviderMock;
	let proxy;
	dist_default.beforeEach(function() {
		workerMock = (0, import_testdouble$43.instance)(WorkerImpl);
		offlineStorageMock = (0, import_testdouble$43.instance)(OfflineStorage);
		offlineStorageProviderMock = (0, import_testdouble$43.func)();
		proxy = new LateInitializedCacheStorageImpl(async (error) => {
			await workerMock.sendError(error);
		}, offlineStorageProviderMock);
	});
	dist_default.spec("initialization", function() {
		dist_default("should create a persistent storage when params are provided and offline storage is enabled", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(offlineStorageMock);
			const { isPersistent } = await proxy.initialize({
				type: "offline",
				userId: userId$1,
				databaseKey,
				timeRangeDays: null,
				forceNewDatabase: false
			});
			dist_default(isPersistent).equals(true);
		});
		dist_default("should create a ephemeral storage when no params are provided but offline storage is enabled", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(offlineStorageMock);
			const { isPersistent } = await proxy.initialize({
				type: "ephemeral",
				userId: userId$1
			});
			dist_default(isPersistent).equals(false);
		});
		dist_default("should create a ephemeral storage when params are provided but offline storage is disabled", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(null);
			const { isPersistent } = await proxy.initialize({
				type: "offline",
				userId: userId$1,
				databaseKey,
				timeRangeDays: null,
				forceNewDatabase: false
			});
			dist_default(isPersistent).equals(false);
		});
		dist_default("should create a ephemeral storage when no params are provided and offline storage is disabled", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(null);
			const { isPersistent } = await proxy.initialize({
				type: "ephemeral",
				userId: userId$1
			});
			dist_default(isPersistent).equals(false);
		});
		dist_default("will flag newDatabase as true when offline storage says it is", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(offlineStorageMock);
			const args = {
				type: "offline",
				userId: userId$1,
				databaseKey,
				timeRangeDays: null,
				forceNewDatabase: false
			};
			(0, import_testdouble$43.when)(offlineStorageMock.init(args)).thenResolve(true);
			const { isNewOfflineDb } = await proxy.initialize(args);
			dist_default(isNewOfflineDb).equals(true);
		});
		dist_default("will flag newDatabase as false when offline storage says it is not", async function() {
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenResolve(offlineStorageMock);
			const args = {
				type: "offline",
				userId: userId$1,
				databaseKey,
				timeRangeDays: null,
				forceNewDatabase: false
			};
			(0, import_testdouble$43.when)(offlineStorageMock.init(args)).thenResolve(false);
			const { isNewOfflineDb } = await proxy.initialize(args);
			dist_default(isNewOfflineDb).equals(false);
		});
		dist_default("will fall back to an ephemeral storage when there is an error, and error is caught but sent to the worker", async function() {
			const error = new Error("oh no!!!");
			(0, import_testdouble$43.when)(offlineStorageProviderMock()).thenReject(error);
			const { isPersistent } = await proxy.initialize({
				type: "offline",
				userId: userId$1,
				databaseKey,
				timeRangeDays: null,
				forceNewDatabase: false
			});
			dist_default(isPersistent).equals(false);
			verify(workerMock.sendError(error));
		});
	});
});

//#endregion
//#region tests/contacts/VCardExporterTest.ts
let idCounter = 0;
dist_default.spec("VCardExporterTest", function() {
	dist_default("contactsToVCardsTest", function() {
		let contactArray = [];
		let contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"], ["tuta.com", "tutanota.com"]);
		contactArray.push(contact1);
		let c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Mr. Ant Lange Ste, Jr.\nN:Ste;Ant;Lange;Mr.;Jr.\nNICKNAME:Buffalo\nADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\nEMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\nTEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\nURL:https://www.diaspora.de\nURL:https://www.tuta.com\nURL:https://www.tutanota.com\nORG:Tutao;IT\nNOTE:Hello World!\nEND:VCARD\n\n`;
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:\nN:;;;;\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contact1 = createFilledContact("Ant", "Tut", "", "", "", "", "", "", "", [], [], [], []);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nEND:VCARD\n\nBEGIN:VCARD\nVERSION:3.0\nFN:Ant Tut\nN:Tut;Ant;;;\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"], ["tuta.com", "tutanota.com"]);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nEND:VCARD\n\nBEGIN:VCARD\nVERSION:3.0\nFN:Ant Tut\nN:Tut;Ant;;;\nEND:VCARD\n\nBEGIN:VCARD\nVERSION:3.0\nFN:Mr. Ant Lange Ste, Jr.\nN:Ste;Ant;Lange;Mr.;Jr.\nNICKNAME:Buffalo\nADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\nEMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\nTEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\nURL:https://www.diaspora.de\nURL:https://www.tuta.com\nURL:https://www.tutanota.com\nORG:Tutao;IT\nNOTE:Hello World!\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"], ["tuta.com", "tutanota.com"]);
		contactArray.push(contact1);
		contactArray.push(contact1);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Mr. Ant Lange Ste, Jr.\nN:Ste;Ant;Lange;Mr.;Jr.\nNICKNAME:Buffalo\nADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\nEMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\nTEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\nURL:https://www.diaspora.de\nURL:https://www.tuta.com\nURL:https://www.tutanota.com\nORG:Tutao;IT\nNOTE:Hello World!\nEND:VCARD\n
BEGIN:VCARD\nVERSION:3.0\nFN:Mr. Ant Lange Ste, Jr.\nN:Ste;Ant;Lange;Mr.;Jr.\nNICKNAME:Buffalo\nADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\nEMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\nTEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\nURL:https://www.diaspora.de\nURL:https://www.tuta.com\nURL:https://www.tutanota.com\nORG:Tutao;IT\nNOTE:Hello World!\nEND:VCARD\n\n`;
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("Ant", "Ste", "", "Tutao", "Mr.", "", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], [], ["Housestreet 123\nTown 123\nState 123\nCountry 123"], ["tuta.com", "tutanota.com"]);
		contactArray.push(contact1);
		contact1 = createFilledContact("Bob", "Kev", "", "Tuta", "Phd.", "", "Manthey", "VI", "HR", ["bobkev@antste.de", "bobkev@bentste.de"], ["89", "78"], [], ["Housestreet 890\nTown 098\nState 098\nCountry 789"], ["tuta.com.br", "tutanota.com.br"]);
		contactArray.push(contact1);
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Mr. Ant Lange Ste, Jr.\nN:Ste;Ant;Lange;Mr.;Jr.\nADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\nEMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\nTEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\nURL:https://www.tuta.com\nURL:https://www.tutanota.com\nORG:Tutao;IT\nEND:VCARD\n
BEGIN:VCARD\nVERSION:3.0\nFN:Phd. Bob Manthey Kev, VI\nN:Kev;Bob;Manthey;Phd.;VI\nADR;TYPE=work:Housestreet 890\\nTown 098\\nState 098\\nCountry 789\nEMAIL;TYPE=work:bobkev@antste.de\nEMAIL;TYPE=work:bobkev@bentste.de\nTEL;TYPE=work:89\nTEL;TYPE=work:78\nURL:https://www.tuta.com.br\nURL:https://www.tutanota.com.br\nORG:Tuta;HR\nEND:VCARD\n\n`;
		dist_default(contactsToVCard(contactArray)).equals(c1String);
	});
	dist_default("birthdayToVCardsFormatString", function() {
		let contactArray = [];
		let contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "2000-09-09";
		let c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:2000-09-09\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "2000-10-10";
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:2000-10-10\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contactArray = [];
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "1800-10-10";
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:1800-10-10\nEND:VCARD\n\n`;
		contactArray.push(contact1);
		dist_default(contactsToVCard(contactArray)).equals(c1String);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "2000-09-01";
		dist_default(contactsToVCard([contact1])).equals(`BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:2000-09-01\nEND:VCARD\n\n`);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "2000-09-09";
		dist_default(contactsToVCard([contact1])).equals(`BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:2000-09-09\nEND:VCARD\n\n`);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "1991-10-10";
		dist_default(contactsToVCard([contact1])).equals(`BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:1991-10-10\nEND:VCARD\n\n`);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "1943-10-10";
		dist_default(contactsToVCard([contact1])).equals(`BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:1943-10-10\nEND:VCARD\n\n`);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "1800-01-31";
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:1800-01-31\nEND:VCARD\n\n`;
		dist_default(contactsToVCard([contact1])).equals(c1String);
		contact1 = createFilledContact("Ant", "", "", "", "", "", "", "", "", [], [], [], []);
		contact1.birthdayIso = "--10-10";
		c1String = `BEGIN:VCARD\nVERSION:3.0\nFN:Ant\nN:;Ant;;;\nBDAY:1111-10-10\nEND:VCARD\n\n`;
		dist_default(contactsToVCard([contact1])).equals(c1String);
	});
	dist_default.spec("contactsToVCards more than 75 char content line", function() {
		dist_default("ADR", async function() {
			const contact = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123 this is so there is a line break in this contact"], ["tuta.com", "tutanota.com"]);
			const exprected = `BEGIN:VCARD
VERSION:3.0
FN:Mr. Ant Lange Ste, Jr.
N:Ste;Ant;Lange;Mr.;Jr.
NICKNAME:Buffalo
ADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123 this is so \n there is a line break in this contact
EMAIL;TYPE=work:antste@antste.de
EMAIL;TYPE=work:bentste@bentste.de
TEL;TYPE=work:123123123
TEL;TYPE=work:321321321
URL:https://www.diaspora.de
URL:https://www.tuta.com
URL:https://www.tutanota.com
ORG:Tutao;IT
NOTE:Hello World!
END:VCARD

`;
			dist_default(contactsToVCard([contact])).equals(exprected);
		});
		dist_default("URL", async function() {
			const contact = createFilledContact("Ant", "Ste", "Hello World!", "Tutao is the best mail client for your privacy just go for it and youll see it will be amazing!!!!!", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de", "facebook.com/aaaa/bbb/cccccc/DDDDDDD/llllllll/uuuuuuu/ppppp/aaaaaaaaaaaaaaaaaaaaa"], ["Housestreet 123\nTown 123\nState 123\nCountry 123 this is so there is a line break in this contact"], ["tuta.com", "tutanota.com"]);
			const expected = `BEGIN:VCARD
VERSION:3.0
FN:Mr. Ant Lange Ste, Jr.
N:Ste;Ant;Lange;Mr.;Jr.
NICKNAME:Buffalo
ADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123 this is so \n there is a line break in this contact
EMAIL;TYPE=work:antste@antste.de
EMAIL;TYPE=work:bentste@bentste.de
TEL;TYPE=work:123123123
TEL;TYPE=work:321321321
URL:https://www.diaspora.de
URL:https://www.facebook.com/aaaa/bbb/cccccc/DDDDDDD/llllllll/uuuuuuu/ppppp
 /aaaaaaaaaaaaaaaaaaaaa
URL:https://www.tuta.com
URL:https://www.tutanota.com
ORG:Tutao is the best mail client for your privacy just go for it and youll
  see it will be amazing!!!!!;IT
NOTE:Hello World!
END:VCARD

`;
			dist_default(contactsToVCard([contact])).equals(expected);
		});
	});
	dist_default("contactsToVCardsEscapingTest", function() {
		let contactArray = [];
		let contact1 = createFilledContact("Ant,", "Ste;", "Hello::: World!", "Tutao;:", "Mr.:", "Buffalo;p", "Lange,", "Jr.,", "IT,", [":antste@antste.de;", "bentste@bent:ste.de"], ["1;23123123", "32132:1321"], ["https://diaspora.de"], ["Housestreet 123\nTo:wn 123\nState 123\nCountry 123"]);
		contactArray.push(contact1);
		let c1String = `BEGIN:VCARD
VERSION:3.0
FN:Mr.: Ant\\, Lange\\, Ste\\;, Jr.\\,
N:Ste\\;;Ant\\,;Lange\\,;Mr.:;Jr.\\,
NICKNAME:Buffalo\\;p
ADR;TYPE=work:Housestreet 123\\nTo:wn 123\\nState 123\\nCountry 123
EMAIL;TYPE=work::antste@antste.de\\;
EMAIL;TYPE=work:bentste@bent:ste.de
TEL;TYPE=work:1\\;23123123
TEL;TYPE=work:32132:1321
URL:https://diaspora.de
ORG:Tutao\\;:;IT\\,
NOTE:Hello::: World!
END:VCARD

`;
		dist_default(contactsToVCard(contactArray)).equals(c1String);
	});
	dist_default("addressesToVcardFormatString", function() {
		let contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		let c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.addresses), "ADR");
		let expectedResult = `ADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.addresses[0].type = ContactAddressType.PRIVATE;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.addresses), "ADR");
		expectedResult = `ADR;TYPE=home:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.addresses[0].type = ContactAddressType.CUSTOM;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.addresses), "ADR");
		expectedResult = `ADR:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.addresses[0].type = ContactAddressType.OTHER;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.addresses), "ADR");
		expectedResult = `ADR:Housestreet 123\\nTown 123\\nState 123\\nCountry 123\n`;
		dist_default(expectedResult).equals(c1String);
	});
	dist_default("mailAddressesToVCardString", function() {
		let contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		let c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.mailAddresses), "EMAIL");
		let expectedResult = `EMAIL;TYPE=work:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.mailAddresses[0].type = ContactAddressType.PRIVATE;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.mailAddresses), "EMAIL");
		expectedResult = `EMAIL;TYPE=home:antste@antste.de\nEMAIL;TYPE=work:bentste@bentste.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.mailAddresses[1].type = ContactAddressType.CUSTOM;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.mailAddresses), "EMAIL");
		expectedResult = `EMAIL;TYPE=home:antste@antste.de\nEMAIL:bentste@bentste.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.mailAddresses[0].type = ContactAddressType.OTHER;
		c1String = _vCardFormatArrayToString(_addressesToVCardAddresses(contact1.mailAddresses), "EMAIL");
		expectedResult = `EMAIL:antste@antste.de\nEMAIL:bentste@bentste.de\n`;
		dist_default(expectedResult).equals(c1String);
	});
	dist_default("phoneNumbersToVCardString", function() {
		let contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		let c1String = _vCardFormatArrayToString(_phoneNumbersToVCardPhoneNumbers(contact1.phoneNumbers), "TEL");
		let expectedResult = `TEL;TYPE=work:123123123\nTEL;TYPE=work:321321321\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.phoneNumbers[0].type = ContactPhoneNumberType.PRIVATE;
		c1String = _vCardFormatArrayToString(_phoneNumbersToVCardPhoneNumbers(contact1.phoneNumbers), "TEL");
		expectedResult = `TEL;TYPE=home:123123123\nTEL;TYPE=work:321321321\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.phoneNumbers[1].type = ContactPhoneNumberType.CUSTOM;
		c1String = _vCardFormatArrayToString(_phoneNumbersToVCardPhoneNumbers(contact1.phoneNumbers), "TEL");
		expectedResult = `TEL;TYPE=home:123123123\nTEL:321321321\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.phoneNumbers[0].type = ContactPhoneNumberType.OTHER;
		c1String = _vCardFormatArrayToString(_phoneNumbersToVCardPhoneNumbers(contact1.phoneNumbers), "TEL");
		expectedResult = `TEL:123123123\nTEL:321321321\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.phoneNumbers[0].type = ContactPhoneNumberType.FAX;
		c1String = _vCardFormatArrayToString(_phoneNumbersToVCardPhoneNumbers(contact1.phoneNumbers), "TEL");
		expectedResult = `TEL;TYPE=fax:123123123\nTEL:321321321\n`;
		dist_default(expectedResult).equals(c1String);
	});
	dist_default("socialIdsToVCardString", function() {
		let contact1 = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], [
			"TutanotaTeam",
			"xing.com",
			"facebook.de"
		], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		contact1.socialIds[0].type = ContactSocialType.LINKED_IN;
		let c1String = _vCardFormatArrayToString(_socialIdsToVCardSocialUrls(contact1.socialIds), "URL");
		let expectedResult = `URL:https://www.linkedin.com/in/TutanotaTeam\nURL:https://www.xing.com\nURL:https://www.facebook.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.socialIds[0].type = ContactSocialType.TWITTER;
		c1String = _vCardFormatArrayToString(_socialIdsToVCardSocialUrls(contact1.socialIds), "URL");
		expectedResult = `URL:https://www.twitter.com/TutanotaTeam\nURL:https://www.xing.com\nURL:https://www.facebook.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.socialIds[1].type = ContactSocialType.CUSTOM;
		c1String = _vCardFormatArrayToString(_socialIdsToVCardSocialUrls(contact1.socialIds), "URL");
		expectedResult = `URL:https://www.twitter.com/TutanotaTeam\nURL:https://www.xing.com\nURL:https://www.facebook.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.socialIds[1].type = ContactSocialType.OTHER;
		c1String = _vCardFormatArrayToString(_socialIdsToVCardSocialUrls(contact1.socialIds), "URL");
		expectedResult = `URL:https://www.twitter.com/TutanotaTeam\nURL:https://www.xing.com\nURL:https://www.facebook.de\n`;
		dist_default(expectedResult).equals(c1String);
		contact1.socialIds[0].type = ContactSocialType.FACEBOOK;
		c1String = _vCardFormatArrayToString(_socialIdsToVCardSocialUrls(contact1.socialIds), "URL");
		expectedResult = `URL:https://www.facebook.com/TutanotaTeam\nURL:https://www.xing.com\nURL:https://www.facebook.de\n`;
		dist_default(expectedResult).equals(c1String);
	});
	dist_default("testSpecialCharsInVCard", function() {
		let a = `BEGIN:VCARD\nVERSION:3.0\nFN:Mr. John\\;Quinlan Public\nN:Public;John\\;Quinlan;;Mr.;\nBDAY:2016-09-09\nADR:Die Heide 81\\nBasche\nNOTE:Hello World\\nHier ist ein Umbruch\nEND:VCARD\n\n`;
		let b = createTestEntity(ContactTypeRef);
		let bday = createTestEntity(BirthdayTypeRef);
		let contacts$1 = [b];
		b._ownerGroup = "";
		b.addresses[0] = {
			_type: ContactAddressTypeRef,
			_id: neverNull(null),
			address: "Die Heide 81\nBasche",
			customTypeName: "",
			type: "2"
		};
		b.firstName = "John;Quinlan";
		b.lastName = "Public";
		b.comment = "Hello World\nHier ist ein Umbruch";
		b.company = "";
		b.role = "";
		b.title = "Mr.";
		b.nickname = neverNull(null);
		b.birthdayIso = "2016-09-09";
		dist_default(JSON.stringify(contactsToVCard(contacts$1))).equals(JSON.stringify(a));
	});
	dist_default("import export roundtrip", function() {
		const cString = `BEGIN:VCARD
VERSION:3.0
FN:Mr. John\\;Quinlan Public
N:Public;John\\;Quinlan;;Mr.;
BDAY:2016-09-09
ADR:Die Heide 81\\nBasche
NOTE:Hello World\\nHier ist ein Umbruch
END:VCARD

BEGIN:VCARD
VERSION:3.0
FN:Mr. Ant Ste
N:Ste;Ant;;Mr.;
NICKNAME:Buffalo
ADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123 this is so \n there is a line break in this contact
EMAIL;TYPE=work:antste@antste.de
EMAIL;TYPE=work:bentste@bentste.de
TEL;TYPE=work:123123123
TEL;TYPE=work:321321321
URL:https://www.diaspora.de
ORG:Tutao
NOTE:Hello World!
END:VCARD

BEGIN:VCARD
VERSION:3.0
FN:Mr. Ant Ste
N:Ste;Ant;;Mr.;
NICKNAME:Buffalo
ADR;TYPE=work:Housestreet 123\\nTown 123\\nState 123\\nCountry 123
EMAIL;TYPE=work:antste@antste.de
EMAIL;TYPE=work:bentste@bentste.de
TEL;TYPE=work:123123123
TEL;TYPE=work:321321321
URL:https://www.diaspora.de
ORG:Tutao
NOTE:Hello World!
END:VCARD

`;
		dist_default(contactsToVCard(vCardListToContacts(neverNull(vCardFileToVCards(cString)), ""))).equals(cString);
	});
});
function createFilledContact(firstName, lastName, comment, company, title, nickname, middleName, nameSuffix, department, emailAddresses, phoneNumbers, socialIds, addresses, websites, birthdayIso) {
	let c = createTestEntity(ContactTypeRef);
	c._id = ["0", String(idCounter++)];
	c.firstName = firstName;
	c.lastName = lastName;
	if (emailAddresses) for (const m of emailAddresses) {
		let a = createTestEntity(ContactMailAddressTypeRef);
		a.address = m;
		a.type = ContactAddressType.WORK;
		a.customTypeName = "";
		c.mailAddresses.push(a);
	}
	if (phoneNumbers) for (const m of phoneNumbers) {
		let a = createTestEntity(ContactPhoneNumberTypeRef);
		a.number = m;
		a.type = ContactAddressType.WORK;
		a.customTypeName = "";
		c.phoneNumbers.push(a);
	}
	if (addresses) for (const m of addresses) {
		let a = createTestEntity(ContactAddressTypeRef);
		a.address = m;
		a.type = ContactAddressType.WORK;
		a.customTypeName = "";
		c.addresses.push(a);
	}
	if (socialIds) for (const m of socialIds) {
		let a = createTestEntity(ContactSocialIdTypeRef);
		if (typeof m === "string") {
			a.socialId = m;
			a.type = ContactSocialType.OTHER;
		} else {
			a.socialId = m[0];
			a.type = m[1] || ContactSocialType.OTHER;
		}
		a.customTypeName = "";
		c.socialIds.push(a);
	}
	if (websites) for (const website of websites) {
		let entity = createTestEntity(ContactWebsiteTypeRef);
		entity.url = website;
		entity.type = ContactWebsiteType.OTHER;
		c.websites.push(entity);
	}
	c.title = title;
	c.comment = comment;
	c.company = company;
	c.nickname = nickname;
	c.birthdayIso = birthdayIso ?? null;
	c.middleName = middleName;
	c.nameSuffix = nameSuffix;
	c.department = department;
	return c;
}

//#endregion
//#region tests/contacts/VCardImporterTest.ts
dist_default.spec("VCardImporterTest", function() {
	dist_default.before(async function() {
		window.whitelabelCustomizations = null;
		if (globalThis.isBrowser) globalThis.TextDecoder = window.TextDecoder;
else globalThis.TextDecoder = (await import("node:util")).TextDecoder;
		lang.init(en_default);
	});
	dist_default("testFileToVCards", function() {
		let str = `BEGIN:VCARD
VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\nBerlin;;12345;Deutschland
END:VCARD

BEGIN:VCARD
VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30, 67890 hamburg ;;;;
END:VCARD

`;
		let expected = [`VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\nBerlin;;12345;Deutschland`, `VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30, 67890 hamburg ;;;;`];
		dist_default(vCardFileToVCards(str)).deepEquals(expected);
	});
	dist_default("testImportEmpty", function() {
		dist_default(vCardFileToVCards("")).equals(null);
	});
	dist_default("testImportWithoutLinefeed", function() {
		let str = `BEGIN:VCARD
VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\nBerlin;;12345;Deutschlan
 d
END:VCARD
BEGIN:VCARD
VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30, 67890 hamburg ;;;;
END:VCARD`;
		let expected = [`VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\nBerlin;;12345;Deutschland`, `VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30, 67890 hamburg ;;;;`];
		dist_default(vCardFileToVCards(str)).deepEquals(expected);
	});
	dist_default("TestBEGIN:VCARDinFile", function() {
		let str = `BEGIN:VCARD
VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\\nBerlin;;12345;Deutschland
END:VCARD

BEGIN:VCARD
VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30\\, 67890 hamburg ;;;;
NOTE:BEGIN:VCARD\\n i Love VCARDS;
END:VCARD

`;
		let expected = [`VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\\nBerlin;;12345;Deutschland`, `VERSION:3.0
FN:Test Kontakt
N:Kontakt;Test;;;
ORG:Tuta
BDAY:2001-01-01
EMAIL;TYPE=WORK:k1576147@mvrht.net
TEL;TYPE=CELL,WORK:123456789
TEL;TYPE=VOICE,HOME:789456123
ADR;TYPE=WORK:;;Strasse 30\\, 67890 hamburg ;;;;
NOTE:BEGIN:VCARD\\n i Love VCARDS;`];
		dist_default(vCardFileToVCards(str)).deepEquals(expected);
	});
	dist_default("windowsLinebreaks", function() {
		let str = "BEGIN:VCARD\r\nVERSION:3.0\r\nFN:proto type\r\nN:type;proto;;;\r\nADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\\nBerlin;;12345;Deutschland\r\nEND:VCARD\r\n";
		let expected = [`VERSION:3.0
FN:proto type
N:type;proto;;;
ADR;TYPE=HOME,PREF:;;Humboldstrasse 5;\\nBerlin;;12345;Deutschland`];
		dist_default(vCardFileToVCards(str)).deepEquals(expected);
	});
	dist_default("testToContactNames", function() {
		let a = ["N:Public\\\\;John\\;Quinlan;Lange;Mr.;Esq.\nBDAY:2016-09-09\nADR:Die Heide 81\\nBasche\nNOTE:Hello World\\nHier ist ein Umbruch"];
		let contacts$1 = vCardListToContacts(a, "");
		let b = createTestEntity(ContactTypeRef);
		b._ownerGroup = "";
		b.addresses[0] = {
			_type: ContactAddressTypeRef,
			_id: neverNull(null),
			address: "Die Heide 81\nBasche",
			customTypeName: "",
			type: "2"
		};
		b.middleName = "Lange";
		b.department = "";
		b.firstName = "John;Quinlan";
		b.lastName = "Public\\";
		b.comment = "Hello World\nHier ist ein Umbruch";
		b.company = "";
		b.role = "";
		b.title = "Mr.";
		b.nameSuffix = "Esq.";
		b.nickname = neverNull(null);
		b.birthdayIso = "2016-09-09";
		dist_default(JSON.stringify(contacts$1[0])).equals(JSON.stringify(b));
	});
	dist_default("testEmptyAddressElements", function() {
		let a = ["N:Public\\\\;John\\;Quinlan;;Mr.;Esq.\nBDAY:2016-09-09\nADR:Die Heide 81;; ;;Basche"];
		let contacts$1 = vCardListToContacts(a, "");
		let b = createTestEntity(ContactTypeRef);
		b._ownerGroup = "";
		b.addresses[0] = {
			_type: ContactAddressTypeRef,
			_id: neverNull(null),
			address: "Die Heide 81\nBasche",
			customTypeName: "",
			type: "2"
		};
		b.middleName = "";
		b.firstName = "John;Quinlan";
		b.lastName = "Public\\";
		b.comment = "";
		b.department = "";
		b.company = "";
		b.role = "";
		b.nameSuffix = "Esq.";
		b.title = "Mr.";
		b.nickname = neverNull(null);
		b.birthdayIso = "2016-09-09";
		dist_default(JSON.stringify(contacts$1[0])).equals(JSON.stringify(b));
	});
	dist_default("testTooManySpaceElements", function() {
		let a = ["N:Public\\\\; John\\; Quinlan;;Mr.    ;Esq.\nBDAY: 2016-09-09\nADR: Die Heide 81;;;; Basche"];
		let contacts$1 = vCardListToContacts(a, "");
		let b = createTestEntity(ContactTypeRef);
		b._ownerGroup = "";
		b.addresses[0] = {
			_type: ContactAddressTypeRef,
			_id: neverNull(null),
			address: "Die Heide 81\nBasche",
			customTypeName: "",
			type: "2"
		};
		b.firstName = "John; Quinlan";
		b.lastName = "Public\\";
		b.middleName = "";
		b.comment = "";
		b.department = "";
		b.company = "";
		b.role = "";
		b.title = "Mr.";
		b.nameSuffix = "Esq.";
		b.nickname = neverNull(null);
		b.birthdayIso = "2016-09-09";
		dist_default(JSON.stringify(contacts$1[0])).equals(JSON.stringify(b));
	});
	dist_default("testVCard4", function() {
		let aContent = "VERSION:4.0\nN:Public\\\\;John\\;Quinlan;;Mr.;Esq.\nBDAY:2016-09-09\nADR:Die Heide 81;Basche\nNOTE:Hello World\\nHier ist ein Umbruch";
		let a = `BEGIN:VCARD\n${aContent}\nEND:VCARD\n`;
		let bContent = "version:4.0\nFN:John B";
		let b = `begin:vcard\n${bContent}\nend:vcard\n`;
		dist_default(vCardFileToVCards(a + b)).deepEquals([aContent, bContent]);
	});
	dist_default("testTypeInUserText", function() {
		let a = ["EMAIL;TYPE=WORK:HOME@mvrht.net\nADR;TYPE=WORK:Street;HOME;;\nTEL;TYPE=WORK:HOME01923825434"];
		let contacts$1 = vCardListToContacts(a, "");
		let b = createTestEntity(ContactTypeRef);
		b._ownerGroup = "";
		b.middleName = "";
		b.department = "";
		b.nameSuffix = "";
		b.mailAddresses[0] = {
			_type: ContactMailAddressTypeRef,
			_id: neverNull(null),
			address: "HOME@mvrht.net",
			customTypeName: "",
			type: "1"
		};
		b.addresses[0] = {
			_type: ContactAddressTypeRef,
			_id: neverNull(null),
			address: "Street\nHOME",
			customTypeName: "",
			type: "1"
		};
		b.phoneNumbers[0] = {
			_type: ContactPhoneNumberTypeRef,
			_id: neverNull(null),
			customTypeName: "",
			number: "HOME01923825434",
			type: "1"
		};
		b.comment = "";
		dist_default(JSON.stringify(contacts$1[0])).equals(JSON.stringify(b));
	});
	dist_default("test vcard 4.0 date format", function() {
		let vcards = `BEGIN:VCARD
VERSION:3.0
BDAY:19540331
END:VCARD
BEGIN:VCARD
VERSION:3.0
BDAY:--0626
END:VCARD`;
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].birthdayIso)).equals("1954-03-31");
		dist_default(neverNull(contacts$1[1].birthdayIso)).equals("--06-26");
	});
	dist_default("simple vcard 4.0 import with v4 date format", function() {
		let vcards = `BEGIN:VCARD
VERSION:4.0
BDAY:19540331
END:VCARD
BEGIN:VCARD
VERSION:3.0
BDAY:--0626
END:VCARD`;
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].birthdayIso)).equals("1954-03-31");
		dist_default(neverNull(contacts$1[1].birthdayIso)).equals("--06-26");
	});
	dist_default("test import without year", function() {
		let vcards = `BEGIN:VCARD
VERSION:3.0
BDAY:1111-03-31
END:VCARD
BEGIN:VCARD
VERSION:3.0
BDAY:11110331
END:VCARD`;
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].birthdayIso)).equals("--03-31");
		dist_default(neverNull(contacts$1[1].birthdayIso)).equals("--03-31");
	});
	dist_default("quoted printable utf-8 entirely encoded", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN:Mustermann;Max;;;\nFN:Max Mustermann\nADR;HOME;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;;=54=65=73=74=73=74=72=61=C3=9F=65=20=34=32;;;;\nEND:VCARD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].addresses[0].address)).equals("Teststrae 42");
	});
	dist_default("quoted printable utf-8 partially encoded", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN:Mustermann;Max;;;\nFN:Max Mustermann\nADR;HOME;CHARSET=UTF-8;ENCODING=QUOTED-PRINTABLE:;;Teststra=C3=9Fe 42;;;;\nEND:VCARD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].addresses[0].address)).equals("Teststrae 42");
	});
	dist_default("base64 utf-8", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN:Mustermann;Max;;;\nFN:Max Mustermann\nADR;HOME;CHARSET=UTF-8;ENCODING=BASE64:;;w4TDpMOkaGhtbQ==;;;;\nEND:VCARD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].addresses[0].address)).equals("hhmm");
	});
	dist_default("test with latin charset", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN:Mustermann;Max;;;\nFN:Max Mustermann\nADR;HOME;CHARSET=ISO-8859-1;ENCODING=QUOTED-PRINTABLE:;;Rua das Na=E7=F5es;;;;\nEND:VCARD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].addresses[0].address)).equals("Rua das Naes");
	});
	dist_default("test with no charset but encoding", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN;ENCODING=QUOTED-PRINTABLE:=4E;\nEND:VCARD\nD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].lastName)).equals("N");
	});
	dist_default("base64 implicit utf-8", function() {
		let vcards = "BEGIN:VCARD\nVERSION:2.1\nN:Mustermann;Max;;;\nFN:Max Mustermann\nADR;HOME;ENCODING=BASE64:;;w4TDpMOkaGhtbQ==;;;;\nEND:VCARD";
		let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vcards)), "");
		dist_default(neverNull(contacts$1[0].addresses[0].address)).equals("hhmm");
	});
	dist_default.spec("protonmail exports are imported correctly", function() {
		dist_default("protonmail v4.0 simple import", function() {
			let vCard = "BEGIN:VCARD\nVERSION:4.0\nPRODID;VALUE=TEXT:-//ProtonMail//ProtonMail vCard 1.0.0//EN\nFN;PREF=1:johnsuser@test.tuta.com\nUID:proton-autosave-19494094-e26d-4e59-b4fb-766afcf82fa5\nITEM1.EMAIL;PREF=1:johnsuser@test.tuta.com\nEND:VCARD";
			let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vCard)), "");
			dist_default(contacts$1.length).equals(1);
			dist_default(contacts$1[0].firstName).equals("johnsuser@test.tuta.com");
			dist_default(contacts$1[0].lastName).equals("");
			dist_default(contacts$1[0].nickname).equals(null);
			dist_default(contacts$1[0].mailAddresses.length).equals(1);
			dist_default(contacts$1[0].mailAddresses[0].address).equals("johnsuser@test.tuta.com");
		});
		dist_default("protonmail v4.0 complicated import", function() {
			let vCard = "BEGIN:VCARD\nVERSION:4.0\nADR;PREF=1:;;908 S 1780 W;Orem;UT;;USA\nNOTE:This is a note\nTEL;PREF=1:8013194412\nTEL;TYPE=cell;PREF=2:+49530112345\nFN;PREF=1:Jane Test\nITEM1.EMAIL;PREF=1:jane.test@tutanota.de\nUID:proton-web-3466d132-2347-2541-3375-391fc3423bf3\nEND:VCARD";
			let contacts$1 = vCardListToContacts(neverNull(vCardFileToVCards(vCard)), "");
			dist_default(contacts$1.length).equals(1);
			dist_default(contacts$1[0].firstName).equals("Jane Test");
			dist_default(contacts$1[0].lastName).equals("");
			dist_default(contacts$1[0].nickname).equals(null);
			dist_default(contacts$1[0].mailAddresses.length).equals(1);
			dist_default(contacts$1[0].mailAddresses[0].address).equals("jane.test@tutanota.de");
			dist_default(contacts$1[0].phoneNumbers.length).equals(2);
			dist_default(contacts$1[0].phoneNumbers[0].number).equals("8013194412");
			dist_default(contacts$1[0].phoneNumbers[1].number).equals("+49530112345");
			dist_default(contacts$1[0].comment).equals("This is a note");
		});
	});
});

//#endregion
//#region tests/misc/ClientDetectorTest.ts
dist_default.spec("ClientDetector test", function() {
	dist_default("ClientDetector detect chrome windows", () => {
		window.TouchEvent = function() {};
		client.init("Mozilla/5.0 (Windows NT 6.2 WOW64) AppleWebKit/537.15 (KHTML, like Gecko) Chrome/30.0.1295.0 Safari/537.15", "Linux");
		dist_default(client.browser).equals(BrowserType.CHROME);
		dist_default(client.browserVersion).equals(30);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
		window.touchEvent = undefined;
	});
	dist_default("ClientDetector detect chrome macOS", () => {
		window.TouchEvent = function() {};
		client.init("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36", "MacIntel");
		dist_default(client.browser).equals(BrowserType.CHROME);
		dist_default(client.browserVersion).equals(77);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
		window.touchEvent = undefined;
	});
	dist_default("ClientDetector detect firefox linux", () => {
		client.init("Mozilla/5.0 (X11 Ubuntu Linux x86_64 rv:17.0) Gecko/17.0 Firefox/17.0", "Linux");
		dist_default(client.browser).equals(BrowserType.FIREFOX);
		dist_default(client.browserVersion).equals(17);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect safari 5.1 ipad", () => {
		client.init("Mozilla/5.0 (iPad CPU OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko ) Version/5.1 Mobile/9B176 Safari/7534.48.3", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(5.1);
		dist_default(client.device).equals(DeviceType.IPAD);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect safari 6.0 ipad", () => {
		client.init("Mozilla/5.0 (iPad CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A403 Safari/8536.25", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(6);
		dist_default(client.device).equals(DeviceType.IPAD);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect safari 6.1 ipad", () => {
		client.init("Mozilla/5.0 (iPad CPU OS 6_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.1 Mobile/10A403 Safari/8536.25", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(6.1);
		dist_default(client.device).equals(DeviceType.IPAD);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect safari 7 iphone", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A501 Safari/9537.53", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(7);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect safari 6.0 iphone home screen", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 6_1_6 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Mobile/10B500", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(6.1);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect safari 7 iphone home screen", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/11A501", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(7);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect opera 12 windows", () => {
		client.init("Opera/9.80 (Windows NT 6.1 WOW64) Presto/2.12.388 Version/12.11", "Linux");
		dist_default(client.browser).equals(BrowserType.OPERA);
		dist_default(client.browserVersion).equals(12.1);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect opera 21 windows", () => {
		client.init("Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.132 Safari/537.36 OPR/21.0.1432.67 (Edition Campaign 38)", "Linux");
		dist_default(client.browser).equals(BrowserType.OPERA);
		dist_default(client.browserVersion).equals(21);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect opera 21 Mac", () => {
		client.init("Mozilla/5.0 (Macintosh Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.132 Safari/537.36 OPR/21.0.1432.67", "Linux");
		dist_default(client.browser).equals(BrowserType.OPERA);
		dist_default(client.browserVersion).equals(21);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect safari 6.1 on OS X", () => {
		client.init("Mozilla/5.0 (Macintosh Intel Mac OS X 10_8_5) AppleWebKit/537.71 (KHTML, like Gecko) Version/6.1 Safari/537.71", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(6.1);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect safari 7 on OS X", () => {
		client.init("Mozilla/5.0 (Macintosh Intel Mac OS X 10_9) AppleWebKit/537.71 (KHTML, like Gecko) Version/7.0 Safari/537.71", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(7);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect safari 8 on OS X", () => {
		client.init("Mozilla/5.0 (Macintosh Intel Mac OS X 10_10_1) AppleWebKit/600.1.25 (KHTML, like Gecko) Version/8.0 Safari/600.1.25", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(8);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("palemoon gets classified as other, linux", function() {
		client.init("Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Goanna/5.1 Firefox/68.0 PaleMoon/31.1.0", "Linux");
		client.browserVersion = 0;
		client.browser = BrowserType.OTHER;
	});
	dist_default("palemoon gets classified as other, windows", function() {
		client.init("Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Goanna/5.1 Firefox/68.0 PaleMoon/31.1.1", "Win32");
		client.browserVersion = 0;
		client.browser = BrowserType.OTHER;
	});
	dist_default("ClientDetector detect safari 6.05 on OS X", () => {
		client.init("Mozilla/5.0 (Macintosh Intel Mac OS X 10_8_4) AppleWebKit/536.30.1 (KHTML, like Gecko) Version/6.0.5 Safari/536.30.1", "Linux");
		dist_default(client.browser).equals(BrowserType.SAFARI);
		dist_default(client.browserVersion).equals(6);
		dist_default(client.device).equals(DeviceType.DESKTOP);
		dist_default(client.isMobileDevice()).equals(false);
	});
	dist_default("ClientDetector detect chrome on Android", () => {
		client.init("Mozilla/5.0 (Linux Android 4.1.1 HTC Desire X Build/JRO03C) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.99 Mobile Safari/537.36", "Linux");
		dist_default(client.browser).equals(BrowserType.CHROME);
		dist_default(client.browserVersion).equals(32);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect firefox on Android", () => {
		client.init("Mozilla/5.0 (Android Mobile rv:27.0) Gecko/27.0 Firefox/27.0", "Linux");
		dist_default(client.browser).equals(BrowserType.FIREFOX);
		dist_default(client.browserVersion).equals(27);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect android browser 4.1 on Android", () => {
		client.init("Mozilla/5.0 (Linux U Android 4.1.1, de-de HTC_Desire_X Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "Linux");
		dist_default(client.browser).equals(BrowserType.ANDROID);
		dist_default(client.browserVersion).equals(4.1);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect opera 19 on Android", () => {
		client.init("Mozilla/5.0 (Linux Android 4.1.1 HTC One X+ Build/JRO03C) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.72 Mobile Safari/537.36 OPR/19.0.1340.69721", "Linux");
		dist_default(client.browser).equals(BrowserType.OPERA);
		dist_default(client.browserVersion).equals(19);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default("ClientDetector detect chrome 34 on iphone", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) CriOS/34.0.1847.18 Mobile/11A501 Safari/9537.53", "Linux");
		dist_default(client.browser).equals(BrowserType.CHROME);
		dist_default(client.browserVersion).equals(34);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
	});
	dist_default.spec("app", function() {
		let prevMode;
		dist_default.before(function() {
			prevMode = env.mode;
			env.mode = Mode.App;
		});
		dist_default.after(function() {
			env.mode = prevMode;
		});
		dist_default("ClientDetector the android 4 in app mode supported", () => {
			client.init("Mozilla/5.0 (Linux U Android 4.0, de-de HTC_Desire_X Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "Linux");
			dist_default(client.browser).equals(BrowserType.ANDROID);
			dist_default(client.browserVersion).equals(4);
			dist_default(client.device).equals(DeviceType.ANDROID);
			dist_default(client.isMobileDevice()).equals(true);
		});
		dist_default("ClientDetector the android 3 in app mode not supported", () => {
			client.init("Mozilla/5.0 (Linux U Android 4.0, de-de HTC_Desire_X Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/3.9 Mobile Safari/534.30", "Linux");
			dist_default(client.browser).equals(BrowserType.ANDROID);
			dist_default(client.browserVersion).equals(4);
			dist_default(client.device).equals(DeviceType.ANDROID);
			dist_default(client.isMobileDevice()).equals(true);
		});
		dist_default("ClientDetector apps on ios are supported", () => {
			client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit", "Linux");
			dist_default(client.browser).equals(BrowserType.SAFARI);
			dist_default(client.browserVersion).equals(7);
			dist_default(client.device).equals(DeviceType.IPHONE);
			dist_default(client.isMobileDevice()).equals(true);
		});
		dist_default("ClientDetector iceweasel browser are supported", () => {
			client.init("Mozilla/5.0 (X11 Linux x86_64 rv:37.0)  Gecko/20100101 Iceweasel/37.0.1", "Linux");
			dist_default(client.browser).equals(BrowserType.FIREFOX);
			dist_default(client.browserVersion).equals(37);
			dist_default(client.device).equals(DeviceType.DESKTOP);
			dist_default(client.isMobileDevice()).equals(false);
		});
		dist_default("ClientDetector firefox os is supported", () => {
			env.mode = Mode.App;
			client.init("Mozilla/5.0 (Mobile rv:26.0) Gecko/26.0 Firefox/26.0", "Linux");
			dist_default(client.browser).equals(BrowserType.FIREFOX);
			dist_default(client.browserVersion).equals(26);
			dist_default(client.device).equals(DeviceType.OTHER_MOBILE);
			dist_default(client.isMobileDevice()).equals(true);
			env.mode = Mode.Browser;
		});
		dist_default("ClientDetector firefox os tablet is supported", () => {
			env.mode = Mode.App;
			client.init("Mozilla/5.0 (Tablet rv:26.0) Gecko/26.0 Firefox/26.0", "Linux");
			dist_default(client.browser).equals(BrowserType.FIREFOX);
			dist_default(client.browserVersion).equals(26);
			dist_default(client.device).equals(DeviceType.OTHER_MOBILE);
			dist_default(client.isMobileDevice()).equals(true);
			env.mode = Mode.Browser;
		});
	});
	dist_default("old Chrome is not supported", function() {
		client.init("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36", "Linux");
		dist_default(client.isSupportedBrowserVersion()).equals(false);
	});
	dist_default("Chrome 55 is not supported", function() {
		client.init("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2062.120 Safari/537.36", "Linux");
		dist_default(client.isSupportedBrowserVersion()).equals(false);
	});
	dist_default("newer Chrome is supported", function() {
		client.init("Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2125.104 Safari/537.36", "Linux");
		dist_default(client.isSupportedBrowserVersion()).equals(true);
	});
	dist_default("detect iPadOS", function() {
		window.TouchEvent = function() {};
		client.init("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/605.1.15 (KHTML, like Gecko)", "MacIntel");
		dist_default(client.device).equals(DeviceType.IPAD);
		window.TouchEvent = undefined;
	});
});
dist_default.spec("ClientDetector AppType test", function() {
	dist_default.beforeEach(function() {
		env.mode = Mode.App;
	});
	dist_default("ClientDetector detect calendar app on Android", () => {
		client.init("Mozilla/5.0 (Linux Android 4.1.1 HTC Desire X Build/JRO03C) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.99 Mobile Safari/537.36", "Linux", AppType.Calendar);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
		dist_default(client.getIdentifier()).equals("Android Calendar App");
	});
	dist_default("ClientDetector detect calendar app on iPhone", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A501 Safari/9537.53", "Linux", AppType.Calendar);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
		dist_default(client.getIdentifier()).equals("iPhone Calendar App");
	});
	dist_default("ClientDetector detect mail app on Android", () => {
		client.init("Mozilla/5.0 (Linux Android 4.1.1 HTC Desire X Build/JRO03C) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.99 Mobile Safari/537.36", "Linux", AppType.Mail);
		dist_default(client.device).equals(DeviceType.ANDROID);
		dist_default(client.isMobileDevice()).equals(true);
		dist_default(client.getIdentifier()).equals("Android Mail App");
	});
	dist_default("ClientDetector detect mail app on iPhone", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A501 Safari/9537.53", "Linux", AppType.Mail);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
		dist_default(client.getIdentifier()).equals("iPhone Mail App");
	});
	dist_default("ClientDetector throws on wrong configuration", () => {
		client.init("Mozilla/5.0 (iPhone CPU iPhone OS 7_0_2 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) Version/7.0 Mobile/11A501 Safari/9537.53", "Linux", AppType.Integrated);
		dist_default(client.device).equals(DeviceType.IPHONE);
		dist_default(client.isMobileDevice()).equals(true);
		dist_default(() => client.getIdentifier()).throws("AppType.Integrated is not allowed for mobile apps");
	});
});

//#endregion
//#region tests/misc/LanguageViewModelTest.ts
dist_default.spec("LanguageViewModelTests", function() {
	dist_default("en is default language", browser(async function() {
		dist_default.timeout(4500);
		await lang.init(en_default);
		dist_default(lang.fallback).equals(en_default);
	}));
	dist_default("getAvailableLanguage", function() {
		const cases = [
			["en", "en"],
			["zh_CN", "zh"],
			["zh_Hant", "zh_hant"],
			["zh_HK", "zh_hant"],
			["zh_TW", "zh_hant"],
			["uk_ua", "uk"],
			["de", "de"],
			["a", "en"],
			["clingon", "en"],
			["pt_pt", "pt_pt"],
			["pt_br", "pt_br"],
			["fi", "fi"],
			["fa", "fa_ir"]
		];
		for (const [k, r] of cases) dist_default(getAvailableLanguageCode(k)).equals(r);
	});
	dist_default("_getSubstitutedLanguageCode", function() {
		const cases = [
			["en", "en"],
			["zh_hant", "zh_hant"],
			["zh_HK", "zh_hant"],
			["uk_ua", "uk"],
			["de", "de"],
			["a", null],
			["clingon", null],
			["pt_pt", "pt_pt"],
			["pt_br", "pt_br"],
			["fi", "fi"],
			["fa", "fa_ir"]
		];
		for (const [k, r] of cases) dist_default(getSubstitutedLanguageCode(k)).equals(r);
	});
	dist_default("_getSubstitutedLanguageCodeWhitelabelCustomizations", function() {
		const globalSelf = typeof window == "undefined" ? global : window;
		globalSelf.whitelabelCustomizations = { germanLanguageCode: "de_sie" };
		dist_default(getSubstitutedLanguageCode("de")).equals("de_sie");
		globalSelf.whitelabelCustomizations = undefined;
	});
});

//#endregion
//#region tests/api/common/utils/CommonFormatterTest.ts
dist_default.spec("CommonFormatterTest", function() {
	dist_default("formatNameAndAddress", function() {
		dist_default(formatNameAndAddress("", "")).equals("");
		dist_default(formatNameAndAddress("Bernd", "")).equals("Bernd");
		dist_default(formatNameAndAddress("Bernd", "")).equals("Bernd");
		dist_default(formatNameAndAddress("", "Hanomaghof")).equals("Hanomaghof");
		dist_default(formatNameAndAddress("Bernd", "Hanomaghof 2\n30449 Hannover")).equals("Bernd\nHanomaghof 2\n30449 Hannover");
		dist_default(formatNameAndAddress("Bernd", "Hanomaghof 2\n30449 Hannover", "FR")).equals("Bernd\nHanomaghof 2\n30449 Hannover\nFrance");
		dist_default(formatNameAndAddress("", "", "DE")).equals("Deutschland");
		dist_default(formatNameAndAddress("a", "", "DE")).equals("a\nDeutschland");
	});
});

//#endregion
//#region tests/misc/FormatterTest.ts
const parseDateWithFormatter = (text) => parseDate(text, (refdate) => formatDate(refdate));
const parseBirthdayWithFormatter = (text) => parseBirthday(text, (refdate) => formatDate(refdate));
dist_default.spec("FormatterTest", function() {
	dist_default("Intl and parse support for all supported locales", browser(function() {
		let referenceDate = new Date(2017, 5, 23);
		for (let l of [...languages, {
			code: "en_gb",
			textId: ""
		}]) {
			lang._setLanguageTag(languageCodeToTag(l.code));
			let formattedDate = formatDate(referenceDate);
			if (l.code.startsWith("fa") || l.code.startsWith("ar")) console.log("Skipping parse ", l.code);
else {
				let parsed = parseDateWithFormatter(formattedDate);
				dist_default(formatDate(parsed)).equals(formattedDate)(`invalid date parsing for lang ${l.code}: ${formatDate(parsed)}`);
			}
		}
	}));
	dist_default("parse nice dates de", browser(function() {
		lang._setLanguageTag("de");
		dist_default(parseDateWithFormatter("29.02.2020")).deepEquals(new Date(2020, 1, 29));
		dist_default(parseDateWithFormatter("03.05.2015")).deepEquals(new Date(2015, 4, 3));
		dist_default(parseDateWithFormatter("1/4/21")).deepEquals(new Date(2021, 3, 1));
		dist_default(parseDateWithFormatter("01-02")).deepEquals(new Date(new Date().getFullYear(), 1, 1));
	}));
	dist_default("parse nice dates en", browser(function() {
		lang._setLanguageTag("en");
		dist_default(parseDateWithFormatter("02.29.2020")).deepEquals(new Date(2020, 1, 29));
		dist_default(parseDateWithFormatter("03.05.2015")).deepEquals(new Date(2015, 2, 5));
		dist_default(parseDateWithFormatter("1/4/21")).deepEquals(new Date(2021, 0, 4));
		dist_default(parseDateWithFormatter("01-02")).deepEquals(new Date(new Date().getFullYear(), 0, 2));
	}));
	dist_default("parse nice dates hu", browser(function() {
		lang._setLanguageTag("hu");
		dist_default(parseDateWithFormatter("2020.02.29")).deepEquals(new Date(2020, 1, 29));
		dist_default(parseDateWithFormatter("2015.05.03")).deepEquals(new Date(2015, 4, 3));
		dist_default(parseDateWithFormatter("21/4/15")).deepEquals(new Date(2021, 3, 15));
		dist_default(parseDateWithFormatter("01-22")).deepEquals(new Date(new Date().getFullYear(), 0, 22));
	}));
	dist_default("parse date edge case :-)", browser(function() {
		lang._setLanguageTag("de");
		dist_default(parseDateWithFormatter("03/05/2015")).deepEquals(new Date(2015, 4, 3));
	}));
	dist_default("parse bad dates de", browser(function() {
		lang._setLanguageTag("de");
		dist_default(() => parseDateWithFormatter("31/06/2020")).throws(Error);
		dist_default(() => parseDateWithFormatter("32/01/2020")).throws(Error);
		dist_default(() => parseDateWithFormatter("29/02/2021")).throws(Error);
		dist_default(() => parseDateWithFormatter("01.2015")).throws(Error);
		dist_default(() => parseDateWithFormatter("05.2015")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015")).throws(Error);
		dist_default(() => parseDateWithFormatter("2020.09.12")).throws(Error);
		dist_default(() => parseDateWithFormatter("2020/12/19")).throws(Error);
		dist_default(() => parseDateWithFormatter("05.2015.01")).throws(Error);
	}));
	dist_default("parse bad dates en", browser(function() {
		lang._setLanguageTag("en");
		dist_default(() => parseDateWithFormatter("06/31/2020")).throws(Error);
		dist_default(() => parseDateWithFormatter("01/32/2020")).throws(Error);
		dist_default(() => parseDateWithFormatter("02/29/2021")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015/01")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015/05/")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015")).throws(Error);
		dist_default(() => parseDateWithFormatter("2020/09/12")).throws(Error);
		dist_default(() => parseDateWithFormatter("2020.12.19")).throws(Error);
		dist_default(() => parseDateWithFormatter("05/2015/01")).throws(Error);
	}));
	dist_default("parse bad dates hu", browser(function() {
		lang._setLanguageTag("hu");
		dist_default(() => parseDateWithFormatter("2020/06/31")).throws(Error);
		dist_default(() => parseDateWithFormatter("2020/01/32")).throws(Error);
		dist_default(() => parseDateWithFormatter("2021/02/29")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015/01")).throws(Error);
		dist_default(() => parseDateWithFormatter("2015/05/")).throws(Error);
		dist_default(() => parseDateWithFormatter("01.2015")).throws(Error);
		dist_default(() => parseDateWithFormatter("05/2015")).throws(Error);
	}));
	dist_default("parseBirthdayGermanLocale", browser(function() {
		lang._setLanguageTag("de-DE");
		dist_default(parseBirthdayWithFormatter("")).equals(null)("empty string");
		dist_default(parseBirthdayWithFormatter("a")).equals(null)("a");
		dist_default(parseBirthdayWithFormatter("1.13.1950")).equals(null)("1.13.1950");
		dist_default(parseBirthdayWithFormatter("a.4.12")).equals(null)("a.4.12");
		_checkparseBirthdayWithFormatter("1a.1.2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("1.1.2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("1.12.2001", 1, 12, 2001);
		_checkparseBirthdayWithFormatter("01.01.2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("01.12.2001", 1, 12, 2001);
		_checkparseBirthdayWithFormatter("1.1.", 1, 1, null);
		_checkparseBirthdayWithFormatter("1.1.2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("1.1.18", 1, 1, 2018);
		_checkparseBirthdayWithFormatter("1.1.50", 1, 1, 1950);
	}));
	dist_default("parseWithFormatterUsLocale", browser(function() {
		lang._setLanguageTag("en-US");
		dist_default(parseBirthdayWithFormatter("")).equals(null);
		dist_default(parseBirthdayWithFormatter("a")).equals(null);
		dist_default(parseBirthdayWithFormatter("13/1/1950")).equals(null)("13/1/1950");
		dist_default(parseBirthdayWithFormatter("a/4/12")).equals(null)("a/4/12");
		_checkparseBirthdayWithFormatter("1a/1/2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("1/1/2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("12/1/2001", 1, 12, 2001);
		_checkparseBirthdayWithFormatter("01/01/2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("12/01/2001", 1, 12, 2001);
		_checkparseBirthdayWithFormatter("1/1", 1, 1, null);
		_checkparseBirthdayWithFormatter("1/1/2001", 1, 1, 2001);
		_checkparseBirthdayWithFormatter("1/1/18", 1, 1, 2018);
		_checkparseBirthdayWithFormatter("1/1/50", 1, 1, 1950);
	}));
	dist_default("days of month", function() {
		dist_default(_getNumDaysInMonth(1, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(1, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(2, 2021)).equals(28);
		dist_default(_getNumDaysInMonth(2, 2020)).equals(29);
		dist_default(_getNumDaysInMonth(3, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(3, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(4, 2021)).equals(30);
		dist_default(_getNumDaysInMonth(4, 2020)).equals(30);
		dist_default(_getNumDaysInMonth(5, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(5, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(6, 2021)).equals(30);
		dist_default(_getNumDaysInMonth(6, 2020)).equals(30);
		dist_default(_getNumDaysInMonth(7, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(7, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(8, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(8, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(9, 2021)).equals(30);
		dist_default(_getNumDaysInMonth(9, 2020)).equals(30);
		dist_default(_getNumDaysInMonth(10, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(10, 2020)).equals(31);
		dist_default(_getNumDaysInMonth(11, 2021)).equals(30);
		dist_default(_getNumDaysInMonth(11, 2020)).equals(30);
		dist_default(_getNumDaysInMonth(12, 2021)).equals(31);
		dist_default(_getNumDaysInMonth(12, 2020)).equals(31);
	});
	function _checkparseBirthdayWithFormatter(text, expectedDay, expectedMonth, expectedYear) {
		let expected = createTestEntity(BirthdayTypeRef);
		expected._id = "";
		expected.day = String(expectedDay);
		expected.month = String(expectedMonth);
		expected.year = expectedYear ? String(expectedYear) : null;
		let result = parseBirthdayWithFormatter(text);
		if (result) {
			result._id = "";
			result._type = expected._type;
		}
		dist_default(result).deepEquals(expected);
	}
});

//#endregion
//#region tests/api/worker/UrlifierTest.ts
dist_default.spec("UrlifierTest", function() {
	dist_default(" validHtmlLinks", function() {
		dist_default(urlify("http://hello.it")).equals("<a href=\"http://hello.it\" target=\"_blank\" rel=\"noopener noreferrer\">http://hello.it</a>");
		dist_default(urlify("https://hello.it")).equals("<a href=\"https://hello.it\" target=\"_blank\" rel=\"noopener noreferrer\">https://hello.it</a>");
		dist_default(urlify("http://www.tutanota.de")).equals("<a href=\"http://www.tutanota.de\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.tutanota.de</a>");
		dist_default(urlify("https://www.tutanota.de")).equals("<a href=\"https://www.tutanota.de\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.tutanota.de</a>");
		dist_default(urlify("bed-free@tutanota.de")).equals("<a href=\"mailto:bed-free@tutanota.de\" target=\"_blank\" rel=\"noopener noreferrer\">bed-free@tutanota.de</a>");
	});
	dist_default(" invalidHtmlLinks", function() {
		dist_default(urlify("@de_tutanota")).equals("@de_tutanota");
		dist_default(urlify("#de_tutanota")).equals("#de_tutanota");
		dist_default(urlify("0511202801-0")).equals("0511202801-0");
		dist_default(urlify("+49511202801")).equals("+49511202801");
		dist_default(urlify("(555)555-5555")).equals("(555)555-5555");
	});
});

//#endregion
//#region tests/misc/PasswordUtilsTest.ts
dist_default.spec("PasswordUtilsTest", function() {
	function checkStrength(pw, min, max) {
		dist_default(min <= getPasswordStrength(pw, [])).equals(true)("Passphrase " + pw + " strength: " + getPasswordStrength(pw, []) + " is smaller than expected " + min);
		dist_default(getPasswordStrength(pw, []) <= max).equals(true)("Passphrase " + pw + " strength: " + getPasswordStrength(pw, []) + " is bigger than expected " + max);
	}
	dist_default("password strength", function() {
		checkStrength("", 0, 0);
		checkStrength("a", 0, 20);
		checkStrength("aX", 0, 30);
		checkStrength("aX%", 10, 35);
		checkStrength("aX%7", 20, 45);
		checkStrength("aX%7#", 30, 60);
		checkStrength("aX%7#+", 40, 70);
		checkStrength("aX%7#+t", 50, 80);
		checkStrength("aX%7#+tO", 80, 100);
		checkStrength("dasisteinpasswort", 50, 70);
		checkStrength("das-ist-ein-passwort", 80, 100);
		checkStrength("helloWorld!", 80, 90);
		checkStrength("testtesttesttest", 0, 20);
		checkStrength("!*$%/()=", 30, 50);
		checkStrength("abcdefgh", 10, 30);
		checkStrength("mjudleugdh", 50, 70);
		checkStrength("12345678", 10, 30);
		checkStrength("abcde1gh", 30, 50);
		checkStrength("ab!de1gh", 60, 79);
		checkStrength("987654321", 10, 30);
		checkStrength("11111111111111111111", 0, 20);
		checkStrength("Aihlod$1", 60, 79);
		checkStrength("ai$hl1oD", 70, 79);
		checkStrength("Ai$h1oDl", 80, 90);
		checkStrength("!i$hL1D", 70, 79);
		checkStrength("Ahagitubitbl", 70, 79);
		checkStrength("Ahagitubitblz", 80, 90);
	});
	dist_default("getNbrOfSequenceChars", function() {
		dist_default(_getNbrOfSequenceChars("qwertz", _BAD_SEQUENCES, true)).equals(6);
		dist_default(_getNbrOfSequenceChars("qwerty", _BAD_SEQUENCES, true)).equals(6);
		dist_default(_getNbrOfSequenceChars("4567890", _BAD_SEQUENCES, true)).equals(7);
		dist_default(_getNbrOfSequenceChars("m,.-", _BAD_SEQUENCES, true)).equals(4);
		dist_default(_getNbrOfSequenceChars("3kfh5678awf", _BAD_SEQUENCES, true)).equals(4);
		dist_default(_getNbrOfSequenceChars("3kfhkjhgfawf", _BAD_SEQUENCES, true)).equals(5);
		dist_default(_getNbrOfSequenceChars("3kfhkjhgfawf", _BAD_SEQUENCES, false)).equals(0);
		dist_default(_getNbrOfSequenceChars("a2345ngb890d", _BAD_SEQUENCES, true)).equals(4);
		dist_default(_getNbrOfSequenceChars("a2345890d", _BAD_SEQUENCES, true)).equals(4);
		dist_default(_getNbrOfSequenceChars("r56b", _BAD_SEQUENCES, true)).equals(0);
		dist_default(_getNbrOfSequenceChars("tzuio54", _BAD_SEQUENCES, true)).equals(5);
		dist_default(_getNbrOfSequenceChars("54tzuio", _BAD_SEQUENCES, true)).equals(5);
	});
	dist_default("scalueToVisualPasswordStrength", function() {
		dist_default(scaleToVisualPasswordStrength(0)).equals(0);
		dist_default(scaleToVisualPasswordStrength(10)).equals(12.5);
		dist_default(scaleToVisualPasswordStrength(79)).equals(98.75);
		dist_default(scaleToVisualPasswordStrength(80)).equals(100);
		dist_default(scaleToVisualPasswordStrength(100)).equals(100);
	});
	dist_default("isSecure", function() {
		dist_default(isSecurePassword(0)).equals(false);
		dist_default(isSecurePassword(10)).equals(false);
		dist_default(isSecurePassword(63)).equals(false);
		dist_default(isSecurePassword(64)).equals(true);
		dist_default(isSecurePassword(79)).equals(true);
		dist_default(isSecurePassword(80)).equals(true);
	});
	dist_default("calculatePasswordStrength -> reserved strings are case insensitive", function() {
		dist_default(getPasswordStrength("7jeGABvliT", ["7jegabvlit"])).equals(54);
		dist_default(getPasswordStrength("7jegabvlit", ["7jegabvlit"])).equals(37);
		dist_default(getPasswordStrength("7jegabvlit", [])).equals(77);
		dist_default(getPasswordStrength("7jegabvlit", [])).equals(getPasswordStrength("7jegabvlit", ["7390535"]));
		dist_default(getPasswordStrength("7jegabvlit", ["7jegabvlit"])).equals(getPasswordStrength("7JEGABVLIT", ["7jegabvlit"]));
		dist_default(getPasswordStrength("7jegabvlit", ["7jeGABvliT"])).equals(getPasswordStrength("7jegabvlit", ["7jegabvlit"]));
	});
});

//#endregion
//#region tests/misc/PasswordGeneratorTest.ts
dist_default.spec("PasswordGenerator", function() {
	let generator;
	let randomNumber;
	const DICTIONARY = [
		"dash",
		"flash",
		"neighbour",
		"escape",
		"office",
		"season",
		"priority",
		"liberty",
		"bottom",
		"summary",
		"affair",
		"peak",
		"lazy",
		"method",
		"computer",
		"smooth",
		"muzzle",
		"fine",
		"assume",
		"distant",
		"fling",
		"give",
		"borrow",
		"conservation"
	];
	dist_default.beforeEach(function() {
		randomNumber = 0;
		const randomizerMock = { async generateRandomNumber() {
			return randomNumber;
		} };
		generator = new PasswordGenerator(randomizerMock, []);
	});
	dist_default.spec("generate random data", function() {
		dist_default("generate random number in range", async function() {
			dist_default(await generator.generateRandomNumberInRange(10)).equals(0);
			randomNumber = BYTE_RANGE - 1;
			dist_default(await generator.generateRandomNumberInRange(10)).equals(9);
		});
		dist_default("there should be no duplicates in the generated password", async function() {
			const passwordGenerator = new PasswordGenerator(downcast({}), [
				"a",
				"B",
				"c",
				"d",
				"c",
				"e",
				"f",
				"g"
			]);
			let i = 0;
			passwordGenerator.generateRandomNumberInRange = async function() {
				return i++;
			};
			const randomPassword = await passwordGenerator.generateRandomPassphrase();
			dist_default(randomPassword).equals("a B c d e f");
		});
	});
});

//#endregion
//#region tests/misc/PasswordModelTest.ts
var import_testdouble$42 = __toESM(require_testdouble(), 1);
dist_default.spec("PasswordModelTest", function() {
	let passwordModel = null;
	let reservedStrings = [];
	dist_default.beforeEach(function() {
		reservedStrings = [];
		let logins = (0, import_testdouble$42.object)();
		let usageTestController = (0, import_testdouble$42.object)();
		(0, import_testdouble$42.when)(usageTestController.getTest(import_testdouble$42.matchers.anything())).thenReturn({});
		passwordModel = new PasswordModel(usageTestController, logins, {
			checkOldPassword: false,
			enforceStrength: true,
			reservedStrings: () => reservedStrings
		});
	});
	dist_default.spec("calculatePasswordStrength -> reserved strings are considered", function() {
		dist_default("generate random number in range", async function() {
			passwordModel.setNewPassword("7jeGABvliT");
			dist_default(passwordModel.getPasswordStrength()).equals(80);
			reservedStrings = ["7jeGABvliT"];
			passwordModel?.recalculatePasswordStrength();
			dist_default(passwordModel.getPasswordStrength()).equals(54);
		});
	});
});

//#endregion
//#region tests/gui/animation/AnimationsTest.ts
client.device = DeviceType.DESKTOP;
globalThis.HTMLElement = window.HTMLElement || class HTMLElement {
	style;
	constructor() {
		this.style = downcast({});
	}
};
const defaultMutation = {
	updateDom(target, percent, easing) {},
	willChange() {
		return "nothing";
	}
};
function newTarget() {
	return document.createElement("div");
}
dist_default.spec("Animations", function() {
	dist_default.spec("base", function() {
		let originalRequestAnimationFrame = window.requestAnimationFrame;
		let originalPerformance = window.performance;
		let newPerformance = { now: () => time };
		let time;
		dist_default.beforeEach(function() {
			animations.activeAnimations = [];
			Object.defineProperty(window, "performance", { get() {
				return newPerformance;
			} });
		});
		dist_default.after(function() {
			window.requestAnimationFrame = originalRequestAnimationFrame;
			Object.defineProperty(window, "performance", { get() {
				return originalPerformance;
			} });
		});
		dist_default("animation is created on add with default delay of 0", function() {
			let target = newTarget();
			window.requestAnimationFrame = spy();
			animations.add([target], defaultMutation);
			dist_default(animations.activeAnimations.length).equals(1);
			dist_default(animations.activeAnimations[0].delay).equals(0);
			dist_default(animations.activeAnimations[0].mutations).deepEquals([defaultMutation]);
			dist_default(animations.activeAnimations[0].target).equals(target);
		});
		dist_default("single element animation with delay", function() {
			let target = newTarget();
			window.requestAnimationFrame = spy();
			animations.add([target], defaultMutation, { delay: 55 });
			dist_default(animations.activeAnimations.length).equals(1);
			dist_default(animations.activeAnimations[0].delay).equals(55);
			dist_default(animations.activeAnimations[0].mutations).deepEquals([defaultMutation]);
			dist_default(animations.activeAnimations[0].target).equals(target);
		});
		dist_default("adding to an empty queue triggers the animation", function() {
			dist_default(animations.activeAnimations).deepEquals([]);
			let target = newTarget();
			window.requestAnimationFrame = spy();
			animations.add([target], defaultMutation);
			dist_default(window.requestAnimationFrame.args).deepEquals([animations._animate]);
		});
		dist_default("adding to a non empty queue does not trigger multiple animation frame requests", function() {
			dist_default(animations.activeAnimations).deepEquals([]);
			let target = newTarget();
			window.requestAnimationFrame = spy();
			animations.add([target], defaultMutation);
			animations.add([target], defaultMutation);
			dist_default(window.requestAnimationFrame.callCount).equals(1);
		});
		dist_default("unfinished animations are invoked and a new animation frame is requested", function() {
			time = 5;
			let animation = downcast({
				animateFrame: spy(),
				isFinished: spy(),
				resolve: spy()
			});
			animations.activeAnimations = [animation];
			window.requestAnimationFrame = spy();
			animations._animate();
			dist_default(animation.animateFrame.args).deepEquals([time]);
			dist_default(animations.activeAnimations).deepEquals([animation]);
			dist_default(window.requestAnimationFrame.args).deepEquals([animations._animate]);
		});
		dist_default("finished animations are removed from the queue and resolved", function() {
			let animation = downcast({
				animateFrame: spy(),
				isFinished: () => true,
				resolve: spy()
			});
			animations.activeAnimations = [animation];
			window.requestAnimationFrame = spy();
			animations._animate();
			dist_default(animation.animateFrame.callCount).equals(1);
			dist_default(animations.activeAnimations).deepEquals([]);
			dist_default(window.requestAnimationFrame.callCount).equals(0);
		});
		dist_default("stagger", function() {
			const targets = [
				newTarget(),
				newTarget(),
				newTarget()
			];
			window.requestAnimationFrame = spy();
			animations.add(targets, defaultMutation, { stagger: 55 });
			dist_default(window.requestAnimationFrame.callCount).equals(1);
			dist_default(animations.activeAnimations.length).equals(3);
			dist_default(animations.activeAnimations[0].delay).equals(0);
			dist_default(animations.activeAnimations[1].delay).equals(55);
			dist_default(animations.activeAnimations[2].delay).equals(110);
			dist_default(animations.activeAnimations[0].resolve).equals(null);
			dist_default(animations.activeAnimations[1].resolve).equals(null);
			dist_default(animations.activeAnimations[2].resolve instanceof Function).equals(true);
			animations.activeAnimations[0].delay = 0;
			animations.activeAnimations[1].delay = 0;
			animations.activeAnimations[2].delay = 0;
			animations.activeAnimations[2].resolve = null;
			dist_default(JSON.stringify(animations.activeAnimations[0])).equals(JSON.stringify(animations.activeAnimations[1]));
			dist_default(JSON.stringify(animations.activeAnimations[1])).equals(JSON.stringify(animations.activeAnimations[2]));
		});
		dist_default("start and finish", function() {
			let target = newTarget();
			let mutation = Object.assign({}, defaultMutation, { updateDom: spy() });
			let resolve = spy();
			let a = new Animation(target, [mutation], resolve, 0, ease.linear);
			dist_default(a.animationStart).equals(null);
			dist_default(a.duration).equals(DefaultAnimationTime);
			dist_default(a.isFinished()).equals(false);
			a.animateFrame(4);
			dist_default(a.animationStart).equals(4);
			dist_default(a.runTime).equals(0);
			dist_default(a.isFinished()).equals(false);
			a.animateFrame(203);
			dist_default(a.animationStart).equals(4);
			dist_default(a.runTime).equals(199);
			dist_default(a.isFinished()).equals(false);
			a.animateFrame(204);
			dist_default(a.animationStart).equals(4);
			dist_default(a.runTime).equals(200);
			dist_default(a.isFinished()).equals(true);
			a.animateFrame(304);
			dist_default(a.animationStart).equals(4);
			dist_default(a.runTime).equals(200);
			dist_default(a.isFinished()).equals(true);
		});
		dist_default("delay and domMutation", function() {
			let target = newTarget();
			let mutation = Object.assign({}, defaultMutation, { updateDom: spy() });
			let resolve = spy();
			let delay$1 = 150;
			let a = new Animation(target, [mutation], resolve, delay$1, ease.linear);
			dist_default(a.animationStart).equals(null);
			dist_default(a.duration).equals(DefaultAnimationTime);
			dist_default(a.isFinished()).equals(false);
			a.animateFrame(0);
			dist_default(a.animationStart).equals(0);
			dist_default(a.runTime).equals(-150);
			dist_default(a.isFinished()).equals(false);
			dist_default(mutation.updateDom.callCount).equals(0);
			a.animateFrame(150);
			dist_default(a.animationStart).equals(0);
			dist_default(a.runTime).equals(0);
			dist_default(a.isFinished()).equals(false);
			dist_default(mutation.updateDom.callCount).equals(1);
			dist_default(mutation.updateDom.args).deepEquals([
				target,
				assertNotNull(a.runTime) / a.duration,
				ease.linear
			]);
			a.animateFrame(250);
			dist_default(a.animationStart).equals(0);
			dist_default(a.runTime).equals(100);
			dist_default(a.isFinished()).equals(false);
			dist_default(mutation.updateDom.callCount).equals(2);
			dist_default(mutation.updateDom.args).deepEquals([
				target,
				assertNotNull(a.runTime) / a.duration,
				ease.linear
			]);
			a.animateFrame(350);
			dist_default(a.animationStart).equals(0);
			dist_default(a.runTime).equals(200);
			dist_default(a.isFinished()).equals(true);
			dist_default(mutation.updateDom.callCount).equals(3);
			dist_default(mutation.updateDom.args).deepEquals([
				target,
				assertNotNull(a.runTime) / a.duration,
				ease.linear
			]);
		});
	});
	dist_default.spec("transform dom updates", function() {
		dist_default("translateX with constant y", function() {
			const target = newTarget();
			let m = transform(TransformEnum.TranslateX, 0, 120).chain(TransformEnum.TranslateY, 8, 8);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.transform).equals("translateX(0px) translateY(8px)");
			m.updateDom(target, .1, ease.linear);
			dist_default(target.style.transform).equals("translateX(12px) translateY(8px)");
			m.updateDom(target, .995, ease.linear);
			dist_default(target.style.transform).equals("translateX(119.4px) translateY(8px)");
			m.updateDom(target, 1, ease.linear);
			dist_default(target.style.transform).equals("translateX(120px) translateY(8px)");
			client.device = DeviceType.OTHER_MOBILE;
			m.updateDom(target, .1, ease.linear);
			dist_default(target.style.transform).equals("translateX(12px) translateY(8px)");
		});
		dist_default("translateY", function() {
			const target = newTarget();
			let m = transform(TransformEnum.TranslateY, 0, 120);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.transform).equals("translateY(0px)");
			m.updateDom(target, .1, ease.linear);
			dist_default(target.style.transform).equals("translateY(12px)");
		});
		dist_default("force gpu on mobile devices (not on desktop)", function() {
			const target = newTarget();
			let m = transform(TransformEnum.TranslateX, 0, 120);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.transform).equals("translateX(0px)");
			client.device = DeviceType.OTHER_MOBILE;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.transform).equals("translateX(0px)");
		});
		dist_default("rotate", function() {
			const target = newTarget();
			let m = transform(TransformEnum.RotateY, 0, 120);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.transform).equals("rotateY(0deg)");
			m.updateDom(target, .1, ease.linear);
			dist_default(target.style.transform).equals("rotateY(12deg)");
		});
	});
	dist_default.spec("Alpha", function() {
		dist_default("background-color", function() {
			const target = newTarget();
			let m = alpha(AlphaEnum.BackgroundColor, "#000000", 0, 1);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.backgroundColor).equals("rgba(0, 0, 0, 0)");
			m.updateDom(target, .5, ease.linear);
			dist_default(target.style.backgroundColor).equals("rgba(0, 0, 0, 0.5)");
			m.updateDom(target, 1, ease.linear);
			browser(() => {
				dist_default(target.style.backgroundColor).equals("rgba(0, 0, 0)");
			});
			node(() => {
				dist_default(target.style.backgroundColor).equals("rgba(0, 0, 0, 1)");
			});
		});
		dist_default("color", function() {
			const target = newTarget();
			let m = alpha(AlphaEnum.Color, "#ffffff", 0, 1);
			client.device = DeviceType.DESKTOP;
			m.updateDom(target, 0, ease.linear);
			dist_default(target.style.color).equals("rgba(255, 255, 255, 0)");
			m.updateDom(target, .5, ease.linear);
			dist_default(target.style.color).equals("rgba(255, 255, 255, 0.5)");
			m.updateDom(target, 1, ease.linear);
			browser(() => {
				dist_default(target.style.color).equals("rgba(255, 255, 255)");
			});
			node(() => {
				dist_default(target.style.color).equals("rgba(255, 255, 255, 1)");
			});
		});
	});
});

//#endregion
//#region tests/gui/ThemeControllerTest.ts
var import_testdouble$41 = __toESM(require_testdouble(), 1);
dist_default.spec("ThemeController", function() {
	let themeManager;
	let themeFacadeMock;
	let htmlSanitizerMock;
	let theme;
	dist_default.beforeEach(async function() {
		theme = {};
		themeFacadeMock = (0, import_testdouble$41.object)();
		(0, import_testdouble$41.when)(themeFacadeMock.getThemes()).thenResolve([]);
		htmlSanitizerMock = (0, import_testdouble$41.object)();
		(0, import_testdouble$41.when)(htmlSanitizerMock.sanitizeHTML(import_testdouble$41.matchers.anything())).thenReturn({
			html: "sanitized",
			blockedExternalContent: 0,
			inlineImageCids: [],
			links: []
		});
		themeManager = new ThemeController(theme, themeFacadeMock, () => Promise.resolve(htmlSanitizerMock), AppType.Integrated);
		await themeManager.initialized;
	});
	dist_default("updateCustomTheme", async function() {
		const theme$1 = downcast({
			themeId: "HelloFancyId",
			content_bg: "#fffeee",
			logo: "unsanitized_logo",
			base: "light"
		});
		await themeManager.applyCustomizations(theme$1);
		const captor$4 = import_testdouble$41.matchers.captor();
		verify(themeFacadeMock.setThemes(captor$4.capture()));
		const savedTheme = captor$4.values[0][4];
		dist_default(savedTheme.themeId).equals("HelloFancyId");
		dist_default(savedTheme.content_bg).equals("#fffeee");
		dist_default(savedTheme.logo).equals("sanitized");
		dist_default(savedTheme.content_fg).equals(themeManager.getDefaultTheme().content_fg);
		dist_default(themeManager.getCurrentTheme().logo).equals("sanitized");
	});
	dist_default("when using automatic theme and preferring dark, dark theme is applied, and themeId is automatic", async function() {
		(0, import_testdouble$41.when)(themeFacadeMock.getThemePreference()).thenResolve("auto:light|dark");
		(0, import_testdouble$41.when)(themeFacadeMock.prefersDark()).thenResolve(true);
		await themeManager.reloadTheme();
		dist_default(themeManager.getCurrentTheme().themeId).equals("dark");
		dist_default(themeManager.themeId).equals("dark");
		dist_default(themeManager.themePreference).equals("auto:light|dark");
	});
	dist_default("when using automatic theme and preferring light, light theme is applied, and themeId is automatic", async function() {
		(0, import_testdouble$41.when)(themeFacadeMock.getThemePreference()).thenResolve("auto:light|dark");
		(0, import_testdouble$41.when)(themeFacadeMock.prefersDark()).thenResolve(false);
		await themeManager.reloadTheme();
		dist_default(themeManager.getCurrentTheme().themeId).equals("light");
		dist_default(themeManager.themeId).equals("light");
		dist_default(themeManager.themePreference).equals("auto:light|dark");
	});
	dist_default("when switching to automatic and preferring the light theme, light theme is applied, and themeId is automatic", async function() {
		(0, import_testdouble$41.when)(themeFacadeMock.getThemePreference()).thenResolve("dark");
		await themeManager._initializeTheme();
		(0, import_testdouble$41.when)(themeFacadeMock.prefersDark()).thenResolve(false);
		await themeManager.setThemePreference("automatic");
		dist_default(themeManager.getCurrentTheme().themeId).equals("light");
		dist_default(themeManager.themeId).equals("automatic");
	});
});

//#endregion
//#region tests/api/main/EntropyCollectorTest.ts
var import_testdouble$40 = __toESM(require_testdouble(), 1);
var FakeWindow = class {
	listeners = new Map();
	addEventListener = (event, listener) => {
		this.getListeners(event).push(listener);
	};
	getListeners(event) {
		return getFromMap(this.listeners, event, () => []);
	}
	removeEventListener = (event, listener) => {
		remove(this.getListeners(event), listener);
	};
	dispatch(name, event) {
		for (let listener of this.getListeners(name)) listener(event);
	}
	crypto = { getRandomValues(array) {
		if (array) array[0] = 32;
		return array;
	} };
	performance = {
		now: () => 3,
		getEntries: () => []
	};
	screen = { orientation: { angle: 90 } };
};
dist_default.spec("EntropyCollector", function() {
	let collector;
	let entropyFacade;
	let scheduler;
	let addedEntropy;
	let fakeWindow;
	const TIME_ENTROPY = {
		source: "time",
		entropy: 2,
		data: 3
	};
	const RANDOM_ENTROPY = {
		source: "random",
		entropy: 32,
		data: 32
	};
	const ENTROPY_SUFFIX = [
		TIME_ENTROPY,
		RANDOM_ENTROPY,
		TIME_ENTROPY
	];
	dist_default.beforeEach(function() {
		entropyFacade = (0, import_testdouble$40.object)();
		addedEntropy = [];
		(0, import_testdouble$40.when)(entropyFacade.addEntropy(import_testdouble$40.matchers.anything())).thenDo((e) => addedEntropy.push(e));
		scheduler = new SchedulerMock();
		fakeWindow = new FakeWindow();
		collector = new EntropyCollector(entropyFacade, scheduler, fakeWindow);
	});
	dist_default.afterEach(function() {
		collector.stop();
	});
	function runInterval() {
		scheduler.scheduledPeriodic.get(EntropyCollector.SEND_INTERVAL).thunk();
	}
	dist_default("when collector is not started click is collected", function() {
		fakeWindow.dispatch("click", {
			clientX: 888,
			clientY: 777
		});
		dist_default(scheduler.scheduledPeriodic.get(EntropyCollector.SEND_INTERVAL)).equals(undefined);
		dist_default(addedEntropy).deepEquals([]);
	});
	dist_default("when there's nothing in the cache nothing is added", function() {
		collector.start();
		runInterval();
		dist_default(addedEntropy.length).equals(0)("nothing added");
	});
	dist_default("when collector is started click is collected", function() {
		collector.start();
		fakeWindow.dispatch("click", {
			clientX: 888,
			clientY: 777
		});
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([{
			source: "mouse",
			entropy: 2,
			data: 113
		}, ...ENTROPY_SUFFIX]);
	});
	dist_default("when collector is started all events are collected", function() {
		collector.start();
		fakeWindow.dispatch("click", {
			clientX: 888,
			clientY: 777
		});
		fakeWindow.dispatch("keydown", { key: "W" });
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0].length).equals(6);
	});
	dist_default("when collector is started mousemove is collected", function() {
		collector.start();
		fakeWindow.dispatch("mousemove", {
			clientX: 123,
			clientY: 456
		});
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([{
			source: "mouse",
			entropy: 2,
			data: 435
		}, ...ENTROPY_SUFFIX]);
	});
	dist_default("when collector is started keydown is collected", function() {
		collector.start();
		fakeWindow.dispatch("keydown", { key: "0" });
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([{
			source: "key",
			entropy: 2,
			data: 48
		}, ...ENTROPY_SUFFIX]);
	});
	dist_default("when collector is started touchstart is collected", function() {
		collector.start();
		fakeWindow.dispatch("touchstart", { touches: [{
			clientX: 3,
			clientY: 4
		}] });
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([{
			source: "touch",
			entropy: 2,
			data: 7
		}, ...ENTROPY_SUFFIX]);
	});
	dist_default("when collector is started touchmove is collected", function() {
		collector.start();
		fakeWindow.dispatch("touchmove", { touches: [{
			clientX: 3,
			clientY: 4
		}] });
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([{
			source: "touch",
			entropy: 2,
			data: 7
		}, ...ENTROPY_SUFFIX]);
	});
	dist_default("when collector is started devicemotion is collected", function() {
		collector.start();
		fakeWindow.dispatch("devicemotion", { accelerationIncludingGravity: {
			x: 3,
			y: 4,
			z: 5
		} });
		runInterval();
		dist_default(addedEntropy.length).equals(1)("added entropy");
		dist_default(addedEntropy[0]).deepEquals([
			{
				source: "accel",
				entropy: 2,
				data: 2
			},
			{
				source: "time",
				entropy: 2,
				data: 3
			},
			{
				source: "accel",
				entropy: 0,
				data: 90
			},
			...ENTROPY_SUFFIX
		]);
	});
});

//#endregion
//#region tests/misc/HtmlSanitizerTest.ts
dist_default.spec("HtmlSanitizerTest", browser(function() {
	dist_default("OWASP XSS attacks", function() {
		let tests = [
			{
				html: "<div>';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//\";\nalert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//--\n></SCRIPT>\">'><SCRIPT>alert(String.fromCharCode(88,83,83))</SCRIPT></div>",
				expected: "<div>';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//\";\nalert(String.fromCharCode(88,83,83))//\";alert(String.fromCharCode(88,83,83))//--\n&gt;\"&gt;'&gt;</div>"
			},
			{
				html: "<div>'';!--\"<XSS>=&{()}</div>",
				expected: "<div>'';!--\"=&amp;{()}</div>"
			},
			{
				html: "<SCRIPT SRC=http://ha.ckers.org/xss.js></SCRIPT>",
				expected: ""
			},
			{
				html: "<IMG SRC=\"javascript:alert('XSS');\">",
				expected: `<img style="max-width: 100%;">`
			},
			{
				html: "<IMG SRC=javascript:alert('XSS')>",
				expected: `<img style="max-width: 100%;">`
			}
		];
		for (const test of tests) dist_default(htmlSanitizer.sanitizeHTML(test.html, { blockExternalContent: false }).html).equals(test.expected);
	});
	dist_default("blockquotes", function() {
		dist_default(htmlSanitizer.sanitizeHTML("<blockquote class=\"tutanota_quote\">test</blockquote>", { blockExternalContent: true }).html).equals("<blockquote class=\"tutanota_quote\">test</blockquote>");
		dist_default(htmlSanitizer.sanitizeHTML("<blockquote type=\"cite\"cite=\"mid:AC55602DD\"></blockquote>", { blockExternalContent: true }).html).equals("<blockquote type=\"cite\"></blockquote>");
	});
	dist_default("custom classes", function() {
		dist_default(htmlSanitizer.sanitizeHTML("<div class=\"custom1 tutanota_quote custom2\">test</div>").html).equals("<div class=\"tutanota_quote\">test</div>");
	});
	dist_default("leading text node", function() {
		dist_default(htmlSanitizer.sanitizeHTML("hello<blockquote>test</blockquote>").html).equals("hello<blockquote>test</blockquote>");
	});
	dist_default("html links", function() {
		let simpleHtmlLink = "<a href=\"https://tutanota.com\">here</a>";
		let sanitizedLink = htmlSanitizer.sanitizeHTML(simpleHtmlLink).html;
		dist_default(sanitizedLink.includes("href=\"https://tutanota.com\"")).equals(true);
		dist_default(sanitizedLink.includes("target=\"_blank\"")).equals(true);
		dist_default(sanitizedLink.includes("rel=\"noopener noreferrer\"")).equals(true);
		dist_default(sanitizedLink.includes(">here</a>")).equals(true);
		let htmlLink = "<a href=\"https://www.coursera.org/maestro/auth/normal/change_email.php?payload=9722E7n3bcN/iM08q79eG2plUafuyc6Yj631JIMAuZgGAQL0UdTqbP7w2bH8b7fmpsljKMVVVpF81l0zD1HMVQ==|Iv5+NfeRQh0Gk7/Idr0jsIZfC69Mnixw0FNbTRNmuUTgIqLefDMOhKBqY8prtvyBB7jV8kZy9XtGDue7uuUMwNYv1ucDvn/RYt76LAVXIQrY9BhW1Y381ZyMbuhB14LERDe05DUJgQI6XkM9gxM3APT7RZs48ERUIb/MstkJtxw=\">here</a>";
		sanitizedLink = htmlSanitizer.sanitizeHTML(htmlLink).html;
		dist_default(sanitizedLink.includes("href=\"https://www.coursera.org/maestro/auth/normal/change_email.php?payload=9722E7n3bcN/iM08q79eG2plUafuyc6Yj631JIMAuZgGAQL0UdTqbP7w2bH8b7fmpsljKMVVVpF81l0zD1HMVQ==|Iv5+NfeRQh0Gk7/Idr0jsIZfC69Mnixw0FNbTRNmuUTgIqLefDMOhKBqY8prtvyBB7jV8kZy9XtGDue7uuUMwNYv1ucDvn/RYt76LAVXIQrY9BhW1Y381ZyMbuhB14LERDe05DUJgQI6XkM9gxM3APT7RZs48ERUIb/MstkJtxw=\"")).equals(true);
		dist_default(sanitizedLink.includes("target=\"_blank\"")).equals(true);
		dist_default(sanitizedLink.includes("rel=\"noopener noreferrer\"")).equals(true);
		dist_default(sanitizedLink.includes(">here</a>")).equals(true);
	});
	dist_default("tutatemplate links in html", function() {
		let tutatemplateLink = "<a href=\"tutatemplate:some-id/some-entry\">#hashtag</a>";
		let sanitized = htmlSanitizer.sanitizeHTML(tutatemplateLink).html;
		dist_default(sanitized.includes("href=\"tutatemplate:some-id/some-entry\"")).equals(true);
	});
	dist_default("tutatemplate links in fragment", function() {
		const tutatemplateLink = "<a href=\"tutatemplate:some-id/some-entry\">#hashtag</a>";
		const sanitized = htmlSanitizer.sanitizeFragment(tutatemplateLink).fragment;
		const a = sanitized.querySelector("a");
		dist_default(a != null && a.href.includes("tutatemplate:some-id/some-entry")).equals(true);
	});
	dist_default("notification mail template link", function() {
		let simpleHtmlLink = "<a href=\" {link} \">here</a>";
		let sanitizedLink = htmlSanitizer.sanitizeHTML(simpleHtmlLink, { blockExternalContent: true }).html;
		dist_default(sanitizedLink.includes("href=\"{link}\"")).equals(true);
		dist_default(sanitizedLink.includes("target=\"_blank\"")).equals(true);
		dist_default(sanitizedLink.includes("rel=\"noopener noreferrer\"")).equals(true);
		dist_default(sanitizedLink.includes(">here</a>")).equals(true);
	});
	dist_default("area element", function() {
		let element = "<area href=\"https://tutanota.com\">here</area>";
		let sanitizedElement = htmlSanitizer.sanitizeHTML(element, { blockExternalContent: true }).html;
		dist_default(sanitizedElement.includes("href=\"https://tutanota.com\"")).equals(true);
		dist_default(sanitizedElement.includes("target=\"_blank\"")).equals(true);
		dist_default(sanitizedElement.includes("rel=\"noopener noreferrer\"")).equals(true);
	});
	dist_default("sanitizing empty body", function() {
		let sanitized = htmlSanitizer.sanitizeHTML("", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("");
		sanitized = htmlSanitizer.sanitizeHTML(" ", { blockExternalContent: true }).html;
		dist_default(sanitized).equals(" ");
		sanitized = htmlSanitizer.sanitizeHTML("yo", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("yo");
		sanitized = htmlSanitizer.sanitizeHTML("<br>", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("<br>");
		sanitized = htmlSanitizer.sanitizeHTML("<div></div>", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("<div></div>");
		sanitized = htmlSanitizer.sanitizeHTML("<html></html>", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("");
		sanitized = htmlSanitizer.sanitizeHTML("<html><body></body></html>", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("");
		sanitized = htmlSanitizer.sanitizeHTML("<html><body>yo</body></html>", { blockExternalContent: true }).html;
		dist_default(sanitized).equals("yo");
	});
	dist_default("external image replacement is correct", function() {
		dist_default(PREVENT_EXTERNAL_IMAGE_LOADING_ICON).equals("data:image/svg+xml;utf8,<svg version='1.1' viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'> <rect width='512' height='512' fill='%23f8f8f8'/> <path d='m220 212c0 12.029-9.7597 21.789-21.789 21.789-12.029 0-21.789-9.7597-21.789-21.789s9.7597-21.789 21.789-21.789c12.029 0 21.789 9.7597 21.789 21.789zm116.21 43.578v50.841h-159.79v-21.789l36.315-36.315 18.158 18.158 58.104-58.104zm10.895-79.893h-181.58c-1.9292 0-3.6315 1.7023-3.6315 3.6315v138c0 1.9292 1.7023 3.6315 3.6315 3.6315h181.58c1.9292 0 3.6315-1.7023 3.6315-3.6315v-138c0-1.9292-1.7023-3.6315-3.6315-3.6315zm18.158 3.6315v138c0 9.9867-8.1709 18.158-18.158 18.158h-181.58c-9.9867 0-18.158-8.1709-18.158-18.158v-138c0-9.9867 8.1709-18.158 18.158-18.158h181.58c9.9867 0 18.158 8.1709 18.158 18.158z' fill='%23b4b4b4' stroke-width='.11348'/></svg>");
	});
	const REPLACEMENT_VALUE = `url("${PREVENT_EXTERNAL_IMAGE_LOADING_ICON}")`;
	dist_default.spec("external background images", function() {
		dist_default("when external content is blocked background-image url is replaced", function() {
			const result = htmlSanitizer.sanitizeFragment("<p style=\"background-image: url(&quot;https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image&quot;)\"></p>", { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("content is blocked if there is any non-data url in background-image ", function() {
			const result = htmlSanitizer.sanitizeFragment("<p style=\"background-image: url('data:image/svg+xml;utf8,inline,'), url(&quot;https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image&quot;)\"></p>", { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(`url("${PREVENT_EXTERNAL_IMAGE_LOADING_ICON}")`);
		});
		dist_default("when external content is blocked background url in quotes is replaced", function() {
			const result = htmlSanitizer.sanitizeFragment("<p style=\"background: url(&quot;https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image&quot;)\"></p>", { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is blocked background url in html quotes is replaced", function() {
			const result = htmlSanitizer.sanitizeFragment("<p style=\"background: url(&#39;https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image&#39;)\"></p>", { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is not blocked background url in html quotes is not replaced", function() {
			const result = htmlSanitizer.sanitizeFragment("<p style=\"background: url(&quot;https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image&quot;)\"></p>", { blockExternalContent: false });
			dist_default(result.blockedExternalContent).equals(0);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(`url("https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image")`);
		});
		dist_default("when external content is blocked background-image image-set is replaced", function() {
			const cssValue = `image-set(url('https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image') 1x, url('https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image') 2x)`;
			if (!CSS.supports("background-image", cssValue)) {
				console.warn("HtmlSanitizerTest: Browser doesn't support image-set, skipping");
				return;
			}
			const dirty = `<p style="background-image: ${cssValue};"></p>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is blocked background-image url -webkit-image-set is replaced", function() {
			const cssValue = `-webkit-image-set(url('https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image') 1x, url('https://emailprivacytester.com/cb/1134f6cba766bf0b/background_image') 2x)`;
			if (!CSS.supports("background-image", cssValue)) {
				console.warn("HtmlSanitizerTest: Browser doesn't support -webkit-image-set, skipping");
				return;
			}
			const dirty = `<p style="background-image: ${cssValue};"></p>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is blocked background-image with multiple url is replaced", function() {
			const dirty = `
<p style="background: url('https://example.com/1.png'), url('https://exmaple.com/2.jpg');">
</p>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is blocked background-image with gradient and url is replaced", function() {
			const dirty = `
<p style="background: linear-gradient(blueviolet, black), url('https://exmaple.com/1.jpg')">
</p>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(REPLACEMENT_VALUE);
		});
		dist_default("when external content is blocked inline background is not replaced", function() {
			const backgroundUrl = "data:image/svg+xml;utf8,inline";
			const ditry = `
	<p style="background: url('${backgroundUrl}');">
	</p>`;
			const result = htmlSanitizer.sanitizeFragment(ditry, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(0);
			const p = result.fragment.querySelector("p");
			dist_default(p.style.backgroundImage).equals(`url("${backgroundUrl}")`);
		});
		dist_default("when external content is blocked url border-image-source is removed", function() {
			const dirty = `<div style="border-image-source: url('https://exmaple.com/1.jpg')">hi</div>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const div = result.fragment.querySelector("div");
			dist_default(div.style.borderImageSource).equals("");
		});
		dist_default("when external content is blocked url mask-image is removed", function() {
			const dirty = `<div style="mask-image: url('https://exmaple.com/1.jpg')">hi</div>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			const div = result.fragment.querySelector("div");
			dist_default(div.style.maskImage == undefined || div.style.maskImage === "").equals(true)(`makImage is not set`);
		});
		dist_default("when external content is blocked url shape-outside is removed", function() {
			const dirty = `<div style="shape-outside: url('https://exmaple.com/1.jpg')">hi</div>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			dist_default(result.blockedExternalContent).equals(1);
			const div = result.fragment.querySelector("div");
			dist_default(div.style.shapeOutside).equals("");
		});
		dist_default("when external content is blocked mask-border-source is removed", function() {
			const dirty = `<div style="mask-border-source: url('https://exmaple.com/1.jpg')">hi</div>`;
			const result = htmlSanitizer.sanitizeFragment(dirty, { blockExternalContent: true });
			const div = result.fragment.querySelector("div");
			dist_default(div.style.maskBorderSource == undefined || div.style.maskBorderSource === "").equals(true)("mask-border-source");
		});
	});
	dist_default("detect background inline images", function() {
		const backgroundUrl = "data:image/svg+xml;utf8,inline";
		let result = htmlSanitizer.sanitizeHTML(`<p style="background-image: url(${backgroundUrl})"> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
		result = htmlSanitizer.sanitizeHTML(`<p style="background-image: url(${backgroundUrl}), url(${backgroundUrl})"> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
		result = htmlSanitizer.sanitizeHTML(`<p style="background-image: url('${backgroundUrl}')"> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
		result = htmlSanitizer.sanitizeHTML(`<p style='background-image: url("${backgroundUrl}")'> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
		result = htmlSanitizer.sanitizeHTML(`<p style="background-image: url(&quot;${backgroundUrl}&quot;)"> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
		result = htmlSanitizer.sanitizeHTML(`<p style="background-image: url(&#39;${backgroundUrl}&#39;)"> </p>`, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes(backgroundUrl)).equals(true);
	});
	dist_default("background attribute", function() {
		const plainHtml = "<table><tr><td background=\"https://tutanota.com/image.jpg\"> ....</td></tr></table>";
		const cleanHtml = htmlSanitizer.sanitizeHTML(plainHtml, { blockExternalContent: true });
		dist_default(cleanHtml.blockedExternalContent).equals(1);
		dist_default(cleanHtml.html.split(" ").some((e) => e === "background=\"https://tutanota.com/image.jpg\"")).equals(false);
		dist_default(cleanHtml.html.includes("draft-background")).equals(true);
		dist_default(htmlSanitizer.sanitizeHTML(plainHtml, { blockExternalContent: false }).html.includes("background=")).equals(true);
		dist_default(htmlSanitizer.sanitizeHTML(plainHtml, { blockExternalContent: false }).html.includes("draft-background=")).equals(false);
	});
	dist_default("srcset attribute", function() {
		const plainHtml = "<img srcset=\"https://tutanota.com/image1.jpg 1x, https://tutanota.com/image2.jpg 2x, https://tutanota.com/image3.jpg 3x\" src=\"https://tutanota.com/image.jpg\">";
		const cleanHtml = htmlSanitizer.sanitizeHTML(plainHtml, { blockExternalContent: true });
		dist_default(cleanHtml.blockedExternalContent).equals(2);
		dist_default(cleanHtml.html.split(" ").some((e) => e === "srcSet=\"https://tutanota.com/image1.jpg 1x, https://tutanota.com/image2.jpg 2x, https://tutanota.com/image3.jpg 3x\"" || e === "srcset=\"https://tutanota.com/image1.jpg 1x, https://tutanota.com/image2.jpg 2x, https://tutanota.com/image3.jpg 3x\"")).equals(false);
		dist_default(cleanHtml.html.includes("draft-srcset=\"https://tutanota.com/image1.jpg 1x, https://tutanota.com/image2.jpg 2x, https://tutanota.com/image3.jpg 3x")).equals(true);
		dist_default(cleanHtml.html.includes("src=\"data:image/svg+xml;utf8,")).equals(true);
	});
	dist_default("detect images and set maxWidth=100px for placeholder images", function() {
		let result = htmlSanitizer.sanitizeHTML("<img src=\"https://emailprivacytester.com/cb/510828b5a8f43ab5\">", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("src=\"data:image/svg+xml;utf8,")).equals(true);
		dist_default(result.html.includes("style=\"max-width: 100px;")).equals(true);
	});
	dist_default("detect figure", function() {
		let inputElement = "<figure src=\"https://tutanota.com/images/favicon/favicon.ico\" type=\"image\">";
		let result = htmlSanitizer.sanitizeHTML(inputElement, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.split(" ").some((e) => e === "src=\"https://tutanota.com")).equals(false);
		dist_default(result.html.includes("draft-src=\"https://tutanota.com")).equals(true);
	});
	dist_default("detect video posters", function() {
		let result = htmlSanitizer.sanitizeHTML("<video poster=\"https://emailprivacytester.com/cb/04e69deda1be1c37/video_poster\" height=\"1\" width=\"1\"></video>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("poster=\"data:image/svg+xml;utf8,")).equals(true);
	});
	dist_default("detect style list images", function() {
		let result = htmlSanitizer.sanitizeHTML("<ul style=\"list-style-image: url(http://www.heise.de/icons/ho/heise_online_logo_top.gif);\"><li>Zeile 1</li></ul>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("list-style-image: url(&quot;data:image/svg+xml;utf8,")).equals(true);
	});
	dist_default("detect style content urls", function() {
		let result = htmlSanitizer.sanitizeHTML("<div style=\"content: url(http://www.heise.de/icons/ho/heise_online_logo_top.gif)\"></div>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("content: url(&quot;data:image/svg+xml;utf8,")).equals(true);
		result = htmlSanitizer.sanitizeHTML("<div style=\"content: blabla\"> </div >", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html.includes("content: blabla")).equals(true);
	});
	dist_default("detect style cursor images", function() {
		let result = htmlSanitizer.sanitizeHTML("<div style=\"cursor:url(https://tutanota.com/images/favicon/favicon.ico),auto;\" ></div>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html).equals("<div style=\"\"></div>");
		dist_default(result.html.includes("cursor:")).equals(false);
		result = htmlSanitizer.sanitizeHTML("<div style=\"cursor:url(https://tutanota.com/images/favicon/favicon2.ico),url(https://tutanota.com/images/favicon/favicon.ico),auto;\"></div>", { blockExternalContent: false });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html).equals("<div style=\"cursor:url(https://tutanota.com/images/favicon/favicon2.ico),url(https://tutanota.com/images/favicon/favicon.ico),auto;\"></div>");
	});
	dist_default("detect style filter files", function() {
		let result = htmlSanitizer.sanitizeHTML("<div style=\"filter:url(https://tutanota.com/images/favicon/favicon.ico);\" ></div>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("filter:")).equals(false);
		result = htmlSanitizer.sanitizeHTML("<div style=\"filter:url(https://tutanota.com/images/favicon/favicon.ico);\" ></div>", { blockExternalContent: false });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html).equals("<div style=\"filter:url(https://tutanota.com/images/favicon/favicon.ico);\"></div>");
	});
	dist_default("detect style element", function() {
		let result = htmlSanitizer.sanitizeHTML("<div><style>@import url(https://fonts.googleapis.com/css?family=Diplomata+SC);</style></div>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html).equals("<div></div>");
		result = htmlSanitizer.sanitizeHTML("<div><style>@import url(https://fonts.googleapis.com/css?family=Diplomata+SC);</style></div>", { blockExternalContent: false });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html).equals("<div></div>");
	});
	dist_default("replace images and links", function() {
		let result = htmlSanitizer.sanitizeHTML("<html><img src=\"https://localhost/1.png\"><img src=\"https://localhost/2.png\"><img src=\"https://localhost/3.png\"><img src=\"https://localhost/4.png\"><img src=\"https://localhost/5.png\"><img src=\"https://localhost/6.png\"><img src=\"https://localhost/7.png\"><img src=\"https://localhost/8.png\"><img src=\"https://localhost/9\"><a href=\"http://localhost/index.html\"></a> </html>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(9);
		dist_default(result.html.includes("<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"http://localhost/index.html\">") || result.html.includes("<a href=\"http://localhost/index.html\" rel=\"noopener noreferrer\" target=\"_blank\">")).equals(true);
	});
	dist_default("do not replace inline images", function() {
		const input = "<html><img src=\"cid:asbasdf-safd_d\"><img src=\"data:image/svg+xml;utf8,sadfsdasdf\"></html>";
		const result = htmlSanitizer.sanitizeHTML(input, { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.inlineImageCids).deepEquals(["asbasdf-safd_d"]);
		dist_default(result.html.includes(`cid="asbasdf-safd_d"`)).equals(true);
		dist_default(result.html.includes(`data:image/svg+xml;utf8,sadfsdasdf`)).equals(true);
		dist_default(result.html.match(/max-width: 100%;/g).length).equals(2);
	});
	dist_default("audio tag", function() {
		let result = htmlSanitizer.sanitizeHTML("<audio controls autoplay loop muted preload src=\"https://www.w3schools.com/tags/horse.mp3\" type=\"audio/mpeg\"></audio>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html.includes("data:image/svg+xml;utf8,")).equals(true);
	});
	dist_default("embed tag", function() {
		let result = htmlSanitizer.sanitizeHTML("<div><embed src=\"https://tutanota.com/images/favicon/favicon.ico\"></div>", { blockExternalContent: true });
		dist_default(result.blockedExternalContent).equals(1);
		dist_default(result.html).equals("<div></div>");
		result = htmlSanitizer.sanitizeHTML("<div><embed src=\"https://tutanota.com/images/favicon/favicon.ico\"></div>", { blockExternalContent: false });
		dist_default(result.blockedExternalContent).equals(0);
		dist_default(result.html).equals("<div></div>");
	});
	dist_default("disallow relative links", function() {
		dist_default(htmlSanitizer.sanitizeHTML("<a href=\"relative\">text</a>").html).equals("<a href=\"javascript:void(0)\">text</a>");
		dist_default(htmlSanitizer.sanitizeHTML("<a href=\"/relative\">text</a>").html).equals("<a href=\"javascript:void(0)\">text</a>");
	});
	dist_default("allow relative links when asked", function() {
		dist_default(htmlSanitizer.sanitizeHTML("<a href=\"relative\">text</a>", { allowRelativeLinks: true }).html).equals("<a href=\"relative\" rel=\"noopener noreferrer\" target=\"_blank\">text</a>");
		dist_default(htmlSanitizer.sanitizeHTML("<a href=\"/relative\">text</a>", { allowRelativeLinks: true }).html).equals("<a href=\"/relative\" rel=\"noopener noreferrer\" target=\"_blank\">text</a>");
	});
	dist_default("filter out position css", function() {
		dist_default(htmlSanitizer.sanitizeHTML(`<div style="color: red; position: absolute;"></div>`).html).equals(`<div style="color: red;"></div>`);
		dist_default(htmlSanitizer.sanitizeHTML(`<div style="color: red; position: absolute;"></div>`, { blockExternalContent: false }).html).equals(`<div style="color: red;"></div>`);
	});
	dist_default("use image loading placeholder", function() {
		const r1 = htmlSanitizer.sanitizeHTML(`<img src="cid:123456">`, { usePlaceholderForInlineImages: true }).html;
		dist_default(r1.includes(`src="${PREVENT_EXTERNAL_IMAGE_LOADING_ICON}"`)).equals(true);
		dist_default(r1.includes(`style="max-width: 100%;"`)).equals(true);
		dist_default(r1.includes(`cid="123456"`)).equals(true);
		dist_default(r1.includes(`class="tutanota-placeholder"`)).equals(true);
		const r2 = htmlSanitizer.sanitizeHTML(`<img src="cid:123456">`).html;
		dist_default(r2.includes(`src="${PREVENT_EXTERNAL_IMAGE_LOADING_ICON}"`)).equals(true);
		dist_default(r2.includes(`style="max-width: 100%;"`)).equals(true);
		dist_default(r2.includes(`cid="123456"`)).equals(true);
		dist_default(r2.includes(`class="tutanota-placeholder"`)).equals(true);
	});
	dist_default("don't use image loading placeholder", function() {
		const result = htmlSanitizer.sanitizeHTML(`<img src="cid:123456">`, { usePlaceholderForInlineImages: false }).html;
		dist_default(result).equals(`<img src="cid:123456" style="max-width: 100%;">`);
	});
	dist_default("add max-width to images", function() {
		const result = htmlSanitizer.sanitizeHTML(`<img src="cid:123456">`, { usePlaceholderForInlineImages: false }).html;
		dist_default(result).equals(`<img src="cid:123456" style="max-width: 100%;">`);
	});
	dist_default("add max-width to images that have a given width", function() {
		const result = htmlSanitizer.sanitizeHTML(`<img src="cid:123456" style="width: 150px;">`, { usePlaceholderForInlineImages: false }).html;
		dist_default(result).equals(`<img style="width: 150px; max-width: 100%;" src="cid:123456">`);
	});
	dist_default("replace max-width for inline images", function() {
		const result = htmlSanitizer.sanitizeHTML(`<img src="cid:123456" style="max-width: 60%;">`, { usePlaceholderForInlineImages: false }).html;
		dist_default(result).equals(`<img style="max-width: 100%;" src="cid:123456">`);
	});
	dist_default("replace max-width for external images", function() {
		const result = htmlSanitizer.sanitizeHTML(`<img src="https://tutanota.com/images/favicon/favicon.ico">`, { blockExternalContent: false }).html;
		dist_default(result).equals(`<img src="https://tutanota.com/images/favicon/favicon.ico" style="max-width: 100%;">`);
	});
	dist_default("svg tag not removed", function() {
		const result = htmlSanitizer.sanitizeSVG(`<svg> <rect x="10" y="10" width="10" height="10"> </rect> </svg>`).html.trim();
		const element = document.createElement("div");
		element.innerHTML = result;
		dist_default(element.children[0]?.nodeName).equals("svg");
		dist_default(element.children[0]?.children[0]?.nodeName.toLowerCase()).equals("rect");
		dist_default(element.children[0]?.children[0]?.getAttribute("x")).equals("10");
		dist_default(element.children[0]?.children[0]?.getAttribute("y")).equals("10");
		dist_default(element.children[0]?.children[0]?.getAttribute("width")).equals("10");
		dist_default(element.children[0]?.children[0]?.getAttribute("height")).equals("10");
	});
	dist_default("svg fragment should not be removed", function() {
		const result = htmlSanitizer.sanitizeSVG(`<rect x="10" y="10" width="10" height="10"> </rect>`).html.trim();
		const element = document.createElement("svg");
		element.innerHTML = result;
		dist_default(element.children[0]?.nodeName.toLowerCase()).equals("rect");
		dist_default(element.children[0]?.getAttribute("x")).equals("10");
		dist_default(element.children[0]?.getAttribute("y")).equals("10");
		dist_default(element.children[0]?.getAttribute("width")).equals("10");
		dist_default(element.children[0]?.getAttribute("height")).equals("10");
	});
	dist_default("svg fragment should be removed", function() {
		const result = htmlSanitizer.sanitizeHTML(`<rect x="10" y="10" width="10" height="10"> </rect>`).html.trim();
		dist_default(result).equals(``);
	});
	dist_default.spec("inline attachment sanitization", function() {
		dist_default("svg with xss gets sanitized", function() {
			const svgDocumentWithXSS = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n\n<svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n<polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/>\n<script type=\"text/javascript\">\nalert(localStorage.getItem(\"tutanotaConfig\"));\n</script></svg>";
			const expectedSvgDocument = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n<polygon stroke=\"#004400\" fill=\"#009900\" points=\"0,0 0,50 50,0\" id=\"triangle\"/>\n</svg>";
			const xssDataFile = createDataFile("xss.svg", "image/svg+xml", stringToUtf8Uint8Array(svgDocumentWithXSS), "some-cid");
			const sanitizedDataFile = htmlSanitizer.sanitizeInlineAttachment(xssDataFile);
			dist_default(sanitizedDataFile.cid).equals("some-cid");
			dist_default(sanitizedDataFile.mimeType).equals("image/svg+xml");
			dist_default(sanitizedDataFile.name).equals("xss.svg");
			const parser = new DOMParser();
			const cleanSvgTree = parser.parseFromString(utf8Uint8ArrayToString(sanitizedDataFile.data), "image/svg+xml");
			const expectedSvgTree = parser.parseFromString(expectedSvgDocument, "image/svg+xml");
			const serializer = new XMLSerializer();
			const reserializedClean = serializer.serializeToString(cleanSvgTree);
			const reserializedExpected = serializer.serializeToString(expectedSvgTree);
			dist_default(reserializedClean).equals(reserializedExpected);
		});
		dist_default("svg without xss gets left alone", function() {
			const svgDocumentWithoutXSS = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<polygon stroke=\"#004400\" fill=\"#009900\" points=\"0,0 0,50 50,0\" id=\"script\"/>\n</svg>";
			const noxssDataFile = createDataFile("no-xss.svg", "image/svg+xml", stringToUtf8Uint8Array(svgDocumentWithoutXSS), "some-other-cid");
			const sanitizedDataFile = htmlSanitizer.sanitizeInlineAttachment(noxssDataFile);
			const parser = new DOMParser();
			const cleanSvgTree = parser.parseFromString(utf8Uint8ArrayToString(sanitizedDataFile.data), "image/svg+xml");
			dist_default(cleanSvgTree.getElementsByTagName("script").length).equals(0);
			const polys = cleanSvgTree.getElementsByTagName("polygon");
			dist_default(polys.length).equals(1);
			dist_default(polys[0].id).equals("script");
			dist_default(polys[0].getAttributeNames().sort()).deepEquals([
				"stroke",
				"fill",
				"points",
				"id"
			].sort());
			dist_default(polys[0].getAttribute("stroke")).equals("#004400");
			dist_default(polys[0].getAttribute("fill")).equals("#009900");
			dist_default(polys[0].getAttribute("points")).equals("0,0 0,50 50,0");
			const svgs = cleanSvgTree.getElementsByTagName("svg");
			dist_default(svgs.length).equals(1);
			dist_default(svgs[0].getAttributeNames().sort()).deepEquals(["version", "xmlns"]);
			dist_default(svgs[0].getAttribute("version")).equals("1.1");
			dist_default(svgs[0].getAttribute("xmlns")).equals("http://www.w3.org/2000/svg");
		});
		dist_default("invalid svg gets replaced with empty text", function() {
			const invalidSvg = "<svg/><?xml version=\"1.0\">";
			const utf16DataFile = createDataFile("no-xss.svg", "image/svg+xml", stringToUtf8Uint8Array(invalidSvg), "third-cid");
			const sanitizedDataFile = htmlSanitizer.sanitizeInlineAttachment(utf16DataFile);
			dist_default(sanitizedDataFile.data.length).equals(0);
		});
		dist_default("non-svg inline attachments get left alone", function() {
			const someData = Uint8Array.from([
				84,
				0,
				89,
				0,
				80,
				47,
				0,
				47,
				0,
				87
			]);
			const someDataFile = createDataFile("no-xss.svg", "image/png", someData, "third-cid");
			const sanitizedDataFile = htmlSanitizer.sanitizeInlineAttachment(someDataFile);
			dist_default(sanitizedDataFile.data).deepEquals(someData);
		});
	});
}));

//#endregion
//#region tests/mail/InboxRuleHandlerTest.ts
dist_default.spec("InboxRuleHandlerTest", function() {
	dist_default.spec("Test _matchesRegularExpression", function() {
		dist_default(" check invalid regular expressions", function() {
			dist_default(_matchesRegularExpression("", _createRule(""))).equals(false);
			dist_default(_matchesRegularExpression("1", _createRule("1"))).equals(false);
			dist_default(_matchesRegularExpression("$", _createRule("$"))).equals(false);
		});
		dist_default(" check regular expressions", function() {
			let regExRuleEmpty = _createRule("//");
			dist_default(_matchesRegularExpression("", regExRuleEmpty)).equals(true);
			dist_default(_matchesRegularExpression(" ", regExRuleEmpty)).equals(true);
			let regExRule123 = _createRule("/123/");
			dist_default(_matchesRegularExpression("123", regExRule123)).equals(true);
			dist_default(_matchesRegularExpression("01234", regExRule123)).equals(true);
			dist_default(_matchesRegularExpression("0124", regExRule123)).equals(false);
			let regExRuleCharacterClass = _createRule("/[1]+/");
			dist_default(_matchesRegularExpression("1", regExRuleCharacterClass)).equals(true);
			dist_default(_matchesRegularExpression("1111111", regExRuleCharacterClass)).equals(true);
			dist_default(_matchesRegularExpression("1211111", regExRuleCharacterClass)).equals(true);
			dist_default(_matchesRegularExpression("22", regExRuleCharacterClass)).equals(false);
			let regExRuleEscaped = _createRule("/\\[1\\]/");
			dist_default(_matchesRegularExpression("[1]", regExRuleEscaped)).equals(true);
			dist_default(_matchesRegularExpression("[1", regExRuleEscaped)).equals(false);
		});
		dist_default("check case insensitivity", function() {
			let regExRuleLowerCase = _createRule("/hey/");
			dist_default(_matchesRegularExpression("hey", regExRuleLowerCase)).equals(true);
			dist_default(_matchesRegularExpression("HEY", regExRuleLowerCase)).equals(false);
			let regExRuleUpperCase = _createRule("/HEY/");
			dist_default(_matchesRegularExpression("hey", regExRuleUpperCase)).equals(false);
			dist_default(_matchesRegularExpression("HEY", regExRuleUpperCase)).equals(true);
		});
		dist_default("check regular expression with flags", function() {
			let regExRuleWithFlagsLowerCase = _createRule("/hey/i");
			dist_default(_matchesRegularExpression("hey", regExRuleWithFlagsLowerCase)).equals(true);
			dist_default(_matchesRegularExpression("HEY", regExRuleWithFlagsLowerCase)).equals(true);
			dist_default(_matchesRegularExpression("hEy", regExRuleWithFlagsLowerCase)).equals(true);
			let regExRuleWithFlagsUpperCase = _createRule("/HEY/i");
			dist_default(_matchesRegularExpression("hey", regExRuleWithFlagsUpperCase)).equals(true);
			dist_default(_matchesRegularExpression("HEY", regExRuleWithFlagsUpperCase)).equals(true);
		});
	});
	dist_default.spec("Test _findMatchingRule", function() {
		const restClient = new EntityRestClientMock();
		const entityClient$1 = new EntityClient(restClient);
		dist_default("check FROM_EQUALS is applied to from", async function() {
			const rules = [_createRule("sender@tuta.com", InboxRuleType.FROM_EQUALS, ["ruleTarget", "ruleTarget"])];
			const mail = _createMailWithDifferentEnvelopeSender();
			const rule = await _findMatchingRule(this.mailFacade, mail, rules);
			dist_default(rule).notEquals(null);
			if (rule) dist_default(_equalTupels(rule.targetFolder, ["ruleTarget", "ruleTarget"])).equals(true);
		});
		dist_default("check FROM_EQUALS is applied to envelope  sender", async function() {
			const rules = [_createRule("differentenvelopsender@something.com", InboxRuleType.FROM_EQUALS, ["ruleTarget", "ruleTarget"])];
			const mail = _createMailWithDifferentEnvelopeSender();
			const rule = await _findMatchingRule(this.mailFacade, mail, rules);
			dist_default(rule).notEquals(null);
			if (rule) dist_default(_equalTupels(rule.targetFolder, ["ruleTarget", "ruleTarget"])).equals(true);
		});
	});
});
function _createMailWithDifferentEnvelopeSender() {
	let mail = createTestEntity(MailTypeRef);
	let sender = createTestEntity(MailAddressTypeRef);
	sender.address = "sender@tuta.com";
	mail.sender = sender;
	mail.differentEnvelopeSender = "differentenvelopsender@something.com";
	return mail;
}
function _createRule(value, type, targetFolder) {
	let rule = createTestEntity(InboxRuleTypeRef);
	rule.value = value;
	rule.type = type ? type : InboxRuleType.SUBJECT_CONTAINS;
	rule.targetFolder = targetFolder ? targetFolder : ["empty", "empty"];
	return rule;
}
function _equalTupels(t1, t2) {
	if (t1.length === 2 && t2.length == 2) {
		if (t1[0] !== t2[0] || t1[1] !== t2[1]) return false;
		return true;
	}
	return false;
}

//#endregion
//#region tests/mail/MailUtilsSignatureTest.ts
const TEST_DEFAULT_SIGNATURE = "--\nDefault signature";
dist_default.spec("MailUtilsSignatureTest", function() {
	const mockedAttributes = [];
	dist_default.before(function() {
		mockedAttributes.push(mockAttribute(lang, lang.get, function(key, obj) {
			if (key === "defaultEmailSignature_msg") return TEST_DEFAULT_SIGNATURE;
			throw new Error("unexpected translation key: " + key);
		}));
		mockedAttributes.push(mockAttribute(htmlSanitizer, htmlSanitizer.sanitizeHTML, function(text) {
			return {
				html: text,
				externalContent: [],
				inlineImageCids: [],
				links: []
			};
		}));
	});
	dist_default.after(function() {
		for (const mockedAttribute of mockedAttributes) unmockAttribute(mockedAttribute);
	});
	dist_default("append - no signature", function() {
		const properties = downcast({
			emailSignatureType: EmailSignatureType.EMAIL_SIGNATURE_TYPE_NONE,
			customEmailSignature: ""
		});
		dist_default(appendEmailSignature("", properties)).equals("");
		dist_default(appendEmailSignature("123", properties)).equals("123");
	});
	dist_default("append - default signature", function() {
		const properties = downcast({
			emailSignatureType: EmailSignatureType.EMAIL_SIGNATURE_TYPE_DEFAULT,
			customEmailSignature: "abc"
		});
		dist_default(appendEmailSignature("", properties)).equals(LINE_BREAK + LINE_BREAK + TEST_DEFAULT_SIGNATURE);
		dist_default(appendEmailSignature("123", properties)).equals("123" + LINE_BREAK + LINE_BREAK + TEST_DEFAULT_SIGNATURE);
	});
	dist_default("append - custom signature", function() {
		const properties = downcast({
			emailSignatureType: EmailSignatureType.EMAIL_SIGNATURE_TYPE_CUSTOM,
			customEmailSignature: "abc"
		});
		dist_default(appendEmailSignature("", properties)).equals(LINE_BREAK + "abc");
		dist_default(appendEmailSignature("123", properties)).equals("123" + LINE_BREAK + "abc");
	});
	dist_default("prepend - no signature", function() {
		const loginController = createLoginController(EmailSignatureType.EMAIL_SIGNATURE_TYPE_NONE, "abc", true);
		dist_default(prependEmailSignature("", loginController)).equals("");
		dist_default(prependEmailSignature("123", loginController)).equals(LINE_BREAK + LINE_BREAK + LINE_BREAK + "123");
	});
	dist_default("prepend - default signature", function() {
		const loginController = createLoginController(EmailSignatureType.EMAIL_SIGNATURE_TYPE_DEFAULT, "abc", true);
		dist_default(prependEmailSignature("", loginController)).equals(LINE_BREAK + LINE_BREAK + TEST_DEFAULT_SIGNATURE);
		dist_default(prependEmailSignature("123", loginController)).equals(LINE_BREAK + LINE_BREAK + TEST_DEFAULT_SIGNATURE + LINE_BREAK + LINE_BREAK + LINE_BREAK + "123");
	});
	dist_default("prepend - default signature - do not add signature for external user", function() {
		const loginController = createLoginController(EmailSignatureType.EMAIL_SIGNATURE_TYPE_DEFAULT, "abc", false);
		dist_default(prependEmailSignature("", loginController)).equals("");
		dist_default(prependEmailSignature("123", loginController)).equals(LINE_BREAK + LINE_BREAK + LINE_BREAK + "123");
	});
	dist_default("prepend - custom signature", function() {
		const loginController = createLoginController(EmailSignatureType.EMAIL_SIGNATURE_TYPE_CUSTOM, "abc", true);
		dist_default(prependEmailSignature("", loginController)).equals(LINE_BREAK + "abc");
		dist_default(prependEmailSignature("123", loginController)).equals(LINE_BREAK + "abc" + LINE_BREAK + LINE_BREAK + LINE_BREAK + "123");
	});
	dist_default("prepend - custom signature - do not add signature for external user", function() {
		const loginController = createLoginController(EmailSignatureType.EMAIL_SIGNATURE_TYPE_CUSTOM, "abc", false);
		dist_default(prependEmailSignature("", loginController)).equals("");
		dist_default(prependEmailSignature("123", loginController)).equals(LINE_BREAK + LINE_BREAK + LINE_BREAK + "123");
	});
});
function createLoginController(signatureType, signature, internalUser) {
	const properties = downcast({
		emailSignatureType: signatureType,
		customEmailSignature: signature
	});
	const loginController = downcast({ getUserController() {
		return {
			isInternalUser: () => internalUser,
			props: properties
		};
	} });
	return loginController;
}

//#endregion
//#region tests/api/common/mail/CommonMailUtilsTest.ts
dist_default.spec("MailUtilsTest", function() {
	function createSystemMail(overrides = {}) {
		return createTestEntity(MailTypeRef, {
			...{
				sender: createTestEntity(MailAddressTypeRef, {
					address: "system@tutanota.de",
					name: "System"
				}),
				replyTos: [],
				state: MailState.RECEIVED,
				authStatus: null,
				_errors: {},
				_id: ["", ""],
				_ownerEncSessionKey: null,
				_ownerGroup: "",
				_permissions: "",
				attachments: [],
				bccRecipients: [],
				body: null,
				bucketKey: null,
				ccRecipients: [],
				confidential: true,
				conversationEntry: ["", ""],
				differentEnvelopeSender: null,
				encryptionAuthStatus: null,
				firstRecipient: null,
				headers: null,
				listUnsubscribe: false,
				mailDetails: null,
				mailDetailsDraft: null,
				method: "",
				movedTime: null,
				phishingStatus: "",
				receivedDate: new Date(),
				recipientCount: "",
				replyType: "",
				subject: "",
				toRecipients: [],
				unread: false
			},
			...overrides
		});
	}
	const tutanotaSender = () => createMailAddress({
		address: "sender@tutanota.de",
		name: "Tutanota sender",
		contact: null
	});
	const tutaoSender = () => createMailAddress({
		address: "sender@tutao.de",
		name: "Tutao sender",
		contact: null
	});
	const tutanotaNoReplySender = () => createMailAddress({
		address: "no-reply@tutanota.de",
		name: "Tutanota no-reply",
		contact: null
	});
	const tutaoNoReplySender = () => createMailAddress({
		address: "no-reply@tutao.de",
		name: "Tutao no-reply",
		contact: null
	});
	dist_default("getDisplayedSender", function() {
		const mail = createSystemMail();
		dist_default(getDisplayedSender(mail)).deepEquals({
			address: "system@tutanota.de",
			name: "System"
		});
	});
	dist_default("isTutanotaTeamAddress", function() {
		dist_default(isTutanotaTeamAddress("system@tutanota.de")).deepEquals(false);
		dist_default(isTutanotaTeamAddress("bed-free@tutanota.de")).deepEquals(false);
		dist_default(isTutanotaTeamAddress("admin@somesite.com")).deepEquals(false);
		dist_default(isTutanotaTeamAddress("no-reply@tutao.de")).deepEquals(true);
		dist_default(isTutanotaTeamAddress("sales@tutao.de")).deepEquals(true);
		dist_default(isTutanotaTeamAddress("no-reply@tutanota.de")).deepEquals(true);
	});
	dist_default("getConfidentialIcon", function() {
		const mail = createTestEntity(MailTypeRef, {
			confidential: true,
			encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED
		});
		dist_default(getConfidentialIcon(mail)).equals(Icons.PQLock);
		mail.encryptionAuthStatus = EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED;
		dist_default(getConfidentialIcon(mail)).equals(Icons.PQLock);
		mail.encryptionAuthStatus = EncryptionAuthStatus.AES_NO_AUTHENTICATION;
		dist_default(getConfidentialIcon(mail)).equals(Icons.Lock);
		mail.encryptionAuthStatus = null;
		dist_default(getConfidentialIcon(mail)).equals(Icons.Lock);
		mail.encryptionAuthStatus = EncryptionAuthStatus.RSA_NO_AUTHENTICATION;
		dist_default(getConfidentialIcon(mail)).equals(Icons.Lock);
		mail.encryptionAuthStatus = EncryptionAuthStatus.TUTACRYPT_SENDER;
		dist_default(getConfidentialIcon(mail)).equals(Icons.PQLock);
		mail.confidential = false;
		dist_default(() => getConfidentialIcon(mail)).throws(ProgrammingError);
	});
	dist_default.spec("isTutanotaTeamMail", function() {
		dist_default("regular non-confidential email is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutanotaSender()
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("regular confidential email is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutanotaSender()
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("system email without auth is", function() {
			const mail = createSystemMail();
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default("system email failing PQ auth is not", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED });
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("system email with RSA (no) auth is", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.RSA_NO_AUTHENTICATION });
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default("system email with AES (no) auth is not", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.AES_NO_AUTHENTICATION });
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("confidential email from tutao without auth is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				encryptionAuthStatus: null
			});
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default("confidential email from tutao with PQ auth is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED
			});
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default("confidential email from tutao with failing PQ auth is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("confidential email from tutao with RSA (no) auth is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				encryptionAuthStatus: EncryptionAuthStatus.RSA_NO_AUTHENTICATION
			});
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default("confidential email from tutao with AES (no) auth is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				encryptionAuthStatus: EncryptionAuthStatus.AES_NO_AUTHENTICATION
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("confidential email from no-reply is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutanotaNoReplySender()
			});
			dist_default(isTutanotaTeamMail(mail)).equals(true);
		});
		dist_default(`non-confidential "system" email is not`, function() {
			const mail = createMail({
				...createSystemMail(),
				confidential: false
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("non-confidential email from tutao is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutaoSender()
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
		dist_default("non confidential email from no-reply is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutanotaNoReplySender()
			});
			dist_default(isTutanotaTeamMail(mail)).equals(false);
		});
	});
	dist_default.spec("isSystemNotification", function() {
		dist_default("regular non-confidential email is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutanotaSender()
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("regular confidential email is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutanotaSender()
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("system email without auth is", function() {
			const mail = createSystemMail();
			dist_default(isSystemNotification(mail)).equals(true);
		});
		dist_default("system email with PQ auth is", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED });
			dist_default(isSystemNotification(mail)).equals(true);
		});
		dist_default("system email with failing PQ auth is not", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_FAILED });
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("system email with RSA (no) auth is", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.RSA_NO_AUTHENTICATION });
			dist_default(isSystemNotification(mail)).equals(true);
		});
		dist_default("system email with AES (no) auth is not", function() {
			const mail = createSystemMail({ encryptionAuthStatus: EncryptionAuthStatus.AES_NO_AUTHENTICATION });
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("confidential email from tutao is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				authStatus: null
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("confidential email from tutao with PQ auth is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoSender(),
				authStatus: EncryptionAuthStatus.TUTACRYPT_AUTHENTICATION_SUCCEEDED
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("confidential email from tutanota no-reply is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutanotaNoReplySender()
			});
			dist_default(isSystemNotification(mail)).equals(true);
		});
		dist_default("confidential email from tutao no-reply is", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: true,
				state: MailState.RECEIVED,
				sender: tutaoNoReplySender()
			});
			dist_default(isSystemNotification(mail)).equals(true);
		});
		dist_default(`non-confidential "system" email is not`, function() {
			const mail = createMail({
				...createSystemMail(),
				confidential: false
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("non-confidential email from tutao is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutaoSender()
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
		dist_default("non confidential email from no-reply is not", function() {
			const mail = createTestEntity(MailTypeRef, {
				confidential: false,
				state: MailState.RECEIVED,
				sender: tutanotaNoReplySender()
			});
			dist_default(isSystemNotification(mail)).equals(false);
		});
	});
});

//#endregion
//#region tests/mail/MailModelTest.ts
var import_testdouble$39 = __toESM(require_testdouble(), 1);
dist_default.spec("MailModelTest", function() {
	let notifications;
	let showSpy;
	let model;
	const inboxFolder = createTestEntity(MailFolderTypeRef, {
		_id: ["folderListId", "inboxId"],
		isMailSet: false
	});
	inboxFolder.mails = "instanceListId";
	inboxFolder.folderType = MailSetKind.INBOX;
	const anotherFolder = createTestEntity(MailFolderTypeRef, {
		_id: ["folderListId", "archiveId"],
		isMailSet: false
	});
	anotherFolder.mails = "anotherListId";
	anotherFolder.folderType = MailSetKind.ARCHIVE;
	let mailboxDetails;
	let logins;
	let inboxRuleHandler;
	const restClient = new EntityRestClientMock();
	dist_default.beforeEach(function() {
		notifications = {};
		const mailboxModel = (0, import_testdouble$39.instance)(MailboxModel);
		const eventController = (0, import_testdouble$39.instance)(EventController);
		const mailFacade = (0, import_testdouble$39.instance)(MailFacade);
		showSpy = notifications.showNotification = spy();
		logins = (0, import_testdouble$39.object)();
		let userController = (0, import_testdouble$39.object)();
		(0, import_testdouble$39.when)(userController.isUpdateForLoggedInUserInstance(import_testdouble$39.matchers.anything(), import_testdouble$39.matchers.anything())).thenReturn(false);
		(0, import_testdouble$39.when)(logins.getUserController()).thenReturn(userController);
		inboxRuleHandler = (0, import_testdouble$39.object)();
		model = new MailModel(downcast({}), mailboxModel, eventController, new EntityClient(restClient), logins, mailFacade, null, null);
	});
	dist_default("doesn't send notification for another folder", async function() {
		const mail = createTestEntity(MailTypeRef, {
			_id: [anotherFolder.mails, "mailId"],
			sets: []
		});
		restClient.addListInstances(mail);
		await model.entityEventsReceived([makeUpdate({
			instanceListId: getListId(mail),
			instanceId: getElementId(mail),
			operation: OperationType.CREATE
		})]);
		dist_default(showSpy.invocations.length).equals(0);
	});
	dist_default("doesn't send notification for move operation", async function() {
		const mail = createTestEntity(MailTypeRef, {
			_id: [inboxFolder.mails, "mailId"],
			sets: []
		});
		restClient.addListInstances(mail);
		await model.entityEventsReceived([makeUpdate({
			instanceListId: getListId(mail),
			instanceId: getElementId(mail),
			operation: OperationType.DELETE
		}), makeUpdate({
			instanceListId: getListId(mail),
			instanceId: getElementId(mail),
			operation: OperationType.CREATE
		})]);
		dist_default(showSpy.invocations.length).equals(0);
	});
	function makeUpdate(arg) {
		return Object.assign({}, {
			type: MailTypeRef.type,
			application: MailTypeRef.app,
			instanceId: "instanceId"
		}, arg);
	}
});

//#endregion
//#region tests/contacts/ContactUtilsTest.ts
dist_default.spec("ContactUtilsTest", function() {
	let compare = function(c1Firstname, c1Lastname, c1MailAddress, c2Firstname, c2Lastname, c2MailAddress, byFirstName, expectedResult) {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1._id = ["a", "1"];
		c2._id = ["a", "2"];
		c1.firstName = c1Firstname;
		c2.firstName = c2Firstname;
		c1.lastName = c1Lastname;
		c2.lastName = c2Lastname;
		if (c1MailAddress) {
			let m = createTestEntity(ContactMailAddressTypeRef);
			m.address = c1MailAddress;
			c1.mailAddresses.push(m);
		}
		if (c2MailAddress) {
			let m = createTestEntity(ContactMailAddressTypeRef);
			m.address = c2MailAddress;
			c2.mailAddresses.push(m);
		}
		let result = compareContacts(c1, c2, byFirstName);
		if (result != expectedResult) console.log("error >>>>>>>", "'" + c1Firstname + "'", "'" + c1Lastname + "'", c1MailAddress, "'" + c2Firstname + "'", "'" + c2Lastname + "'", c2MailAddress, "expected:", expectedResult, "result", result);
		dist_default(result).equals(expectedResult);
	};
	dist_default("compareContacts by first name", function() {
		compare("Alf", "", null, "", "", null, true, -1);
		compare("Alf", "", null, "Bob", "", null, true, -1);
		compare("", "", null, "Bob", "", null, true, 1);
		compare("Bob", "", null, "Alf", "", null, true, 1);
		compare("", "Alf", null, "", "", null, true, -1);
		compare("", "Alf", null, "", "Bob", null, true, -1);
		compare("", "", null, "", "Bob", null, true, 1);
		compare("", "Bob", null, "", "Alf", null, true, 1);
		compare("", "", "Alf", "", "", null, true, -1);
		compare("", "", "Alf", "", "", "Bob", true, -1);
		compare("", "", null, "", "", "Bob", true, 1);
		compare("", "", "Bob", "", "", "Alf", true, 1);
		compare("", "Alf", null, "Alf", "Bob", null, true, 1);
		compare("Alf", "Bob", null, "Bob", "Alf", null, true, -1);
		compare("Alf", "Bob", null, "", "Bob", null, true, -1);
		compare("Alf", "", null, "Alf", "Bob", null, true, 1);
		compare("", "Bob", null, "", "", "Alf", true, -1);
		compare("Bob", "", null, "", "", "Alf", true, -1);
		compare("Alf", "Bob", "Bob", "Alf", "Bob", "Alf", true, 1);
		compare("Alf", "Bob", null, "", "", "Alf", true, -1);
		compare("", "", null, "", "", null, true, 1);
		compare("Alf", "Bob", "Bob", "Alf", "Bob", "Bob", true, 1);
		compare("ma", "p", "aa", "Gump", "Forrest", "aa", true, 1);
	});
	dist_default("compareContacts by last name", function() {
		compare("Alf", "", null, "", "", null, false, -1);
		compare("Alf", "", null, "Bob", "", null, false, -1);
		compare("", "", null, "Bob", "", null, false, 1);
		compare("Bob", "", null, "Alf", "", null, false, 1);
		compare("", "Alf", null, "", "", null, false, -1);
		compare("", "Alf", null, "", "Bob", null, false, -1);
		compare("", "", null, "", "Bob", null, false, 1);
		compare("", "Bob", null, "", "Alf", null, false, 1);
		compare("", "", "Alf", "", "", null, false, -1);
		compare("", "", "Alf", "", "", "Bob", false, -1);
		compare("", "", null, "", "", "Bob", false, 1);
		compare("", "", "Bob", "", "", "Alf", false, 1);
		compare("", "Alf", null, "Alf", "Bob", null, false, -1);
		compare("Alf", "Bob", null, "Bob", "Alf", null, false, 1);
		compare("Alf", "Bob", null, "", "Bob", null, false, -1);
		compare("Alf", "", null, "Alf", "Bob", null, false, 1);
		compare("", "Bob", null, "", "", "Alf", false, -1);
		compare("Bob", "", null, "", "", "Alf", false, -1);
		compare("Alf", "Bob", "Bob", "Alf", "Bob", "Alf", false, 1);
		compare("Alf", "Bob", null, "", "", "Alf", false, -1);
		compare("", "", null, "", "", null, false, 1);
		compare("Alf", "Bob", "Bob", "Alf", "Bob", "Bob", false, 1);
		compare("ma", "p", "aa", "Gump", "Forrest", "aa", false, 1);
	});
	dist_default("formatNewBirthdayTest", function() {
		lang.setLanguage({
			code: "en",
			languageTag: "en"
		});
		lang.updateFormats({});
		let bday = createTestEntity(BirthdayTypeRef);
		bday.day = "12";
		bday.month = "10";
		bday.year = "2009";
		dist_default(formatBirthdayNumeric(bday)).equals("10/12/2009");
		bday.day = "9";
		bday.month = "07";
		bday.year = null;
		dist_default(formatBirthdayNumeric(bday)).equals("7/9");
		bday.day = "09";
		bday.month = "7";
		bday.year = null;
		dist_default(formatBirthdayNumeric(bday)).equals("7/9");
		bday = createTestEntity(BirthdayTypeRef);
		bday.day = "12";
		bday.month = "10";
		bday.year = "2009";
	});
	dist_default("formatBirthdayNumeric", function() {
		const leapYearBirthday = createTestEntity(BirthdayTypeRef);
		leapYearBirthday.year = "2016";
		leapYearBirthday.month = "2";
		leapYearBirthday.day = "29";
		const leapYearBirthdayNoYear = createTestEntity(BirthdayTypeRef);
		leapYearBirthdayNoYear.month = "2";
		leapYearBirthdayNoYear.day = "29";
		const chromeBugBirthday = createTestEntity(BirthdayTypeRef);
		chromeBugBirthday.year = "1911";
		chromeBugBirthday.month = "8";
		chromeBugBirthday.day = "15";
		lang._setLanguageTag("en");
		dist_default(formatBirthdayNumeric(leapYearBirthday)).equals("2/29/2016");
		dist_default(formatBirthdayNumeric(leapYearBirthdayNoYear)).equals("2/29");
		dist_default(formatBirthdayNumeric(chromeBugBirthday)).equals("8/15/1911");
		lang._setLanguageTag("de");
		dist_default(formatBirthdayNumeric(leapYearBirthday)).equals("29.2.2016");
		dist_default(formatBirthdayNumeric(chromeBugBirthday)).equals("15.8.1911");
		lang._setLanguageTag("ja");
		dist_default(formatBirthdayNumeric(leapYearBirthday)).equals("2016/2/29");
		dist_default(formatBirthdayNumeric(chromeBugBirthday)).equals("1911/8/15");
		lang._setLanguageTag("pt");
		dist_default(formatBirthdayNumeric(leapYearBirthday)).equals("29/02/2016");
		dist_default(formatBirthdayNumeric(chromeBugBirthday)).equals("15/08/1911");
	});
	dist_default("extractStructuredEmailAddress", function() {
		const contact = createTestEntity(ContactTypeRef);
		contact.mailAddresses.push(createTestEntity(ContactMailAddressTypeRef));
		contact.mailAddresses.push(createTestEntity(ContactMailAddressTypeRef));
		dist_default(extractStructuredMailAddresses(contact.mailAddresses)).deepEquals(contact.mailAddresses.map((address) => ({
			address: address.address,
			type: address.type,
			customTypeName: address.customTypeName
		})));
	});
	dist_default("extractStructuredAddress", function() {
		const contact = createTestEntity(ContactTypeRef);
		contact.addresses.push(createTestEntity(ContactAddressTypeRef));
		contact.addresses.push(createTestEntity(ContactAddressTypeRef));
		dist_default(extractStructuredAddresses(contact.addresses)).deepEquals(contact.addresses.map((address) => ({
			address: address.address,
			type: address.type,
			customTypeName: address.customTypeName
		})));
	});
	dist_default("extractStructuredPhoneNumber", function() {
		const contact = createTestEntity(ContactTypeRef);
		contact.phoneNumbers.push(createTestEntity(ContactPhoneNumberTypeRef));
		contact.phoneNumbers.push(createTestEntity(ContactPhoneNumberTypeRef));
		dist_default(extractStructuredPhoneNumbers(contact.phoneNumbers)).deepEquals(contact.phoneNumbers.map((phone) => ({
			number: phone.number,
			type: phone.type,
			customTypeName: phone.customTypeName
		})));
	});
});

//#endregion
//#region tests/contacts/ContactMergeUtilsTest.ts
dist_default.spec("ContactMergeUtilsTest", function() {
	dist_default("GetMergableContactsTest", function() {
		let c1 = createEmailPhoneContact("A", "B", ["a@b.de"]);
		let c2 = createEmailPhoneContact("A", "B", ["a@b.de"]);
		let c3 = createEmailPhoneContact("A", "B", ["c@b.de"]);
		let c4 = createEmailPhoneContact("A", "B", ["c@b.de"]);
		let c5 = createEmailPhoneContact("A", "B", ["d@b.de"]);
		let c6 = createEmailPhoneContact("c", "c", ["ADC@b.de"]);
		let c7 = createEmailPhoneContact("c", "c", ["BDC@b.de"]);
		let c8 = createEmailPhoneContact("c", "c", ["CDC@b.de"]);
		let c9 = createEmailPhoneContact("a", "", ["hello@hello.de"], ["123456"]);
		let c10 = createEmailPhoneContact("a", "", ["hello@hello.de"], ["789456123"]);
		c10 = addFilledContactOtherFields(c10, "", "", "Mr.", "");
		let c11 = createEmailPhoneContact("", "", ["hello@hello.de"], ["258258"]);
		let c12 = createEmailPhoneContact("b", "b", ["tuta@hello.de"], ["654321"]);
		let c13 = createEmailPhoneContact("b", "b", ["bnt@bnt.com"], ["147852369"]);
		c13 = addFilledContactOtherFields(c13, "", "tuta", "Mr.Dr.", "");
		let c14 = createEmailPhoneContact("b", "b", [], ["1231231258258"]);
		let c15 = createEmailPhoneContact("a", "", ["hello@hello.de"], [
			"123456",
			"789456123",
			"258258"
		]);
		c15 = addFilledContactOtherFields(c15, "", "", "Mr.", "");
		let c16 = createEmailPhoneContact("b", "b", ["tuta@hello.de", "bnt@bnt.com"], [
			"654321",
			"147852369",
			"1231231258258"
		]);
		c16 = addFilledContactOtherFields(c16, "", "tuta", "Mr.Dr.", "");
		dist_default(JSON.stringify(getMergeableContacts([
			c1,
			c2,
			c3
		]))).equals(JSON.stringify({
			mergeable: [[c1, c3]],
			deletable: [c2]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c1,
			c3,
			c2
		]))).equals(JSON.stringify({
			mergeable: [[c1, c3]],
			deletable: [c2]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c3,
			c1,
			c2
		]))).equals(JSON.stringify({
			mergeable: [[c3, c1]],
			deletable: [c2]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c3,
			c1,
			c2,
			c4
		]))).equals(JSON.stringify({
			mergeable: [[c3, c1]],
			deletable: [c2, c4]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c1,
			c2,
			c3,
			c4,
			c5
		]))).equals(JSON.stringify({
			mergeable: [[
				c1,
				c3,
				c5
			]],
			deletable: [c2, c4]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c1,
			c2,
			c3,
			c6,
			c7,
			c8
		]))).equals(JSON.stringify({
			mergeable: [[c1, c3], [
				c6,
				c7,
				c8
			]],
			deletable: [c2]
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c15,
			c16,
			c9,
			c10,
			c11,
			c12,
			c13,
			c14
		]))).equals(JSON.stringify({
			mergeable: [[
				c15,
				c9,
				c10,
				c11
			], [
				c16,
				c12,
				c13,
				c14
			]],
			deletable: []
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c15,
			c9,
			c10,
			c11,
			c12,
			c13,
			c14,
			c16
		]))).equals(JSON.stringify({
			mergeable: [[
				c15,
				c9,
				c10,
				c11
			], [
				c12,
				c13,
				c14,
				c16
			]],
			deletable: []
		}));
		dist_default(JSON.stringify(getMergeableContacts([
			c15,
			c16,
			c9,
			c10,
			c12,
			c13,
			c14,
			c11
		]))).equals(JSON.stringify({
			mergeable: [[
				c15,
				c9,
				c10,
				c11
			], [
				c16,
				c12,
				c13,
				c14
			]],
			deletable: []
		}));
		dist_default(getMergeableContacts([
			c10,
			c9,
			c15,
			c13,
			c11,
			c16,
			c12,
			c14
		]).mergeable[0].length).equals(4);
		dist_default(getMergeableContacts([
			c10,
			c9,
			c15,
			c13,
			c11,
			c16,
			c12,
			c14
		]).mergeable[1].length).equals(4);
	});
	function createEmailPhoneContact(firstName, lastName, emailAddresses, phoneNumbers) {
		return createFilledContact(firstName, lastName, "", "", "", "", "", "", "", emailAddresses, phoneNumbers);
	}
	dist_default("testCompareMailaddresses", function() {
		let c1 = createFilledContactMailAddresses([]);
		let c2 = createFilledContactMailAddresses([]);
		dist_default(_compareMailAddresses(c1, c2)).equals(IndifferentContactComparisonResult.BothEmpty);
		c1 = createFilledContactMailAddresses(["anton@mail.de"]);
		c2 = createFilledContactMailAddresses(["anton@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Equal);
		c1 = createFilledContactMailAddresses([" anton@mail.de"]);
		c2 = createFilledContactMailAddresses(["anton@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Equal);
		dist_default(_compareMailAddresses(c2, c1)).equals(ContactComparisonResult.Equal);
		c1 = createFilledContactMailAddresses(["TOM@mail.de"]);
		c2 = createFilledContactMailAddresses(["anton@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Unique);
		dist_default(_compareMailAddresses(c2, c1)).equals(ContactComparisonResult.Unique);
		c1 = createFilledContactMailAddresses(["TOM@mail.de", "anton@mail.de"]);
		c2 = createFilledContactMailAddresses(["anton@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareMailAddresses(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createFilledContactMailAddresses(["TOM@mail.de"]);
		c2 = createFilledContactMailAddresses(["tom@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareMailAddresses(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createFilledContactMailAddresses(["tom@mail.de", "tom@mail.de"]);
		c2 = createFilledContactMailAddresses(["tom@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareMailAddresses(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createFilledContactMailAddresses([]);
		c2 = createFilledContactMailAddresses(["tom@mail.de"]);
		dist_default(_compareMailAddresses(c1, c2)).equals(IndifferentContactComparisonResult.OneEmpty);
		dist_default(_compareMailAddresses(c2, c1)).equals(IndifferentContactComparisonResult.OneEmpty);
	});
	function createFilledContactMailAddresses(mailAddresses) {
		return mailAddresses.map((m) => {
			let a = createTestEntity(ContactMailAddressTypeRef);
			a.address = m;
			a.type = ContactAddressType.WORK;
			a.customTypeName = "";
			return a;
		});
	}
	dist_default("testCompareFullNames", function() {
		let c1 = createEmailPhoneContact("anton", "schmidt", null);
		let c2 = createEmailPhoneContact("bob", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Unique);
		dist_default(_compareFullName(c2, c1)).equals(ContactComparisonResult.Unique);
		c1 = createEmailPhoneContact("anton", "schmidt", null);
		c2 = createEmailPhoneContact("", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareFullName(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createEmailPhoneContact("", "schmidt", null);
		c2 = createEmailPhoneContact("", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Equal);
		c1 = createEmailPhoneContact("", "", null);
		c2 = createEmailPhoneContact("", "", null);
		dist_default(_compareFullName(c1, c2)).equals(IndifferentContactComparisonResult.BothEmpty);
		c1 = createEmailPhoneContact("", "", null);
		c2 = createEmailPhoneContact("a", "b", null);
		dist_default(_compareFullName(c1, c2)).equals(IndifferentContactComparisonResult.OneEmpty);
		dist_default(_compareFullName(c2, c1)).equals(IndifferentContactComparisonResult.OneEmpty);
		c1 = createEmailPhoneContact("anton", "schmidt", null);
		c2 = createEmailPhoneContact("anton", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Equal);
		c1 = createEmailPhoneContact("Anton", "Schmidt", null);
		c2 = createEmailPhoneContact("anton", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareFullName(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createEmailPhoneContact("anton", "schmidt", null);
		c2 = createEmailPhoneContact("Anton", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareFullName(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createEmailPhoneContact("", "Schmidt", null);
		c2 = createEmailPhoneContact("", "schmidt", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Similar);
		dist_default(_compareFullName(c2, c1)).equals(ContactComparisonResult.Similar);
		c1 = createEmailPhoneContact("anton", "", null);
		c2 = createEmailPhoneContact("anton", "", null);
		dist_default(_compareFullName(c1, c2)).equals(ContactComparisonResult.Equal);
	});
	dist_default("testComparePhonenumbers", function() {
		let c1 = createFilledContactPhoneNumbers([]);
		let c2 = createFilledContactPhoneNumbers([]);
		dist_default(_comparePhoneNumbers(c1, c2)).equals(IndifferentContactComparisonResult.BothEmpty);
		c1 = createFilledContactPhoneNumbers(["017999854654"]);
		c2 = createFilledContactPhoneNumbers(["017999854654"]);
		dist_default(_comparePhoneNumbers(c1, c2)).equals(ContactComparisonResult.Equal);
		c1 = createFilledContactPhoneNumbers(["017999854654"]);
		c2 = createFilledContactPhoneNumbers(["099999999999"]);
		dist_default(_comparePhoneNumbers(c1, c2)).equals(ContactComparisonResult.Unique);
		dist_default(_comparePhoneNumbers(c2, c1)).equals(ContactComparisonResult.Unique);
		c1 = createFilledContactPhoneNumbers(["017999854654"]);
		c2 = createFilledContactPhoneNumbers(["099999999999", "017999854654"]);
		dist_default(_comparePhoneNumbers(c2, c1)).equals(ContactComparisonResult.Similar);
		dist_default(_comparePhoneNumbers(c1, c2)).equals(ContactComparisonResult.Similar);
	});
	function createFilledContactPhoneNumbers(phoneNumbers) {
		return phoneNumbers.map((n) => {
			let a = createTestEntity(ContactPhoneNumberTypeRef);
			a.number = n;
			a.type = ContactAddressType.WORK;
			a.customTypeName = "";
			return a;
		});
	}
	dist_default("testCompareResidualContact", function() {
		let c1 = createFilledContactOtherFields("", "", "", "");
		let c2 = createFilledContactOtherFields("", "", "", "");
		dist_default(_areResidualContactFieldsEqual(c1, c2)).equals(true);
		c1 = createFilledContactOtherFields("", "Tutao GmbH", "", "");
		c2 = createFilledContactOtherFields("", "Tutao GmbH", "", "");
		dist_default(_areResidualContactFieldsEqual(c1, c2)).equals(true);
		c1 = createFilledContactOtherFields("Tutao GmbH", "", "", "");
		c2 = createFilledContactOtherFields("Hallo", "Tutao GmbH", "", "");
		dist_default(_areResidualContactFieldsEqual(c1, c2)).equals(false);
		c1 = createFilledContactOtherFields("Tutao GmbH", "Tutao GmbH", "", "");
		c2 = createFilledContactOtherFields("Hallo", "Tutao GmbH", "", "");
		dist_default(_areResidualContactFieldsEqual(c1, c2)).equals(false);
	});
	function createFilledContactOtherFields(comment, company, title, nickname) {
		return createFilledContact("", "", "", "", "", comment, company, title, nickname);
	}
	function addFilledContactOtherFields(c, comment, company, title, nickname, socialIds, addresses) {
		c.title = title;
		c.comment = comment;
		c.company = company;
		c.nickname = nickname;
		if (addresses) addresses.map((m) => {
			let a = createTestEntity(ContactAddressTypeRef);
			a.address = m;
			a.type = ContactAddressType.WORK;
			a.customTypeName = "";
			c.addresses.push(a);
		});
		if (socialIds) socialIds.map((m) => {
			let a = createTestEntity(ContactSocialIdTypeRef);
			a.socialId = m;
			a.type = ContactSocialType.TWITTER;
			a.customTypeName = "";
			c.socialIds.push(a);
		});
		return c;
	}
	dist_default.spec("testCompareContactsForMerge", function() {
		dist_default("contacts are equal 1", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de"], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("empty contacts", function() {
			const c1 = createEmailPhoneContact("", "", [], []);
			const c2 = createEmailPhoneContact("", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are equal - phone numer matches", function() {
			const c1 = createEmailPhoneContact("", "", [], ["123456"]);
			const c2 = createEmailPhoneContact("", "", [], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are equal - mail address matches", function() {
			const c1 = createEmailPhoneContact("", "", ["a@b.de"], []);
			const c2 = createEmailPhoneContact("", "", ["a@b.de"], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are equal 2", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", [], []);
			const c2 = createEmailPhoneContact("anton", "schmidt", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are similar - additional email addresses", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de"], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - case insensitive email addresses", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "TUTA@io.de"], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - name different", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", [], []);
			const c2 = createEmailPhoneContact("", "schmidt", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - different email addresses", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], []);
			const c2 = createEmailPhoneContact("anton", "schmidt", ["b@mail.de", "c@io.de"], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - different phone numbers ", function() {
			const c1 = createEmailPhoneContact("anton", "schmidt", [], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", [], ["1234567890"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - last name matches 1", function() {
			const c1 = createEmailPhoneContact("", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", [""], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - last name matches 2", function() {
			const c1 = createEmailPhoneContact("", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("", "schmidt", [""], [""]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - case insensitive name check", function() {
			const c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", [""], ["123"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - mail addess matches, name is empty", function() {
			const c1 = createEmailPhoneContact("", "", ["a@b.de"], []);
			const c2 = createEmailPhoneContact("a", "tom", ["a@b.de"], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - phone number matches, name and email empty", function() {
			const c1 = createEmailPhoneContact("", "", [], ["123456"]);
			const c2 = createEmailPhoneContact("a", "tom", [], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are unique - firstname matches", function() {
			const c1 = createEmailPhoneContact("anton", "Bob", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", ["b@mail.de", "c@io.de"], ["1234567890"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are unique - last name matches, first name is different but no email addresses", function() {
			const c1 = createEmailPhoneContact("bob", "schmidt", [], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "schmidt", [], ["123456"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are unique - mail address matches but last name is different", function() {
			const c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			const c2 = createEmailPhoneContact("anton", "tom", ["anton@mail.de"], ["1234567"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are unique - one contact is empty", function() {
			const c1 = createEmailPhoneContact("", "", [], []);
			const c2 = createEmailPhoneContact("a", "tom", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are equal - all is equal", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "1991-12-8");
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "1991-12-8");
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are equal - all is equal birthday without year", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "--12-8");
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "--12-8");
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are similar - birthday with and without year", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", ["ant@ant.de"], [], [], [], [], "--08-12");
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", ["ant@ant.de"], [], [], [], [], "1991-08-12");
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - on birthday without year", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "--08-12");
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], null);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar - one birthday with year", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], null);
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "--08-12");
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are unique - different birthdays", function() {
			const c1 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "1992-08-12");
			const c2 = createFilledContact("ant", "bent", "hello", "tuta", "Mr.", "Bob", "", "", "", [], [], [], [], [], "1991-09-13");
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are equal - other contact fields", function() {
			let c1 = createEmailPhoneContact("anton", "schmidt", [], []);
			let c2 = createEmailPhoneContact("anton", "schmidt", [], []);
			c1 = addFilledContactOtherFields(c1, "A", "B", "C", "D", ["E"], ["F"]);
			c2 = addFilledContactOtherFields(c2, "A", "B", "C", "D", ["E"], ["F"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Equal);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Equal);
		});
		dist_default("contacts are similar 1", function() {
			let c1 = createEmailPhoneContact("anton", "schmidt", [], []);
			let c2 = createEmailPhoneContact("anton", "schmidt", [], []);
			c1 = addFilledContactOtherFields(c1, "", "", "", "A", [], []);
			c2 = addFilledContactOtherFields(c2, "", "", "b", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 2", function() {
			let c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("", "schmidt", ["anton@mail.de", "TUTA@io.de"], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "b", "A", [], []);
			c2 = addFilledContactOtherFields(c2, "A", "A", "b", "A", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 3", function() {
			let c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", ["b@mail.de", "c@io.de"], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "", "", "", "A", ["Facebook sucks in privacy", "Google also does"], [
				"Address 123",
				"Berlin 1234",
				"Hannover"
			]);
			c2 = addFilledContactOtherFields(c2, "", "", "b", "", [], ["Hannover"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 4", function() {
			let c1 = createEmailPhoneContact("anton", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", ["b@mail.de", "c@io.de"], ["1234567890"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			c2 = addFilledContactOtherFields(c2, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 5", function() {
			let c1 = createEmailPhoneContact("anton", "Bob", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", ["b@mail.de", "c@io.de"], ["1234567890"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			c2 = addFilledContactOtherFields(c2, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 6", function() {
			let c1 = createEmailPhoneContact("bob", "schmidt", [""], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", [""], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			c2 = addFilledContactOtherFields(c2, "", "", "", "", [
				"",
				"",
				""
			], [
				"",
				"",
				""
			]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 7", function() {
			let c1 = createEmailPhoneContact("", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", [""], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			c2 = addFilledContactOtherFields(c2, "b", "c", "d", "e", [
				"f",
				"g",
				"h"
			], [
				"q",
				"w",
				"j"
			]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 8", function() {
			let c1 = createEmailPhoneContact("", "schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("", "schmidt", [""], [""]);
			c1 = addFilledContactOtherFields(c1, "", "", "", "", [
				"A",
				"B",
				"C"
			], [
				"A",
				"B",
				"C"
			]);
			c2 = addFilledContactOtherFields(c2, "", "", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 9", function() {
			let c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "schmidt", [""], ["123"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", ["A"], ["A"]);
			c2 = addFilledContactOtherFields(c2, "A", "A", "A", "A", ["A"], ["A"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 10", function() {
			let c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "tom", [""], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", ["A"], ["A"]);
			c2 = addFilledContactOtherFields(c2, "A", "A", "A", "A", ["A"], ["A"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 11", function() {
			let c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "tom", [""], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "A", "A", "A", ["A"], ["A"]);
			c2 = addFilledContactOtherFields(c2, "A", "A", "A", "A", ["A"], ["B"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 12", function() {
			let c1 = createEmailPhoneContact("Anton", "Schmidt", ["anton@mail.de", "tuta@io.de"], ["123456"]);
			let c2 = createEmailPhoneContact("anton", "tom", ["anton@mail.de"], ["1234567"]);
			c1 = addFilledContactOtherFields(c1, "", "", "", "", [], []);
			c2 = addFilledContactOtherFields(c2, "", "", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 13", function() {
			let c1 = createEmailPhoneContact("", "", [], []);
			let c2 = createEmailPhoneContact("a", "tom", [], []);
			c1 = addFilledContactOtherFields(c1, "", "", "", "", [], []);
			c2 = addFilledContactOtherFields(c2, "", "", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Unique);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Unique);
		});
		dist_default("contacts are similar 14", function() {
			let c1 = createEmailPhoneContact("", "", ["a@b.de"], []);
			let c2 = createEmailPhoneContact("a", "tom", ["a@b.de"], []);
			c1 = addFilledContactOtherFields(c1, "A", "", "", "", [], []);
			c2 = addFilledContactOtherFields(c2, "A", "B", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 15", function() {
			let c1 = createEmailPhoneContact("", "", [], ["123456"]);
			let c2 = createEmailPhoneContact("a", "tom", [], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "", "", "", "", ["Diaspora my be better than Facebook"], ["Hannover"]);
			c2 = addFilledContactOtherFields(c2, "", "", "", "", [], ["Hannover"]);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 16", function() {
			let c1 = createEmailPhoneContact("", "", [], ["123456"]);
			let c2 = createEmailPhoneContact("", "", [], ["123456"]);
			c1 = addFilledContactOtherFields(c1, "A", "", "", "", [], []);
			c2 = addFilledContactOtherFields(c2, "A", "B", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
		dist_default("contacts are similar 17", function() {
			let c1 = createEmailPhoneContact("", "", ["a@b.de"], []);
			let c2 = createEmailPhoneContact("", "", ["a@b.de"], []);
			c1 = addFilledContactOtherFields(c1, "A", "", "", "", [], []);
			c2 = addFilledContactOtherFields(c2, "A", "B", "", "", [], []);
			dist_default(_compareContactsForMerge(c1, c2)).equals(ContactComparisonResult.Similar);
			dist_default(_compareContactsForMerge(c2, c1)).equals(ContactComparisonResult.Similar);
		});
	});
	dist_default("testCompareContactsWithPresharedPasswordForMerge", function() {
		let allContacts = [];
		allContacts[0] = createTestEntity(ContactTypeRef);
		allContacts[1] = createTestEntity(ContactTypeRef);
		allContacts[0].mailAddresses[0] = createTestEntity(ContactMailAddressTypeRef);
		allContacts[1].mailAddresses[0] = createTestEntity(ContactMailAddressTypeRef);
		allContacts[0].phoneNumbers[0] = createTestEntity(ContactPhoneNumberTypeRef);
		allContacts[1].phoneNumbers[0] = createTestEntity(ContactPhoneNumberTypeRef);
		allContacts[0].phoneNumbers[0].number = "017999854654";
		allContacts[1].phoneNumbers[0].number = "017999854654";
		allContacts[0].mailAddresses[0].address = "anton@mail.de";
		allContacts[1].mailAddresses[0].address = "anton@mail.de";
		allContacts[0].comment = "A";
		allContacts[1].comment = "A";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
		allContacts[1].presharedPassword = "B";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Similar);
		allContacts[0].presharedPassword = "A";
		allContacts[1].presharedPassword = null;
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Similar);
		allContacts[1].presharedPassword = "B";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Unique);
		allContacts[0] = createTestEntity(ContactTypeRef);
		allContacts[1] = createTestEntity(ContactTypeRef);
		allContacts[1].presharedPassword = "B";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Unique);
		allContacts[0].presharedPassword = "B";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
	});
	dist_default("testContactTypeValuesForUnimportance", function() {
		let allContacts = [];
		allContacts[0] = createTestEntity(ContactTypeRef);
		allContacts[1] = createTestEntity(ContactTypeRef);
		allContacts[0].mailAddresses[0] = createTestEntity(ContactMailAddressTypeRef);
		allContacts[1].mailAddresses[0] = createTestEntity(ContactMailAddressTypeRef);
		allContacts[0].phoneNumbers[0] = createTestEntity(ContactPhoneNumberTypeRef);
		allContacts[1].phoneNumbers[0] = createTestEntity(ContactPhoneNumberTypeRef);
		allContacts[0].phoneNumbers[0].number = "017999854654";
		allContacts[1].phoneNumbers[0].number = "017999854654";
		allContacts[0].mailAddresses[0].address = "anton@mail.de";
		allContacts[1].mailAddresses[0].address = "anton@mail.de";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
		allContacts[0].mailAddresses[0].type = "0";
		allContacts[1].mailAddresses[0].type = "1";
		allContacts[0].phoneNumbers[0].type = "1";
		allContacts[1].phoneNumbers[0].type = "0";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
		allContacts[0].mailAddresses[0].type = "1";
		allContacts[1].mailAddresses[0].type = "1";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
		allContacts[1].mailAddresses[0].customTypeName = "FUN";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
		allContacts[0].phoneNumbers[0].type = "1";
		allContacts[1].phoneNumbers[0].type = "1";
		dist_default(_compareContactsForMerge(allContacts[0], allContacts[1])).equals(ContactComparisonResult.Equal);
	});
	dist_default("getMergedBirthdaysTest", function() {
		_testMerge(_createBirthdayContact("2000-01-01"), _createBirthdayContact("2000-01-02"), _createBirthdayContact("2000-01-01"));
		_testMerge(_createBirthdayContact(null), _createBirthdayContact("2000-01-02"), _createBirthdayContact("2000-01-02"));
		_testMerge(_createBirthdayContact("2000-01-01"), _createBirthdayContact(null), _createBirthdayContact("2000-01-01"));
		_testMerge(_createBirthdayContact(null), _createBirthdayContact("--01-02"), _createBirthdayContact("--01-02"));
		_testMerge(_createBirthdayContact("2000-01-01"), _createBirthdayContact("--01-02"), _createBirthdayContact("2000-01-01"));
		_testMerge(_createBirthdayContact("--01-01"), _createBirthdayContact("2000-01-02"), _createBirthdayContact("2000-01-02"));
	});
	function _createBirthdayContact(birthdayIso) {
		return createFilledContact("A", "B", "", "", "", "", "", "", "", null, null, null, null, [], birthdayIso);
	}
	function _testMerge(c1, c2, merged) {
		mergeContacts(c1, c2);
		delete downcast(c1)._id;
		delete downcast(merged)._id;
		dist_default(c1).deepEquals(merged);
	}
	dist_default("getMergedNameFieldTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.firstName = _getMergedNameField(c1.firstName, c2.firstName);
		dist_default(c1.firstName).equals(c1.firstName);
		c1.firstName = "bob";
		c1.firstName = _getMergedNameField(c1.firstName, c2.firstName);
		dist_default(c1.firstName).equals("bob");
		c1.lastName = "mob";
		c1.lastName = _getMergedNameField(c1.lastName, c2.lastName);
		dist_default(c1.lastName).equals("mob");
		c2.firstName = "flop";
		c1.firstName = _getMergedNameField(c1.firstName, c2.firstName);
		dist_default(c1.firstName).equals("bob");
		c2.lastName = "Top";
		c1.lastName = _getMergedNameField(c1.lastName, c2.lastName);
		dist_default(c1.lastName).equals("mob");
		c1.firstName = "";
		c1.firstName = _getMergedNameField(c1.firstName, c2.firstName);
		dist_default(c1.firstName).equals("flop");
		c1.lastName = "qop";
		c1.lastName = _getMergedNameField(c1.lastName, c2.lastName);
		dist_default(c1.lastName).equals("qop");
	});
	dist_default("getMergedOtherFieldTitleTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.title = _getMergedOtherField(c1.title, c2.title, ", ");
		dist_default(c1.title).equals(null);
		c1.title = "bob";
		c1.title = _getMergedOtherField(c1.title, c2.title, ", ");
		dist_default(c1.title).equals("bob");
		c2.title = "flop";
		c1.title = _getMergedOtherField(c1.title, c2.title, ", ");
		dist_default(c1.title).equals("bob, flop");
		c1.title = "";
		c1.title = _getMergedOtherField(c1.title, c2.title, ", ");
		dist_default(c1.title).equals("flop");
	});
	dist_default("getMergedOtherFieldCommentTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.comment = neverNull(_getMergedOtherField(c1.comment, c2.comment, "\n\n"));
		dist_default(c1.comment).equals("");
		c1.comment = "bob";
		c1.comment = neverNull(_getMergedOtherField(c1.comment, c2.comment, "\n\n"));
		dist_default(c1.comment).equals("bob");
		c2.comment = "flop";
		c1.comment = neverNull(_getMergedOtherField(c1.comment, c2.comment, "\n\n"));
		dist_default(c1.comment).equals("bob\n\nflop");
		c1.comment = "";
		c1.comment = neverNull(_getMergedOtherField(c1.comment, c2.comment, "\n\n"));
		dist_default(c1.comment).equals("flop");
	});
	dist_default("getMergedOtherFieldCompanyTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.company = neverNull(_getMergedOtherField(c1.company, c2.company, ", "));
		dist_default(c1.company).equals("");
		c1.company = "bob";
		c1.company = neverNull(_getMergedOtherField(c1.company, c2.company, ", "));
		dist_default(c1.company).equals("bob");
		c2.company = "flop";
		c1.company = neverNull(_getMergedOtherField(c1.company, c2.company, ", "));
		dist_default(c1.company).equals("bob, flop");
		c1.company = "";
		c1.company = neverNull(_getMergedOtherField(c1.company, c2.company, ", "));
		dist_default(c1.company).equals("flop");
	});
	dist_default("getMergedOtherFieldNicknameTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.nickname = _getMergedOtherField(c1.nickname, c2.nickname, ", ");
		dist_default(c1.nickname).equals(null);
		c1.nickname = "bob";
		c1.nickname = neverNull(_getMergedOtherField(c1.nickname, c2.nickname, ", "));
		dist_default(c1.nickname).equals("bob");
		c2.nickname = "flop";
		c1.nickname = neverNull(_getMergedOtherField(c1.nickname, c2.nickname, ", "));
		dist_default(c1.nickname).equals("bob, flop");
		c1.nickname = "";
		c1.nickname = neverNull(_getMergedOtherField(c1.nickname, c2.nickname, ", "));
		dist_default(c1.nickname).equals("flop");
	});
	dist_default("getMergedOtherFieldRoleTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.role = neverNull(_getMergedOtherField(c1.role, c2.role, ", "));
		dist_default(c1.role).equals("");
		c1.role = "bob";
		c1.role = neverNull(_getMergedOtherField(c1.role, c2.role, ", "));
		dist_default(c1.role).equals("bob");
		c2.role = "flop";
		c1.role = neverNull(_getMergedOtherField(c1.role, c2.role, ", "));
		dist_default(c1.role).equals("bob, flop");
		c1.role = "";
		c1.role = neverNull(_getMergedOtherField(c1.role, c2.role, ", "));
		dist_default(c1.role).equals("flop");
	});
	dist_default("getMergedOtherFieldPresharedPasswordTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.presharedPassword = _getMergedOtherField(c1.presharedPassword, c2.presharedPassword, "");
		dist_default(c1.presharedPassword).equals(null);
		c1.presharedPassword = "bob";
		c1.presharedPassword = neverNull(_getMergedOtherField(c1.presharedPassword, c2.presharedPassword, ""));
		dist_default(c1.presharedPassword).equals("bob");
		c2.presharedPassword = "flop";
		c1.presharedPassword = neverNull(_getMergedOtherField(c1.presharedPassword, c2.presharedPassword, ""));
		dist_default(c1.presharedPassword).equals("bobflop");
		c1.presharedPassword = "";
		c1.presharedPassword = neverNull(_getMergedOtherField(c1.presharedPassword, c2.presharedPassword, ""));
		dist_default(c1.presharedPassword).equals("flop");
	});
	dist_default("getMergedEmailAddressesTest", function() {
		let keptContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		let eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses[1].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.mailAddresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de"], [], [], []);
		keptContact.mailAddresses[0].type = ContactAddressType.OTHER;
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		eliminatedContact.mailAddresses[0].type = ContactAddressType.WORK;
		eliminatedContact.mailAddresses[1].type = ContactAddressType.OTHER;
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[0].type).equals(ContactAddressType.OTHER);
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses[1].type).equals(ContactAddressType.OTHER);
		dist_default(keptContact.mailAddresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.mailAddresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", ["bentste@bentste.de"], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses.length).equals(0);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [
			"antste@antste.de",
			"bentste@bentste.de",
			"bent@bent.de"
		], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", ["antste@antste.de", "bentste@bentste.de"], [], [], []);
		keptContact.mailAddresses = _getMergedEmailAddresses(keptContact.mailAddresses, eliminatedContact.mailAddresses);
		dist_default(keptContact.mailAddresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.mailAddresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.mailAddresses[2].address).equals("bent@bent.de");
		dist_default(keptContact.mailAddresses.length).equals(3);
	});
	dist_default("getMergedPhoneNumbersTest", function() {
		let keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		let eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[0].type).equals(ContactPhoneNumberType.WORK);
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers[1].type).equals(ContactPhoneNumberType.WORK);
		dist_default(keptContact.phoneNumbers.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123"], [], []);
		keptContact.phoneNumbers[0].type = ContactPhoneNumberType.OTHER;
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		eliminatedContact.phoneNumbers[0].type = ContactPhoneNumberType.WORK;
		eliminatedContact.phoneNumbers[1].type = ContactPhoneNumberType.OTHER;
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[0].type).equals(ContactPhoneNumberType.OTHER);
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers[1].type).equals(ContactPhoneNumberType.OTHER);
		dist_default(keptContact.phoneNumbers.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[0].type).equals(ContactPhoneNumberType.WORK);
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers[0].type).equals(ContactPhoneNumberType.WORK);
		dist_default(keptContact.phoneNumbers.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["963258741"], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers.length).equals(0);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [
			"789654123",
			"963258741",
			"789852"
		], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["789654123", "963258741"], [], []);
		keptContact.phoneNumbers = _getMergedPhoneNumbers(keptContact.phoneNumbers, eliminatedContact.phoneNumbers);
		dist_default(keptContact.phoneNumbers[0].number).equals("789654123");
		dist_default(keptContact.phoneNumbers[1].number).equals("963258741");
		dist_default(keptContact.phoneNumbers[2].number).equals("789852");
		dist_default(keptContact.phoneNumbers.length).equals(3);
	});
	dist_default("getMergedPhoneNumber should ignore whitespace", function() {
		const numberWithoutWhitespace = createTestEntity(ContactPhoneNumberTypeRef, { number: "789654123" });
		const numberWithWhitespace = createTestEntity(ContactPhoneNumberTypeRef, { number: " 789 654123 " });
		const mergedPhoneNumbers = _getMergedPhoneNumbers([numberWithoutWhitespace], [numberWithWhitespace]);
		dist_default(mergedPhoneNumbers).deepEquals([createTestEntity(ContactPhoneNumberTypeRef, { number: "789654123" })]);
	});
	dist_default("getMergedAddressesTest", function() {
		let keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		let eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses[1].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.addresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de"]);
		keptContact.addresses[0].type = ContactAddressType.OTHER;
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		eliminatedContact.addresses[0].type = ContactAddressType.WORK;
		eliminatedContact.addresses[1].type = ContactAddressType.OTHER;
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[0].type).equals(ContactAddressType.OTHER);
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses[1].type).equals(ContactAddressType.OTHER);
		dist_default(keptContact.addresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses[0].type).equals(ContactAddressType.WORK);
		dist_default(keptContact.addresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["bentste@bentste.de"]);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses.length).equals(0);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], [
			"antste@antste.de",
			"bentste@bentste.de",
			"bent@bent.de"
		]);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], ["antste@antste.de", "bentste@bentste.de"]);
		keptContact.addresses = _getMergedAddresses(keptContact.addresses, eliminatedContact.addresses);
		dist_default(keptContact.addresses[0].address).equals("antste@antste.de");
		dist_default(keptContact.addresses[1].address).equals("bentste@bentste.de");
		dist_default(keptContact.addresses[2].address).equals("bent@bent.de");
		dist_default(keptContact.addresses.length).equals(3);
	});
	dist_default("getMergedSocialIdsTest", function() {
		let keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		let eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[0].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds[1].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de"], []);
		keptContact.socialIds[0].type = ContactSocialType.OTHER;
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		eliminatedContact.socialIds[0].type = ContactSocialType.OTHER;
		eliminatedContact.socialIds[1].type = ContactSocialType.OTHER;
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[0].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds[1].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[0].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds[0].type).equals(ContactSocialType.OTHER);
		dist_default(keptContact.socialIds.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["bentste@bentste.de"], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds.length).equals(2);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds.length).equals(0);
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [
			"antste@antste.de",
			"bentste@bentste.de",
			"bent@bent.de"
		], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		keptContact.socialIds = _getMergedSocialIds(keptContact.socialIds, eliminatedContact.socialIds);
		dist_default(keptContact.socialIds[0].socialId).equals("antste@antste.de");
		dist_default(keptContact.socialIds[1].socialId).equals("bentste@bentste.de");
		dist_default(keptContact.socialIds[2].socialId).equals("bent@bent.de");
		dist_default(keptContact.socialIds.length).equals(3);
	});
	dist_default("mergeContactsTest", function() {
		let keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		let eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		let compareContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de", "bentste@bentste.de"], []);
		mergeContacts(keptContact, eliminatedContact);
		dist_default(_contactToVCard(keptContact)).equals(_contactToVCard(compareContact));
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], ["antste@antste.de"], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["0989089"], ["antste@antste.de", "bentste@bentste.de"], []);
		compareContact = createFilledContact("", "", "", "", "", "", "", "", "", [], ["0989089"], ["antste@antste.de", "bentste@bentste.de"], []);
		mergeContacts(keptContact, eliminatedContact);
		dist_default(_contactToVCard(keptContact)).equals(_contactToVCard(compareContact));
		keptContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		compareContact = createFilledContact("", "", "", "", "", "", "", "", "", [], [], [], []);
		mergeContacts(keptContact, eliminatedContact);
		dist_default(_contactToVCard(keptContact)).equals(_contactToVCard(compareContact));
		keptContact = createFilledContact("", "", "Tests are great ... noooot", "", "", "", "", "", "", [], [], [], []);
		eliminatedContact = createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "", "", "", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		compareContact = createFilledContact("Ant", "Ste", "Tests are great ... noooot\n\nHello World!", "Tutao", "Mr.", "Buffalo", "", "", "", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"], ["Housestreet 123\nTown 123\nState 123\nCountry 123"]);
		mergeContacts(keptContact, eliminatedContact);
		dist_default(_contactToVCard(keptContact)).equals(_contactToVCard(compareContact));
	});
	dist_default("_compareBirthdaysForComparisonResultTest", function() {
		let c1 = createTestEntity(ContactTypeRef);
		let c2 = createTestEntity(ContactTypeRef);
		c1.birthdayIso = fillBirthday("14", "11", "1999");
		c2.birthdayIso = fillBirthday("14", "11", "1999");
		dist_default(_compareBirthdays(c1, c2)).equals(ContactComparisonResult.Equal);
		c1.birthdayIso = fillBirthday("14", "11", null);
		c2.birthdayIso = fillBirthday("14", "11", null);
		dist_default(_compareBirthdays(c1, c2)).equals(ContactComparisonResult.Equal);
		c1.birthdayIso = null;
		c2.birthdayIso = null;
		dist_default(_compareBirthdays(c1, c2)).equals(IndifferentContactComparisonResult.BothEmpty);
		c1.birthdayIso = fillBirthday("14", "11", "1999");
		c2.birthdayIso = null;
		dist_default(_compareBirthdays(c1, c2)).equals(IndifferentContactComparisonResult.OneEmpty);
		c1 = createTestEntity(ContactTypeRef);
		c2.birthdayIso = fillBirthday("14", "11", "1999");
		dist_default(_compareBirthdays(c1, c2)).equals(IndifferentContactComparisonResult.OneEmpty);
		c1 = createTestEntity(ContactTypeRef);
		c2 = createTestEntity(ContactTypeRef);
		c2.birthdayIso = fillBirthday("14", "11", null);
		dist_default(_compareBirthdays(c1, c2)).equals(IndifferentContactComparisonResult.OneEmpty);
		c1.birthdayIso = fillBirthday("14", "11", "2000");
		c2.birthdayIso = fillBirthday("14", "11", null);
		dist_default(_compareBirthdays(c1, c2)).equals(ContactComparisonResult.Similar);
		c1 = createTestEntity(ContactTypeRef);
		c2 = createTestEntity(ContactTypeRef);
		c1.birthdayIso = fillBirthday("12", "8", null);
		c2.birthdayIso = fillBirthday("12", "8", "1999");
		dist_default(_compareBirthdays(c1, c2)).equals(ContactComparisonResult.Similar);
		c1.birthdayIso = fillBirthday("14", "11", "1999");
		c2.birthdayIso = fillBirthday("14", "11", "2000");
		dist_default(_compareBirthdays(c1, c2)).equals(ContactComparisonResult.Unique);
	});
});
function fillBirthday(day, month, year) {
	let bday = createTestEntity(BirthdayTypeRef);
	bday.day = day;
	bday.month = month;
	bday.year = year ?? null;
	return birthdayToIsoDate(bday);
}

//#endregion
//#region tests/calendar/CalendarModelTest.ts
var import_testdouble$38 = __toESM(require_testdouble(), 1);
dist_default.spec("CalendarModel", function() {
	dist_default.spec("incrementByRepeatPeriod", function() {
		const timeZone = "Europe/Berlin";
		dist_default("with daylight saving", function() {
			const daylightSavingDay = DateTime.fromObject({
				year: 2019,
				month: 10,
				day: 26,
				hour: 10
			}, { zone: "Europe/Moscow" }).toJSDate();
			const dayAfter = DateTime.fromObject({
				year: 2019,
				month: 10,
				day: 27,
				hour: 11
			}, { zone: "Europe/Moscow" }).toJSDate();
			dist_default(incrementByRepeatPeriod(daylightSavingDay, RepeatPeriod.DAILY, 1, timeZone).toISOString()).equals(dayAfter.toISOString());
		});
		dist_default("event in timezone without daylight saving should not be subject to daylight saving", function() {
			const daylightSavingDay = DateTime.fromObject({
				year: 2019,
				month: 10,
				day: 26,
				hour: 10
			}, { zone: "Europe/Moscow" }).toJSDate();
			const dayAfter = DateTime.fromObject({
				year: 2019,
				month: 10,
				day: 27,
				hour: 10
			}, { zone: "Europe/Moscow" }).toJSDate();
			dist_default(incrementByRepeatPeriod(daylightSavingDay, RepeatPeriod.DAILY, 1, "Europe/Moscow").toISOString()).equals(dayAfter.toISOString());
		});
		dist_default("weekly", function() {
			const onFriday = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 31,
				hour: 10
			}, { zone: timeZone }).toJSDate();
			const nextFriday = DateTime.fromObject({
				year: 2019,
				month: 6,
				day: 7,
				hour: 10
			}, { zone: timeZone }).toJSDate();
			dist_default(incrementByRepeatPeriod(onFriday, RepeatPeriod.WEEKLY, 1, timeZone).toISOString()).equals(nextFriday.toISOString());
			const oneYearAfter = DateTime.fromObject({
				year: 2020,
				month: 5,
				day: 29,
				hour: 10
			}, { zone: timeZone }).toJSDate();
			dist_default(incrementByRepeatPeriod(onFriday, RepeatPeriod.WEEKLY, 52, timeZone).toISOString()).equals(oneYearAfter.toISOString());
		});
		dist_default("monthly", function() {
			const endOfMay = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 31
			}, { zone: timeZone }).toJSDate();
			const endOfJune = DateTime.fromObject({
				year: 2019,
				month: 6,
				day: 30
			}, { zone: timeZone }).toJSDate();
			const calculatedEndOfJune = incrementByRepeatPeriod(endOfMay, RepeatPeriod.MONTHLY, 1, timeZone);
			dist_default(calculatedEndOfJune.toISOString()).equals(endOfJune.toISOString());
			const endOfJuly = DateTime.fromObject({
				year: 2019,
				month: 7,
				day: 31
			}, { zone: timeZone }).toJSDate();
			const endOfJulyString = endOfJuly.toISOString();
			const incrementedDateString = incrementByRepeatPeriod(endOfMay, RepeatPeriod.MONTHLY, 2, timeZone).toISOString();
			dist_default(incrementedDateString).equals(endOfJulyString);
		});
		dist_default("annually", function() {
			const leapYear = DateTime.fromObject({
				year: 2020,
				month: 2,
				day: 29
			}, { zone: timeZone }).toJSDate();
			const yearAfter = DateTime.fromObject({
				year: 2021,
				month: 2,
				day: 28
			}, { zone: timeZone }).toJSDate();
			dist_default(incrementByRepeatPeriod(leapYear, RepeatPeriod.ANNUALLY, 1, timeZone).toISOString()).equals(yearAfter.toISOString());
			const twoYearsAfter = DateTime.fromObject({
				year: 2022,
				month: 2,
				day: 28
			}, { zone: timeZone }).toJSDate();
			dist_default(incrementByRepeatPeriod(leapYear, RepeatPeriod.ANNUALLY, 2, timeZone).toISOString()).equals(twoYearsAfter.toISOString());
			const fourYearsAfter = DateTime.fromObject({
				year: 2024,
				month: 2,
				day: 29
			}, { zone: timeZone }).toJSDate();
			dist_default(incrementByRepeatPeriod(leapYear, RepeatPeriod.ANNUALLY, 4, timeZone).toISOString()).equals(fourYearsAfter.toISOString());
		});
	});
	dist_default.spec("calendar event updates", function() {
		let restClientMock;
		let groupRoot;
		const loginController = makeLoginController();
		const alarmsListId = neverNull(loginController.getUserController().user.alarmInfoList).alarms;
		dist_default.beforeEach(function() {
			groupRoot = createTestEntity(CalendarGroupRootTypeRef, {
				_id: "groupRootId",
				longEvents: "longEvents",
				shortEvents: "shortEvents"
			});
			restClientMock = new EntityRestClientMock();
			restClientMock.addElementInstances(groupRoot);
		});
		dist_default("reply but sender is not a guest", async function() {
			const uid = "uid";
			const existingEvent = createTestEntity(CalendarEventTypeRef, { uid });
			const calendarFacade = makeCalendarFacade({ getEventsByUid: (loadUid) => uid === loadUid ? Promise.resolve({
				progenitor: existingEvent,
				alteredInstances: []
			}) : Promise.resolve(null) }, restClientMock);
			const workerClient = makeWorkerClient();
			const model = init({
				workerClient,
				restClientMock,
				calendarFacade
			});
			await model.processCalendarData("sender@example.com", {
				method: CalendarMethod.REPLY,
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, { uid }),
					alarms: []
				}]
			});
			verify(calendarFacade.updateCalendarEvent(import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything()), { times: 0 });
		});
		dist_default("reply", async function() {
			const uid = "uid";
			const sender = "sender@example.com";
			const anotherGuest = "another-attendee";
			const alarm = createTestEntity(AlarmInfoTypeRef, { _id: "alarm-id" });
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_id: ["listId", "eventId"],
				uid,
				_ownerGroup: groupRoot._id,
				summary: "v1",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
					status: CalendarAttendeeStatus.NEEDS_ACTION
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: anotherGuest }),
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})],
				alarmInfos: [[alarmsListId, alarm._id]]
			});
			restClientMock.addListInstances(createTestEntity(UserAlarmInfoTypeRef, {
				_id: [alarmsListId, alarm._id],
				alarmInfo: alarm
			}));
			const workerClient = makeWorkerClient();
			const calendarFacade = makeCalendarFacade({ getEventsByUid: (loadUid) => uid === loadUid ? Promise.resolve({
				progenitor: existingEvent,
				alteredInstances: []
			}) : Promise.resolve(null) }, restClientMock);
			const model = init({
				workerClient,
				restClientMock,
				calendarFacade
			});
			await model.processCalendarData(sender, {
				method: CalendarMethod.REPLY,
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						uid,
						attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
							status: CalendarAttendeeStatus.ACCEPTED
						}), createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, { address: anotherGuest }),
							status: CalendarAttendeeStatus.DECLINED
						})]
					}),
					alarms: []
				}]
			});
			const eventCaptor = import_testdouble$38.matchers.captor();
			const alarmsCaptor = import_testdouble$38.matchers.captor();
			verify(calendarFacade.updateCalendarEvent(eventCaptor.capture(), alarmsCaptor.capture(), import_testdouble$38.matchers.anything()));
			const createdEvent = eventCaptor.value;
			const alarms = alarmsCaptor.value;
			dist_default(createdEvent.uid).equals(existingEvent.uid);
			dist_default(createdEvent.summary).equals(existingEvent.summary);
			dist_default(createdEvent.attendees).deepEquals([createTestEntity(CalendarEventAttendeeTypeRef, {
				address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
				status: CalendarAttendeeStatus.ACCEPTED
			}), createTestEntity(CalendarEventAttendeeTypeRef, {
				address: createTestEntity(EncryptedMailAddressTypeRef, { address: "another-attendee" }),
				status: CalendarAttendeeStatus.NEEDS_ACTION
			})]);
			dist_default(alarms).deepEquals([alarm]);
		});
		dist_default("request as a new invite", async function() {
			const uid = "uid";
			const sender = "sender@example.com";
			const restClientMock$1 = new EntityRestClientMock();
			const workerClient = makeWorkerClient();
			const calendarFacade = makeCalendarFacade({ getEventsByUid: (_loadUid) => Promise.resolve(null) }, restClientMock$1);
			const model = init({
				workerClient,
				restClientMock: restClientMock$1,
				calendarFacade
			});
			await model.processCalendarData(sender, {
				method: CalendarMethod.REQUEST,
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						uid,
						attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
							status: CalendarAttendeeStatus.ACCEPTED
						})]
					}),
					alarms: []
				}]
			});
			verify(calendarFacade.updateCalendarEvent(import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything()), { times: 0 });
		});
		dist_default("request as an update", async function() {
			const uid = "uid";
			const sender = "sender@example.com";
			const alarm = createTestEntity(AlarmInfoTypeRef, { _id: "alarm-id" });
			restClientMock.addListInstances(createTestEntity(UserAlarmInfoTypeRef, {
				_id: [alarmsListId, alarm._id],
				alarmInfo: alarm
			}));
			const startTime = new Date();
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_id: ["listId", "eventId"],
				_ownerGroup: groupRoot._id,
				summary: "v1",
				sequence: "1",
				uid,
				organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
				alarmInfos: [[alarmsListId, alarm._id]],
				startTime
			});
			const workerClient = makeWorkerClient();
			const calendarFacade = makeCalendarFacade({ getEventsByUid: (loadUid) => uid === loadUid ? Promise.resolve({
				progenitor: existingEvent,
				alteredInstances: []
			}) : Promise.resolve(null) }, restClientMock);
			const model = init({
				workerClient,
				restClientMock,
				calendarFacade
			});
			const sentEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "v2",
				uid,
				sequence: "2",
				organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
				startTime
			});
			await model.processCalendarData(sender, {
				method: CalendarMethod.REQUEST,
				contents: [{
					event: sentEvent,
					alarms: []
				}]
			});
			const eventCaptor = import_testdouble$38.matchers.captor();
			const alarmsCaptor = import_testdouble$38.matchers.captor();
			const oldEventCaptor = import_testdouble$38.matchers.captor();
			verify(calendarFacade.updateCalendarEvent(eventCaptor.capture(), alarmsCaptor.capture(), oldEventCaptor.capture()));
			const updatedEvent = eventCaptor.value;
			const updatedAlarms = alarmsCaptor.value;
			const oldEvent = oldEventCaptor.value;
			dist_default(updatedEvent.summary).equals(sentEvent.summary);
			dist_default(updatedEvent.sequence).equals(sentEvent.sequence);
			dist_default(updatedAlarms).deepEquals([alarm]);
			dist_default(oldEvent).deepEquals(existingEvent);
		});
		dist_default("event is re-created when the start time changes", async function() {
			const uid = "uid";
			const sender = "sender@example.com";
			const alarm = createTestEntity(AlarmInfoTypeRef, { _id: "alarm-id" });
			restClientMock.addListInstances(createTestEntity(UserAlarmInfoTypeRef, {
				_id: [alarmsListId, alarm._id],
				alarmInfo: alarm
			}));
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_id: ["listId", "eventId"],
				_ownerGroup: groupRoot._id,
				summary: "v1",
				sequence: "1",
				uid,
				organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
				startTime: DateTime.fromObject({
					year: 2020,
					month: 5,
					day: 10
				}, { zone: "UTC" }).toJSDate(),
				alarmInfos: [[alarmsListId, alarm._id]]
			});
			const workerClient = makeWorkerClient();
			const calendarFacade = makeCalendarFacade({ getEventsByUid: (loadUid) => uid === loadUid ? Promise.resolve({
				progenitor: existingEvent,
				alteredInstances: []
			}) : Promise.resolve(null) }, restClientMock);
			const model = init({
				workerClient,
				restClientMock,
				calendarFacade
			});
			const sentEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "v2",
				uid,
				sequence: "2",
				startTime: DateTime.fromObject({
					year: 2020,
					month: 5,
					day: 11
				}, { zone: "UTC" }).toJSDate(),
				organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
			});
			await model.processCalendarData(sender, {
				method: CalendarMethod.REQUEST,
				contents: [{
					event: sentEvent,
					alarms: []
				}]
			});
			verify(calendarFacade.updateCalendarEvent(import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything()), { times: 0 });
			const eventCaptor = import_testdouble$38.matchers.captor();
			const alarmsCaptor = import_testdouble$38.matchers.captor();
			const oldEventCaptor = import_testdouble$38.matchers.captor();
			verify(calendarFacade.saveCalendarEvent(eventCaptor.capture(), alarmsCaptor.capture(), oldEventCaptor.capture()));
			const updatedEvent = eventCaptor.value;
			const updatedAlarms = alarmsCaptor.value;
			const oldEvent = oldEventCaptor.value;
			dist_default(updatedEvent.summary).equals(sentEvent.summary);
			dist_default(updatedEvent.sequence).equals(sentEvent.sequence);
			dist_default(updatedEvent.startTime.toISOString()).equals(sentEvent.startTime.toISOString());
			dist_default(updatedEvent.uid).equals(uid);
			dist_default(updatedAlarms).deepEquals([alarm]);
			dist_default(oldEvent).deepEquals(existingEvent);
		});
		dist_default.spec("cancel", function() {
			dist_default("event is cancelled by organizer", async function() {
				const uid = "uid";
				const sender = "sender@example.com";
				const existingEvent = createTestEntity(CalendarEventTypeRef, {
					_id: ["listId", "eventId"],
					_ownerGroup: groupRoot._id,
					sequence: "1",
					uid,
					organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
				});
				restClientMock.addListInstances(existingEvent);
				const workerClient = makeWorkerClient();
				const calendarFacade = makeCalendarFacade({ getEventsByUid: (loadUid) => uid === loadUid ? Promise.resolve({
					progenitor: existingEvent,
					alteredInstances: []
				}) : Promise.resolve(null) }, restClientMock);
				const model = init({
					workerClient,
					restClientMock,
					calendarFacade
				});
				const sentEvent = createTestEntity(CalendarEventTypeRef, {
					uid,
					sequence: "2",
					organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
				});
				await model.processCalendarData(sender, {
					method: CalendarMethod.CANCEL,
					contents: [{
						event: sentEvent,
						alarms: []
					}]
				});
				await dist_default(() => restClientMock.load(CalendarEventTypeRef, existingEvent._id)).asyncThrows(NotFoundError);
			});
			dist_default("event is cancelled by someone else than organizer", async function() {
				const uid = "uid";
				const sender = "sender@example.com";
				const existingEvent = createTestEntity(CalendarEventTypeRef, {
					_id: ["listId", "eventId"],
					_ownerGroup: groupRoot._id,
					sequence: "1",
					uid,
					organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
				});
				restClientMock.addListInstances(existingEvent);
				const workerClient = makeWorkerClient();
				const model = init({
					workerClient,
					restClientMock
				});
				const sentEvent = createTestEntity(CalendarEventTypeRef, {
					uid,
					sequence: "2",
					organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
				});
				await model.processCalendarData("another-sender", {
					method: CalendarMethod.CANCEL,
					contents: [{
						event: sentEvent,
						alarms: []
					}]
				});
				dist_default(await restClientMock.load(CalendarEventTypeRef, existingEvent._id)).equals(existingEvent)("Calendar event was not deleted");
			});
		});
		dist_default("reprocess deferred calendar events with no owner enc session key", async function() {
			const calendarFile = createTestEntity(FileTypeRef, { _id: ["fileListId", "fileId"] });
			const eventUpdate = createTestEntity(CalendarEventUpdateTypeRef, {
				_id: ["calendarEventUpdateListId", "calendarEventUpdateId"],
				file: calendarFile._id
			});
			const uid = "uid";
			const sender = "sender@example.com";
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_id: ["calendarListId", "eventId"],
				_ownerGroup: groupRoot._id,
				sequence: "1",
				uid,
				organizer: createTestEntity(EncryptedMailAddressTypeRef, { address: sender })
			});
			const fileControllerMock = makeFileController();
			const workerClient = makeWorkerClient();
			const eventControllerMock = makeEventController();
			fileControllerMock.getAsDataFile = (0, import_testdouble$38.func)();
			(0, import_testdouble$38.when)(fileControllerMock.getAsDataFile(import_testdouble$38.matchers.anything())).thenResolve(createDataFile("event.ics", "ical", stringToUtf8Uint8Array("UID: " + uid), "cid"));
			const actuallyLoad = restClientMock.load;
			restClientMock.load = (0, import_testdouble$38.func)();
			(0, import_testdouble$38.when)(restClientMock.load(import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything()), { ignoreExtraArgs: true }).thenDo((...args) => actuallyLoad.apply(restClientMock, args));
			(0, import_testdouble$38.when)(restClientMock.load(FileTypeRef, calendarFile._id), { ignoreExtraArgs: true }).thenReject(new SessionKeyNotFoundError("test"));
			const model = init({
				workerClient,
				restClientMock,
				fileFacade: fileControllerMock,
				eventController: eventControllerMock.eventController
			});
			restClientMock.addListInstances(calendarFile, eventUpdate, existingEvent);
			await eventControllerMock.sendEvent({
				application: CalendarEventUpdateTypeRef.app,
				type: CalendarEventUpdateTypeRef.type,
				instanceListId: listIdPart(eventUpdate._id),
				instanceId: elementIdPart(eventUpdate._id),
				operation: OperationType.CREATE
			});
			dist_default(model.getFileIdToSkippedCalendarEventUpdates().get(getElementId(calendarFile))).deepEquals(eventUpdate);
			dist_default(await restClientMock.load(CalendarEventUpdateTypeRef, eventUpdate._id)).deepEquals(eventUpdate);
			restClientMock.load = actuallyLoad;
			calendarFile._ownerEncSessionKey = hexToUint8Array("01");
			await eventControllerMock.sendEvent({
				application: FileTypeRef.app,
				type: FileTypeRef.type,
				instanceListId: listIdPart(calendarFile._id),
				instanceId: elementIdPart(calendarFile._id),
				operation: OperationType.UPDATE
			});
			dist_default(model.getFileIdToSkippedCalendarEventUpdates().size).deepEquals(0);
			verify(fileControllerMock.getAsDataFile(import_testdouble$38.matchers.anything()), { times: 1 });
			await dist_default(async () => restClientMock.load(CalendarEventUpdateTypeRef, eventUpdate._id)).asyncThrows(NotFoundError);
		});
	});
});
function makeNotifications() {
	return downcast({});
}
function makeProgressTracker() {
	const progressTracker = (0, import_testdouble$38.object)();
	(0, import_testdouble$38.when)(progressTracker.registerMonitorSync(import_testdouble$38.matchers.anything())).thenReturn(0);
	(0, import_testdouble$38.when)(progressTracker.getMonitor(import_testdouble$38.matchers.anything())).thenReturn(new NoopProgressMonitor());
	return progressTracker;
}
function makeEventController() {
	const listeners = new Array();
	return {
		eventController: downcast({
			listeners,
			addEntityListener(listener) {
				listeners.push(listener);
			}
		}),
		sendEvent: async (update) => {
			for (let listener of listeners) await listener([update]);
		}
	};
}
function makeWorkerClient() {
	return downcast({});
}
function makeLoginController() {
	const loginController = (0, import_testdouble$38.object)();
	const alarmInfoList = createTestEntity(UserAlarmInfoListTypeTypeRef, { alarms: "alarms" });
	const userController = (0, import_testdouble$38.object)();
	userController.user = createTestEntity(UserTypeRef, {
		_id: "user-id",
		alarmInfoList
	});
	(0, import_testdouble$38.when)(loginController.getUserController()).thenReturn(userController);
	(0, import_testdouble$38.when)(userController.getCalendarMemberships()).thenReturn([]);
	return loginController;
}
function makeMailModel() {
	return downcast({});
}
function makeCalendarFacade(getEventsByUid, entityRestClient) {
	const saveCalendarEvent = (0, import_testdouble$38.func)();
	(0, import_testdouble$38.when)(saveCalendarEvent(import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything(), import_testdouble$38.matchers.anything())).thenDo((event) => {
		if (!event.__matches) entityRestClient.addListInstances(event);
		return Promise.resolve();
	});
	return {
		getEventsByUid: getEventsByUid.getEventsByUid,
		updateCalendarEvent: (0, import_testdouble$38.func)(),
		saveCalendarEvent
	};
}
function makeFileController() {
	return downcast({});
}
function makeExternalCalendarFacade() {
	return downcast({});
}
function makeDeviceConfig() {
	return downcast({});
}
function init({ notifications = makeNotifications(), eventController = makeEventController().eventController, workerClient, restClientMock, loginController = makeLoginController(), progressTracker = makeProgressTracker(), entityClient: entityClient$1 = new EntityClient(restClientMock), mailModel = makeMailModel(), alarmScheduler = makeAlarmScheduler(), calendarFacade = makeCalendarFacade({ getEventsByUid: () => Promise.resolve(null) }, restClientMock), fileFacade = makeFileController(), externalCalendarFacade = makeExternalCalendarFacade(), deviceConfig = makeDeviceConfig() }) {
	const lazyScheduler = async () => alarmScheduler;
	return new CalendarModel(notifications, lazyScheduler, eventController, workerClient, loginController, progressTracker, entityClient$1, mailModel, calendarFacade, fileFacade, "Europe/Berlin", externalCalendarFacade, deviceConfig, downcast({ getLoadedPushIdentifier: () => ({
		identifier: "",
		disabled: false
	}) }));
}

//#endregion
//#region tests/calendar/CalendarUtilsTest.ts
var import_testdouble$37 = __toESM(require_testdouble(), 1);
const zone$2 = "Europe/Berlin";
dist_default.spec("calendar utils tests", function() {
	function iso(strings$1, ...dates) {
		let result = "";
		for (const [i, d] of dates.entries()) {
			const s = strings$1[i];
			result += s;
			result += `(${d}) ${DateTime.fromMillis(d).toISO({
				format: "extended",
				includeOffset: true
			})}`;
		}
		result += lastThrow(strings$1);
		return result;
	}
	dist_default.spec("getAllDayDateUTCFromZone", function() {
		dist_default("it produces a date with the same day in UTC", function() {
			const date = new Date("2023-01-29T17:00:00.000Z");
			const expected = "2023-01-30T00:00:00.000Z";
			const result = getAllDayDateUTCFromZone(date, "Asia/Krasnoyarsk").toISOString();
			dist_default(result).equals(expected)(`${result} vs. ${expected}`);
		});
	});
	dist_default.spec("getStartOfDayWithZone", function() {
		dist_default("it produces a date at the start of the day according to the time zone", function() {
			const date = new Date("2023-01-29T22:30:00.000Z");
			const expected = "2023-01-29T17:00:00.000Z";
			const result = getStartOfDayWithZone(date, "Asia/Krasnoyarsk");
			dist_default(result.toISOString()).equals(expected)(`${result.toISOString()} vs ${expected}`);
		});
		dist_default("when given a date that's already start of day, that date is returned", function() {
			const date = new Date("2023-01-29T00:00:00.000Z");
			const expected = "2023-01-29T00:00:00.000Z";
			const result = getStartOfDayWithZone(date, "utc");
			dist_default(result.toISOString()).equals(expected)("the utc date was not kept the same");
		});
	});
	dist_default.spec("getAllDayDateForTimezone", function() {
		dist_default("converts UTC all-day date into a local one", function() {
			const date = new Date(16750368e5);
			const expected = 16750116e5;
			const result = getAllDayDateForTimezone(date, "Asia/Krasnoyarsk");
			dist_default(result.getTime()).equals(expected)(iso`${result.getTime()} vs ${expected}`);
		});
	});
	dist_default.spec("getCalendarMonth", function() {
		dist_default.before(function() {
			lang.init({});
			lang.setLanguage({
				code: "en",
				languageTag: "en"
			});
		});
		dist_default("getCalendarMonth starting on sunday - first day saturday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 5, 10), 0, false));
			dist_default(result).equals("Sun,Mon,Tue,Wed,Thu,Fri,Sat\n26,27,28,29,30,31,1\n2,3,4,5,6,7,8\n9,10,11,12,13,14,15\n16,17,18,19,20,21,22\n23,24,25,26,27,28,29\n30,1,2,3,4,5,6");
		});
		dist_default("getCalendarMonth starting on monday - first day saturday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 5, 10), 1, false));
			dist_default(result).equals("Mon,Tue,Wed,Thu,Fri,Sat,Sun\n27,28,29,30,31,1,2\n3,4,5,6,7,8,9\n10,11,12,13,14,15,16\n17,18,19,20,21,22,23\n24,25,26,27,28,29,30\n1,2,3,4,5,6,7");
		});
		dist_default("getCalendarMonth starting on saturday - first day saturday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 5, 10), 6, false));
			dist_default(result).equals("Sat,Sun,Mon,Tue,Wed,Thu,Fri\n1,2,3,4,5,6,7\n8,9,10,11,12,13,14\n15,16,17,18,19,20,21\n22,23,24,25,26,27,28\n29,30,1,2,3,4,5\n6,7,8,9,10,11,12");
		});
		dist_default("getCalendarMonth starting on sunday - first day sunday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 8, 10), 0, false));
			dist_default(result).equals("Sun,Mon,Tue,Wed,Thu,Fri,Sat\n1,2,3,4,5,6,7\n8,9,10,11,12,13,14\n15,16,17,18,19,20,21\n22,23,24,25,26,27,28\n29,30,1,2,3,4,5\n6,7,8,9,10,11,12");
		});
		dist_default("getCalendarMonth starting on monday - first day sunday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 8, 10), 1, false));
			dist_default(result).equals("Mon,Tue,Wed,Thu,Fri,Sat,Sun\n26,27,28,29,30,31,1\n2,3,4,5,6,7,8\n9,10,11,12,13,14,15\n16,17,18,19,20,21,22\n23,24,25,26,27,28,29\n30,1,2,3,4,5,6");
		});
		dist_default("getCalendarMonth starting on saturday - first day sunday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 8, 10), 6, false));
			dist_default(result).equals("Sat,Sun,Mon,Tue,Wed,Thu,Fri\n31,1,2,3,4,5,6\n7,8,9,10,11,12,13\n14,15,16,17,18,19,20\n21,22,23,24,25,26,27\n28,29,30,1,2,3,4\n5,6,7,8,9,10,11");
		});
		dist_default("getCalendarMonth starting on sunday - first day monday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 6, 10), 0, false));
			dist_default(result).equals("Sun,Mon,Tue,Wed,Thu,Fri,Sat\n30,1,2,3,4,5,6\n7,8,9,10,11,12,13\n14,15,16,17,18,19,20\n21,22,23,24,25,26,27\n28,29,30,31,1,2,3\n4,5,6,7,8,9,10");
		});
		dist_default("getCalendarMonth starting on monday - first day monday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 6, 10), 1, false));
			dist_default(result).equals("Mon,Tue,Wed,Thu,Fri,Sat,Sun\n1,2,3,4,5,6,7\n8,9,10,11,12,13,14\n15,16,17,18,19,20,21\n22,23,24,25,26,27,28\n29,30,31,1,2,3,4\n5,6,7,8,9,10,11");
		});
		dist_default("getCalendarMonth starting on saturday - first day monday", function() {
			const result = toCalendarString(getCalendarMonth(new Date(2019, 6, 10), 6, false));
			dist_default(result).equals("Sat,Sun,Mon,Tue,Wed,Thu,Fri\n29,30,1,2,3,4,5\n6,7,8,9,10,11,12\n13,14,15,16,17,18,19\n20,21,22,23,24,25,26\n27,28,29,30,31,1,2\n3,4,5,6,7,8,9");
		});
	});
	dist_default.spec("parseTimeTo", function() {
		function parseTimeString(timeString) {
			return neverNull(Time.parseFromString(timeString)?.toObject() ?? null);
		}
		dist_default("parses full 24H time", function() {
			dist_default(parseTimeString("12:45")).deepEquals({
				hours: 12,
				minutes: 45
			});
			dist_default(parseTimeString("1245")).deepEquals({
				hours: 12,
				minutes: 45
			});
			dist_default(parseTimeString("2359")).deepEquals({
				hours: 23,
				minutes: 59
			});
			dist_default(parseTimeString("0000")).deepEquals({
				hours: 0,
				minutes: 0
			});
			dist_default(parseTimeString("0623")).deepEquals({
				hours: 6,
				minutes: 23
			});
			dist_default(parseTimeString("08:09")).deepEquals({
				hours: 8,
				minutes: 9
			});
		});
		dist_default("parses partial 24H time", function() {
			dist_default(parseTimeString("12")).deepEquals({
				hours: 12,
				minutes: 0
			});
			dist_default(parseTimeString("1:2")).deepEquals({
				hours: 1,
				minutes: 2
			});
			dist_default(parseTimeString("102")).deepEquals({
				hours: 1,
				minutes: 2
			});
			dist_default(parseTimeString("17")).deepEquals({
				hours: 17,
				minutes: 0
			});
			dist_default(parseTimeString("6")).deepEquals({
				hours: 6,
				minutes: 0
			});
			dist_default(parseTimeString("955")).deepEquals({
				hours: 9,
				minutes: 55
			});
			dist_default(parseTimeString("12:3")).deepEquals({
				hours: 12,
				minutes: 3
			});
			dist_default(parseTimeString("809")).deepEquals({
				hours: 8,
				minutes: 9
			});
		});
		dist_default("not parses incorrect time", function() {
			dist_default(parseTimeString("12:3m")).equals(null);
			dist_default(parseTimeString("A:3")).equals(null);
			dist_default(parseTimeString("")).equals(null);
			dist_default(parseTimeString(":2")).equals(null);
			dist_default(parseTimeString("25:03")).equals(null);
			dist_default(parseTimeString("22:93")).equals(null);
			dist_default(parseTimeString("24")).equals(null);
			dist_default(parseTimeString("13pm")).equals(null);
			dist_default(parseTimeString("263PM")).equals(null);
			dist_default(parseTimeString("1403PM")).equals(null);
			dist_default(parseTimeString("14:03:33PM")).equals(null);
			dist_default(parseTimeString("9:37 acme")).equals(null);
		});
		dist_default("parses AM/PM time", function() {
			dist_default(parseTimeString("7PM")).deepEquals({
				hours: 19,
				minutes: 0
			});
			dist_default(parseTimeString("11PM")).deepEquals({
				hours: 23,
				minutes: 0
			});
			dist_default(parseTimeString("12PM")).deepEquals({
				hours: 12,
				minutes: 0
			});
			dist_default(parseTimeString("11:30PM")).deepEquals({
				hours: 23,
				minutes: 30
			});
			dist_default(parseTimeString("12AM")).deepEquals({
				hours: 0,
				minutes: 0
			});
			dist_default(parseTimeString("12:30AM")).deepEquals({
				hours: 0,
				minutes: 30
			});
			dist_default(parseTimeString("3:30AM")).deepEquals({
				hours: 3,
				minutes: 30
			});
			dist_default(parseTimeString("3:30PM")).deepEquals({
				hours: 15,
				minutes: 30
			});
			dist_default(parseTimeString("9:37am")).deepEquals({
				hours: 9,
				minutes: 37
			});
			dist_default(parseTimeString("1:59pm")).deepEquals({
				hours: 13,
				minutes: 59
			});
			dist_default(parseTimeString("3:30 AM")).deepEquals({
				hours: 3,
				minutes: 30
			});
			dist_default(parseTimeString("3:30 PM")).deepEquals({
				hours: 15,
				minutes: 30
			});
			dist_default(parseTimeString("9:37 am")).deepEquals({
				hours: 9,
				minutes: 37
			});
			dist_default(parseTimeString("1:59 pm")).deepEquals({
				hours: 13,
				minutes: 59
			});
			dist_default(parseTimeString("9:37 a.m.")).deepEquals({
				hours: 9,
				minutes: 37
			});
			dist_default(parseTimeString("1:59 p.m.")).deepEquals({
				hours: 13,
				minutes: 59
			});
			dist_default(parseTimeString("1052 P.M.")).deepEquals({
				hours: 22,
				minutes: 52
			});
			dist_default(parseTimeString("1052 A.M.")).deepEquals({
				hours: 10,
				minutes: 52
			});
			dist_default(parseTimeString("948 P.M.")).deepEquals({
				hours: 21,
				minutes: 48
			});
			dist_default(parseTimeString("948 A.M.")).deepEquals({
				hours: 9,
				minutes: 48
			});
		});
	});
	dist_default.spec("timeStringFromParts", function() {
		dist_default("works", function() {
			dist_default(timeStringFromParts(0, 0, true)).equals("12:00 am");
			dist_default(timeStringFromParts(12, 0, true)).equals("12:00 pm");
			dist_default(timeStringFromParts(10, 55, true)).equals("10:55 am");
			dist_default(timeStringFromParts(10, 55, false)).equals("10:55");
			dist_default(timeStringFromParts(22, 55, true)).equals("10:55 pm");
			dist_default(timeStringFromParts(22, 55, false)).equals("22:55");
		});
	});
	dist_default.spec("getStartOfWeek", function() {
		dist_default("works", function() {
			dist_default(getStartOfWeek(new Date(2019, 6, 7), 0).toISOString()).equals(new Date(2019, 6, 7).toISOString());
			dist_default(getStartOfWeek(new Date(2019, 6, 7), 1).toISOString()).equals(new Date(2019, 6, 1).toISOString());
			dist_default(getStartOfWeek(new Date(2019, 6, 7, 3, 4, 5), 1).toISOString()).equals(new Date(2019, 6, 1).toISOString());
		});
	});
	dist_default.spec("getWeekNumber", function() {
		dist_default("works", function() {
			dist_default(getWeekNumber(new Date(2019, 7, 5))).equals(32);
			dist_default(getWeekNumber(new Date(2019, 7, 4))).equals(31);
			dist_default(getWeekNumber(new Date(2017, 11, 25))).equals(52);
			dist_default(getWeekNumber(new Date(2018, 0, 1))).equals(1);
		});
	});
	dist_default.spec("capability", function() {
		let user;
		let ownerUser;
		let group;
		let groupMembership;
		let groupOwnerMembership;
		dist_default.before(function() {
			group = createTestEntity(GroupTypeRef, {
				_id: "g1",
				type: GroupType.Calendar,
				user: "groupOwner"
			});
			groupMembership = createTestEntity(GroupMembershipTypeRef, { group: group._id });
			groupOwnerMembership = createTestEntity(GroupMembershipTypeRef, { group: group._id });
			ownerUser = createTestEntity(UserTypeRef, {
				_id: "groupOwner",
				memberships: [groupOwnerMembership]
			});
			user = createTestEntity(UserTypeRef, {
				_id: "groupMember",
				memberships: [groupMembership]
			});
		});
		dist_default("hasCapability - Invite", function() {
			groupMembership.capability = ShareCapability.Invite;
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Invite)).equals(true);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Write)).equals(true);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Read)).equals(true);
		});
		dist_default("hasCapability - Write", function() {
			groupMembership.capability = ShareCapability.Write;
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Invite)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Write)).equals(true);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Read)).equals(true);
		});
		dist_default("hasCapability - Read", function() {
			groupMembership.capability = ShareCapability.Read;
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Invite)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Write)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Read)).equals(true);
		});
		dist_default("hasCapability - Null", function() {
			groupMembership.capability = null;
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Invite)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Write)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Read)).equals(false);
		});
		dist_default("hasCapability - Owner", function() {
			groupMembership.capability = null;
			dist_default(hasCapabilityOnGroup(ownerUser, group, ShareCapability.Invite)).equals(true);
			dist_default(hasCapabilityOnGroup(ownerUser, group, ShareCapability.Write)).equals(true);
			dist_default(hasCapabilityOnGroup(ownerUser, group, ShareCapability.Read)).equals(true);
		});
		dist_default("hasCapability - no membership", function() {
			user.memberships = [];
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Invite)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Write)).equals(false);
			dist_default(hasCapabilityOnGroup(user, group, ShareCapability.Read)).equals(false);
		});
	});
	dist_default.spec("prepareCalendarDescription", function() {
		dist_default("angled link replaced with a proper link", function() {
			dist_default(prepareCalendarDescription("JoinBlahBlah<https://the-link.com/path>", identity)).equals(`JoinBlahBlah<a href="https://the-link.com/path">https://the-link.com/path</a>`);
		});
		dist_default("normal HTML link is not touched", function() {
			dist_default(prepareCalendarDescription(`JoinBlahBlah<a href="https://the-link.com/path">a link</a>`, identity)).equals(`JoinBlahBlah<a href="https://the-link.com/path">a link</a>`);
		});
		dist_default("non-HTTP/HTTPS link is not allowed", function() {
			dist_default(prepareCalendarDescription(`JoinBlahBlah<protocol://the-link.com/path>`, identity)).equals(`JoinBlahBlah<protocol://the-link.com/path>`);
		});
		dist_default("link with additional text is not allowed", function() {
			dist_default(prepareCalendarDescription("JoinBlahBlah<https://the-link.com/path and some other text>", identity)).equals(`JoinBlahBlah<https://the-link.com/path and some other text>`);
		});
		dist_default("non-closed tag is not allowed", function() {
			dist_default(prepareCalendarDescription("JoinBlahBlah<https://the-link.com/path and some other text", identity)).equals(`JoinBlahBlah<https://the-link.com/path and some other text`);
		});
	});
	dist_default.spec("findNextAlarmOccurrence", function() {
		const timeZone = "Europe/Berlin";
		dist_default("weekly never ends", function() {
			const now$1 = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 2
			}, { zone: timeZone }).toJSDate();
			const eventStart = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 2,
				hour: 12
			}, { zone: timeZone }).toJSDate();
			const eventEnd = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 2,
				hour: 14
			}, { zone: timeZone }).toJSDate();
			const occurrences = iterateAlarmOccurrences(now$1, timeZone, eventStart, eventEnd, RepeatPeriod.WEEKLY, 1, EndType.Never, 0, [], StandardAlarmInterval.ONE_HOUR, timeZone, 10);
			dist_default(occurrences.slice(0, 4)).deepEquals([
				DateTime.fromObject({
					year: 2019,
					month: 5,
					day: 2,
					hour: 11
				}, { zone: timeZone }).toJSDate(),
				DateTime.fromObject({
					year: 2019,
					month: 5,
					day: 9,
					hour: 11
				}, { zone: timeZone }).toJSDate(),
				DateTime.fromObject({
					year: 2019,
					month: 5,
					day: 16,
					hour: 11
				}, { zone: timeZone }).toJSDate(),
				DateTime.fromObject({
					year: 2019,
					month: 5,
					day: 23,
					hour: 11
				}, { zone: timeZone }).toJSDate()
			]);
		});
		dist_default("ends for all-day event correctly", function() {
			const repeatRuleTimeZone = "Asia/Anadyr";
			const now$1 = DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 1
			}, { zone: timeZone }).toJSDate();
			const eventStart = getAllDayDateUTC(DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 2
			}).toJSDate());
			const eventEnd = getAllDayDateUTC(DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 3
			}).toJSDate());
			const repeatEnd = getAllDayDateUTC(DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 4
			}).toJSDate());
			const occurrences = iterateAlarmOccurrences(now$1, repeatRuleTimeZone, eventStart, eventEnd, RepeatPeriod.DAILY, 1, EndType.UntilDate, repeatEnd.getTime(), [], StandardAlarmInterval.ONE_DAY, timeZone, 10);
			dist_default(occurrences).deepEquals([DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 1,
				hour: 0
			}, { zone: timeZone }).toJSDate(), DateTime.fromObject({
				year: 2019,
				month: 5,
				day: 2,
				hour: 0
			}, { zone: timeZone }).toJSDate()]);
		});
	});
	dist_default.spec("Diff between events", function() {
		dist_default("getDiffIn60mIntervals", function() {
			dist_default(getDiffIn60mIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2021-01-01T23:00:00.000Z"))).equals(24);
			dist_default(getDiffIn60mIntervals(new Date("2021-01-01T23:00:00.000Z"), new Date("2020-12-31T23:00:00.000Z"))).equals(-24);
			dist_default(getDiffIn60mIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2020-12-31T23:30:00.000Z"))).equals(0);
			dist_default(getDiffIn60mIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2021-01-01T00:00:00.000Z"))).equals(1);
		});
		dist_default("getDiffIn24hIntervals", function() {
			dist_default(getDiffIn24hIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2021-01-01T23:00:00.000Z"))).equals(1);
			dist_default(getDiffIn24hIntervals(new Date("2021-01-01T23:00:00.000Z"), new Date("2020-12-31T23:00:00.000Z"))).equals(-1);
			dist_default(getDiffIn24hIntervals(new Date("2021-01-01T00:01:00.000Z"), new Date("2020-12-30T23:59:00.000Z"))).equals(-2)("less than 2*24, but gives -2?");
			dist_default(getDiffIn24hIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2020-12-31T23:30:00.000Z"))).equals(0);
			dist_default(getDiffIn24hIntervals(new Date("2020-12-31T23:00:00.000Z"), new Date("2021-01-01T00:00:00.000Z"))).equals(0);
		});
	});
	dist_default.spec("Event start and end time comparison", function() {
		const zone$3 = getTimeZone();
		function eventOn(start, end) {
			return createTestEntity(CalendarEventTypeRef, {
				startTime: start,
				endTime: end
			});
		}
		dist_default("starts after", function() {
			dist_default(eventStartsAfter(new Date(2021, 0, 1), zone$3, eventOn(new Date(2021, 0, 1), new Date(2021, 0, 1)))).equals(false)(`starts same day`);
			dist_default(eventStartsAfter(new Date(2021, 0, 1), zone$3, eventOn(new Date(2020, 11, 31), new Date(2021, 0, 1)))).equals(false)(`starts before`);
			dist_default(eventStartsAfter(new Date(2021, 0, 1), zone$3, eventOn(new Date(2021, 0, 2), new Date(2021, 0, 2)))).equals(true)(`starts after`);
		});
		dist_default("ends before", function() {
			dist_default(eventEndsBefore(new Date(2021, 0, 1), zone$3, eventOn(new Date(2020, 11, 31), new Date(2021, 0, 1)))).equals(false)(`ends same day`);
			dist_default(eventEndsBefore(new Date(2021, 0, 1), zone$3, eventOn(new Date(2020, 11, 31), new Date(2021, 0, 2)))).equals(false)(`ends after`);
			dist_default(eventEndsBefore(new Date(2021, 0, 1), zone$3, eventOn(new Date(2020, 11, 30), new Date(2020, 11, 31)))).equals(true)(`ends before`);
		});
		dist_default("event is in week", function() {
			const firstDayOfWeek = new Date(2021, 8, 6);
			const lastDayOfWeek = new Date(2021, 8, 12);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 5, 13, 30), new Date(2021, 8, 6, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts before, ends first day`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 5, 13, 30), new Date(2021, 8, 12, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts before, ends last day`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 6, 13, 30), new Date(2021, 8, 6, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts first day, ends first day`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 6, 13, 30), new Date(2021, 8, 12, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts first day, ends last day`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 6, 13, 30), new Date(2021, 8, 13, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts first day, ends after`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 12, 13, 30), new Date(2021, 8, 12, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts last day, ends last day`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 12, 13, 30), new Date(2021, 8, 13, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts last day, ends after`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 5, 13, 30), new Date(2021, 8, 13, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(true)(`starts before, ends after`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 5, 13, 30), new Date(2021, 8, 5, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(false)(`starts before, ends before`);
			dist_default(isEventBetweenDays(eventOn(new Date(2021, 8, 13, 13, 30), new Date(2021, 8, 13, 13, 30)), firstDayOfWeek, lastDayOfWeek, zone$3)).equals(false)(`starts after, ends after`);
		});
	});
	dist_default.spec("check event validity", function() {
		dist_default("events with invalid dates are detected", function() {
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("nan"),
				endTime: new Date("1990")
			}))).equals(CalendarEventValidity.InvalidContainsInvalidDate);
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1991"),
				endTime: new Date("nan")
			}))).equals(CalendarEventValidity.InvalidContainsInvalidDate);
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("nan"),
				endTime: new Date("nan")
			}))).equals(CalendarEventValidity.InvalidContainsInvalidDate);
		});
		dist_default("events with start date not before end date are detected", function() {
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1990"),
				endTime: new Date("1990")
			}))).equals(CalendarEventValidity.InvalidEndBeforeStart);
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1990"),
				endTime: new Date("1980")
			}))).equals(CalendarEventValidity.InvalidEndBeforeStart);
		});
		dist_default("events with date before 1970 are detected", function() {
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1969"),
				endTime: new Date("1990")
			}))).equals(CalendarEventValidity.InvalidPre1970);
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1960"),
				endTime: new Date("1966")
			}))).equals(CalendarEventValidity.InvalidPre1970);
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("1970"),
				endTime: new Date("1966")
			}))).equals(CalendarEventValidity.InvalidEndBeforeStart);
		});
		dist_default("valid events are detected", function() {
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: getDateInUTC("1970"),
				endTime: getDateInUTC("1990")
			}))).equals(CalendarEventValidity.Valid)("events on the cusp of 1970 UTC are valid");
			dist_default(checkEventValidity(createTestEntity(CalendarEventTypeRef, {
				startTime: getDateInZone("1971"),
				endTime: getDateInZone("2022")
			}))).equals(CalendarEventValidity.Valid);
		});
	});
	dist_default.spec("addDaysForEventInstance", function() {
		let eventsForDays;
		dist_default.beforeEach(function() {
			eventsForDays = new Map();
		});
		dist_default("short event same month", function() {
			const event = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-01T10:00"));
			const month = getMonthRange(getDateInZone("2019-05-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, month, zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
		});
		dist_default("short event prev month", function() {
			const event = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-01T10:00"));
			const prevMonth = getMonthRange(getDateInZone("2019-04-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, prevMonth, zone$2);
			const eventsForDay = neverNull(eventsForDays.get(getStartOfDay(event.startTime).getTime()));
			dist_default(eventsForDay).deepEquals(undefined);
		});
		dist_default("short event next month", function() {
			const krsk = "Asia/Krasnoyarsk";
			const event = createEvent(getDateInZone("2019-05-01T08:00", krsk), getDateInZone("2019-05-01T10:00", krsk));
			const nextMonth = getMonthRange(getDateInZone("2019-06-01"), krsk);
			addDaysForEventInstance(eventsForDays, event, nextMonth, zone$2);
			const eventsForDay = neverNull(eventsForDays.get(getStartOfDay(event.startTime).getTime()));
			dist_default(eventsForDay).deepEquals(undefined);
		});
		dist_default("short event multiple days", function() {
			const event = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-04T10:00"));
			const thisMonth = getMonthRange(getDateInZone("2019-05-01"), zone$2);
			const nextMonth = getMonthRange(getDateInZone("2019-06-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, nextMonth, zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(0);
			addDaysForEventInstance(eventsForDays, event, thisMonth, zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-03").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-04").getTime())).deepEquals([event]);
		});
		dist_default("short event multiple days spans next month", function() {
			const event = createEvent(getDateInZone("2019-05-29T08:00"), getDateInZone("2019-06-02T10:00"));
			const thisMonth = getMonthRange(getDateInZone("2019-05-01"), zone$2);
			const nextMonth = getMonthRange(getDateInZone("2019-06-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, nextMonth, zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([event]);
			addDaysForEventInstance(eventsForDays, event, thisMonth, zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(5);
			dist_default(eventsForDays.get(getDateInZone("2019-05-29").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-30").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([event]);
		});
		dist_default("all day event", function() {
			const event = createEvent(getDateInUTC("2019-05-01"), getDateInUTC("2019-05-02"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
		});
		dist_default("all day event two days", function() {
			const event = createEvent(getDateInUTC("2019-04-30"), getDateInUTC("2019-05-02"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-04-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
			dist_default(eventsForDays.get(getDateInZone("2019-04-30").getTime())).deepEquals([event]);
		});
		dist_default("add same event", function() {
			const event = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-01T10:00"));
			const month = getMonthRange(getDateInZone("2019-05-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, month, zone$2);
			const secondEvent = clone(event);
			addDaysForEventInstance(eventsForDays, secondEvent, month, zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
		});
		dist_default("event became shorter", function() {
			const event = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-05T12:00"));
			const month = getMonthRange(getDateInZone("2019-05-01"), zone$2);
			addDaysForEventInstance(eventsForDays, event, month, zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-05").getTime())).deepEquals([event])("Original event is added");
			const shorterEvent = createEvent(getDateInZone("2019-05-01T08:00"), getDateInZone("2019-05-03T12:00"));
			shorterEvent._id = event._id;
			addDaysForEventInstance(eventsForDays, shorterEvent, month, zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-05").getTime())).deepEquals([])("Original event is removed");
			dist_default(eventsForDays.get(getDateInZone("2019-05-03").getTime())).deepEquals([shorterEvent])("New event is added");
		});
	});
	dist_default.spec("addDaysForRecurringEvent", function() {
		let eventsForDays;
		dist_default.beforeEach(function() {
			eventsForDays = new Map();
		});
		dist_default("recurring event - short with time ", function() {
			const event = createEvent(getDateInZone("2019-05-02T10:00"), getDateInZone("2019-05-02T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
			dist_default(eventsForDays.get(getDateInZone("2019-06-06").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-06T10:00"), getDateInZone("2019-06-06T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-13").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-13T10:00"), getDateInZone("2019-06-13T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-20").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-20T10:00"), getDateInZone("2019-06-20T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-27").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-27T10:00"), getDateInZone("2019-06-27T12:00"))]);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(9);
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-02T10:00"), getDateInZone("2019-05-02T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-09").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-09T10:00"), getDateInZone("2019-05-09T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-16").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-16T10:00"), getDateInZone("2019-05-16T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-23").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-23T10:00"), getDateInZone("2019-05-23T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-30").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-30T10:00"), getDateInZone("2019-05-30T12:00"))]);
		});
		dist_default("recurring event - short with time & day interval", function() {
			const event = createEvent(getDateInZone("2019-05-30T10:00"), getDateInZone("2019-05-30T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.DAILY, 4, zone$2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-03T10:00"), getDateInZone("2019-06-03T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-07").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-07T10:00"), getDateInZone("2019-06-07T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-11").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-11T10:00"), getDateInZone("2019-06-11T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-15").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-15T10:00"), getDateInZone("2019-06-15T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-19").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-19T10:00"), getDateInZone("2019-06-19T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-23").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-23T10:00"), getDateInZone("2019-06-23T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-27").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-27T10:00"), getDateInZone("2019-06-27T12:00"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(7);
		});
		dist_default("recurring event - short with time & monthly", function() {
			const event = createEvent(getDateInZone("2019-05-31T10:00"), getDateInZone("2019-05-31T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.MONTHLY, 1, zone$2);
			const expectedForMay = [cloneEventWithNewTime(event, getDateInZone("2019-05-31T10:00"), getDateInZone("2019-05-31T12:00"))];
			const expectedForJune = [cloneEventWithNewTime(event, getDateInZone("2019-06-30T10:00"), getDateInZone("2019-06-30T12:00"))];
			const expectedForJuly = [cloneEventWithNewTime(event, getDateInZone("2019-07-31T10:00"), getDateInZone("2019-07-31T12:00"))];
			const expectedForFebruary = [cloneEventWithNewTime(event, getDateInZone("2020-02-29T10:00"), getDateInZone("2020-02-29T12:00"))];
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals(expectedForMay);
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals(expectedForMay);
			dist_default(eventsForDays.get(getDateInZone("2019-06-30").getTime())).deepEquals(expectedForJune);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-07-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals(expectedForMay);
			dist_default(eventsForDays.get(getDateInZone("2019-06-30").getTime())).deepEquals(expectedForJune);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals(expectedForJuly);
			dist_default(countDaysWithEvents(eventsForDays)).equals(3);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2020-02-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals(expectedForMay);
			dist_default(eventsForDays.get(getDateInZone("2019-06-30").getTime())).deepEquals(expectedForJune);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals(expectedForJuly);
			dist_default(eventsForDays.get(getDateInZone("2020-02-29").getTime())).deepEquals(expectedForFebruary);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
		});
		dist_default("recurring event - short with time & monthly interval", function() {
			const event = createEvent(getDateInZone("2019-05-31T10:00"), getDateInZone("2019-05-31T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.MONTHLY, 2, zone$2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(0)("does not occur in june");
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-07-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-07-31T10:00"), getDateInZone("2019-07-31T12:00"))])("event instance in july is added");
			dist_default(countDaysWithEvents(eventsForDays)).equals(1);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-08-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-07-31T10:00"), getDateInZone("2019-07-31T12:00"))])("event instance in july is still there");
			dist_default(countDaysWithEvents(eventsForDays)).equals(1)("nothing added for august");
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-09-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-07-31T10:00"), getDateInZone("2019-07-31T12:00"))])("event instance in july is still still there");
			dist_default(eventsForDays.get(getDateInZone("2019-09-30").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-09-30T10:00"), getDateInZone("2019-09-30T12:00"))])("event instance in september was added ");
			dist_default(countDaysWithEvents(eventsForDays)).equals(2)("only september was added");
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-11-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-07-31").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-07-31T10:00"), getDateInZone("2019-07-31T12:00"))])("event instance in july is still still still there");
			dist_default(eventsForDays.get(getDateInZone("2019-11-30").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-11-30T10:00"), getDateInZone("2019-11-30T12:00"))])("event instance in november was added");
			dist_default(countDaysWithEvents(eventsForDays)).deepEquals(3);
		});
		dist_default("recurring event - short multiple days ", function() {
			const event = createEvent(getDateInZone("2019-05-03T10:00"), getDateInZone("2019-05-05T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			/**
			*       May 2019
			* So Mo Di Mi Do Fr Sa
			*           1  2  3  4
			*  5  6  7  8  9 10 11
			* 12 13 14 15 16 17 18
			* 19 20 21 22 23 24 25
			* 26 27 28 29 30 31
			*
			*     June 2019
			* So Mo Di Mi Do Fr Sa
			*                    1
			*  2  3  4  5  6  7  8
			*  9 10 11 12 13 14 15
			* 16 17 18 19 20 21 22
			* 23 24 25 26 27 28 29
			* 30
			*
			*      July 2019
			* So Mo Di Mi Do Fr Sa
			*     1  2  3  4  5  6
			*  7  8  9 10 11 12 13
			* 14 15 16 17 18 19 20
			* 21 22 23 24 25 26 27
			* 28 29 30 31
			*/
			const zerothjuneOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-05-31T10:00"), getDateInZone("2019-06-02T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([zerothjuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([zerothjuneOccurrence]);
			const firstJuneOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-06-07T10:00"), getDateInZone("2019-06-09T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-06-07").getTime())).deepEquals([firstJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-08").getTime())).deepEquals([firstJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-09").getTime())).deepEquals([firstJuneOccurrence]);
			const secondJuneOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-06-14T10:00"), getDateInZone("2019-06-16T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-06-14").getTime())).deepEquals([secondJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-15").getTime())).deepEquals([secondJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-16").getTime())).deepEquals([secondJuneOccurrence]);
			const thirdJuneOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-06-21T10:00"), getDateInZone("2019-06-23T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-06-21").getTime())).deepEquals([thirdJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-22").getTime())).deepEquals([thirdJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-23").getTime())).deepEquals([thirdJuneOccurrence]);
			const fourthJuneOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-06-28T10:00"), getDateInZone("2019-06-30T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-06-28").getTime())).deepEquals([fourthJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-29").getTime())).deepEquals([fourthJuneOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-30").getTime())).deepEquals([fourthJuneOccurrence]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(14);
			const firstMayOccurrence = event;
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-03").getTime())).deepEquals([firstMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-04").getTime())).deepEquals([firstMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-05").getTime())).deepEquals([firstMayOccurrence]);
			const secondMayOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-05-10T10:00"), getDateInZone("2019-05-12T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-05-10").getTime())).deepEquals([secondMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-11").getTime())).deepEquals([secondMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-12").getTime())).deepEquals([secondMayOccurrence]);
			const thirdMayOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-05-17T10:00"), getDateInZone("2019-05-19T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-05-17").getTime())).deepEquals([thirdMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-18").getTime())).deepEquals([thirdMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-19").getTime())).deepEquals([thirdMayOccurrence]);
			const fourthMayOccurrence = cloneEventWithNewTime(event, getDateInZone("2019-05-24T10:00"), getDateInZone("2019-05-26T12:00"));
			dist_default(eventsForDays.get(getDateInZone("2019-05-24").getTime())).deepEquals([fourthMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-25").getTime())).deepEquals([fourthMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-26").getTime())).deepEquals([fourthMayOccurrence]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([zerothjuneOccurrence]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(27);
		});
		dist_default("weekly all-day with DST in another time zone", function() {
			const krsk = "Asia/Krasnoyarsk";
			const event = createEvent(getDateInUTC("2020-02-12"), getDateInUTC("2020-02-13"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			event.repeatRule.timeZone = "America/Los_angeles";
			const month = getMonthRange(getDateInZone("2020-03-01", krsk), krsk);
			addDaysForRecurringEvent(eventsForDays, event, month, krsk);
			dist_default(eventsForDays.get(getDateInZone("2020-03-04", krsk).getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2020-03-04"), getDateInUTC("2020-03-05"))]);
			dist_default(eventsForDays.get(getDateInZone("2020-03-11", krsk).getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2020-03-11"), getDateInUTC("2020-03-12"))]);
			dist_default(eventsForDays.get(getDateInZone("2020-03-18", krsk).getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2020-03-18"), getDateInUTC("2020-03-19"))]);
			dist_default(eventsForDays.get(getDateInZone("2020-03-25", krsk).getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2020-03-25"), getDateInUTC("2020-03-26"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
		});
		dist_default("end count", function() {
			const event = createEvent(getDateInZone("2019-06-02T10:00"), getDateInZone("2019-06-02T12:00"));
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			repeatRule.endType = EndType.Count;
			repeatRule.endValue = "2";
			event.repeatRule = repeatRule;
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-02T10:00"), getDateInZone("2019-06-02T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-09").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-09T10:00"), getDateInZone("2019-06-09T12:00"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-07-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
		});
		dist_default("end on date", function() {
			const event = createEvent(getDateInZone("2019-06-02T10:00"), getDateInZone("2019-06-02T12:00"));
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			repeatRule.endType = EndType.UntilDate;
			repeatRule.endValue = String(getDateInZone("2019-06-29").getTime());
			event.repeatRule = repeatRule;
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-02T10:00"), getDateInZone("2019-06-02T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-09").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-09T10:00"), getDateInZone("2019-06-09T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-16").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-16T10:00"), getDateInZone("2019-06-16T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-23").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-23T10:00"), getDateInZone("2019-06-23T12:00"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-07-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
		});
		dist_default("end on date - all day", function() {
			const event = createEvent(getDateInUTC("2019-06-02"), getDateInUTC("2019-06-03"));
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.DAILY, 1);
			repeatRule.endType = EndType.UntilDate;
			repeatRule.endValue = String(getDateInUTC("2019-06-04").getTime());
			event.repeatRule = repeatRule;
			event.repeatRule.timeZone = "Asia/Anadyr";
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2019-06-02"), getDateInUTC("2019-06-03"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInUTC("2019-06-03"), getDateInUTC("2019-06-04"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2);
		});
		dist_default("add same recurring event", function() {
			const event = createEvent(getDateInZone("2019-05-02T10:00"), getDateInZone("2019-05-02T12:00"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.WEEKLY, 1, zone$2);
			const monthDate = getDateInZone("2019-06-01");
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(monthDate, zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-06").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-06T10:00"), getDateInZone("2019-06-06T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-13").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-13T10:00"), getDateInZone("2019-06-13T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-20").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-20T10:00"), getDateInZone("2019-06-20T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-27").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-06-27T10:00"), getDateInZone("2019-06-27T12:00"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(4);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			const eventClone = clone(event);
			addDaysForRecurringEvent(eventsForDays, eventClone, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-09").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-09T10:00"), getDateInZone("2019-05-09T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-16").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-16T10:00"), getDateInZone("2019-05-16T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-23").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-23T10:00"), getDateInZone("2019-05-23T12:00"))]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-30").getTime())).deepEquals([cloneEventWithNewTime(event, getDateInZone("2019-05-30T10:00"), getDateInZone("2019-05-30T12:00"))]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(9);
		});
		dist_default("monthly with shorter month", function() {
			const event = createEvent(getDateInUTC("2020-03-29"), getDateInUTC("2020-04-01"));
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.MONTHLY, 1, zone$2);
			repeatRule.endValue = "2";
			repeatRule.endType = EndType.Count;
			event.repeatRule = repeatRule;
			const occurrence = cloneEventWithNewTime(event, getDateInUTC("2020-04-29"), getDateInUTC("2020-05-02"));
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2020-03-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2020-03-29").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2020-03-30").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2020-03-31").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2020-04-01").getTime())).deepEquals(undefined);
			dist_default(countDaysWithEvents(eventsForDays)).equals(3);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2020-04-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2020-04-29").getTime())).deepEquals([occurrence])("29th is 1st day of the occurrence");
			dist_default(eventsForDays.get(getDateInZone("2020-04-30").getTime())).deepEquals([occurrence])("30. is 2. day of 2nd occurrence");
			dist_default(eventsForDays.get(getDateInZone("2020-05-01").getTime())).deepEquals(undefined)("outside range");
			dist_default(countDaysWithEvents(eventsForDays)).equals(5);
		});
		dist_default("monthly with longer month", function() {
			const event = createEvent(getDateInZone("2020-02-29", "utc"), getDateInZone("2020-03-01", "utc"));
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.MONTHLY, 1, zone$2);
			repeatRule.endValue = "2";
			repeatRule.endType = EndType.Count;
			event.repeatRule = repeatRule;
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2020-02-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2020-02-29").getTime())).deepEquals([event])("the 29th of feb is in the map");
			dist_default(countDaysWithEvents(eventsForDays)).equals(1)("only the last day of february is in the map");
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2020-03-01"), zone$2), zone$2);
			const occurrence = cloneEventWithNewTime(event, getDateInZone("2020-03-29", "utc"), getDateInZone("2020-03-30", "utc"));
			dist_default(eventsForDays.get(getDateInZone("2020-03-29").getTime())).deepEquals([occurrence])("the 29th of march is in the map");
		});
		dist_default("adding a progenitor while there are altered instances does not remove the altered instance", function() {
			const event = createEvent(getDateInZone("2023-07-13T13:00"), getDateInZone("2023-07-13T13:30"));
			event.summary = "summary";
			const repeatRule = createRepeatRuleWithValues(RepeatPeriod.DAILY, 1, zone$2);
			repeatRule.endValue = "2";
			repeatRule.endType = EndType.Count;
			repeatRule.excludedDates = [createTestEntity(DateWrapperTypeRef, { date: event.startTime })];
			event.repeatRule = repeatRule;
			const alteredEvent = clone(event);
			alteredEvent._id = ["shortEvents", generateEventElementId(alteredEvent.startTime.getTime())];
			alteredEvent.repeatRule = null;
			alteredEvent.recurrenceId = alteredEvent.startTime;
			alteredEvent.summary = "another summary";
			addDaysForEventInstance(eventsForDays, alteredEvent, getMonthRange(getDateInZone("2023-07-01"), zone$2), zone$2);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2023-07-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2023-07-13").getTime())).deepEquals([alteredEvent])("altered instance is on the day it occurs, but event is excluded");
			const eventsOn14th = eventsForDays.get(getDateInZone("2023-07-14").getTime()) ?? [];
			dist_default(eventsOn14th.length).equals(1)("one event on 14th");
			dist_default(eventsOn14th[0].summary).equals("summary")("occurrence of original series on 14th");
		});
	});
	dist_default.spec("addDaysForEvent for long events", function() {
		let eventsForDays;
		dist_default.beforeEach(function() {
			eventsForDays = new Map();
		});
		dist_default("longer than a month", function() {
			const event = createEvent(getDateInZone("2019-05-02T10:00"), getDateInZone("2019-06-02T12:00"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.size).equals(3);
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([]);
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.size).equals(33);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).equals(undefined);
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([event]);
		});
		dist_default("longer than a month all day", function() {
			const event = createEvent(getDateInUTC("2019-05-02"), getDateInUTC("2019-06-04"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), "Europe/Berlin");
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event])("there on the first");
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([event])("there on the 2nd");
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([event])("also there on the 3rd");
			dist_default(countDaysWithEvents(eventsForDays)).equals(3)("no more days added");
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), "Europe/Berlin");
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-03").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event]);
			dist_default(countDaysWithEvents(eventsForDays)).equals(33);
		});
		dist_default("multiple months", function() {
			const event = createEvent(getDateInZone("2019-04-02T10:00"), getDateInZone("2019-06-02T12:00"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event])("there on the 1st");
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([event])("there on the 2nd");
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([])("not there on the 3rd");
			dist_default(eventsForDays.size).equals(3)("no more days added for this call");
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime())).deepEquals([event])("there on the 1st");
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event])("there on the 2nd");
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([event])("there on the 31st");
			dist_default(eventsForDays.size).equals(34)("added for each day of may but no more");
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-04-01"), zone$2), zone$2);
			dist_default(eventsForDays.size).equals(63)("now it's there for june, may, april");
			dist_default(eventsForDays.get(getDateInZone("2019-04-01").getTime())).deepEquals(undefined)("1st of april is not touched");
			dist_default(eventsForDays.get(getDateInZone("2019-04-02").getTime())).deepEquals([event])("2nd it's there");
			dist_default(eventsForDays.get(getDateInZone("2019-04-03").getTime())).deepEquals([event])("3rd it's there");
		});
		dist_default("longer than a month repeating", function() {
			const event = createEvent(new Date("2019-05-02T08:00:00.000Z"), new Date("2019-06-02T10:00:00.000Z"));
			event.repeatRule = createRepeatRuleWithValues(RepeatPeriod.MONTHLY, 1, zone$2);
			const startingInMay = cloneEventWithNewTime(event, getDateInZone("2019-05-02T10:00"), getDateInZone("2019-06-02T12:00"));
			const startingInJune = cloneEventWithNewTime(event, getDateInZone("2019-06-02T10:00"), getDateInZone("2019-07-03T12:00"));
			const startingInJuly = cloneEventWithNewTime(event, getDateInZone("2019-07-02T10:00"), getDateInZone("2019-08-02T12:00"));
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals(undefined)("nothing added for the 31st of may");
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([startingInMay])("but may instance is still going on at start of june");
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([startingInMay, startingInJune]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-30").getTime())).deepEquals([startingInJune]);
			dist_default(eventsForDays.get(getDateInZone("2019-07-01").getTime())).deepEquals(undefined)("we're not caring about july");
			dist_default(eventsForDays.size).equals(30);
			addDaysForRecurringEvent(eventsForDays, event, getMonthRange(getDateInZone("2019-07-01"), zone$2), zone$2);
			dist_default(eventsForDays.get(getDateInZone("2019-07-01").getTime())).deepEquals([startingInJune])("june instance still going on");
			dist_default(eventsForDays.get(getDateInZone("2019-07-03").getTime())).deepEquals([startingInJune, startingInJuly])("july instance added as well");
			dist_default(eventsForDays.get(getDateInZone("2019-07-04").getTime())).deepEquals([startingInJuly])("june instance now ended.");
			dist_default(eventsForDays.get(getDateInZone("2019-07-30").getTime())).deepEquals([startingInJuly])("only starting in july at end of july");
			dist_default(eventsForDays.get(getDateInZone("2019-08-01").getTime())).deepEquals(undefined)("nothing in august");
			dist_default(eventsForDays.size).equals(61);
		});
		dist_default("add same event does not increase number of days with events", function() {
			const event = createEvent(getDateInZone("2019-05-02T10:00"), getDateInZone("2019-06-02T12:00"));
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			addDaysForEventInstance(eventsForDays, clone(event), getMonthRange(getDateInZone("2019-06-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(2)("days with events after adding june twice");
			dist_default(eventsForDays.get(getDateInZone("2019-06-01").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-06-03").getTime())).deepEquals([]);
			addDaysForEventInstance(eventsForDays, event, getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			addDaysForEventInstance(eventsForDays, clone(event), getMonthRange(getDateInZone("2019-05-01"), zone$2), zone$2);
			dist_default(countDaysWithEvents(eventsForDays)).equals(32)("days with events after adding may twice");
			dist_default(eventsForDays.get(getDateInZone("2019-05-01").getTime()) == null).equals(true);
			dist_default(eventsForDays.get(getDateInZone("2019-05-02").getTime())).deepEquals([event]);
			dist_default(eventsForDays.get(getDateInZone("2019-05-31").getTime())).deepEquals([event]);
		});
	});
	dist_default.spec("calendarEventHasMoreThanOneOccurrencesLeft", function() {
		dist_default("event without end condition has more than one occurrence", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Never,
				frequency: RepeatPeriod.DAILY,
				interval: "1"
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date(),
				endTime: new Date(),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(true);
		});
		dist_default("event without repeat rule has less than two occurrences", function() {
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date(),
				endTime: new Date(),
				repeatRule: null
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
		dist_default("event with higher count than exclusions+1 has more left", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Count,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: "3",
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-03T22:00:00Z") })],
				timeZone: zone$2
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(true);
		});
		dist_default("event with count and enough exclusions has less than two left", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Count,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: "3",
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-03T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-04T22:00:00Z") })],
				timeZone: zone$2
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
		dist_default("event with count and enough exclusions has less than two left, first is excluded", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Count,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: "3",
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-04T22:00:00Z") })],
				timeZone: zone$2
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
		dist_default("event with end date and enough exclusions has less than two left, first is excluded", function() {
			const repeatRule = createCalendarRepeatRule({
				endType: EndType.UntilDate,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: String(DateTime.fromObject({
					year: 2023,
					month: 3,
					day: 5
				}, { zone: zone$2 }).toMillis()),
				timeZone: zone$2,
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-04T22:00:00Z") })],
				advancedRules: []
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
		dist_default("event with end date and enough exclusions has more than two left, first is excluded", function() {
			const repeatRule = createCalendarRepeatRule({
				endType: EndType.UntilDate,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: String(DateTime.fromObject({
					year: 2023,
					month: 3,
					day: 6
				}, { zone: zone$2 }).toMillis()),
				timeZone: zone$2,
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-04T22:00:00Z") })],
				advancedRules: []
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(true);
		});
		dist_default("event with end date and enough exclusions has more than two left, first is excluded", function() {
			const repeatRule = createCalendarRepeatRule({
				endType: EndType.UntilDate,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: String(DateTime.fromObject({
					year: 2023,
					month: 3,
					day: 8
				}, { zone: zone$2 }).toMillis()),
				timeZone: zone$2,
				excludedDates: [
					createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T22:00:00Z") }),
					createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-04T22:00:00Z") }),
					createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-05T22:00:00Z") })
				],
				advancedRules: []
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: [{ recurrenceId: new Date("2023-03-05T22:00:00Z") }]
			})).equals(true);
		});
		dist_default("event with end date after 2 occurrences and an altered instance is considered to have more than one occurrence", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.UntilDate,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: getDateInUTC("2023-03-04").getTime().toString(),
				timeZone: zone$2,
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: getDateInZone("2023-03-02T22:00") })]
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: getDateInZone("2023-03-02T22:00"),
				endTime: getDateInZone("2023-03-02T23:00"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: [{ recurrenceId: getDateInZone("2023-03-02T22:00") }]
			})).equals(true);
		});
		dist_default("event with exclusions that are not occurrences", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Count,
				frequency: RepeatPeriod.DAILY,
				interval: "2",
				endValue: "2",
				timeZone: zone$2,
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-03T22:00:00Z") })]
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(true);
		});
		dist_default("event with one occurrence (count), no exclusions", function() {
			const repeatRule = createTestEntity(CalendarRepeatRuleTypeRef, {
				endType: EndType.Count,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: "1",
				timeZone: zone$2,
				excludedDates: []
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
		dist_default("event with one occurrence (untilDate), no exclusions", function() {
			const repeatRule = createCalendarRepeatRule({
				endType: EndType.UntilDate,
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endValue: String(DateTime.fromObject({
					year: 2023,
					month: 3,
					day: 3
				}, { zone: zone$2 }).toMillis()),
				timeZone: zone$2,
				excludedDates: [],
				advancedRules: []
			});
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-02T22:00:00Z"),
				endTime: new Date("2023-03-02T23:00:00Z"),
				repeatRule
			});
			dist_default(calendarEventHasMoreThanOneOccurrencesLeft({
				progenitor,
				ownerGroup: "",
				alteredInstances: []
			})).equals(false);
		});
	});
	dist_default.spec("getEventType", function() {
		let userController;
		dist_default.beforeEach(() => {
			const user = createTestEntity(UserTypeRef, { _id: "user-id" });
			const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef, { groupSettings: [] });
			userController = makeUserController([], AccountType.PAID, undefined, false, false, user, userSettingsGroupRoot);
		});
		dist_default("external gets EXTERNAL", function() {
			const event = {};
			const calendars$1 = new Map();
			const ownMailAddresses = [];
			(0, import_testdouble$37.replace)(userController.user, "accountType", AccountType.EXTERNAL);
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.EXTERNAL);
		});
		dist_default("if no ownergroup but organizer, gets OWN", function() {
			const event = { organizer: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "my@address.to",
				name: "my"
			}) };
			const calendars$1 = new Map();
			const ownMailAddresses = ["my@address.to"];
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.OWN);
		});
		dist_default("if no ownergroup and not organizer, gets INVITE", function() {
			const event = { organizer: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "no@address.to",
				name: "my"
			}) };
			const calendars$1 = new Map();
			const ownMailAddresses = ["my@address.to"];
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.INVITE);
		});
		dist_default("event in not any of our calendars gets SHARED_RO", function() {
			const event = {
				organizer: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "no@address.to",
					name: "my"
				}),
				_ownerGroup: "ownergroup"
			};
			const calendars$1 = new Map();
			const ownMailAddresses = ["my@address.to"];
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.SHARED_RO);
		});
		dist_default("event in rw-shared calendar w/o attendees gets SHARED_RW", function() {
			const event = {
				organizer: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "no@address.to",
					name: "my"
				}),
				_ownerGroup: "ownergroup"
			};
			const calendars$1 = new Map();
			calendars$1.set("ownergroup", {
				shared: true,
				group: createTestEntity(GroupTypeRef, {
					_id: "calendarGroup",
					type: GroupType.Calendar,
					user: "otherUser"
				})
			});
			const ownMailAddresses = ["my@address.to"];
			(0, import_testdouble$37.replace)(userController.user, "_id", ["userList", "userId"]);
			(0, import_testdouble$37.replace)(userController.user, "memberships", [createTestEntity(GroupMembershipTypeRef, {
				group: "calendarGroup",
				capability: ShareCapability.Write
			})]);
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.SHARED_RW);
		});
		dist_default("event in rw-shared calendar w attendees gets LOCKED", function() {
			const event = {
				organizer: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "no@address.to",
					name: "my"
				}),
				_ownerGroup: "ownergroup",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "bla",
					name: "blabla"
				}) })]
			};
			const calendars$1 = new Map();
			calendars$1.set("ownergroup", {
				shared: true,
				group: createTestEntity(GroupTypeRef, {
					_id: "calendarGroup",
					type: GroupType.Calendar,
					user: "otherUser"
				})
			});
			const ownMailAddresses = ["my@address.to"];
			(0, import_testdouble$37.replace)(userController.user, "_id", ["userList", "userId"]);
			(0, import_testdouble$37.replace)(userController.user, "memberships", [createTestEntity(GroupMembershipTypeRef, {
				group: "calendarGroup",
				capability: ShareCapability.Write
			})]);
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.LOCKED);
		});
		dist_default("event with ownergroup in own calendar where we're organizer gets OWN", function() {
			const event = {
				organizer: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "my@address.to",
					name: "my"
				}),
				_ownerGroup: "ownergroup",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: createTestEntity(EncryptedMailAddressTypeRef, {
					address: "bla",
					name: "blabla"
				}) })]
			};
			const calendars$1 = new Map();
			calendars$1.set("ownergroup", {
				shared: false,
				group: createTestEntity(GroupTypeRef, {
					_id: "calendarGroup",
					type: GroupType.Calendar,
					user: "userId"
				})
			});
			const ownMailAddresses = ["my@address.to"];
			(0, import_testdouble$37.replace)(userController.user, "_id", ["userList", "userId"]);
			dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.OWN);
		});
	});
	dist_default("event with ownergroup in ro-shared calendar gets shared_ro", function() {
		const event = {
			organizer: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "no@address.to",
				name: "my"
			}),
			_ownerGroup: "ownergroup",
			attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "bla",
				name: "blabla"
			}) })]
		};
		const calendars$1 = new Map();
		calendars$1.set("ownergroup", {
			shared: true,
			group: createTestEntity(GroupTypeRef, {
				_id: "calendarGroup",
				type: GroupType.Calendar,
				user: "otherUser"
			})
		});
		const ownMailAddresses = ["my@address.to"];
		const user = createTestEntity(UserTypeRef, {
			_id: "user-id",
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				group: "calendarGroup",
				capability: ShareCapability.Read
			})]
		});
		(0, import_testdouble$37.replace)(user, "_id", ["userList", "userId"]);
		const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef, { groupSettings: [] });
		const userController = makeUserController([], AccountType.PAID, undefined, false, false, user, userSettingsGroupRoot);
		dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.SHARED_RO);
	});
	dist_default("event with ownergroup in own calendar and a different organizer gets INVITE", function() {
		const event = {
			organizer: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "other@address.to",
				name: "other"
			}),
			_ownerGroup: "ownergroup",
			attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: createTestEntity(EncryptedMailAddressTypeRef, {
				address: "bla",
				name: "blabla"
			}) })]
		};
		const calendars$1 = new Map();
		calendars$1.set("ownergroup", {
			shared: false,
			group: createTestEntity(GroupTypeRef, {
				_id: "calendarGroup",
				type: GroupType.Calendar,
				user: "userId"
			})
		});
		const ownMailAddresses = ["my@address.to"];
		const user = createTestEntity(UserTypeRef, { _id: "user-id" });
		(0, import_testdouble$37.replace)(user, "_id", ["userList", "userId"]);
		const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef, { groupSettings: [] });
		const userController = makeUserController([], AccountType.PAID, undefined, false, false, user, userSettingsGroupRoot);
		dist_default(getEventType(event, calendars$1, ownMailAddresses, userController)).equals(EventType.INVITE);
	});
	dist_default.spec("parseAlarmInterval", () => {
		dist_default("accepts valid values", () => {
			dist_default(parseAlarmInterval("1M")).deepEquals({
				unit: AlarmIntervalUnit.MINUTE,
				value: 1
			});
			dist_default(parseAlarmInterval("10M")).deepEquals({
				unit: AlarmIntervalUnit.MINUTE,
				value: 10
			});
			dist_default(parseAlarmInterval("42H")).deepEquals({
				unit: AlarmIntervalUnit.HOUR,
				value: 42
			});
			dist_default(parseAlarmInterval("35D")).deepEquals({
				unit: AlarmIntervalUnit.DAY,
				value: 35
			});
			dist_default(parseAlarmInterval("6W")).deepEquals({
				unit: AlarmIntervalUnit.WEEK,
				value: 6
			});
		});
		dist_default("does not accept invalid values", () => {
			for (const value of [
				"-1M",
				"M",
				"3G",
				"3",
				"H5"
			]) dist_default(() => parseAlarmInterval(value)).throws(ParserError)(`Should throw on ${value}`);
		});
	});
	dist_default("serializeAlarmInterval", () => {
		dist_default(serializeAlarmInterval({
			value: 2,
			unit: AlarmIntervalUnit.MINUTE
		})).equals("2M");
		dist_default(serializeAlarmInterval({
			value: 2,
			unit: AlarmIntervalUnit.HOUR
		})).equals("2H");
		dist_default(serializeAlarmInterval({
			value: 35,
			unit: AlarmIntervalUnit.DAY
		})).equals("35D");
		dist_default(serializeAlarmInterval({
			value: 2,
			unit: AlarmIntervalUnit.WEEK
		})).equals("2W");
	});
});
function toCalendarString(calenderMonth) {
	return calenderMonth.weekdays.join(",") + "\n" + calenderMonth.weeks.map((w) => w.map((d) => d.day).join(",")).join("\n");
}
function iterateAlarmOccurrences(now$1, timeZone, eventStart, eventEnd, repeatPeriod, interval, endType, endValue, exclusions, alarmInterval, calculationZone, maxOccurrences) {
	const occurrences = [];
	while (occurrences.length < maxOccurrences) {
		const next = neverNull(findNextAlarmOccurrence(now$1, timeZone, eventStart, eventEnd, repeatPeriod, interval, endType, endValue, exclusions, alarmInterval, calculationZone));
		if (next) {
			occurrences.push(next.alarmTime);
			now$1 = new Date(next.eventTime.getTime());
		} else break;
	}
	return occurrences;
}
function createEvent(startTime, endTime) {
	const event = createTestEntity(CalendarEventTypeRef);
	event.startTime = startTime;
	event.endTime = endTime;
	event._id = ["listId", generateEventElementId(event.startTime.getTime())];
	return event;
}
function countDaysWithEvents(eventsForDays) {
	return Array.from(eventsForDays).filter(([_, events]) => events.length).length;
}
function cloneEventWithNewTime(event, startTime, endTime) {
	const clonedEvent = clone(event);
	clonedEvent.startTime = startTime;
	clonedEvent.endTime = endTime;
	return clonedEvent;
}

//#endregion
//#region tests/calendar/CalendarInvitesTest.ts
var import_testdouble$36 = __toESM(require_testdouble(), 1);
const { anything: anything$5, argThat: argThat$2 } = import_testdouble$36.matchers;
dist_default.spec("CalendarInviteHandlerTest", function() {
	let maiboxModel, calendarIniviteHandler, calendarModel, logins, sendMailModel;
	let calendarNotificationSender;
	let mailboxDetails;
	dist_default.beforeEach(function() {
		const customerId = "customerId";
		const user = {
			_id: "userId",
			customer: customerId
		};
		const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef);
		let userController = makeUserController([], AccountType.FREE, undefined, false, false, user, userSettingsGroupRoot);
		mailboxDetails = {
			mailbox: createTestEntity(MailBoxTypeRef),
			mailGroupInfo: createTestEntity(GroupInfoTypeRef, { mailAddress: "mailgroup@addre.ss" }),
			mailGroup: createTestEntity(GroupTypeRef),
			mailboxGroupRoot: createTestEntity(MailboxGroupRootTypeRef)
		};
		const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef, {});
		maiboxModel = (0, import_testdouble$36.instance)(MailboxModel);
		(0, import_testdouble$36.when)(maiboxModel.getMailboxProperties(anything$5())).thenResolve(mailboxProperties);
		calendarModel = (0, import_testdouble$36.instance)(CalendarModel);
		(0, import_testdouble$36.when)(calendarModel.getEventsByUid(anything$5())).thenResolve({
			ownerGroup: "whatever",
			progenitor: null,
			alteredInstances: []
		});
		mockAttribute(calendarModel, calendarModel.processCalendarEventMessage, () => Promise.resolve());
		logins = (0, import_testdouble$36.instance)(LoginController);
		(0, import_testdouble$36.when)(logins.getUserController()).thenReturn(userController);
		calendarNotificationSender = (0, import_testdouble$36.instance)(CalendarNotificationSender);
		sendMailModel = (0, import_testdouble$36.instance)(SendMailModel);
		calendarIniviteHandler = new CalendarInviteHandler(maiboxModel, calendarModel, logins, calendarNotificationSender, async () => {
			return sendMailModel;
		});
	});
	dist_default.spec("ReplyToEventInvitation", function() {
		dist_default("respond yes to event", async function() {
			const sender = "sender@example.com";
			const attendee = "attendee@example.com";
			const event = createTestEntity(CalendarEventTypeRef, {
				uid: "uid",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: attendee }),
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})]
			});
			const ownAttendee = findAttendeeInAddresses(event.attendees, [attendee]);
			let mail = createTestEntity(MailTypeRef);
			mail.sender = createMailAddress({
				address: sender,
				name: "whatever",
				contact: null
			});
			(0, import_testdouble$36.when)(calendarModel.getCalendarInfos()).thenResolve(calendars);
			dist_default(await calendarIniviteHandler.replyToEventInvitation(event, ownAttendee, CalendarAttendeeStatus.ACCEPTED, mail, mailboxDetails)).equals(ReplyResult.ReplySent);
			dist_default(calendarModel.processCalendarEventMessage.callCount).equals(1);
		});
		dist_default("respond no to event", async function() {
			const sender = "sender@example.com";
			const attendee = "attendee@example.com";
			const event = createTestEntity(CalendarEventTypeRef, {
				uid: "uid",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: attendee }),
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})]
			});
			const ownAttendee = findAttendeeInAddresses(event.attendees, [attendee]);
			let mail = createTestEntity(MailTypeRef);
			mail.sender = createMailAddress({
				address: sender,
				name: "whatever",
				contact: null
			});
			(0, import_testdouble$36.when)(calendarModel.getCalendarInfos()).thenResolve(calendars);
			dist_default(await calendarIniviteHandler.replyToEventInvitation(event, ownAttendee, CalendarAttendeeStatus.DECLINED, mail, mailboxDetails)).equals(ReplyResult.ReplySent);
			dist_default(calendarModel.processCalendarEventMessage.callCount).equals(0);
		});
		dist_default("respond yes to event on read only shared calendar", async function() {
			const sender = "sender@example.com";
			const attendee = "attendee@example.com";
			const event = createTestEntity(CalendarEventTypeRef, {
				organizer: createTestEntity(EncryptedMailAddressTypeRef, {
					address: sender,
					name: "sender"
				}),
				_ownerGroup: "ownergroup",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: sender }),
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: createTestEntity(EncryptedMailAddressTypeRef, { address: attendee }),
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})]
			});
			const ownAttendee = findAttendeeInAddresses(event.attendees, [attendee]);
			let mail = createTestEntity(MailTypeRef);
			mail.sender = createMailAddress({
				address: sender,
				name: "whatever",
				contact: null
			});
			(0, import_testdouble$36.when)(calendarModel.getCalendarInfos()).thenResolve(new Map());
			dist_default(await calendarIniviteHandler.replyToEventInvitation(event, ownAttendee, CalendarAttendeeStatus.DECLINED, mail, mailboxDetails)).equals(ReplyResult.ReplySent);
			dist_default(calendarModel.processCalendarEventMessage.callCount).equals(0);
		});
	});
});

//#endregion
//#region tests/calendar/CalendarParserTest.ts
dist_default.spec("CalendarParser", function() {
	dist_default.spec("propertySequenceParser", function() {
		dist_default("simple value", function() {
			dist_default(propertySequenceParser(new StringIterator("DTSTART:20190531T083000Z"))).deepEquals([
				"DTSTART",
				null,
				":",
				"20190531T083000Z"
			]);
		});
		dist_default("simple value, property parameter", function() {
			dist_default(propertySequenceParser(new StringIterator("DTSTART;VALUE=DATE:20190607"))).deepEquals([
				"DTSTART",
				[";", [[
					"VALUE",
					"=",
					"DATE"
				]]],
				":",
				"20190607"
			]);
		});
		dist_default("simple value, multiple property parameters", function() {
			dist_default(propertySequenceParser(new StringIterator("DTSTART;VALUE=DATE;ANOTHER=VALUE;QUOTED=\"IN ; QUOTES\":20190607"))).deepEquals([
				"DTSTART",
				[";", [
					[
						"VALUE",
						"=",
						"DATE"
					],
					[
						"ANOTHER",
						"=",
						"VALUE"
					],
					[
						"QUOTED",
						"=",
						"IN ; QUOTES"
					]
				]],
				":",
				"20190607"
			]);
		});
		dist_default("key-value value", function() {
			dist_default(propertySequenceParser(new StringIterator("RRULE:FREQ=WEEKLY;BYDAY=SA"))).deepEquals([
				"RRULE",
				null,
				":",
				"FREQ=WEEKLY;BYDAY=SA"
			]);
		});
	});
	dist_default.spec("parseProperty", function() {
		dist_default("simple value", function() {
			dist_default(parseProperty("DTSTART:20190531T083000Z")).deepEquals({
				name: "DTSTART",
				params: {},
				value: "20190531T083000Z"
			});
		});
		dist_default("simple value, property parameter", function() {
			dist_default(parseProperty("DTSTART;VALUE=DATE:20190607")).deepEquals({
				name: "DTSTART",
				params: { VALUE: "DATE" },
				value: "20190607"
			});
		});
		dist_default("value with colon", function() {
			dist_default(parseProperty("DTSTART:https://stuff")).deepEquals({
				name: "DTSTART",
				params: {},
				value: "https://stuff"
			});
		});
		dist_default("value with semicolon", function() {
			dist_default(parseProperty("DTSTART:some\\;things")).deepEquals({
				name: "DTSTART",
				params: {},
				value: "some;things"
			});
		});
		dist_default("accept malformed custom property", function() {
			dist_default(parseProperty("CUSTOM_PROP:some value")).deepEquals({
				name: "CUSTOM_PROP",
				params: {},
				value: "some value"
			});
		});
	});
	dist_default("parsePropertyKeyValue", function() {
		dist_default(parsePropertyKeyValue("KEY=VALUE")).deepEquals({ KEY: "VALUE" });
		dist_default(parsePropertyKeyValue("KEY=VALUE;ANOTHERKEY=ANOTHERVALUE")).deepEquals({
			KEY: "VALUE",
			ANOTHERKEY: "ANOTHERVALUE"
		});
	});
	dist_default("parseDuration", function() {
		dist_default(parseDuration("P")).deepEquals({
			positive: true,
			day: undefined,
			hour: undefined,
			minute: undefined,
			week: undefined
		});
		dist_default(parseDuration("P8W")).deepEquals({
			positive: true,
			day: undefined,
			hour: undefined,
			minute: undefined,
			week: 8
		});
		dist_default(parseDuration("-P11W6D")).deepEquals({
			positive: false,
			day: 6,
			hour: undefined,
			minute: undefined,
			week: 11
		});
		dist_default(parseDuration("P36WT21H")).deepEquals({
			positive: true,
			day: undefined,
			hour: 21,
			minute: undefined,
			week: 36
		});
		dist_default(parseDuration("P1WT1M")).deepEquals({
			positive: true,
			day: undefined,
			hour: undefined,
			minute: 1,
			week: 1
		});
		dist_default(parseDuration("-P11W6DT15H")).deepEquals({
			positive: false,
			day: 6,
			hour: 15,
			minute: undefined,
			week: 11
		});
		dist_default(parseDuration("P2W5DT30M")).deepEquals({
			positive: true,
			day: 5,
			hour: undefined,
			minute: 30,
			week: 2
		});
		dist_default(parseDuration("-P11WT15H15M")).deepEquals({
			positive: false,
			day: undefined,
			hour: 15,
			minute: 15,
			week: 11
		});
		dist_default(parseDuration("-P5W4DT3H18M")).deepEquals({
			positive: false,
			day: 4,
			hour: 3,
			minute: 18,
			week: 5
		});
		dist_default(parseDuration("P3D")).deepEquals({
			positive: true,
			day: 3,
			hour: undefined,
			minute: undefined,
			week: undefined
		});
		dist_default(parseDuration("P22DT60H")).deepEquals({
			positive: true,
			day: 22,
			hour: 60,
			minute: undefined,
			week: undefined
		});
		dist_default(parseDuration("P4DT20M")).deepEquals({
			positive: true,
			day: 4,
			hour: undefined,
			minute: 20,
			week: undefined
		});
		dist_default(parseDuration("P40DT60H120M")).deepEquals({
			positive: true,
			day: 40,
			hour: 60,
			minute: 120,
			week: undefined
		});
		dist_default(parseDuration("-PT4H")).deepEquals({
			positive: false,
			day: undefined,
			hour: 4,
			minute: undefined,
			week: undefined
		});
		dist_default(parseDuration("PT3H15M")).deepEquals({
			positive: true,
			day: undefined,
			hour: 3,
			minute: 15,
			week: undefined
		});
		dist_default(parseDuration("PT18M")).deepEquals({
			positive: true,
			day: undefined,
			hour: undefined,
			minute: 18,
			week: undefined
		});
		dist_default(parseDuration("P60DT15M05S")).deepEquals({
			positive: true,
			day: 60,
			hour: undefined,
			minute: 15,
			week: undefined
		});
		dist_default(() => parseDuration("P8W15M")).throws(Error);
	});
	dist_default("triggerToAlarmInterval", function() {
		dist_default(triggerToAlarmInterval(getDateInUTC("2023-10-01T15:00"), "-PT5H30M")).deepEquals({
			unit: AlarmIntervalUnit.MINUTE,
			value: 330
		});
		dist_default(triggerToAlarmInterval(getDateInUTC("2023-10-01T15:00"), "-PT5H30M20S")).deepEquals({
			unit: AlarmIntervalUnit.MINUTE,
			value: 330
		});
		dist_default(triggerToAlarmInterval(getDateInUTC("2023-10-01T15:00"), "-PT5H0M")).deepEquals({
			unit: AlarmIntervalUnit.HOUR,
			value: 5
		});
		dist_default(triggerToAlarmInterval(getDateInUTC("2023-10-01T15:00"), "-P1DT5H0M")).deepEquals({
			unit: AlarmIntervalUnit.HOUR,
			value: 29
		});
	});
	dist_default("parseTime", function() {
		dist_default(parseTime("20180115T214000Z", "Europe/Berlin")).deepEquals({
			date: new Date(Date.UTC(2018, 0, 15, 21, 40, 0)),
			allDay: false
		});
		dist_default(parseTime("20180115T", "Europe/Berlin")).deepEquals({
			date: new Date(Date.UTC(2018, 0, 15, 0, 0, 0)),
			allDay: true
		});
		dist_default(() => parseTime("20180015T214000Z", "Europe/Berlin")).throws(ParserError);
	});
	dist_default.spec("parseCalendarEvents: fix illegal end times", function() {
		const makeEvent$1 = ({ start, end }) => parseICalendar("BEGIN:VCALENDAR\nVERSION:2.0\nBEGIN:VEVENT\nUID:0c838926-f826-43c9-9f17-4836c565eece\nDTSTAMP:20220106T214416Z\nSUMMARY;LANGUAGE=de:Gelber Sack\n" + `DTSTART:${start}\n` + `DTEND:${end}\n` + "DESCRIPTION:Gelber Sack\n" + "LOCATION:test\n" + "END:VEVENT\n" + "END:VCALENDAR");
		const testParseIllegalCalendarEvents = ({ start, end, expect }) => {
			const event = makeEvent$1({
				start,
				end
			});
			const { event: parsedEvent } = parseCalendarEvents(event, "Europe/Berlin").contents[0];
			dist_default(parsedEvent.endTime.getTime()).equals(expect);
		};
		dist_default("allday equal", function() {
			testParseIllegalCalendarEvents({
				start: "20220315T",
				end: "20220315T",
				expect: parseTime("20220316T", "Europe/Berlin").date.getTime()
			});
		});
		dist_default("allday flipped", function() {
			testParseIllegalCalendarEvents({
				start: "20220315T",
				end: "20220314T",
				expect: parseTime("20220316T", "Europe/Berlin").date.getTime()
			});
		});
		dist_default("allday with an endTime that has hours/minutes/seconds", function() {
			testParseIllegalCalendarEvents({
				start: "20220315T",
				end: "20220314T225915Z",
				expect: parseTime("20220316T", "Europe/Berlin").date.getTime()
			});
		});
		dist_default("endTime equal", function() {
			testParseIllegalCalendarEvents({
				start: "20220315T225900Z",
				end: "20220315T225900Z",
				expect: new Date("2022-03-15T22:59:01.000Z").getTime()
			});
		});
		dist_default("endTime flipped", function() {
			testParseIllegalCalendarEvents({
				start: "20220315T225900Z",
				end: "20220315T225800Z",
				expect: new Date("2022-03-15T22:59:01.000Z").getTime()
			});
		});
	});
	dist_default.spec("parseUntilRruleTime", function() {
		dist_default("when given full UTC date it gives the beginning of the next day", function() {
			const zone$3 = "Asia/Krasnoyarsk";
			dist_default(parseUntilRruleTime("20190919T235959Z", zone$3)).deepEquals(DateTime.fromObject({
				year: 2019,
				month: 9,
				day: 20
			}, { zone: zone$3 }).toJSDate());
		});
	});
	dist_default.spec("parseExcludedDates", function() {
		dist_default("are excluded dates deduplicated", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: {},
				value: "20230308T230000Z,20230308T230000Z,20230309T230000Z"
			}]);
			dist_default(parsedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-08T23:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T23:00:00Z") })]);
		});
		dist_default("are excluded dates sorted", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: {},
				value: "20230313T230000Z,20230309T230000Z"
			}]);
			dist_default(parsedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T23:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-13T23:00:00Z") })]);
		});
		dist_default("multiple exdates in separate lines are parsed", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: {},
				value: "20230309T230000Z"
			}, {
				name: "EXDATES",
				params: {},
				value: "20230203T230000Z"
			}]);
			dist_default(parsedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-02-03T23:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T23:00:00Z") })]);
		});
		dist_default("deduplication over multiple lines works", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: {},
				value: "20230309T230000Z,20230302T230000Z"
			}, {
				name: "EXDATES",
				params: {},
				value: "20230309T230000Z,20230114T230000Z"
			}]);
			dist_default(parsedDates).deepEquals([
				createTestEntity(DateWrapperTypeRef, { date: new Date("2023-01-14T23:00:00Z") }),
				createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T23:00:00Z") }),
				createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T23:00:00Z") })
			]);
		});
		dist_default("is timezone parsed", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: { TZID: "Europe/Berlin" },
				value: "20230309T230000,20230302T230000"
			}]);
			dist_default(parsedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-02T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T22:00:00Z") })]);
		});
		dist_default(" deduplication over different timezones", function() {
			const parsedDates = parseExDates([{
				name: "EXDATES",
				params: { TZID: "Europe/Berlin" },
				value: "20230309T230000"
			}, {
				name: "EXDATES",
				params: { TZID: "Europe/Sofia" },
				value: "20230310T000000"
			}]);
			dist_default(parsedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-09T22:00:00Z") })]);
		});
	});
	dist_default.spec("parseRecurrenceId", function() {
		dist_default("it uses UTC for absolute time", function() {
			const parsedId = parseRecurrenceId({
				name: "RECURRENCE-ID",
				params: { VALUE: "DATETIME" },
				value: "20230809T060000Z"
			}, zone);
			dist_default(parsedId).deepEquals(getDateInUTC("2023-08-09T06:00"));
		});
		dist_default("it uses TZID from param for relative time", function() {
			const parsedId = parseRecurrenceId({
				name: "RECURRENCE-ID",
				params: {
					VALUE: "DATETIME",
					TZID: "Europe/Sofia"
				},
				value: "20230310T000000"
			}, zone);
			dist_default(parsedId).deepEquals(getDateInUTC("2023-03-09T22:00:00Z"));
		});
		dist_default("it uses TZID from param when none are in the value", function() {
			const parsedId = parseRecurrenceId({
				name: "RECURRENCE-ID",
				params: { VALUE: "DATETIME" },
				value: "20230310T000000"
			}, "Europe/Sofia");
			dist_default(parsedId).deepEquals(getDateInUTC("2023-03-09T22:00:00Z"));
		});
	});
});

//#endregion
//#region tests/calendar/CalendarImporterTest.ts
const zone$1 = "Europe/Berlin";
const now = new Date("2019-08-13T14:01:00.630Z");
function jsonEquals(actual, expected, message) {
	const firstJson = JSON.stringify(actual);
	const secondJson = JSON.stringify(expected);
	const isEqual = firstJson === secondJson;
	if (isEqual) return {
		pass: true,
		message: "okay"
	};
else {
		let firstDiff = 0;
		while (firstJson[firstDiff] === secondJson[firstDiff]) firstDiff++;
		firstDiff = Math.max(firstDiff - 25, 0);
		return {
			pass: false,
			message: `${message}:\nfirst diff in json serialization around \nact: ...${firstJson.substring(firstDiff, firstDiff + 50)}... vs. \nexp: ...${secondJson.substring(firstDiff, firstDiff + 50)}...`
		};
	}
}
function testEventEquality(actual, expected, message = "") {
	dist_default(actual).satisfies((a) => jsonEquals(a, expected, message));
}
dist_default.spec("CalendarImporterTest", function() {
	dist_default.spec("serializeEvent", function() {
		dist_default("simple one", function() {
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				description: "Descr \\ ;, \n",
				uid: "test@tuta.com",
				location: "Some location"
			}), [], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				"DTSTART:20190813T030600Z",
				"DTEND:20190913T030600Z",
				`DTSTAMP:20190813T140100Z`,
				"UID:test@tuta.com",
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"DESCRIPTION:Descr \\\\ \\;\\, \\n",
				"LOCATION:Some location",
				"END:VEVENT"
			]);
		});
		dist_default("all day", function() {
			const zone$3 = "utc";
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13
				}, { zone: zone$3 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 14
				}, { zone: zone$3 }).toJSDate(),
				description: "Descr \\ ; \n"
			}), [], now, zone$3)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;VALUE=DATE:20190813`,
				`DTEND;VALUE=DATE:20190914`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"DESCRIPTION:Descr \\\\ \\; \\n",
				"END:VEVENT"
			]);
		});
		dist_default("all day west of UTC", function() {
			const zone$3 = "America/New_York";
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "s",
				startTime: getAllDayDateUTC(DateTime.fromObject({
					year: 2020,
					month: 7,
					day: 31
				}).toJSDate()),
				endTime: getAllDayDateUTC(DateTime.fromObject({
					year: 2020,
					month: 8,
					day: 1
				}).toJSDate()),
				description: "d"
			}), [], now, zone$3)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;VALUE=DATE:20200731`,
				`DTEND;VALUE=DATE:20200801`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:s",
				"DESCRIPTION:d",
				"END:VEVENT"
			]);
		});
		dist_default("with alarms", function() {
			const alarmOne = createTestEntity(UserAlarmInfoTypeRef, { alarmInfo: createTestEntity(AlarmInfoTypeRef, {
				alarmIdentifier: "123",
				trigger: "1D"
			}) });
			const alarmTwo = createTestEntity(UserAlarmInfoTypeRef, { alarmInfo: createTestEntity(AlarmInfoTypeRef, {
				alarmIdentifier: "102",
				trigger: "30M"
			}) });
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				description: "Descr \\ ; \n"
			}), [alarmOne, alarmTwo], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				"DTSTART:20190813T030600Z",
				"DTEND:20190913T030600Z",
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"DESCRIPTION:Descr \\\\ \\; \\n",
				"BEGIN:VALARM",
				"ACTION:DISPLAY",
				"DESCRIPTION:This is an event reminder",
				"TRIGGER:-P1D",
				"END:VALARM",
				"BEGIN:VALARM",
				"ACTION:DISPLAY",
				"DESCRIPTION:This is an event reminder",
				"TRIGGER:-PT30M",
				"END:VALARM",
				"END:VEVENT"
			]);
		});
		dist_default("with repeat rule (never ends)", function() {
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.Never,
					interval: "3",
					frequency: RepeatPeriod.WEEKLY,
					timeZone: zone$1
				})
			}), [], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;TZID=${zone$1}:20190813T050600`,
				`DTEND;TZID=${zone$1}:20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"RRULE:FREQ=WEEKLY;INTERVAL=3",
				"END:VEVENT"
			]);
		});
		dist_default("with repeat rule (ends after occurrences)", function() {
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.Count,
					interval: "3",
					frequency: RepeatPeriod.DAILY,
					endValue: "100",
					timeZone: zone$1
				})
			}), [], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;TZID=${zone$1}:20190813T050600`,
				`DTEND;TZID=${zone$1}:20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"RRULE:FREQ=DAILY;INTERVAL=3;COUNT=100",
				"END:VEVENT"
			]);
		});
		dist_default("with repeat rule (ends on a date)", function() {
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				endTime: DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 13,
					hour: 5,
					minute: 6
				}, { zone: zone$1 }).toJSDate(),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.UntilDate,
					interval: "3",
					frequency: RepeatPeriod.MONTHLY,
					endValue: String(DateTime.fromObject({
						year: 2019,
						month: 9,
						day: 20
					}, { zone: zone$1 }).toMillis()),
					timeZone: zone$1
				})
			}), [], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;TZID=${zone$1}:20190813T050600`,
				`DTEND;TZID=${zone$1}:20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"RRULE:FREQ=MONTHLY;INTERVAL=3;UNTIL=20190919T215959Z",
				"END:VEVENT"
			]);
		});
		dist_default("with repeat rule (ends on a date, all-day)", function() {
			dist_default(serializeEvent(createTestEntity(CalendarEventTypeRef, {
				_id: ["123", "456"],
				_ownerGroup: "ownerId",
				summary: "Word \\ ; \n",
				startTime: getAllDayDateUTC(DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 13
				}).toJSDate()),
				endTime: getAllDayDateUTC(DateTime.fromObject({
					year: 2019,
					month: 8,
					day: 15
				}).toJSDate()),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.UntilDate,
					interval: "3",
					frequency: RepeatPeriod.MONTHLY,
					endValue: String(getAllDayDateUTC(DateTime.fromObject({
						year: 2019,
						month: 9,
						day: 20
					}).toJSDate()).getTime()),
					timeZone: zone$1
				})
			}), [], now, zone$1)).deepEquals([
				"BEGIN:VEVENT",
				`DTSTART;VALUE=DATE:20190813`,
				`DTEND;VALUE=DATE:20190815`,
				`DTSTAMP:20190813T140100Z`,
				`UID:ownerId${now.getTime()}@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\\\ \\; \\n",
				"RRULE:FREQ=MONTHLY;INTERVAL=3;UNTIL=20190919",
				"END:VEVENT"
			]);
		});
	});
	dist_default.spec("import", function() {
		dist_default("regular event", async function() {
			const actual = await parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:Word \\N \\\\ \\;\\, \\n",
				"RRULE:FREQ=WEEKLY;INTERVAL=3",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1);
			const expected = {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "Word \n \\ ;, \n",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						repeatRule: createTestEntity(RepeatRuleTypeRef, {
							endType: EndType.Never,
							interval: "3",
							frequency: RepeatPeriod.WEEKLY,
							timeZone: zone$1
						})
					}),
					alarms: []
				}]
			};
			testEventEquality(actual, expected);
		});
		dist_default("with attendee", async function() {
			const parsedEvent = parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:s",
				"ORGANIZER:mailto:organizer@tuta.com",
				"ATTENDEE;PARTSTAT=NEEDS-ACTION:mailto:test@example.com",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1);
			const expected = {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "s",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						organizer: createTestEntity(EncryptedMailAddressTypeRef, {
							name: "",
							address: "organizer@tuta.com"
						}),
						attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, {
								name: "",
								address: "test@example.com"
							}),
							status: CalendarAttendeeStatus.NEEDS_ACTION
						})]
					}),
					alarms: []
				}]
			};
			testEventEquality(parsedEvent, expected);
		});
		dist_default("with attendee uppercase mailto", async function() {
			const parsedEvent = parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:s",
				"ORGANIZER:MAILTO:organizer@tuta.com",
				"ATTENDEE;PARTSTAT=NEEDS-ACTION:MAILTO:test@example.com",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1);
			const expected = {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "s",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						organizer: createTestEntity(EncryptedMailAddressTypeRef, {
							name: "",
							address: "organizer@tuta.com"
						}),
						attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, {
								name: "",
								address: "test@example.com"
							}),
							status: CalendarAttendeeStatus.NEEDS_ACTION
						})]
					}),
					alarms: []
				}]
			};
			testEventEquality(parsedEvent, expected);
		});
		dist_default("with attendee without PARTSTAT", async function() {
			const parsedEvent = parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SEQUENCE:0",
				"SUMMARY:s",
				"ORGANIZER:MAILTO:organizer@tuta.com",
				"ATTENDEE:mailto:test@example.com",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1);
			const expected = {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "s",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						organizer: createTestEntity(EncryptedMailAddressTypeRef, {
							name: "",
							address: "organizer@tuta.com"
						}),
						attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
							address: createTestEntity(EncryptedMailAddressTypeRef, {
								name: "",
								address: "test@example.com"
							}),
							status: CalendarAttendeeStatus.NEEDS_ACTION
						})]
					}),
					alarms: []
				}]
			};
			testEventEquality(parsedEvent, expected);
		});
		dist_default("all-day event", async function() {
			testEventEquality(parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				"SUMMARY:Labor Day / May Day",
				"DTSTART;VALUE=DATE:20200501",
				"DTEND;VALUE=DATE:20200502",
				"LOCATION:Brazil",
				"DESCRIPTION:Some description",
				"UID:5e528f277e20e1582468903@calendarlabs.com",
				"DTSTAMP:20200223T144143Z",
				"STATUS:CONFIRMED",
				"TRANSP:TRANSPARENT",
				"SEQUENCE:0",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1).contents[0], {
				event: createTestEntity(CalendarEventTypeRef, {
					summary: "Labor Day / May Day",
					startTime: getAllDayDateUTCFromZone(DateTime.fromObject({
						year: 2020,
						month: 5,
						day: 1
					}, { zone: zone$1 }).toJSDate(), zone$1),
					endTime: getAllDayDateUTCFromZone(DateTime.fromObject({
						year: 2020,
						month: 5,
						day: 2
					}, { zone: zone$1 }).toJSDate(), zone$1),
					uid: "5e528f277e20e1582468903@calendarlabs.com",
					hashedUid: null,
					description: "Some description",
					location: "Brazil"
				}),
				alarms: []
			});
		});
		dist_default("recurrence id on event without UID will be deleted", async function() {
			const expected = {
				event: createTestEntity(CalendarEventTypeRef, {
					startTime: new Date("2023-07-04T15:00:00.000Z"),
					endTime: new Date("2023-07-04T15:30:00.000Z"),
					sequence: "1",
					summary: "bkbkbkb",
					recurrenceId: null
				}),
				alarms: []
			};
			const parsed = parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.115.0//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				"DTSTART:20230704T150000Z",
				"DTEND:20230704T153000Z",
				"DTSTAMP:20230712T142825Z",
				"SEQUENCE:1",
				"SUMMARY:bkbkbkb",
				"RECURRENCE-ID:20230704T170000",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1).contents[0];
			dist_default(parsed.event.uid).notEquals(null);
			parsed.event.uid = null;
			testEventEquality(parsed, expected);
		});
		dist_default("all-day event with invalid DTEND", async function() {
			testEventEquality(parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6Yup//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				"SUMMARY:Labor Day / May Day",
				"DTSTART;VALUE=DATE:20200501",
				"DTEND;VALUE=DATE:20200501",
				"LOCATION:Brazil",
				"DESCRIPTION:Some description",
				"UID:5e528f277e20e1582468903@calendarlabs.com",
				"DTSTAMP:20200223T144143Z",
				"STATUS:CONFIRMED",
				"TRANSP:TRANSPARENT",
				"SEQUENCE:0",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1).contents[0], {
				event: createTestEntity(CalendarEventTypeRef, {
					summary: "Labor Day / May Day",
					startTime: getAllDayDateUTCFromZone(DateTime.fromObject({
						year: 2020,
						month: 5,
						day: 1
					}, { zone: zone$1 }).toJSDate(), zone$1),
					endTime: getAllDayDateUTCFromZone(DateTime.fromObject({
						year: 2020,
						month: 5,
						day: 2
					}, { zone: zone$1 }).toJSDate(), zone$1),
					uid: "5e528f277e20e1582468903@calendarlabs.com",
					hashedUid: null,
					description: "Some description",
					location: "Brazil"
				}),
				alarms: []
			});
		});
		dist_default("with relative non-standard alarm", async function() {
			testEventEquality(parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SUMMARY:Word \\\\ \\; \\n",
				"BEGIN:VALARM",
				"ACTION:DISPLAY",
				"TRIGGER:-P15D",
				"END:VALARM",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1), {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "Word \\ ; \n",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						repeatRule: null
					}),
					alarms: [{
						trigger: "15D",
						alarmIdentifier: ""
					}]
				}]
			});
		});
		dist_default("with absolute alarm", async function() {
			testEventEquality(parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SUMMARY:Word \\\\ \\; \\n",
				"BEGIN:VALARM",
				"ACTION:DISPLAY",
				"TRIGGER;VALUE=DATE-TIME:20190813T020000Z",
				"END:VALARM",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1), {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "Word \\ ; \n",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						repeatRule: null
					}),
					alarms: [{
						trigger: "66M",
						alarmIdentifier: ""
					}]
				}]
			});
		});
		dist_default("with alarm in the future", async function() {
			testEventEquality(parseCalendarStringData([
				"BEGIN:VCALENDAR",
				"PRODID:-//Tutao GmbH//Tutanota 3.57.6//EN",
				"VERSION:2.0",
				"CALSCALE:GREGORIAN",
				"METHOD:PUBLISH",
				"BEGIN:VEVENT",
				`DTSTART;TZID="W. Europe Standard Time":20190813T050600`,
				`DTEND;TZID="W. Europe Standard Time":20190913T050600`,
				`DTSTAMP:20190813T140100Z`,
				`UID:test@tuta.com`,
				"SUMMARY:Word \\\\ \\; \\n",
				"BEGIN:VALARM",
				"ACTION:DISPLAY",
				"TRIGGER:P1D",
				"END:VALARM",
				"END:VEVENT",
				"END:VCALENDAR"
			].join("\r\n"), zone$1), {
				method: "PUBLISH",
				contents: [{
					event: createTestEntity(CalendarEventTypeRef, {
						summary: "Word \\ ; \n",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						repeatRule: null
					}),
					alarms: []
				}]
			});
		});
		dist_default("import and re-export descriptions exported from outlook", async function() {
			const text = `BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:REPLY
BEGIN:VEVENT
DTSTART:20221026T210000Z
DTEND:20221026T220000Z
DTSTAMP:20221018T202558Z
UID:040000008200E00074C5B7101A82E00800000000B073543805E3D801000000000000000010000000EA368AA63E095848BAEEE25C239F56C6
SEQUENCE:0
SUMMARY:App Feedback Session
DESCRIPTION:\\n________________________________________________________________________________\\nMicrosoft Teams meeting\\nJoin on your computer\\, mobile app or room device\\nUnited States\\, Minneapolis\\nPhone Conference ID: 000 000 000
LOCATION:Microsoft Teams Meeting
ORGANIZER;EMAIL=Mary.Doe@example.com:mailto:Mary.Doe@example.com
ATTENDEE;CUTYPE=INDIVIDUAL;ROLE=REQ-PARTICIPANT;PARTSTAT=ACCEPTED;RSVP=TRUE;CN="Dack";EMAIL=dack@example.com:mailto:dack@example.com
END:VEVENT
END:VCALENDAR`;
			const parsed = parseCalendarStringData(text, zone$1);
			const serialized = [
				"BEGIN:VCALENDAR",
				`VERSION:2.0`,
				`CALSCALE:GREGORIAN`,
				`METHOD:REPLY`,
				...serializeEvent(parsed.contents[0].event, [], new Date(), zone$1),
				"END:VCALENDAR"
			].join("\n");
			const parsedAgain = parseCalendarStringData(serialized, zone$1);
			dist_default(parsedAgain.contents[0].event.description).equals("\n________________________________________________________________________________\nMicrosoft Teams meeting\nJoin on your computer, mobile app or room device\nUnited States, Minneapolis\nPhone Conference ID: 000 000 000");
		});
		dist_default("roundtrip export -> import", async function() {
			const alarmOne = createTestEntity(UserAlarmInfoTypeRef, { alarmInfo: createTestEntity(AlarmInfoTypeRef, { trigger: "1D" }) });
			const alarmTwo = createTestEntity(UserAlarmInfoTypeRef, { alarmInfo: createTestEntity(AlarmInfoTypeRef, { trigger: "30M" }) });
			const events = [
				{
					event: createTestEntity(CalendarEventTypeRef, {
						_id: ["123", "456"],
						summary: "Word \\ ; \n simple",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 1,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						description: "Descr \\ ; \n",
						uid: "test@tuta.com",
						hashedUid: null,
						sequence: "1"
					}),
					alarms: []
				},
				{
					event: createTestEntity(CalendarEventTypeRef, {
						_id: ["123", "456"],
						_ownerGroup: "ownerId",
						summary: "Word \\ ; \n alarms",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						sequence: "2",
						uid: "test@tuta.com",
						hashedUid: null
					}),
					alarms: [alarmOne, alarmTwo]
				},
				{
					event: createTestEntity(CalendarEventTypeRef, {
						_id: ["123", "456"],
						_ownerGroup: "ownerId",
						summary: "Word \\ ; \n",
						startTime: DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						endTime: DateTime.fromObject({
							year: 2019,
							month: 9,
							day: 13,
							hour: 5,
							minute: 6
						}, { zone: zone$1 }).toJSDate(),
						uid: "test@tuta.com",
						hashedUid: null,
						repeatRule: createTestEntity(RepeatRuleTypeRef, {
							endType: EndType.UntilDate,
							interval: "3",
							frequency: RepeatPeriod.MONTHLY,
							endValue: String(DateTime.fromObject({
								year: 2019,
								month: 9,
								day: 20
							}, { zone: zone$1 }).toMillis()),
							timeZone: zone$1
						})
					}),
					alarms: []
				},
				{
					event: createTestEntity(CalendarEventTypeRef, {
						_id: ["123", "456"],
						_ownerGroup: "ownerId",
						summary: "Word \\ ; \n",
						startTime: getAllDayDateUTC(DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 13
						}).toJSDate()),
						endTime: getAllDayDateUTC(DateTime.fromObject({
							year: 2019,
							month: 8,
							day: 15
						}).toJSDate()),
						uid: "b64lookingValue==",
						hashedUid: null,
						repeatRule: createTestEntity(RepeatRuleTypeRef, {
							endType: EndType.UntilDate,
							interval: "3",
							frequency: RepeatPeriod.MONTHLY,
							endValue: String(getAllDayDateUTC(DateTime.fromObject({
								year: 2019,
								month: 9,
								day: 20
							}, { zone: zone$1 }).toJSDate()).getTime())
						})
					}),
					alarms: []
				}
			];
			const versionNumber = "3.57.6";
			const serialized = serializeCalendar(versionNumber, events, now, zone$1);
			const eventsWithoutIds = events.map(({ event, alarms }) => {
				return {
					event: Object.assign({}, event, {
						_id: null,
						uid: event.uid,
						hashedUid: event.hashedUid,
						_ownerGroup: null
					}),
					alarms: alarms.map((a) => ({
						trigger: a.alarmInfo.trigger,
						alarmIdentifier: a.alarmInfo.alarmIdentifier
					}))
				};
			});
			const parsed = parseCalendarStringData(serialized, zone$1);
			dist_default(parsed.method).equals("PUBLISH")("wrong method");
			for (const i in eventsWithoutIds) testEventEquality(parsed.contents[i], eventsWithoutIds[i], `failed for event ${i}`);
		});
		dist_default("roundtrip import -> export", async function() {
			const text = `BEGIN:VCALENDAR
PRODID:-//Tutao GmbH//Tutanota 3.57.6//EN
VERSION:2.0
CALSCALE:GREGORIAN
METHOD:PUBLISH
BEGIN:VEVENT
DTSTART:20190813T030600Z
DTEND:20190913T030600Z
DTSTAMP:20190813T140100Z
UID:test@tuta.com
SEQUENCE:1
SUMMARY:Word \\\\ \\; \\n simple
DESCRIPTION:Descr \\\\ \\; \\n
END:VEVENT
BEGIN:VEVENT
DTSTART:20190813T030600Z
DTEND:20190913T030600Z
DTSTAMP:20190813T140100Z
UID:123456@tuta.com
SEQUENCE:0
SUMMARY:Word \\\\ \\; \\n alarms
BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:This is an event reminder
TRIGGER:-P1D
END:VALARM
BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:This is an event reminder
TRIGGER:-PT30M
END:VALARM
END:VEVENT
BEGIN:VEVENT
DTSTART;TZID=Europe/Berlin:20190813T050600
DTEND;TZID=Europe/Berlin:20190913T050600
DTSTAMP:20190813T140100Z
UID:123456@tuta.com
SEQUENCE:2
SUMMARY:Word \\\\ \\; \\n repeating
RRULE:FREQ=MONTHLY;INTERVAL=3;UNTIL=20190919T215959Z
END:VEVENT
BEGIN:VEVENT
DTSTART;VALUE=DATE:20190813
DTEND;VALUE=DATE:20190815
DTSTAMP:20190813T140100Z
UID:b64lookingValue==
SEQUENCE:0
SUMMARY:Word \\\\ \\; \\n
RRULE:FREQ=MONTHLY;INTERVAL=3;UNTIL=20190919
END:VEVENT
END:VCALENDAR`.split("\n").join("\r\n");
			const zone$3 = "Europe/Berlin";
			const versionNumber = "3.57.6";
			const parsed = parseCalendarStringData(text, zone$3);
			const serialized = serializeCalendar(versionNumber, parsed.contents.map(({ event, alarms }) => {
				return {
					event: Object.assign({}, event, { _id: ["123", "456"] }),
					alarms: alarms.map((alarmInfo) => createTestEntity(UserAlarmInfoTypeRef, { alarmInfo }))
				};
			}), now, zone$3);
			dist_default(serialized).equals(text);
		});
	});
	dist_default.spec("sortOutParsedEvents", function() {
		dist_default("repeated progenitors are skipped", function() {
			const progenitor1 = createTestEntity(CalendarEventTypeRef, {
				uid: "hello",
				startTime: getDateInZone("2023-01-02T13:00"),
				endTime: getDateInZone("2023-01-02T13:05")
			});
			const progenitor2 = createTestEntity(CalendarEventTypeRef, {
				uid: "hello",
				startTime: getDateInZone("2023-01-01T13:00"),
				endTime: getDateInZone("2023-01-01T13:05")
			});
			const { rejectedEvents, eventsForCreation } = sortOutParsedEvents([{
				event: progenitor1,
				alarms: []
			}, {
				event: progenitor2,
				alarms: []
			}], [], createTestEntity(CalendarGroupRootTypeRef), zone$1);
			dist_default(eventsForCreation[0].event).equals(progenitor1);
			dist_default(rejectedEvents.get(EventImportRejectionReason.Duplicate)?.[0]).equals(progenitor2);
		});
		dist_default("imported altered instances are added as exclusions", function() {
			const progenitor = createTestEntity(CalendarEventTypeRef, {
				uid: "hello",
				startTime: getDateInZone("2023-01-02T13:00"),
				endTime: getDateInZone("2023-01-02T13:05"),
				repeatRule: createTestEntity(RepeatRuleTypeRef)
			});
			const altered = createTestEntity(CalendarEventTypeRef, {
				uid: "hello",
				startTime: getDateInZone("2023-01-02T14:00"),
				endTime: getDateInZone("2023-01-02T14:05"),
				recurrenceId: getDateInZone("2023-01-02T13:00")
			});
			const { rejectedEvents, eventsForCreation } = sortOutParsedEvents([{
				event: progenitor,
				alarms: []
			}, {
				event: altered,
				alarms: []
			}], [], createTestEntity(CalendarGroupRootTypeRef), zone$1);
			dist_default(rejectedEvents.size).equals(0);
			dist_default(eventsForCreation[0].event.repeatRule?.excludedDates[0].date.getTime()).equals(altered.recurrenceId?.getTime());
		});
	});
	dist_default.spec("serializeRepeatRule", function() {
		dist_default("when RRULE is UNTIL and not all date the timestamp of the end of last day is written", function() {
			const repeatRule = createTestEntity(RepeatRuleTypeRef, {
				endType: EndType.UntilDate,
				endValue: String(DateTime.fromObject({
					year: 2019,
					month: 9,
					day: 20
				}, { zone: "UTC" }).toMillis()),
				frequency: RepeatPeriod.MONTHLY,
				interval: "3"
			});
			dist_default(serializeRepeatRule(repeatRule, false, "Asia/Krasnoyarsk")).deepEquals(["RRULE:FREQ=MONTHLY;INTERVAL=3;UNTIL=20190919T235959Z"]);
		});
	});
	dist_default.spec("serializeExcludedDates", function() {
		dist_default("no excluded dates", function() {
			dist_default(serializeExcludedDates([], "Europe/Berlin")).deepEquals([]);
		});
		dist_default("one excluded date", function() {
			dist_default(serializeExcludedDates([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-01-14T22:00:00Z") })], "Europe/Berlin")).deepEquals(["EXDATE;TZID=Europe/Berlin:20230114T230000"]);
		});
		dist_default("more than one excluded date", function() {
			dist_default(serializeExcludedDates([createTestEntity(DateWrapperTypeRef, { date: new Date("2023-01-14T22:00:00Z") }), createTestEntity(DateWrapperTypeRef, { date: new Date("2023-01-21T22:00:00Z") })], "Europe/Berlin")).deepEquals(["EXDATE;TZID=Europe/Berlin:20230114T230000,20230121T230000"]);
		});
	});
	dist_default("serializeTrigger", () => {
		dist_default(serializeTrigger("5M")).equals("-PT5M");
		dist_default(serializeTrigger("3H")).equals("-PT3H");
		dist_default(serializeTrigger("30H")).equals("-PT30H");
		dist_default(serializeTrigger("1D")).equals("-P1D");
		dist_default(serializeTrigger("10D")).equals("-P10D");
		dist_default(serializeTrigger("5W")).equals("-P5W");
		dist_default(serializeTrigger("50W")).equals("-P50W");
	});
});

//#endregion
//#region tests/calendar/AlarmSchedulerTest.ts
dist_default.spec("AlarmScheduler", function() {
	let alarmScheduler;
	let scheduler;
	let now$1;
	const dateProvider$1 = {
		now: () => now$1.toMillis(),
		timeZone: () => "Europe/Berlin"
	};
	dist_default.beforeEach(function() {
		now$1 = DateTime.fromISO("2021-04-20T20:00Z");
		scheduler = new SchedulerMock();
		alarmScheduler = new AlarmScheduler(dateProvider$1, scheduler);
	});
	dist_default.spec("scheduleAlarm", function() {
		dist_default("non-repeating", function() {
			const eventInfo = {
				startTime: DateTime.fromISO("2021-04-21T20:00:00Z").toJSDate(),
				endTime: DateTime.fromISO("2021-04-21T20:30Z").toJSDate(),
				summary: "summary"
			};
			const alarmInfo = createTestEntity(AlarmInfoTypeRef, { trigger: "10M" });
			const notificationSender = spy();
			alarmScheduler.scheduleAlarm(eventInfo, alarmInfo, null, notificationSender);
			const expectedAlarmTime = DateTime.fromISO("2021-04-21T19:50Z").toMillis();
			const scheduled = scheduler.scheduledAt.get(expectedAlarmTime);
			if (scheduled == null) throw new Error("Did not schedule, " + Array.from(scheduler.scheduledAt.keys()).map(Date).join(","));
			scheduled.thunk();
			dist_default(notificationSender.callCount).equals(1);
		});
		dist_default("repeating daily 3 times", function() {
			const eventInfo = {
				startTime: DateTime.fromISO("2021-04-21T20:00:00Z").toJSDate(),
				endTime: DateTime.fromISO("2021-04-21T20:30Z").toJSDate(),
				summary: "summary"
			};
			const alarmInfo = createTestEntity(AlarmInfoTypeRef, { trigger: "30M" });
			const repeatRule = createTestEntity(RepeatRuleTypeRef, {
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endType: EndType.Count,
				endValue: "3",
				timeZone: "Europe/Berlin"
			});
			const notificationSender = spy();
			alarmScheduler.scheduleAlarm(eventInfo, alarmInfo, repeatRule, notificationSender);
			const expectedTimes = [
				DateTime.fromISO("2021-04-21T19:30Z"),
				DateTime.fromISO("2021-04-22T19:30Z"),
				DateTime.fromISO("2021-04-23T19:30Z")
			];
			for (const [idx, time] of expectedTimes.entries()) {
				const scheduled = scheduler.scheduledAt.get(time.toMillis());
				if (scheduled == null) {
					const got = Array.from(scheduler.scheduledAt.keys()).map((t) => DateTime.fromMillis(t).toISO());
					throw new Error(`Did not schedule at ${time.toISO()}, but ${got.join(",")}`);
				}
				now$1 = now$1.plus({ days: 1 });
				scheduled.thunk();
				dist_default(notificationSender.callCount).equals(idx + 1);
			}
		});
		dist_default("repeating with exclusions", function() {
			const eventInfo = {
				startTime: DateTime.fromISO("2021-04-21T20:00:00Z").toJSDate(),
				endTime: DateTime.fromISO("2021-04-21T20:30Z").toJSDate(),
				summary: "summary"
			};
			const alarmInfo = createTestEntity(AlarmInfoTypeRef, { trigger: "30M" });
			const repeatRule = createTestEntity(RepeatRuleTypeRef, {
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endType: EndType.Count,
				endValue: "3",
				timeZone: "Europe/Berlin",
				excludedDates: [createTestEntity(DateWrapperTypeRef, { date: DateTime.fromISO("2021-04-22T20:00Z").toJSDate() })]
			});
			const notificationSender = spy();
			alarmScheduler.scheduleAlarm(eventInfo, alarmInfo, repeatRule, notificationSender);
			const expectedTimes = [DateTime.fromISO("2021-04-21T19:30Z"), DateTime.fromISO("2021-04-23T19:30Z")];
			for (const [idx, time] of expectedTimes.entries()) {
				const scheduled = scheduler.scheduledAt.get(time.toMillis());
				if (scheduled == null) {
					const got = Array.from(scheduler.scheduledAt.keys()).map((t) => DateTime.fromMillis(t).toISO());
					throw new Error(`Did not schedule at ${time.toISO()}, but ${got.join(",")}`);
				}
				now$1 = now$1.plus({ days: 1 });
				scheduled.thunk();
				dist_default(notificationSender.callCount).equals(idx + 1);
			}
		});
	});
	dist_default.spec("cancel alarm", function() {
		dist_default("single", function() {
			const eventInfo = {
				startTime: DateTime.fromISO("2021-04-21T20:00:00Z").toJSDate(),
				endTime: DateTime.fromISO("2021-04-21T20:30Z").toJSDate(),
				summary: "summary"
			};
			const alarmInfo = createTestEntity(AlarmInfoTypeRef, {
				trigger: "10M",
				alarmIdentifier: "identifier"
			});
			const notificationSender = spy();
			alarmScheduler.scheduleAlarm(eventInfo, alarmInfo, null, notificationSender);
			const expectedAlarmTime = DateTime.fromISO("2021-04-21T19:50Z").toMillis();
			const scheduled = scheduler.scheduledAt.get(expectedAlarmTime);
			if (scheduled == null) throw new Error("Did not schedule, " + Array.from(scheduler.scheduledAt.keys()).map(Date).join(","));
			alarmScheduler.cancelAlarm(alarmInfo.alarmIdentifier);
			dist_default(scheduler.cancelledAt.has(scheduled.id)).equals(true)("was unscheduled");
		});
		dist_default("repeating", function() {
			const eventInfo = {
				startTime: DateTime.fromISO("2021-04-21T20:00:00Z").toJSDate(),
				endTime: DateTime.fromISO("2021-04-21T20:30Z").toJSDate(),
				summary: "summary"
			};
			const alarmInfo = createTestEntity(AlarmInfoTypeRef, { trigger: "30M" });
			const repeatRule = createTestEntity(RepeatRuleTypeRef, {
				frequency: RepeatPeriod.DAILY,
				interval: "1",
				endType: EndType.Count,
				endValue: "3",
				timeZone: "Europe/Berlin"
			});
			const notificationSender = spy();
			alarmScheduler.scheduleAlarm(eventInfo, alarmInfo, repeatRule, notificationSender);
			const scheduled = Array.from(scheduler.scheduledAt.values()).map((idThunk) => idThunk.id);
			dist_default(scheduled.length).equals(1);
			alarmScheduler.cancelAlarm(alarmInfo.alarmIdentifier);
			dist_default(Array.from(scheduler.cancelledAt)).deepEquals(scheduled);
		});
	});
});

//#endregion
//#region ../src/calendar-app/calendar/view/CalendarAgendaView.ts
function earliestEventToShowTimeIndicator(events, date) {
	const firstNonAllDayEvent = events.findIndex((event) => !isAllDayEvent(event));
	if (firstNonAllDayEvent < 0) return null;
	const nonAllDayEvents = events.slice(firstNonAllDayEvent);
	const nextEvent = nonAllDayEvents.findIndex((event) => event.startTime > date);
	if (nextEvent < 0) return null;
	return nextEvent + firstNonAllDayEvent;
}

//#endregion
//#region tests/calendar/CalendarAgendaViewTest.ts
dist_default.spec("CalendarAgendaViewTest", function() {
	dist_default("earliestEventToShowTimeIndicator", () => {
		let allDayStartDate = new Date();
		allDayStartDate.setUTCHours(0, 0, 0, 0);
		let allDayEndDate = new Date(allDayStartDate);
		allDayEndDate.setUTCHours(0, 0, 0, 0);
		incrementDate(allDayEndDate, 1);
		let actualEventStart = new Date(allDayStartDate);
		actualEventStart.setUTCHours(4, 0, 0, 0);
		let actualEventEnd = new Date(allDayStartDate);
		actualEventEnd.setUTCHours(5, 0, 0, 0);
		const sameTimeEventStart = actualEventStart;
		let sameTimeEventEnd = new Date(allDayStartDate);
		sameTimeEventEnd.setUTCHours(6, 0, 0, 0);
		let nextEventStart = new Date(allDayStartDate);
		nextEventStart.setUTCHours(10, 0, 0, 0);
		let nextEventEnd = new Date(allDayStartDate);
		nextEventEnd.setUTCHours(12, 0, 0, 0);
		const events = [
			createTestEntity(CalendarEventTypeRef, {
				startTime: allDayStartDate,
				endTime: allDayEndDate
			}),
			createTestEntity(CalendarEventTypeRef, {
				startTime: actualEventStart,
				endTime: actualEventEnd
			}),
			createTestEntity(CalendarEventTypeRef, {
				startTime: sameTimeEventStart,
				endTime: sameTimeEventEnd
			}),
			createTestEntity(CalendarEventTypeRef, {
				startTime: nextEventStart,
				endTime: nextEventEnd
			})
		];
		dist_default(earliestEventToShowTimeIndicator(events, allDayStartDate)).equals(1)("lower index preferred");
		dist_default(earliestEventToShowTimeIndicator(events, actualEventStart)).equals(3)("if the date is equal, skip the event");
		dist_default(earliestEventToShowTimeIndicator(events, nextEventStart)).equals(null)("no dates left");
		dist_default(earliestEventToShowTimeIndicator(events, new Date(0))).equals(1)("even before the day, all-day events are skipped");
	});
});

//#endregion
//#region tests/support/FaqModelTest.ts
async function collect(generator) {
	const result = [];
	for await (const element of generator) result.push(element);
	return result;
}
dist_default.spec("FaqModelTest", function() {
	let faqModel;
	let fetchFaqSpy;
	const deTranslations = {
		name: "de",
		code: "de",
		keys: {
			"faq.otherEntry_title": "Eine berschrift",
			"faq.otherEntry_markdown": "Ganz langer Inhalt",
			"faq.otherEntry_tags": "tag",
			"faq.entry_markdown": "Inhalt",
			"faq.entry_tags": "a, b, c",
			otherTranslation_label: "test"
		}
	};
	const enTranslations = {
		name: "en",
		code: "en",
		keys: {
			"faq.entry_title": "Heading",
			"faq.entry_markdown": "Content",
			"faq.entry_tags": "a, b, c",
			"faq.otherEntry_title": "Other Heading",
			"faq.otherEntry_markdown": "Much longer Content",
			"faq.otherEntry_tags": "tag",
			otherTranslation_label: "test"
		}
	};
	dist_default.beforeEach(function() {
		lang.code = "de";
		faqModel = new FaqModel();
		fetchFaqSpy = spy((language) => {
			if (language === "en") return Promise.resolve(enTranslations);
else if (language === "de") return Promise.resolve(deTranslations);
else return Promise.resolve({
				keys: {},
				code: language
			});
		});
		downcast(faqModel).fetchFAQ = fetchFaqSpy;
	});
	dist_default("initialize faq model", async function() {
		const translation = await faqModel.fetchFAQ("en");
		dist_default(translation).deepEquals(enTranslations);
	});
	dist_default("test init", async function() {
		await faqModel.init();
		dist_default(fetchFaqSpy.callCount).equals(2);
		dist_default(fetchFaqSpy.calls[0][0]).equals("en");
		dist_default(fetchFaqSpy.calls[1][0]).equals("de");
		dist_default(faqModel.faqLanguages.fallback).deepEquals(enTranslations);
		dist_default(faqModel.faqLanguages.translations).deepEquals(deTranslations);
		const list = faqModel.getList();
		dist_default(list.length).equals(2);
		const faqEntry = list[0];
		dist_default(faqEntry.title).equals("Heading");
		dist_default(faqEntry.text).equals("Inhalt");
		dist_default(faqEntry.tags).deepEquals([
			"a",
			"b",
			"c"
		]);
		await faqModel.init();
		dist_default(fetchFaqSpy.callCount).equals(2);
	});
	dist_default("init with language without faq entries", async function() {
		lang.code = "es";
		await faqModel.init();
		dist_default(fetchFaqSpy.callCount).equals(2);
		dist_default(fetchFaqSpy.calls[0][0]).equals("en");
		dist_default(fetchFaqSpy.calls[1][0]).equals("es");
		dist_default(faqModel.faqLanguages.fallback).deepEquals(enTranslations);
		dist_default(faqModel.faqLanguages.translations).deepEquals({
			keys: {},
			code: "es"
		});
		const list = faqModel.getList();
		dist_default(list.length).equals(2);
		const faqEntry = list[0];
		dist_default(faqEntry.title).equals("Heading");
		dist_default(faqEntry.text).equals("Content");
		dist_default(faqEntry.tags).deepEquals([
			"a",
			"b",
			"c"
		]);
	});
	dist_default("init and search with failing fetch faq entries", async function() {
		fetchFaqSpy = spy((language) => {
			return {
				keys: {},
				code: language
			};
		});
		downcast(faqModel).fetchFAQ = fetchFaqSpy;
		await faqModel.init();
		dist_default(fetchFaqSpy.callCount).equals(2);
		dist_default(fetchFaqSpy.calls[0][0]).equals("en");
		dist_default(fetchFaqSpy.calls[1][0]).equals("de");
		dist_default(faqModel.faqLanguages.fallback).deepEquals({
			keys: {},
			code: "en"
		});
		dist_default(faqModel.faqLanguages.translations).deepEquals({
			keys: {},
			code: "de"
		});
		const list = faqModel.getList();
		dist_default(list.length).equals(0);
		dist_default(await collect(faqModel.search("test"))).deepEquals([]);
	});
	dist_default("basic successful search in title", async function() {
		await faqModel.init();
		dist_default(await collect(faqModel.search("Heading"))).deepEquals([{
			id: "entry",
			title: "<mark>Heading</mark>",
			text: "Inhalt",
			tags: [
				"a",
				"b",
				"c"
			]
		}]);
	});
	dist_default("basic successful search in tags", async function() {
		await faqModel.init();
		dist_default(await collect(faqModel.search("tag"))).deepEquals([{
			id: "otherEntry",
			title: "Eine berschrift",
			text: "Ganz langer Inhalt",
			tags: ["<mark>tag</mark>"]
		}]);
	});
	dist_default("basic successful search in text", async function() {
		await faqModel.init();
		dist_default(await collect(faqModel.search("Inhalt"))).deepEquals([{
			id: "entry",
			title: "Heading",
			text: "<mark>Inhalt</mark>",
			tags: [
				"a",
				"b",
				"c"
			]
		}, {
			id: "otherEntry",
			title: "Eine berschrift",
			text: "Ganz langer <mark>Inhalt</mark>",
			tags: ["tag"]
		}]);
	});
	dist_default("search without results", async function() {
		await faqModel.init();
		const results = await collect(faqModel.search("Testquery_without_result"));
		dist_default(results).deepEquals([]);
	});
});

//#endregion
//#region ../src/mail-app/settings/emaildomain/EnterDomainPage.ts
assertMainOrNode();
function validateDomain(domain) {
	let cleanDomainName = domain.toLocaleLowerCase().trim();
	if (!cleanDomainName.length) return "customDomainNeutral_msg";
	if (!isDomainName(cleanDomainName)) return "customDomainInvalid_msg";
else return null;
}
var EnterDomainPageAttrs = class {
	data;
	constructor(domainData) {
		this.data = domainData;
	}
	headerTitle() {
		return "domainSetup_title";
	}
	nextAction(showErrorDialog = true) {
		const errorMsg = validateDomain(this.data.domain());
		if (errorMsg) return showErrorDialog ? Dialog.message(errorMsg).then(() => false) : Promise.resolve(false);
else return Promise.resolve(true);
	}
	isSkipAvailable() {
		return false;
	}
	isEnabled() {
		return true;
	}
};

//#endregion
//#region ../src/mail-app/settings/DomainDnsStatus.ts
assertMainOrNode();
var DomainDnsStatus = class {
	status;
	domain;
	constructor(cleanDomainName, customerId) {
		this.domain = cleanDomainName;
		this.status = new LazyLoaded(() => {
			let data$1 = createCustomDomainCheckGetIn({
				domain: cleanDomainName,
				customer: customerId ?? null
			});
			return locator.serviceExecutor.get(CustomDomainCheckService, data$1);
		});
	}
	getLoadedCustomDomainCheckGetOut() {
		return this.status.getLoaded();
	}
	/**
	* Only checks for the required records (MX and spf) to be fine.
	* We have this less strict check because one can already use the custom domain (with limitations) even if certain records like dmarc are not yet set properly.
	* We want to allow finishing the dialogs succesfully even if just these basic check pass.
	* @returns {boolean} true if records are fine.
	*/
	areRecordsFine() {
		if (!this.status.isLoaded() || this.status.getLoaded().checkResult !== CustomDomainCheckResult.CUSTOM_DOMAIN_CHECK_RESULT_OK) return false;
		const requiredMissingRecords = this.status.getLoaded().missingRecords.filter((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_MX || r.type === DnsRecordType.DNS_RECORD_TYPE_TXT_SPF);
		return !requiredMissingRecords.length;
	}
	/**
	* Checks that ALL records are fine. Even the ones that are only recommended.
	* We need this check on top of areRecordsFine() because we want to display if some records are not yet set correctly even if the domain can already be used.
	* @returns {boolean} true if all records are fine.
	*/
	areAllRecordsFine() {
		return this.status.isLoaded() && this.status.getLoaded().checkResult === CustomDomainCheckResult.CUSTOM_DOMAIN_CHECK_RESULT_OK && this.status.getLoaded().missingRecords.length === 0 && this.status.getLoaded().invalidRecords.length === 0;
	}
	getDnsStatusInfo() {
		if (this.status.isLoaded()) {
			let result = this.status.getLoaded();
			if (result.checkResult === CustomDomainCheckResult.CUSTOM_DOMAIN_CHECK_RESULT_OK) {
				let mxOk = !result.missingRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_MX) && !result.invalidRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_MX);
				let spfOk = !result.missingRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_TXT_SPF) && !result.invalidRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_TXT_SPF);
				let dkimOk = !result.missingRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_CNAME_DKIM) && !result.invalidRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_CNAME_DKIM);
				let mtaStsOk = !result.missingRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_CNAME_MTA_STS) && !result.invalidRecords.some((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_CNAME_MTA_STS);
				let dmarcWarn = result.missingRecords.find((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_TXT_DMARC);
				let dmarcBad = result.invalidRecords.find((r) => r.type === DnsRecordType.DNS_RECORD_TYPE_TXT_DMARC);
				return "MX " + (mxOk ? DnsRecordValidation.OK : DnsRecordValidation.BAD) + ", SPF " + (spfOk ? DnsRecordValidation.OK : DnsRecordValidation.BAD) + ", MTA-STS " + (mtaStsOk ? DnsRecordValidation.OK : DnsRecordValidation.BAD) + ", DKIM " + (dkimOk ? DnsRecordValidation.OK : DnsRecordValidation.BAD) + ", DMARC " + (dmarcBad || dmarcWarn ? DnsRecordValidation.BAD : DnsRecordValidation.OK);
			} else return "DNS " + DnsRecordValidation.BAD;
		} else return lang.get("loading_msg");
	}
	loadCurrentStatus() {
		if (this.status.isLoaded()) return this.status.reload().then(noOp);
else return this.status.getAsync().then(noOp);
	}
};

//#endregion
//#region tests/gui/base/WizardDialogNTest.ts
var import_stream$2 = __toESM(require_stream(), 1);
var import_testdouble$35 = __toESM(require_testdouble(), 1);
const data = {
	domain: (0, import_stream$2.default)("domain"),
	customerInfo: createTestEntity(CustomerInfoTypeRef),
	expectedVerificationRecord: createTestEntity(DnsRecordTypeRef),
	editAliasFormAttrs: {
		model: (0, import_testdouble$35.object)(),
		expanded: false,
		onExpanded: noOp
	},
	domainStatus: new DomainDnsStatus("domain")
};
const wizardPages = [{
	attrs: new EnterDomainPageAttrs(data),
	view: () => null
}];
let counter = 0;
const closeAction = () => {
	counter += 1;
	return Promise.resolve();
};
dist_default.spec("WizardDialogN", function() {
	dist_default("createWizardDialog without pages", function() {
		const dialogBuilder = createWizardDialog(data, [], null, DialogType.EditLarge);
		dist_default(dialogBuilder.dialog instanceof Dialog).equals(true);
		dist_default(dialogBuilder.attrs.currentPage).equals(null);
		dist_default(dialogBuilder.attrs.pages.length).equals(0);
	});
	dist_default("createWizardDialog with pages and closeAction", function() {
		const dialogBuilder = createWizardDialog(data, wizardPages, closeAction, DialogType.EditLarge);
		dist_default(dialogBuilder.attrs.currentPage).equals(wizardPages[0]);
		dist_default(dialogBuilder.attrs.pages.length).equals(1);
		const before = counter;
		dialogBuilder.attrs.closeAction();
		dist_default(counter).equals(before + 1);
	});
	dist_default("createWizardDialog with pages and without closeAction", function() {
		const dialogBuilder = createWizardDialog(data, wizardPages, null, DialogType.EditLarge);
		dist_default(dialogBuilder.attrs.currentPage).equals(wizardPages[0]);
		dist_default(dialogBuilder.attrs.pages.length).equals(1);
		const before = counter;
		dialogBuilder.attrs.closeAction();
		dist_default(counter).equals(before);
	});
});

//#endregion
//#region tests/calendar/eventeditor/CalendarEventWhenModelTest.ts
dist_default.spec("CalendarEventWhenModel", function() {
	const getModelBerlin = (initialValues) => new CalendarEventWhenModel(initialValues, "Europe/Berlin", noOp);
	const getModelKrasnoyarsk = (initialValues) => new CalendarEventWhenModel(initialValues, "Asia/Krasnoyarsk", noOp);
	dist_default.spec("date modifications", function() {
		dist_default("if the start date is set to before 1970, it will be set to this year", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-27T08:57:45.523Z")
			});
			model.startDate = new Date("1969-04-27T08:27:00.000Z");
			dist_default(model.startDate.getFullYear()).equals(new Date().getFullYear());
		});
		dist_default("if the start time is changed while not all-day, the end time changes by the same amount", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:00.000Z"),
				endTime: new Date("2023-04-27T08:57:00.000Z")
			});
			const startTime = model.startTime;
			dist_default(startTime.to24HourString()).equals("10:27");
			model.startTime = new Time(startTime.hour, startTime.minute + 3);
			dist_default(model.startTime.to24HourString()).equals("10:30");
			dist_default(model.endTime.to24HourString()).equals("11:00");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T08:30:00.000Z");
			dist_default(result.endTime.toISOString()).equals("2023-04-27T09:00:00.000Z");
		});
		dist_default("if the start date is changed while not all-day, the end time changes by the same amount", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:00.000Z"),
				endTime: new Date("2023-04-27T08:57:00.000Z")
			});
			const startDate = model.startDate;
			dist_default(startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("start date is start of the day in utc");
			model.startDate = new Date("2023-04-30T05:15:00.000Z");
			dist_default(model.startDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("start date was moved by three days");
			dist_default(model.endDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("end date was moved by three days");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-30T08:27:00.000Z")("start time on result is correct and includes time");
			dist_default(result.endTime.toISOString()).equals("2023-04-30T08:57:00.000Z")("end time on result is correct and includes time");
		});
		dist_default("if the start date is changed while all-day, the end time changes by the same amount", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:00.000Z"),
				endTime: new Date("2023-04-27T08:57:00.000Z")
			});
			model.isAllDay = true;
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("start date for display is start of day in local timezone, not UTC");
			dist_default(model.endDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("end date for display is start of day in local timezone, not UTC");
			model.startDate = new Date("2023-04-30T08:27:00.000Z");
			dist_default(model.startDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("new start date is displayed as start of current day in local tz");
			dist_default(model.endDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("new end date has also been changed");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-30T00:00:00.000Z")("start date on result is correct");
			dist_default(result.endTime.toISOString()).equals("2023-05-01T00:00:00.000Z")("end date on result is correct");
		});
		dist_default("modifying the start time while the event is all-day has no effect after unsetting all-day", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-27T08:57:45.523Z")
			});
			dist_default(model.isAllDay).equals(false);
			dist_default(model.startTime.to24HourString()).equals("10:27")("still the start time we gave the model");
			model.isAllDay = true;
			model.startTime = new Time(13, 30);
			const allDayResult = model.result;
			dist_default(allDayResult.startTime.toISOString()).equals("2023-04-27T00:00:00.000Z");
			model.isAllDay = false;
			dist_default(model.startTime.to24HourString()).equals("10:27")("still the start time we gave the model after change");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T08:27:00.000Z");
		});
		dist_default("modifying the end time while the event is all-day has no effect after unsetting all-day", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-27T08:57:45.523Z")
			});
			dist_default(model.endTime.to24HourString()).equals("10:57")("initialization correctly applied");
			model.isAllDay = true;
			model.endTime = new Time(13, 30);
			dist_default(model.endTime.to24HourString()).equals("00:00")("all-day causes zeroed time");
			const allDayResult = model.result;
			dist_default(allDayResult.endTime.toISOString()).equals("2023-04-28T00:00:00.000Z")("the result also comes without a time part");
			model.isAllDay = false;
			dist_default(model.endTime.to24HourString()).equals("10:57")("still has old time after unsetting all-day");
			const result = model.result;
			dist_default(result.endTime.toISOString()).equals("2023-04-27T08:57:00.000Z")("the not-all-day-result includes the time");
		});
		dist_default("rescheduling the event by a few hours correctly updates start and end time", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-28T08:57:45.523Z")
			});
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display start date");
			dist_default(model.endDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("correct display end date");
			dist_default(model.startTime.to24HourString()).equals("10:27")("display start time correct");
			dist_default(model.endTime.to24HourString()).equals("10:57")("display end time correct");
			model.rescheduleEvent({ hours: 10 });
			dist_default(model.startTime.to24HourString()).equals("20:27")("start time changed correct amount");
			dist_default(model.endTime.to24HourString()).equals("20:57")("end time changed correct amount");
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("the display start date did not change");
			dist_default(model.endDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("the display end date did not change");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T18:27:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-04-28T18:57:00.000Z")("result end time is correct");
		});
		dist_default("rescheduling the event by a few days and hours correctly updates start and end times", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-28T08:57:45.523Z")
			});
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display start date");
			dist_default(model.endDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("correct display end date");
			model.rescheduleEvent({
				days: -3,
				hours: 10
			});
			dist_default(model.startTime.to24HourString()).equals("20:27")("start time updated");
			dist_default(model.endTime.to24HourString()).equals("20:57")("end time updated");
			dist_default(model.startDate.toISOString()).equals("2023-04-23T22:00:00.000Z")("the display start date did change");
			dist_default(model.endDate.toISOString()).equals("2023-04-24T22:00:00.000Z")("the display end date did change");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-24T18:27:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-04-25T18:57:00.000Z")("result end time is correct");
		});
		dist_default("rescheduling the event by a few days correctly updates start and end times for all-day events", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z")
			});
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display start date");
			dist_default(model.endDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display end date");
			model.rescheduleEvent({
				days: 3,
				hours: 10
			});
			dist_default(model.startTime.to24HourString()).equals("00:00")("start time changed correct amount");
			dist_default(model.endTime.to24HourString()).equals("00:00")("end time changed correct amount");
			dist_default(model.startDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("the display start date did not change");
			dist_default(model.endDate.toISOString()).equals("2023-04-29T22:00:00.000Z")("the display end date did not change");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-30T00:00:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-05-01T00:00:00.000Z")("result end time is correct");
		});
		dist_default("setting the start date correctly updates the start date and end date", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-28T08:57:45.523Z")
			});
			model.startDate = new Date("2023-04-28T04:00:00.000Z");
			dist_default(model.startTime.to24HourString()).equals("10:27")("start time did not change");
			dist_default(model.endTime.to24HourString()).equals("10:57")("end time did not change");
			dist_default(model.startDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("the display start date is shifted by one day");
			dist_default(model.endDate.toISOString()).equals("2023-04-28T22:00:00.000Z")("the display end date was also moved by one day");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-28T08:27:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-04-29T08:57:00.000Z")("result end time is correct");
		});
		dist_default("setting the start date correctly updates the start date and end date, all day true", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z")
			});
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display start date");
			dist_default(model.endDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("correct display end date");
			model.startDate = new Date("2023-04-28T04:00:00.000Z");
			dist_default(model.startTime.to24HourString()).equals("00:00")("start time did not change");
			dist_default(model.endTime.to24HourString()).equals("00:00")("end time did not change");
			dist_default(model.startDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("the display start date is shifted by one day");
			dist_default(model.endDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("the display end date was also moved by one day");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-28T00:00:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-04-29T00:00:00.000Z")("result end time is correct");
		});
		dist_default("setting the end date correctly updates the end date", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T08:27:45.523Z"),
				endTime: new Date("2023-04-28T08:57:45.523Z")
			});
			dist_default(model.endDate.toISOString()).equals("2023-04-27T22:00:00.000Z")("the initialization was correctly applied");
			model.endDate = new Date("2023-05-27T04:00:00.000Z");
			dist_default(model.startTime.to24HourString()).equals("10:27")("start time did not change");
			dist_default(model.endTime.to24HourString()).equals("10:57")("end time did not change");
			dist_default(model.startDate.toISOString()).equals("2023-04-26T22:00:00.000Z")("start date did not change");
			dist_default(model.endDate.toISOString()).equals("2023-05-26T22:00:00.000Z")("end date is correctly shifted");
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T08:27:00.000Z")("result start time is correct");
			dist_default(result.endTime.toISOString()).equals("2023-05-27T08:57:00.000Z")("result end time is correct");
		});
	});
	dist_default.spec("all day", function() {
		dist_default("all day is set correctly for an event that is all-day by times", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z")
			});
			dist_default(model.isAllDay).equals(true);
		});
		dist_default("all day is set correctly for an event that is not all-day by times", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-28T00:02:00.000Z")
			});
			dist_default(model.isAllDay).equals(false);
		});
		dist_default("setting all-day correctly sets utc times to midnight", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-28T00:02:00.000Z")
			});
			model.isAllDay = true;
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T00:00:00.000Z");
			dist_default(result.endTime.toISOString()).equals("2023-04-29T00:00:00.000Z");
			dist_default(isAllDayEvent(result)).equals(true);
		});
		dist_default("setting all-day correctly sets utc times to midnight on an event with same start and end date", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-27T00:02:00.000Z")
			});
			model.isAllDay = true;
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals("2023-04-27T00:00:00.000Z");
			dist_default(result.endTime.toISOString()).equals("2023-04-28T00:00:00.000Z");
			dist_default(isAllDayEvent(result)).equals(true);
		});
		dist_default("setting all-day to false will cause result to not be considered all-day and the times to be set to the default", function() {
			const now$1 = new Date();
			const eventWithDefaults = getEventWithDefaultTimes();
			eventWithDefaults.startTime = DateTime.fromJSDate(eventWithDefaults.startTime).set({
				millisecond: 0,
				second: 0
			}).toJSDate();
			eventWithDefaults.endTime = DateTime.fromJSDate(eventWithDefaults.endTime).set({
				millisecond: 0,
				second: 0
			}).toJSDate();
			const model = getModelBerlin({
				startTime: DateTime.fromJSDate(now$1, { zone: "utc" }).set({
					hour: 0,
					minute: 0,
					second: 0,
					millisecond: 0
				}).toJSDate(),
				endTime: DateTime.fromJSDate(now$1, { zone: "utc" }).set({
					hour: 0,
					minute: 0,
					second: 0,
					millisecond: 0
				}).plus({ day: 1 }).toJSDate()
			});
			dist_default(model.isAllDay).equals(true)("correctly devised the all-day status");
			model.isAllDay = false;
			const result = model.result;
			dist_default(result.startTime.toISOString()).equals(eventWithDefaults.startTime?.toISOString())("default start time was correctly applied");
			dist_default(result.endTime.toISOString()).equals(eventWithDefaults.endTime?.toISOString())("default end time was correctly applied");
			dist_default(isAllDayEvent(result)).equals(false)("the result is not considered all-day");
		});
	});
	dist_default.spec("timezones", function() {
		dist_default("creating an all-day event in one time zone will be considered all-day in another time zone", function() {
			const berlinModel = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-27T00:02:00.000Z")
			});
			dist_default(berlinModel.isAllDay).equals(false);
			berlinModel.isAllDay = true;
			const berlinResult = berlinModel.result;
			dist_default(berlinResult.startTime.toISOString()).equals("2023-04-27T00:00:00.000Z");
			dist_default(berlinResult.endTime.toISOString()).equals("2023-04-28T00:00:00.000Z");
			const krasnoyarskModel = getModelKrasnoyarsk(berlinResult);
			dist_default(krasnoyarskModel.isAllDay).equals(true);
		});
		dist_default("events from another timezone correctly translate the displayed start and end times", function() {
			const berlinModel = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-27T00:02:00.000Z")
			});
			dist_default(berlinModel.isAllDay).equals(false);
			berlinModel.startTime = new Time(13, 0);
			berlinModel.endTime = new Time(13, 30);
			const berlinResult = berlinModel.result;
			dist_default(berlinResult.startTime.toISOString()).equals("2023-04-27T11:00:00.000Z");
			dist_default(berlinResult.endTime.toISOString()).equals("2023-04-27T11:30:00.000Z");
			const krasnoyarskModel = getModelKrasnoyarsk(berlinResult);
			dist_default(krasnoyarskModel.isAllDay).equals(false);
			dist_default(krasnoyarskModel.startTime.to24HourString()).equals("18:00");
			dist_default(krasnoyarskModel.endTime.to24HourString()).equals("18:30");
		});
		dist_default("repeat rules from one time zone are updated for the current time zone", function() {
			const berlinModel = getModelBerlin({
				startTime: new Date("2023-04-27T01:00:00.000Z"),
				endTime: new Date("2023-04-27T00:02:00.000Z")
			});
			berlinModel.repeatPeriod = RepeatPeriod.DAILY;
			const result = berlinModel.result;
			dist_default(result.repeatRule?.timeZone).equals(berlinModel.zone);
			const krasnoyarskModel = getModelKrasnoyarsk({
				startTime: result.startTime,
				endTime: result.endTime,
				repeatRule: result.repeatRule
			});
			const newResult = krasnoyarskModel.result;
			dist_default(newResult.repeatRule?.timeZone).equals(krasnoyarskModel.zone);
		});
	});
	dist_default.spec("repeat rules", function() {
		dist_default("the repeat interval is reflected on the result and for display, no repeat", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: null
			});
			dist_default(model.repeatPeriod).equals(null);
			dist_default(model.result.repeatRule).equals(null);
		});
		dist_default("repeat interval is set to daily", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: null
			});
			model.repeatPeriod = RepeatPeriod.DAILY;
			dist_default(model.repeatPeriod).equals(RepeatPeriod.DAILY);
			dist_default(model.result.repeatRule).deepEquals(createTestEntity(RepeatRuleTypeRef, {
				interval: "1",
				endType: EndType.Never,
				endValue: "1",
				frequency: RepeatPeriod.DAILY,
				excludedDates: [],
				timeZone: model.zone
			}));
		});
		dist_default("setting repeat end type after count works", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "1",
					endType: EndType.Never,
					endValue: "1",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			const result = model.result;
			model.repeatEndType = EndType.Count;
			model.repeatEndOccurrences = 13;
			dist_default(model.repeatEndOccurrences).equals(13);
			dist_default(model.result.repeatRule?.endType).equals(EndType.Count);
			dist_default(model.result.repeatRule?.endValue).equals("13");
			const before = model.repeatEndDateForDisplay;
			model.repeatEndDateForDisplay = new Date("2022-04-03T13:00:00.000Z");
			const after = model.repeatEndDateForDisplay;
			dist_default(before.toISOString()).equals(after.toISOString());
			dist_default(model.repeatEndType).equals(EndType.Count);
		});
		dist_default("setting repeat end type after date works", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "1",
					endType: EndType.Never,
					endValue: "1",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			dist_default(model.isAllDay).equals(true);
			const endDateForSetting = new Date("2023-05-27T13:00:00.000Z");
			const endDateForSaving = new Date("2023-05-28T00:00:00.000Z");
			const cleanEndDate = new Date("2023-05-26T22:00:00.000Z");
			model.repeatEndType = EndType.UntilDate;
			model.repeatEndDateForDisplay = endDateForSetting;
			dist_default(model.repeatEndType).equals(EndType.UntilDate);
			dist_default(model.repeatEndDateForDisplay.toISOString()).equals(cleanEndDate.toISOString());
			const result = model.result;
			dist_default(result.repeatRule?.endType).equals(EndType.UntilDate);
			dist_default(new Date(parseInt(result.repeatRule?.endValue ?? "")).toISOString()).equals(endDateForSaving.toISOString())("saved value is one day after the date we set through GUI");
			dist_default(model.repeatEndOccurrences).equals(Number(getDefaultEndCountValue()));
			model.repeatPeriod = null;
			dist_default(model.repeatPeriod).equals(null);
			dist_default(model.result.repeatRule).equals(null);
		});
		dist_default("changing the end date or end count if the event is not repeating is a no-op", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z")
			});
			const resultBefore = model.result;
			model.repeatEndOccurrences = 42;
			dist_default(model.result).deepEquals(resultBefore);
			model.repeatEndDateForDisplay = new Date("2023-04-30T13:00:00.000Z");
			dist_default(model.result).deepEquals(resultBefore);
			dist_default(model.repeatEndDateForDisplay.toISOString()).equals("2023-05-26T22:00:00.000Z");
		});
		dist_default("changing the end date if the event ends after count is a no-op", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "1",
					endType: EndType.Count,
					endValue: "42",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			const resultBefore = model.result;
			model.repeatEndDateForDisplay = new Date("2023-04-30T13:00:00.000Z");
			dist_default(model.result).deepEquals(resultBefore);
			dist_default(model.repeatEndDateForDisplay.toISOString()).equals("2023-05-26T22:00:00.000Z");
			dist_default(model.repeatEndOccurrences).equals(42);
		});
		dist_default("changing the end count if the event ends on date is a no-op", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "1",
					endType: EndType.UntilDate,
					endValue: new Date("2023-04-30T00:00:00.000Z").getTime().toString(),
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			dist_default(model.repeatEndDateForDisplay.toISOString()).equals("2023-04-28T22:00:00.000Z")("before was correct end date");
			const resultBefore = model.result;
			dist_default(resultBefore.repeatRule?.endValue).equals(new Date("2023-04-30T00:00:00.000Z").getTime().toString());
			model.repeatEndOccurrences = 42;
			dist_default(model.result).deepEquals(resultBefore);
			dist_default(model.repeatEndOccurrences).equals(10);
			dist_default(model.repeatEndType).equals(EndType.UntilDate);
			dist_default(model.repeatEndDateForDisplay.toISOString()).equals("2023-04-28T22:00:00.000Z")("still correct end date");
		});
		dist_default("changing the repeat interval to something less than 1 sets it to 1", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "10",
					endType: EndType.Count,
					endValue: "10",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			model.repeatInterval = -1;
			dist_default(model.repeatInterval).equals(1);
			dist_default(model.result.repeatRule?.interval).equals("1");
		});
		dist_default("repeat interval changes are reflected in the result and display", function() {
			const model = getModelBerlin({
				startTime: new Date("2023-04-27T00:00:00.000Z"),
				endTime: new Date("2023-04-28T00:00:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "10",
					endType: EndType.Count,
					endValue: "10",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				})
			});
			dist_default(model.repeatInterval).equals(10);
			dist_default(model.result.repeatRule?.interval).equals("10");
			model.repeatInterval = 5;
			dist_default(model.repeatInterval).equals(5);
			dist_default(model.result.repeatRule?.interval).equals("5");
		});
	});
	dist_default.spec("deleteExcludedDates", function() {
		dist_default("clears the array of excluded dates", async function() {
			const model = await getModelBerlin(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-13T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, { excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-13T00:00:00Z") })] })
			}));
			model.deleteExcludedDates();
			dist_default(model.excludedDates).deepEquals([]);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([]);
		});
		dist_default("end occurrence changed to smaller -> delete exclusions", async function() {
			const model = await getModelBerlin(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-13T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.Count,
					endValue: "42",
					excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-13T00:00:00Z") })]
				})
			}));
			model.repeatEndOccurrences = 30;
			dist_default(model.excludedDates.length).equals(1);
			dist_default(model.result.repeatRule?.excludedDates.length).equals(0);
		});
		dist_default("end occurrence changed to bigger -> delete exclusions", async function() {
			const model = await getModelBerlin(createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-13T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					endType: EndType.Count,
					endValue: "42",
					excludedDates: [createTestEntity(DateWrapperTypeRef, { date: new Date("2023-03-13T00:00:00Z") })]
				})
			}));
			model.repeatEndOccurrences = 300;
			dist_default(model.excludedDates.length).equals(1);
			dist_default(model.result.repeatRule?.excludedDates.length).equals(0);
		});
		dist_default("interval changes delete exclusions", async function() {
			const excludedDates = [new Date("2023-03-13T00:00:00Z")];
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-13T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: "1",
					interval: "1",
					endType: EndType.Count,
					endValue: "10",
					excludedDates: excludedDates.map((date) => createTestEntity(DateWrapperTypeRef, { date })),
					timeZone: "Europe/Berlin"
				})
			});
			const model = getModelBerlin(event);
			model.repeatInterval = 1;
			dist_default(model.excludedDates).deepEquals(excludedDates)("model has same exclusions as original event");
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(event.repeatRule?.excludedDates)("result has same exclusion as original event");
			model.repeatInterval = 2;
			dist_default(model.excludedDates).deepEquals(excludedDates);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([]);
		});
		dist_default("frequency changes delete exclusions", async function() {
			const excludedDates = [new Date("2023-03-13T00:00:00Z")];
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-03-13T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: "1",
					interval: "1",
					endType: EndType.Count,
					endValue: "10",
					excludedDates: excludedDates.map((date) => createTestEntity(DateWrapperTypeRef, { date })),
					timeZone: "Europe/Berlin"
				})
			});
			const model = getModelBerlin(event);
			model.repeatPeriod = RepeatPeriod.WEEKLY;
			dist_default(model.excludedDates).deepEquals(excludedDates);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(event.repeatRule?.excludedDates);
			model.repeatPeriod = RepeatPeriod.DAILY;
			dist_default(model.excludedDates).deepEquals(excludedDates);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([]);
		});
		dist_default("repeat end date changes delete exclusions", async function() {
			const excludedDates = [new Date("2023-04-13T15:00:00Z")];
			const originalUntilDate = new Date("2023-05-13T00:00:00Z");
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T15:00:00Z"),
				endTime: new Date("2023-01-13T20:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.UntilDate,
					endValue: originalUntilDate.getTime().toString(),
					excludedDates: excludedDates.map((date) => createTestEntity(DateWrapperTypeRef, { date })),
					timeZone: "Europe/Berlin"
				})
			});
			const model = getModelBerlin(event);
			model.repeatEndDateForDisplay = new Date(model.repeatEndDateForDisplay.getTime());
			dist_default(model.excludedDates).deepEquals(excludedDates)("we still have them available for display");
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(event.repeatRule?.excludedDates)("in the result, they're still there because the end date did not change");
			model.repeatEndDateForDisplay = new Date("2023-06-13T00:00:00Z");
			dist_default(model.excludedDates).deepEquals(excludedDates);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([]);
		});
		dist_default("repeat end date changes delete exclusions, all-day events", function() {
			const excludedDates = [new Date("2023-04-13T15:00:00Z")];
			const originalUntilDate = new Date("2023-05-13T00:00:00Z");
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.UntilDate,
					endValue: originalUntilDate.getTime().toString(),
					excludedDates: excludedDates.map((date) => createTestEntity(DateWrapperTypeRef, { date })),
					timeZone: "Europe/Berlin"
				})
			});
			const model = getModelBerlin(event);
			dist_default(model.isAllDay).equals(true);
			model.repeatEndDateForDisplay = new Date(model.repeatEndDateForDisplay.getTime());
			dist_default(model.excludedDates).deepEquals(excludedDates)("we still have them available for display");
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(event.repeatRule?.excludedDates)("in the result, they're still there because the end date did not change");
			model.repeatEndDateForDisplay = new Date("2023-06-13T00:00:00Z");
			dist_default(model.excludedDates).deepEquals(excludedDates);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([]);
		});
		dist_default("time zone changes do not delete exclusions", async function() {
			const excludedDates = [new Date("2023-04-13T15:00:00Z")];
			const originalUntilDate = new Date("2023-05-13T00:00:00Z");
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.UntilDate,
					endValue: originalUntilDate.getTime().toString(),
					excludedDates: excludedDates.map((date) => createTestEntity(DateWrapperTypeRef, { date })),
					timeZone: "Asia/Krasnoyarsk"
				})
			});
			const model = getModelBerlin(event);
			dist_default(model.excludedDates).deepEquals(excludedDates);
			const result = model.result;
			dist_default(result.repeatRule?.excludedDates).deepEquals(event.repeatRule?.excludedDates);
			dist_default(result.repeatRule?.timeZone).equals("Europe/Berlin");
		});
	});
	dist_default.spec("excludeDate", function() {
		dist_default("no exclusion is added if event has no repeat rule", async function() {
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: null
			});
			const model = getModelBerlin(event);
			model.excludeDate(new Date("2023-01-13T00:00:00Z"));
			dist_default(model.repeatPeriod).equals(null);
			dist_default(model.result.repeatRule).equals(null);
		});
		dist_default("adding two exclusions in reverse order sorts them", async function() {
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.Never,
					endValue: null,
					excludedDates: []
				})
			});
			const model = getModelBerlin(event);
			const exclusions = [new Date("2023-03-12T00:00:00Z"), new Date("2023-03-13T00:00:00Z")];
			model.excludeDate(exclusions[1]);
			model.excludeDate(exclusions[0]);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(exclusions.map((date) => createTestEntity(DateWrapperTypeRef, { date })));
			dist_default(model.excludedDates).deepEquals(exclusions);
		});
		dist_default("adding two exclusions in order sorts them", async function() {
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.Never,
					endValue: null,
					excludedDates: []
				})
			});
			const model = getModelBerlin(event);
			const exclusions = [new Date("2023-03-12T00:00:00Z"), new Date("2023-03-13T00:00:00Z")];
			model.excludeDate(exclusions[0]);
			model.excludeDate(exclusions[1]);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals(exclusions.map((date) => createTestEntity(DateWrapperTypeRef, { date })));
			dist_default(model.excludedDates).deepEquals(exclusions);
		});
		dist_default("adding the same exclusion multiple times deduplicates them", async function() {
			const event = createTestEntity(CalendarEventTypeRef, {
				startTime: new Date("2023-01-13T00:00:00Z"),
				endTime: new Date("2023-01-14T00:00:00Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					frequency: RepeatPeriod.DAILY,
					interval: "1",
					endType: EndType.Never,
					endValue: null,
					excludedDates: []
				})
			});
			const model = getModelBerlin(event);
			const exclusion = new Date("2023-03-12T00:00:00Z");
			model.excludeDate(exclusion);
			model.excludeDate(exclusion);
			dist_default(model.result.repeatRule?.excludedDates).deepEquals([createTestEntity(DateWrapperTypeRef, { date: exclusion })]);
			dist_default(model.excludedDates).deepEquals([exclusion]);
		});
	});
});

//#endregion
//#region tests/calendar/eventeditor/CalendarEventWhoModelTest.ts
var import_testdouble$34 = __toESM(require_testdouble(), 1);
dist_default.spec("CalendarEventWhoModel", function() {
	const passwordStrengthModel = () => 1;
	let recipients;
	let sendMailModel;
	let userController;
	const setupRecipient = (recipient) => {
		const sameAddressMatcher = import_testdouble$34.matchers.argThat((p) => p.address === recipient.address);
		(0, import_testdouble$34.when)(recipients.resolve(sameAddressMatcher, import_testdouble$34.matchers.anything())).thenReturn({ resolved: () => Promise.resolve(recipient) });
	};
	dist_default.beforeEach(() => {
		userController = makeUserController();
		sendMailModel = (0, import_testdouble$34.object)();
		recipients = (0, import_testdouble$34.object)();
		setupRecipient(ownerRecipient);
		setupRecipient(ownerAliasRecipient);
		setupRecipient(otherRecipient);
		setupRecipient(otherRecipient2);
		setupRecipient(thirdRecipient);
	});
	const getNewModel = (initialValues) => new CalendarEventWhoModel(initialValues, EventType.OWN, CalendarOperation.Create, calendars, calendars.get("ownCalendar"), userController, true, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	const getOldModel = (initialValues, eventType = EventType.OWN) => new CalendarEventWhoModel(initialValues, eventType, CalendarOperation.EditAll, calendars, calendars.get("ownCalendar"), userController, false, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	const getOldSharedModel = (initialValues, eventType = EventType.SHARED_RW) => new CalendarEventWhoModel(initialValues, eventType, CalendarOperation.EditAll, calendars, calendars.get("sharedCalendar"), userController, false, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	const getOldModelWithSingleEdit = (initialValues, eventType = EventType.OWN) => new CalendarEventWhoModel(initialValues, eventType, CalendarOperation.EditThis, calendars, calendars.get("ownCalendar"), userController, false, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	const getOldInviteModel = (initialValues) => new CalendarEventWhoModel(initialValues, EventType.INVITE, CalendarOperation.EditAll, calendars, calendars.get("ownCalendar"), userController, false, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	const getNewInviteModel = (initialValues) => new CalendarEventWhoModel(initialValues, EventType.INVITE, CalendarOperation.Create, calendars, calendars.get("ownCalendar"), userController, true, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
	dist_default.spec("invite capabilities for different events", function() {
		dist_default("invite in our own calendar can only modify own attendance", async function() {
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "existing event",
				startTime: new Date(2020, 4, 26, 12),
				endTime: new Date(2020, 4, 26, 13),
				organizer: otherAddress,
				_ownerGroup: "ownCalendar",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownerAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })]
			});
			const model = getOldInviteModel(existingEvent);
			dist_default(model.ownGuest?.status).equals(CalendarAttendeeStatus.ACCEPTED);
			dist_default(model.canModifyGuests).equals(false);
			model.setOwnAttendance(CalendarAttendeeStatus.DECLINED);
			dist_default(model.ownGuest?.status).equals(CalendarAttendeeStatus.DECLINED);
			dist_default(model.possibleOrganizers).deepEquals([neverNull(existingEvent.organizer)]);
		});
		dist_default("existing normal event in writable calendar can not modify guests", async function() {
			const userController$1 = makeUserController();
			addCapability(userController$1.user, "sharedCalendar", ShareCapability.Write);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "existing event",
				startTime: new Date(2020, 4, 26, 12),
				endTime: new Date(2020, 4, 26, 13),
				organizer: otherAddress,
				_ownerGroup: "sharedCalendar",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownerAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })]
			});
			const model = getOldModel(existingEvent, EventType.SHARED_RW);
			model.selectedCalendar = calendars.get("sharedCalendar");
			dist_default(model.canModifyGuests).equals(false);
			dist_default(model.possibleOrganizers).deepEquals([neverNull(existingEvent.organizer)]);
		});
		dist_default("for an invite in writable calendar, we cannot modify guests", async function() {
			const userController$1 = makeUserController();
			addCapability(userController$1.user, "sharedCalendar", ShareCapability.Write);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "existing event",
				startTime: new Date(2020, 4, 26, 12),
				endTime: new Date(2020, 4, 26, 13),
				organizer: otherAddress,
				_ownerGroup: "sharedCalendar",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress }), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress2 })]
			});
			const model = getOldSharedModel(existingEvent, EventType.LOCKED);
			dist_default(model.canModifyGuests).equals(false)("cannot modify guests");
			dist_default(model.possibleOrganizers).deepEquals([neverNull(existingEvent.organizer)]);
		});
		dist_default("in readonly calendar, cannot modify guests", async function() {
			const userController$1 = makeUserController();
			addCapability(userController$1.user, "sharedCalendar", ShareCapability.Read);
			const existingEvent = createTestEntity(CalendarEventTypeRef, { _ownerGroup: "sharedCalendar" });
			const model = getOldSharedModel(existingEvent, EventType.SHARED_RO);
			dist_default(model.canModifyGuests).equals(false)("canModifyGuests");
			dist_default(model.possibleOrganizers).deepEquals([]);
		});
		dist_default("in writable calendar w/ guests, we cannot modify guests", async function() {
			const userController$1 = makeUserController();
			addCapability(userController$1.user, "sharedCalendar", ShareCapability.Write);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				summary: "existing event",
				startTime: new Date(2020, 4, 26, 12),
				endTime: new Date(2020, 4, 26, 13),
				organizer: otherAddress,
				_ownerGroup: "sharedCalendar",
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress }), createTestEntity(CalendarEventAttendeeTypeRef, { address: ownerAddress })]
			});
			const model = getOldSharedModel(existingEvent, EventType.SHARED_RO);
			dist_default(model.canModifyGuests).equals(false);
			dist_default(model.possibleOrganizers).deepEquals([neverNull(existingEvent.organizer)]);
		});
	});
	dist_default.spec("adding and removing attendees", function() {
		dist_default("adding another alias on your own event replaces the old attendee and updates the organizer", async function() {
			const model = getNewModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: ownAddresses[0] }), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })],
				organizer: ownAddresses[0]
			});
			model.addAttendee(ownerAlias.address, null);
			await model.recipientsSettled;
			dist_default(model.guests).deepEquals([{
				address: otherAddress.address,
				name: otherAddress.name,
				type: RecipientType.EXTERNAL,
				contact: otherRecipient.contact,
				status: CalendarAttendeeStatus.ADDED
			}])("the single non-organizer guest is in guests array");
			dist_default(model.ownGuest).deepEquals(model.organizer)("the own guest is the organizer");
			const result = model.result;
			dist_default(result.inviteModel).notEquals(null)("on a new model, everyone but the organizer needs to be invited, even if added during initialization");
			dist_default(result.updateModel).equals(null);
			dist_default(result.cancelModel).equals(null);
			dist_default(result.responseModel).equals(null);
			dist_default(result.attendees).deepEquals([createTestEntity(CalendarEventAttendeeTypeRef, {
				address: ownerAlias,
				status: CalendarAttendeeStatus.ACCEPTED
			}), createTestEntity(CalendarEventAttendeeTypeRef, {
				address: otherAddress,
				status: CalendarAttendeeStatus.ADDED
			})])("the result contains all attendees including the organizer");
			dist_default(result.organizer).deepEquals(ownerAlias);
		});
		dist_default("setting multiple ownAddresses correctly gives the possible organizers", function() {
			const model = getNewModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: ownAddresses[0] }), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })],
				organizer: ownAddresses[0]
			});
			dist_default(model.possibleOrganizers).deepEquals([ownerAddress, ownerAlias]);
		});
		dist_default("add attendee that is not the user while without organizer -> organizer is now the first of the current users' mail addresses", async function() {
			const model = getNewModel({
				attendees: [],
				organizer: null
			});
			model.addAttendee(otherAddress.address, otherRecipient.contact);
			await model.recipientsSettled;
			dist_default(model.organizer).deepEquals({
				address: ownAddresses[0].address,
				name: ownAddresses[0].name,
				type: RecipientType.INTERNAL,
				status: CalendarAttendeeStatus.ACCEPTED,
				contact: null
			});
			const result = model.result;
			dist_default(result.attendees.map((a) => a.address)).deepEquals([ownerAddress, otherAddress]);
			dist_default(result.organizer).deepEquals(ownerAddress);
		});
		dist_default("remove last attendee that is not the organizer also removes the organizer on the result, but not on the attendees getter", function() {
			const model = getNewModel({
				attendees: [],
				organizer: null
			});
			model.addAttendee(otherAddress.address, otherRecipient.contact);
			dist_default(model.organizer).notEquals(null);
			model.removeAttendee(otherAddress.address);
			const result = model.result;
			dist_default(result.attendees.length).equals(0);
			dist_default(result.organizer).equals(null);
		});
		dist_default("trying to remove the organizer while there are other attendees does nothing", function() {
			const model = getNewModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: ownAddresses[0] }), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })],
				organizer: ownerAddress
			});
			model.removeAttendee(ownerAddress.address);
			const result = model.result;
			dist_default(result.attendees.length).equals(2);
			dist_default(result.organizer).deepEquals(ownerAddress);
		});
		dist_default("getting the result on an old model is idempotent", function() {
			const model = getOldModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownAddresses[0],
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				})],
				organizer: ownerAddress
			});
			model.removeAttendee(otherAddress.address);
			model.addAttendee(otherAddress2.address, otherRecipient2.contact);
			dist_default(model.result).deepEquals(model.result);
		});
		dist_default("removing an attendee while there are other attendees removes only that attendee", async function() {
			const model = getOldModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownAddresses[0],
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, { address: otherAddress })],
				organizer: ownerAddress
			});
			model.addAttendee(otherAddress.address, otherRecipient.contact);
			model.addAttendee(otherAddress2.address, otherRecipient2.contact);
			await model.recipientsSettled;
			const resultBeforeRemove = model.result;
			dist_default(resultBeforeRemove.attendees).deepEquals([
				createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownerAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				}),
				createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.ADDED
				}),
				createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress2,
					status: CalendarAttendeeStatus.ADDED
				})
			])("there are three attendees in the event");
			dist_default(resultBeforeRemove.organizer).deepEquals(ownerAddress);
			model.removeAttendee(otherAddress.address);
			const result = model.result;
			dist_default(result.attendees).deepEquals([createTestEntity(CalendarEventAttendeeTypeRef, {
				address: ownerAddress,
				status: CalendarAttendeeStatus.ACCEPTED
			}), createTestEntity(CalendarEventAttendeeTypeRef, {
				address: otherAddress2,
				status: CalendarAttendeeStatus.ADDED
			})]);
			dist_default(result.organizer).deepEquals(ownerAddress);
		});
		dist_default("setting external passwords is reflected in the getters and result", async function() {
			const model = getNewModel({
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, { address: ownAddresses[0] }), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})],
				organizer: ownerAddress,
				invitedConfidentially: true
			});
			dist_default(model.guests).deepEquals([{
				address: "someone@tutanota.de",
				name: "Some One",
				status: CalendarAttendeeStatus.NEEDS_ACTION,
				type: RecipientType.UNKNOWN,
				contact: null
			}]);
			dist_default(model.getPresharedPassword(otherAddress.address)).deepEquals({
				password: "",
				strength: 0
			})("password is not set");
			await model.recipientsSettled;
			dist_default(model.guests).deepEquals([{
				address: "someone@tutanota.de",
				name: "Some One",
				status: CalendarAttendeeStatus.NEEDS_ACTION,
				type: RecipientType.EXTERNAL,
				contact: otherRecipient.contact
			}]);
			dist_default(model.getPresharedPassword(otherAddress.address)).deepEquals({
				password: "otherPassword",
				strength: 1
			});
			const { attendees } = model.result;
			dist_default(attendees).deepEquals([createTestEntity(CalendarEventAttendeeTypeRef, {
				address: ownerAddress,
				status: CalendarAttendeeStatus.ADDED
			}), createTestEntity(CalendarEventAttendeeTypeRef, {
				address: otherAddress,
				status: CalendarAttendeeStatus.NEEDS_ACTION
			})]);
		});
		dist_default("adding only oneself as an organizer but no attendees results in a result without organizer or attendees", function() {
			const model = getNewModel({});
			model.addAttendee(ownAddresses[0].address);
			dist_default(model.guests.length).equals(0);
			dist_default(model.organizer?.address).equals(ownAddresses[0].address);
			dist_default(model.result.organizer).equals(null);
			dist_default(model.result.attendees.length).equals(0);
		});
		dist_default("organizer is replaced with ourselves when an own event with someone else as organizer is opened", function() {
			const model = getNewModel({
				attendees: [
					createTestEntity(CalendarEventAttendeeTypeRef, {
						address: ownAddresses[0],
						status: CalendarAttendeeStatus.ACCEPTED
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						address: otherAddress,
						status: CalendarAttendeeStatus.ACCEPTED
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						address: otherAddress2,
						status: CalendarAttendeeStatus.NEEDS_ACTION
					})
				],
				organizer: otherAddress
			});
			dist_default(model.guests.length).equals(2)("only two guests besides the organizer");
			dist_default(model.organizer?.address).equals(ownAddresses[0].address)("model states us as organizer");
			dist_default(model.result.organizer).deepEquals(ownAddresses[0])("result has us as an organizer");
			dist_default(model.result.attendees.length).equals(3)("we as organizer + the original organizer + the other attendee are in the result");
		});
		dist_default("removing/adding attendees on existing event correctly creates the send models", function() {
			const sendModels = [
				(0, import_testdouble$34.object)("first"),
				(0, import_testdouble$34.object)("second"),
				(0, import_testdouble$34.object)("third")
			];
			const userController$1 = makeUserController([], AccountType.PAID);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_ownerGroup: "ownCalendar",
				startTime: getDateInZone("2020-06-01"),
				endTime: getDateInZone("2020-06-02"),
				organizer: ownerAddress,
				attendees: [
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: ownerAddress
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: otherAddress2
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: thirdAddress
					})
				]
			});
			const model = new CalendarEventWhoModel(existingEvent, EventType.OWN, CalendarOperation.EditAll, calendars, calendars.get("ownCalendar"), userController$1, false, ownAddresses, recipients, null, passwordStrengthModel, () => assertNotNull(sendModels.pop(), "requested more sendModels than expected"));
			model.shouldSendUpdates = true;
			model.removeAttendee(otherAddress2.address);
			model.addAttendee(otherAddress.address, createTestEntity(ContactTypeRef, { nickname: otherAddress.name }));
			const result = model.result;
			dist_default(result.responseModel).equals(null);
			(0, import_testdouble$34.verify)(result.updateModel?.addRecipient(RecipientField.BCC, thirdAddress), { times: 1 });
			(0, import_testdouble$34.verify)(result.cancelModel?.addRecipient(RecipientField.BCC, otherAddress2), { times: 1 });
			(0, import_testdouble$34.verify)(result.inviteModel?.addRecipient(RecipientField.BCC, otherAddress), { times: 1 });
			dist_default(sendModels.length).equals(0)("all sendmodels have been requested");
			dist_default(result.attendees.length).equals(3)("all the attendees are there");
		});
		dist_default("adding attendees on new event correctly creates invite model", function() {
			const sendModels = [(0, import_testdouble$34.object)()];
			const userController$1 = makeUserController([], AccountType.PAID);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_ownerGroup: "ownCalendar",
				startTime: new Date(2020, 5, 1),
				endTime: new Date(2020, 5, 2),
				organizer: ownerAddress,
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					status: CalendarAttendeeStatus.NEEDS_ACTION,
					address: ownerAddress
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					status: CalendarAttendeeStatus.NEEDS_ACTION,
					address: otherAddress2
				})]
			});
			const model = new CalendarEventWhoModel(existingEvent, EventType.OWN, CalendarOperation.Create, calendars, calendars.get("ownCalendar"), userController$1, true, ownAddresses, recipients, null, passwordStrengthModel, () => sendModels.pop());
			model.addAttendee(otherAddress.address, createTestEntity(ContactTypeRef, { nickname: otherAddress.name }));
			const result = model.result;
			dist_default(result.responseModel).equals(null);
			dist_default(sendModels.length).equals(0);
			dist_default(result.cancelModel).equals(null);
			dist_default(result.updateModel).equals(null);
			(0, import_testdouble$34.verify)(result.inviteModel?.addRecipient(RecipientField.BCC, otherAddress), { times: 1 });
			(0, import_testdouble$34.verify)(result.inviteModel?.addRecipient(RecipientField.BCC, otherAddress2), { times: 1 });
			dist_default(result.attendees.length).equals(3)("all the attendees are there");
		});
	});
	dist_default.spec("calendar selection", function() {
		dist_default.spec("getAvailableCalendars", function() {
			dist_default.beforeEach(() => {
				const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef, downcast({ groupSettings: [{
					group: "ownExternalCalendar",
					sourceUrl: "dummy"
				}] }));
				(0, import_testdouble$34.replace)(userController, "userSettingsGroupRoot", Object.assign({}, userController.userSettingsGroupRoot, userSettingsGroupRoot));
				(0, import_testdouble$34.replace)(userController, "user", createTestEntity(UserTypeRef, { _id: "ownerId" }));
				addCapability(userController.user, "ownExternalCalendar", ShareCapability.Read);
			});
			dist_default("it returns the owned calendars and shared calendars we have write access to when there are no attendees", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getNewModel({});
				dist_default(model.getAvailableCalendars()).deepEquals([
					calendars.get("ownCalendar"),
					calendars.get("ownSharedCalendar"),
					calendars.get("sharedCalendar")
				]);
			});
			dist_default("it returns only the calendars we have write access to", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Read);
				const model = getNewModel({});
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("ownCalendar"), calendars.get("ownSharedCalendar")]);
			});
			dist_default("it returns only own calendars after adding attendees to an existing event", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getOldModel({});
				model.addAttendee(otherAddress.address);
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("ownCalendar"), calendars.get("ownSharedCalendar")]);
			});
			dist_default("it returns only own calendars for existing own event with attendees ", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getOldModel({ attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})] });
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("ownCalendar"), calendars.get("ownSharedCalendar")]);
			});
			dist_default("it returns only own private calendars for invite", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getOldInviteModel({});
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("ownCalendar")]);
			});
			dist_default("it returns only existing calendar if it's existing shared event with attendees", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getOldSharedModel({ attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.NEEDS_ACTION
				})] }, EventType.LOCKED);
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("sharedCalendar")]);
			});
			dist_default("it returns only the current calendar for single-instance editing", function() {
				addCapability(userController.user, "sharedCalendar", ShareCapability.Write);
				const model = getOldModelWithSingleEdit({ attendees: [] });
				dist_default(model.getAvailableCalendars()).deepEquals([calendars.get("ownCalendar")]);
			});
		});
		dist_default("changing the calendar to a shared one while the event has attendees is an error", function() {
			const model = getNewModel({});
			model.addAttendee(otherAddress.address);
			dist_default(model.guests.length).equals(1);
			dist_default(() => model.selectedCalendar = calendars.get("sharedCalendar")).throws(ProgrammingError);
			dist_default(model.selectedCalendar).deepEquals(calendars.get("ownCalendar"));
		});
	});
	dist_default.spec("invites in own calendar, changing own attendance", function() {
		dist_default("changing own attendance on new event results in responseModel and correct status", async function() {
			const userController$1 = makeUserController([], AccountType.PAID);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_ownerGroup: "ownCalendar",
				startTime: getDateInZone("2020-06-01"),
				endTime: getDateInZone("2020-06-02"),
				organizer: otherAddress,
				attendees: [
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.DECLINED,
						address: otherAddress
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: ownerAddress
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: otherAddress2
					})
				]
			});
			const model = new CalendarEventWhoModel(existingEvent, EventType.INVITE, CalendarOperation.Create, calendars, calendars.get("ownCalendar"), userController$1, true, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
			model.setOwnAttendance(CalendarAttendeeStatus.ACCEPTED);
			const result = model.result;
			(0, import_testdouble$34.verify)(result.responseModel?.addRecipient(RecipientField.TO, otherAddress), { times: 1 });
			dist_default(result.attendees.length).equals(3)("all the attendees are still there");
			dist_default(result.attendees[1].status).deepEquals(CalendarAttendeeStatus.ACCEPTED);
			dist_default(result.inviteModel).equals(null)("no invite model");
			dist_default(result.cancelModel).equals(null)("no cancel model");
			dist_default(result.updateModel).equals(null)("no update model");
		});
		dist_default("changing own attendance on existing event results in responseModel and correct status", async function() {
			const userController$1 = makeUserController([], AccountType.PAID);
			const existingEvent = createTestEntity(CalendarEventTypeRef, {
				_ownerGroup: "ownCalendar",
				startTime: new Date(2020, 5, 1),
				endTime: new Date(2020, 5, 2),
				organizer: otherAddress,
				attendees: [
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.DECLINED,
						address: otherAddress
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: ownerAddress
					}),
					createTestEntity(CalendarEventAttendeeTypeRef, {
						status: CalendarAttendeeStatus.NEEDS_ACTION,
						address: otherAddress2
					})
				]
			});
			const model = new CalendarEventWhoModel(existingEvent, EventType.INVITE, CalendarOperation.EditAll, calendars, calendars.get("ownCalendar"), userController$1, false, ownAddresses, recipients, null, passwordStrengthModel, () => sendMailModel);
			model.setOwnAttendance(CalendarAttendeeStatus.DECLINED);
			const result = model.result;
			(0, import_testdouble$34.verify)(result.responseModel?.addRecipient(RecipientField.TO, otherAddress), { times: 1 });
			dist_default(result.attendees.length).equals(3)("all the attendees are still there");
			dist_default(result.attendees[1].status).deepEquals(CalendarAttendeeStatus.DECLINED);
			dist_default(result.inviteModel).equals(null)("no invite model");
			dist_default(result.cancelModel).equals(null)("no cancel model");
			dist_default(result.updateModel).equals(null)("no update model");
		});
	});
});

//#endregion
//#region tests/calendar/eventeditor/CalendarEventAlarmModelTest.ts
var import_testdouble$33 = __toESM(require_testdouble(), 1);
const dateProvider = (0, import_testdouble$33.object)();
(0, import_testdouble$33.when)(dateProvider.now()).thenReturn(42);
dist_default.spec("CalendarEventAlarmModel", function() {
	const languageTag = "en";
	dist_default.before(async function() {
		await lang.init(en_default);
		await lang.setLanguage({
			code: languageTag,
			languageTag
		});
	});
	dist_default.spec("alarm trigger sets", function() {
		dist_default("alarm initialization works", function() {
			const model = new CalendarEventAlarmModel(EventType.OWN, [StandardAlarmInterval.ONE_HOUR], dateProvider);
			dist_default(model.alarms).deepEquals([StandardAlarmInterval.ONE_HOUR]);
			dist_default(model.result.alarms.map(({ trigger }) => trigger)).deepEquals(["1H"]);
		});
		dist_default("adding alarms works", function() {
			const model = new CalendarEventAlarmModel(EventType.OWN, [StandardAlarmInterval.ONE_HOUR], dateProvider);
			model.addAlarm(StandardAlarmInterval.ONE_DAY);
			dist_default(model.alarms).deepEquals([StandardAlarmInterval.ONE_HOUR, StandardAlarmInterval.ONE_DAY]);
			const { alarms } = model.result;
			dist_default(alarms.map(({ trigger }) => trigger)).deepEquals(["1H", "1D"]);
		});
		dist_default("removing an alarm works", function() {
			const model = new CalendarEventAlarmModel(EventType.OWN, [StandardAlarmInterval.ONE_HOUR], dateProvider);
			model.removeAlarm(StandardAlarmInterval.ONE_HOUR);
			model.removeAlarm(StandardAlarmInterval.ONE_DAY);
			dist_default(model.alarms).deepEquals([]);
			const { alarms } = model.result;
			dist_default(alarms).deepEquals([]);
		});
		dist_default("editing capability", function() {
			dist_default(new CalendarEventAlarmModel(EventType.SHARED_RO, [], dateProvider).canEditReminders).equals(false);
			dist_default(new CalendarEventAlarmModel(EventType.EXTERNAL, [], dateProvider).canEditReminders).equals(false);
			dist_default(new CalendarEventAlarmModel(EventType.LOCKED, [], dateProvider).canEditReminders).equals(true);
			dist_default(new CalendarEventAlarmModel(EventType.SHARED_RW, [], dateProvider).canEditReminders).equals(true);
			dist_default(new CalendarEventAlarmModel(EventType.INVITE, [], dateProvider).canEditReminders).equals(true);
			dist_default(new CalendarEventAlarmModel(EventType.OWN, [], dateProvider).canEditReminders).equals(true);
		});
	});
	dist_default.spec("isEqualAlarms", function() {
		dist_default("two equal alarms", function() {
			const model = new CalendarEventAlarmModel(EventType.OWN, [StandardAlarmInterval.ONE_HOUR], dateProvider);
			dist_default(model.isEqualAlarms(StandardAlarmInterval.ONE_HOUR, {
				value: 60,
				unit: AlarmIntervalUnit.MINUTE
			})).equals(true);
		});
		dist_default("two different alarms", function() {
			const model = new CalendarEventAlarmModel(EventType.OWN, [StandardAlarmInterval.ONE_HOUR], dateProvider);
			dist_default(model.isEqualAlarms(StandardAlarmInterval.ONE_HOUR, {
				value: 1,
				unit: AlarmIntervalUnit.DAY
			})).equals(false);
		});
	});
});

//#endregion
//#region tests/calendar/eventeditor/CalendarEventModelTest.ts
var import_testdouble$32 = __toESM(require_testdouble(), 1);
dist_default.spec("CalendarEventModelTest", function() {
	let userController;
	let distributor;
	let calendarModel;
	let entityClient$1;
	let editModels;
	dist_default.beforeEach(function() {
		userController = (0, import_testdouble$32.object)();
		distributor = (0, import_testdouble$32.object)();
		calendarModel = (0, import_testdouble$32.object)();
		entityClient$1 = (0, import_testdouble$32.object)();
		editModels = {
			alarmModel: (0, import_testdouble$32.object)(),
			whenModel: (0, import_testdouble$32.object)(),
			whoModel: (0, import_testdouble$32.object)(),
			summary: (0, import_testdouble$32.object)(),
			description: (0, import_testdouble$32.object)(),
			location: (0, import_testdouble$32.object)()
		};
	});
	dist_default.spec("integration tests", function() {
		dist_default("doing no edit operation on an existing event updates it as expected, no updates.", async function() {
			const event = createTestEntity(CalendarEventTypeRef, {
				sequence: "0",
				_id: ["eventListId", "eventElementId"],
				_ownerGroup: "ownCalendar",
				_permissions: "permissionId",
				summary: "hello event",
				location: "in a boat",
				description: "about 3 inches tall",
				uid: "eventUid",
				hashedUid: null,
				startTime: new Date("2023-04-27T15:00:00.000Z"),
				invitedConfidentially: false,
				endTime: new Date("2023-04-27T15:30:00.000Z"),
				repeatRule: createTestEntity(RepeatRuleTypeRef, {
					interval: "10",
					_id: "repeatRuleId",
					endType: EndType.Count,
					endValue: "10",
					frequency: RepeatPeriod.DAILY,
					excludedDates: []
				}),
				organizer: ownerAddress,
				alarmInfos: [["alarmListId", "alarmElementId"]],
				attendees: [createTestEntity(CalendarEventAttendeeTypeRef, {
					address: ownerAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				}), createTestEntity(CalendarEventAttendeeTypeRef, {
					address: otherAddress,
					status: CalendarAttendeeStatus.ACCEPTED
				})]
			});
			const recipientsModel = (0, import_testdouble$32.object)();
			const logins = (0, import_testdouble$32.object)();
			const userSettingsGroupRoot = createTestEntity(UserSettingsGroupRootTypeRef, { groupSettings: [] });
			const userController$1 = makeUserController([ownerAlias.address], AccountType.PAID, ownerMailAddress, true, false, undefined, userSettingsGroupRoot);
			(0, import_testdouble$32.when)(logins.getUserController()).thenReturn(userController$1);
			(0, import_testdouble$32.when)(calendarModel.loadAlarms(event.alarmInfos, userController$1.user)).thenResolve([createTestEntity(UserAlarmInfoTypeRef, {
				_id: event.alarmInfos[0],
				alarmInfo: createTestEntity(AlarmInfoTypeRef, {
					alarmIdentifier: "alarmIdentifier",
					trigger: "5M",
					calendarRef: createTestEntity(CalendarEventRefTypeRef, {
						elementId: event._id[1],
						listId: event._id[0]
					})
				})
			})]);
			(0, import_testdouble$32.when)(calendarModel.getCalendarInfos()).thenResolve(calendars);
			(0, import_testdouble$32.when)(calendarModel.resolveCalendarEventProgenitor(import_testdouble$32.matchers.anything())).thenResolve(event);
			const resolvableOwner = (0, import_testdouble$32.object)();
			(0, import_testdouble$32.when)(resolvableOwner.resolved()).thenResolve(ownerAddress);
			const resolvableRecipient = (0, import_testdouble$32.object)();
			(0, import_testdouble$32.when)(resolvableRecipient.resolved()).thenResolve(otherAddress);
			const resolvables = [
				resolvableOwner,
				resolvableRecipient,
				resolvableOwner
			];
			let tryCount = 0;
			(0, import_testdouble$32.when)(recipientsModel.resolve(import_testdouble$32.matchers.anything(), ResolveMode.Eager)).thenDo(() => resolvables[tryCount++]);
			const mailboxDetail = {
				mailbox: createTestEntity(MailBoxTypeRef),
				mailGroupInfo: createTestEntity(GroupInfoTypeRef),
				mailGroup: createTestEntity(GroupTypeRef, { user: ownerId }),
				mailboxGroupRoot: createTestEntity(MailboxGroupRootTypeRef)
			};
			const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef, {});
			const sendModelFac = (0, import_testdouble$32.func)();
			const model = await makeCalendarEventModel(CalendarOperation.EditAll, event, recipientsModel, calendarModel, logins, mailboxDetail, mailboxProperties, sendModelFac, distributor, entityClient$1, null, "Europe/Berlin", identity, noOp);
			const result = await model?.apply();
			dist_default(result).equals(EventSaveResult.Saved);
			(0, import_testdouble$32.verify)(calendarModel.updateEvent(import_testdouble$32.matchers.contains({
				...event,
				sequence: "1",
				alarmInfos: [],
				repeatRule: {
					...event.repeatRule,
					_id: null
				}
			}), import_testdouble$32.matchers.argThat((n) => n.length === 1 && n[0].trigger === "5M"), "Europe/Berlin", calendars.get("ownCalendar").groupRoot, event), { times: 1 });
			(0, import_testdouble$32.verify)(sendModelFac(), { times: 0 });
		});
	});
	dist_default.spec("eventHasChanged", function() {
		const fixedOrganizer = createTestEntity(EncryptedMailAddressTypeRef, {
			address: "moo@d.de",
			name: "bla"
		});
		const att = (a, n, s) => createTestEntity(CalendarEventAttendeeTypeRef, {
			address: createTestEntity(EncryptedMailAddressTypeRef, {
				address: a,
				name: n
			}),
			status: s
		});
		const cases = [
			[
				"alarmInfos",
				[],
				["some", "alarm"],
				false,
				"alarmInfos are ignored"
			],
			[
				"summary",
				"new",
				"old",
				true
			],
			[
				"location",
				"here",
				"there",
				true
			],
			[
				"description",
				"ho",
				"ha",
				true
			],
			[
				"invitedConfidentially",
				true,
				false,
				true
			],
			[
				"startTime",
				getDateInZone("2023-05-10T13:30"),
				getDateInZone("2023-05-15T13:30"),
				true
			],
			[
				"endTime",
				getDateInZone("2023-05-26"),
				getDateInZone("2023-05-27"),
				true
			],
			[
				"uid",
				"newUid",
				"oldUid",
				true
			],
			[
				"organizer",
				fixedOrganizer,
				fixedOrganizer,
				false,
				"same object in organizer"
			],
			[
				"organizer",
				fixedOrganizer,
				createTestEntity(EncryptedMailAddressTypeRef, {
					address: "moo@d.de",
					name: "bla"
				}),
				false,
				"same organizer, different object"
			],
			[
				"organizer",
				fixedOrganizer,
				createTestEntity(EncryptedMailAddressTypeRef, {
					address: "moo@d.de",
					name: "blabla"
				}),
				false,
				"different address, same name"
			],
			[
				"organizer",
				fixedOrganizer,
				createTestEntity(EncryptedMailAddressTypeRef, {
					address: "moo@d.io",
					name: "bla"
				}),
				true,
				"same name, different address"
			],
			[
				"attendees",
				[],
				[],
				false,
				"no attendees in either event"
			],
			[
				"attendees",
				[att("b@c.d", "b", CalendarAttendeeStatus.NEEDS_ACTION)],
				[att("b@c.d", "C", CalendarAttendeeStatus.NEEDS_ACTION)],
				false,
				"only names changed"
			],
			[
				"attendees",
				[att("b@c.d", "b", CalendarAttendeeStatus.NEEDS_ACTION)],
				[att("B@C.D", "b", CalendarAttendeeStatus.NEEDS_ACTION)],
				false,
				"only address case changed"
			],
			[
				"attendees",
				[att("b@c.d", "b", CalendarAttendeeStatus.NEEDS_ACTION)],
				[],
				true,
				"attendee changed"
			],
			[
				"attendees",
				[att("b@c.d", "b", CalendarAttendeeStatus.NEEDS_ACTION)],
				[att("b@c.d", "b", CalendarAttendeeStatus.ACCEPTED)],
				true,
				"status changed"
			]
		];
		for (const [attr, now$1, previous, expected, msg] of cases) dist_default(`${attr} changed -> ${expected}`, function() {
			const template = createTestEntity(CalendarEventTypeRef, { [attr]: previous });
			const copy = Object.assign({}, template, { [attr]: now$1 });
			dist_default(eventHasChanged(copy, template)).equals(expected)(msg ?? attr);
			dist_default(eventHasChanged(copy, clone(copy))).equals(false)(`do not change ${msg}`);
		});
		dist_default("same object -> false", function() {
			const event = createTestEntity(CalendarEventTypeRef, {});
			dist_default(eventHasChanged(event, event)).equals(false);
		});
	});
	const dw = (d) => createTestEntity(DateWrapperTypeRef, { date: getDateInZone(d) });
	dist_default.spec("areRepeatRulesEqual", function() {
		const cases = [
			[
				"endType",
				EndType.Never,
				EndType.Count,
				false
			],
			[
				"endValue",
				"10",
				"15",
				false
			],
			[
				"frequency",
				RepeatPeriod.DAILY,
				RepeatPeriod.MONTHLY,
				false
			],
			[
				"interval",
				"10",
				"15",
				false
			],
			[
				"excludedDates",
				[],
				[],
				true,
				"no exclusions"
			],
			[
				"excludedDates",
				[],
				[dw("2023-02-01")],
				false,
				"added exclusion"
			],
			[
				"excludedDates",
				[dw("2023-02-01")],
				[dw("2023-02-01")],
				true,
				"same exclusions"
			]
		];
		for (const [attr, now$1, previous, expected, msg] of cases) dist_default(`${attr} changed -> ${expected}`, function() {
			dist_default(areRepeatRulesEqual(createTestEntity(RepeatRuleTypeRef, { [attr]: now$1 }), createTestEntity(RepeatRuleTypeRef, { [attr]: previous }))).equals(expected)(msg ?? attr);
			dist_default(areRepeatRulesEqual(createTestEntity(RepeatRuleTypeRef, { [attr]: now$1 }), createTestEntity(RepeatRuleTypeRef, { [attr]: now$1 }))).equals(true)(`do not change ${msg}`);
		});
		dist_default("same object -> true", function() {
			const r1 = createTestEntity(RepeatRuleTypeRef, {});
			dist_default(areRepeatRulesEqual(r1, r1)).equals(true);
		});
	});
	dist_default.spec("areExcludedDatesEqual", function() {
		dist_default("empty arrays are equal", function() {
			dist_default(areExcludedDatesEqual([], [])).equals(true);
		});
		dist_default("a nonempty array with an empty array is unequal", function() {
			dist_default(areExcludedDatesEqual([], [dw("2023-03-06T13:56")])).equals(false);
			dist_default(areExcludedDatesEqual([dw("2023-03-06T13:56")], [])).equals(false);
		});
		dist_default("nonequal if an array is a subsequence of the other", function() {
			const a = [dw("2023-03-06T13:56"), dw("2023-03-09T13:56")];
			dist_default(areExcludedDatesEqual(a, a.slice(1))).equals(false);
		});
		dist_default("nonequal if the dates are different", function() {
			dist_default(areExcludedDatesEqual([dw("2023-03-06T13:56")], [dw("2023-03-09T13:56")])).equals(false);
		});
		dist_default("equal if the dates are the same", function() {
			dist_default(areExcludedDatesEqual([dw("2023-03-06T13:56")], [dw("2023-03-06T13:56")])).equals(true);
		});
	});
});

//#endregion
//#region tests/gui/ColorTest.ts
dist_default.spec("color", function() {
	dist_default("hexToRGB 6digit", function() {
		dist_default(hexToRgb("#b73a9a")).deepEquals({
			r: 183,
			g: 58,
			b: 154
		});
	});
	dist_default("hexToRGB 3digit", function() {
		dist_default(hexToRgb("#ABC")).deepEquals({
			r: 170,
			g: 187,
			b: 204
		});
	});
	dist_default("normalizeHueAngle", function() {
		dist_default(normalizeHueAngle(0)).equals(0);
		dist_default(normalizeHueAngle(259)).equals(259);
		dist_default(normalizeHueAngle(360)).equals(0);
		dist_default(normalizeHueAngle(576)).equals(216);
		dist_default(normalizeHueAngle(-120)).equals(240);
		dist_default(normalizeHueAngle(-576)).equals(144);
	});
	dist_default("rgbToHSL", function() {
		dist_default(rgbToHSL({
			r: 186,
			g: 165,
			b: 228
		})).deepEquals({
			h: 260,
			s: 54,
			l: 77
		});
	});
	dist_default("hslToRGB", function() {
		dist_default(hslToRGB({
			h: 260,
			s: 54,
			l: 77
		})).deepEquals({
			r: 186,
			g: 165,
			b: 228
		});
	});
	dist_default("hexToHSLToHex", function() {
		dist_default(hslToHex(hexToHSL("#baa5e4"))).equals("#baa5e4");
	});
	dist_default("hslToHexToHSL", function() {
		dist_default(hexToHSL(hslToHex({
			h: 260,
			s: 54,
			l: 77
		}))).deepEquals({
			h: 260,
			s: 54,
			l: 77
		});
	});
	dist_default("isValidColorCode", function() {
		dist_default(isValidColorCode("#abc")).equals(true);
		dist_default(isValidColorCode("#ABC")).equals(true);
		dist_default(isValidColorCode("#aBc")).equals(true);
		dist_default(isValidColorCode("#aabbcc")).equals(true);
		dist_default(isValidColorCode("#AABBCC")).equals(true);
		dist_default(isValidColorCode("#aAbBcC")).equals(true);
		dist_default(isValidColorCode("AABBCC")).equals(false);
		dist_default(isValidColorCode("#ABCDEG")).equals(false);
	});
	dist_default("rgbToHex", function() {
		dist_default(rgbToHex({
			r: 183,
			g: 58,
			b: 154
		})).equals("#b73a9a");
	});
	dist_default.spec("isColorLight", function() {
		dist_default("pink is dark", function() {
			dist_default(isColorLight("#B73A9A")).equals(false);
		});
		dist_default("blue is light", function() {
			dist_default(isColorLight("#3A9AFF")).equals(true);
		});
		dist_default("three digit white is light", function() {
			dist_default(isColorLight("#FFF")).equals(true);
		});
		dist_default("three digit black is dark", function() {
			dist_default(isColorLight("#000")).equals(false);
		});
		dist_default("three digit cyan is light", function() {
			dist_default(isColorLight("#0FF")).equals(true);
		});
	});
});

//#endregion
//#region tests/mail/ResolvableRecipientMock.ts
var ResolvableRecipientMock = class {
	name;
	type;
	_resolved = false;
	lazyResolve = new LazyLoaded(async () => {
		this._resolved = true;
		this.type = this.type !== RecipientType.UNKNOWN ? this.type : this.internalAddresses.includes(this.address) ? RecipientType.INTERNAL : RecipientType.EXTERNAL;
		this.contact = this.contact ?? this.existingContacts.find(({ mailAddresses }) => mailAddresses.some(({ address }) => address === this.address)) ?? createNewContact(this.user, this.address, this.name);
		return {
			address: this.address,
			name: this.name,
			contact: this.contact,
			type: this.type
		};
	});
	constructor(address, name, contact, type, internalAddresses, existingContacts, resolveMode, user) {
		this.address = address;
		this.contact = contact;
		this.internalAddresses = internalAddresses;
		this.existingContacts = existingContacts;
		this.user = user;
		this.name = name ?? "";
		this.type = type ?? (isTutaMailAddress(address) ? RecipientType.INTERNAL : RecipientType.UNKNOWN);
		if (resolveMode === ResolveMode.Eager) this.lazyResolve.getAsync();
	}
	isResolved() {
		return this._resolved;
	}
	resolved() {
		return this.lazyResolve.getAsync();
	}
	setContact(contact) {
		this.contact = contact;
	}
	setName(name) {
		this.name = name;
	}
	whenResolved(onResolved) {
		throw new Error("STUB");
	}
};

//#endregion
//#region tests/mail/SendMailModelTest.ts
var import_testdouble$31 = __toESM(require_testdouble(), 1);
const { anything: anything$4, argThat: argThat$1 } = import_testdouble$31.matchers;
let testIdGenerator = {
	currentIdValue: 0,
	currentListIdValue: 0,
	newId() {
		return (this.currentIdValue++).toString();
	},
	newListId() {
		return (this.currentListIdValue++).toString();
	},
	newIdTuple() {
		return [this.newListId(), this.newId()];
	}
};
const EXTERNAL_ADDRESS_1 = "address1@test.com";
const EXTERNAL_ADDRESS_2 = "address2@test.com";
const DEFAULT_SENDER_FOR_TESTING = "test@tutanota.de";
const INTERNAL_RECIPIENT_1 = {
	name: "test1",
	address: "test1@tutanota.de",
	contact: null
};
const BODY_TEXT_1 = "lorem ipsum dolor yaddah yaddah";
const SUBJECT_LINE_1 = "Did you get that thing I sent ya";
const STRONG_PASSWORD = "@()IE!)(@FME)0-123jfDSA32SDACmmnvnvddEW";
const WEAK_PASSWORD = "123";
dist_default.spec("SendMailModel", function() {
	dist_default.before(function() {
		lang.init(en_default);
	});
	let mailboxModel, entity, mailFacade, recipientsModel;
	let model;
	dist_default.beforeEach(function() {
		entity = (0, import_testdouble$31.instance)(EntityClient);
		(0, import_testdouble$31.when)(entity.loadRoot(argThat$1((typeRef) => isSameTypeRef(typeRef, ContactListTypeRef)), anything$4())).thenDo(() => ({ contacts: testIdGenerator.newId() }));
		(0, import_testdouble$31.when)(entity.load(anything$4(), anything$4(), anything$4())).thenDo((typeRef, id, params) => ({
			_type: typeRef,
			_id: id
		}));
		mailboxModel = (0, import_testdouble$31.instance)(MailboxModel);
		const contactModel = (0, import_testdouble$31.object)();
		(0, import_testdouble$31.when)(contactModel.getContactListId()).thenResolve("contactListId");
		(0, import_testdouble$31.when)(contactModel.searchForContact(anything$4())).thenResolve(null);
		mailFacade = (0, import_testdouble$31.instance)(MailFacade);
		(0, import_testdouble$31.when)(mailFacade.createDraft(anything$4())).thenDo(() => createTestEntity(MailTypeRef));
		(0, import_testdouble$31.when)(mailFacade.updateDraft(anything$4())).thenDo(() => createTestEntity(MailTypeRef));
		(0, import_testdouble$31.when)(mailFacade.getRecipientKeyData(anything$4())).thenResolve(null);
		(0, import_testdouble$31.when)(mailFacade.getAttachmentIds(anything$4())).thenResolve([]);
		const tutanotaProperties = createTestEntity(TutanotaPropertiesTypeRef, {
			defaultSender: DEFAULT_SENDER_FOR_TESTING,
			defaultUnconfidential: true,
			notificationMailLanguage: "en",
			noAutomaticContacts: false
		});
		const user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef, {
				_id: testIdGenerator.newId(),
				group: testIdGenerator.newId()
			}),
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				_id: testIdGenerator.newId(),
				groupType: GroupType.Contact
			})]
		});
		const userController = (0, import_testdouble$31.object)();
		(0, import_testdouble$31.replace)(userController, "user", user);
		(0, import_testdouble$31.replace)(userController, "props", tutanotaProperties);
		(0, import_testdouble$31.when)(userController.loadCustomer()).thenResolve(createTestEntity(CustomerTypeRef));
		const loginController = (0, import_testdouble$31.object)();
		(0, import_testdouble$31.when)(loginController.isInternalUserLoggedIn()).thenReturn(true);
		(0, import_testdouble$31.when)(loginController.getUserController()).thenReturn(userController);
		const eventController = (0, import_testdouble$31.instance)(EventController);
		const mailboxDetails = {
			mailbox: createTestEntity(MailBoxTypeRef),
			mailGroupInfo: createTestEntity(GroupInfoTypeRef, { mailAddress: "mailgroup@addre.ss" }),
			mailGroup: createTestEntity(GroupTypeRef),
			mailboxGroupRoot: createTestEntity(MailboxGroupRootTypeRef)
		};
		recipientsModel = (0, import_testdouble$31.instance)(RecipientsModel);
		(0, import_testdouble$31.when)(recipientsModel.resolve(anything$4(), anything$4())).thenDo((recipient, resolveMode) => {
			return new ResolvableRecipientMock(recipient.address, recipient.name, recipient.contact, recipient.type, [INTERNAL_RECIPIENT_1.address], [], resolveMode, user);
		});
		const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef);
		model = new SendMailModel(mailFacade, entity, loginController, mailboxModel, contactModel, eventController, mailboxDetails, recipientsModel, new NoZoneDateProvider(), mailboxProperties, async (mail) => {
			return false;
		});
		(0, import_testdouble$31.replace)(model, "getDefaultSender", () => DEFAULT_SENDER_FOR_TESTING);
	});
	dist_default.spec("initialization", function() {
		dist_default("initWithTemplate empty", async function() {
			await model.initWithTemplate({}, "", "", [], false);
			dist_default(model.getConversationType()).equals(ConversationType.NEW);
			dist_default(model.getSubject()).equals("");
			dist_default(model.getBody()).equals("");
			dist_default(model.getDraft()).equals(null);
			dist_default(model.allRecipients().length).equals(0);
			dist_default(model.getSender()).equals(DEFAULT_SENDER_FOR_TESTING);
			dist_default(model.isConfidential()).equals(true);
			dist_default(model.containsExternalRecipients()).equals(false);
			dist_default(model.getAttachments().length).equals(0);
			dist_default(model.hasMailChanged()).equals(false)("initialization should not flag mail changed");
		});
		dist_default("initWithTemplate data", async function() {
			const initializedModel = await model.initWithTemplate({ to: [INTERNAL_RECIPIENT_1] }, SUBJECT_LINE_1, BODY_TEXT_1, [], false, DEFAULT_SENDER_FOR_TESTING);
			dist_default(initializedModel.getConversationType()).equals(ConversationType.NEW);
			dist_default(initializedModel.getSubject()).equals(SUBJECT_LINE_1);
			dist_default(initializedModel.getBody()).equals(BODY_TEXT_1);
			dist_default(initializedModel.getDraft()).equals(null);
			dist_default(initializedModel.allRecipients().length).equals(1);
			dist_default(initializedModel.getSender()).equals(DEFAULT_SENDER_FOR_TESTING);
			dist_default(model.isConfidential()).equals(true);
			dist_default(model.containsExternalRecipients()).equals(false);
			dist_default(initializedModel.getAttachments().length).equals(0);
			dist_default(initializedModel.hasMailChanged()).equals(false)("initialization should not flag mail changed");
		});
		dist_default("initWithTemplate duplicated recipients", async function() {
			const duplicate = {
				name: INTERNAL_RECIPIENT_1.name,
				address: INTERNAL_RECIPIENT_1.address,
				contact: INTERNAL_RECIPIENT_1.contact
			};
			const initializedModel = await model.initWithTemplate({ to: [INTERNAL_RECIPIENT_1, duplicate] }, SUBJECT_LINE_1, BODY_TEXT_1, [], false, DEFAULT_SENDER_FOR_TESTING);
			dist_default(initializedModel.getConversationType()).equals(ConversationType.NEW);
			dist_default(initializedModel.getSubject()).equals(SUBJECT_LINE_1);
			dist_default(initializedModel.getBody()).equals(BODY_TEXT_1);
			dist_default(initializedModel.getDraft()).equals(null);
			dist_default(initializedModel.allRecipients().length).equals(1);
			dist_default(initializedModel.getSender()).equals(DEFAULT_SENDER_FOR_TESTING);
			dist_default(model.isConfidential()).equals(true);
			dist_default(model.containsExternalRecipients()).equals(false);
			dist_default(initializedModel.getAttachments().length).equals(0);
			dist_default(initializedModel.hasMailChanged()).equals(false)("initialization should not flag mail changed");
		});
		dist_default("initWithDraft with blank data", async function() {
			const draft = createTestEntity(MailTypeRef, {
				confidential: false,
				sender: createTestEntity(MailAddressTypeRef),
				subject: "",
				conversationEntry: testIdGenerator.newIdTuple()
			});
			const draftDetails = createTestEntity(MailDetailsTypeRef, {
				recipients: createTestEntity(RecipientsTypeRef),
				body: createTestEntity(BodyTypeRef, { text: BODY_TEXT_1 })
			});
			(0, import_testdouble$31.when)(entity.load(ConversationEntryTypeRef, draft.conversationEntry)).thenResolve(createTestEntity(ConversationEntryTypeRef, { conversationType: ConversationType.REPLY }));
			const initializedModel = await model.initWithDraft(draft, draftDetails, [], new Map());
			dist_default(initializedModel.getConversationType()).equals(ConversationType.REPLY);
			dist_default(initializedModel.getSubject()).equals(draft.subject);
			dist_default(initializedModel.getBody()).equals(BODY_TEXT_1);
			dist_default(initializedModel.getDraft()).equals(draft);
			dist_default(initializedModel.allRecipients().length).equals(0);
			dist_default(initializedModel.getSender()).equals(DEFAULT_SENDER_FOR_TESTING);
			dist_default(model.isConfidential()).equals(true);
			dist_default(model.containsExternalRecipients()).equals(false);
			dist_default(initializedModel.getAttachments().length).equals(0);
			dist_default(initializedModel.hasMailChanged()).equals(false)("initialization should not flag mail changed");
		});
		dist_default("initWithDraft with some data", async function() {
			const draft = createTestEntity(MailTypeRef, {
				confidential: true,
				sender: createTestEntity(MailAddressTypeRef),
				subject: SUBJECT_LINE_1,
				conversationEntry: testIdGenerator.newIdTuple()
			});
			const recipients = createTestEntity(RecipientsTypeRef, {
				toRecipients: [createTestEntity(MailAddressTypeRef, { address: "" }), createTestEntity(MailAddressTypeRef, { address: EXTERNAL_ADDRESS_1 })],
				ccRecipients: [createTestEntity(MailAddressTypeRef, { address: EXTERNAL_ADDRESS_2 })]
			});
			const draftDetails = createTestEntity(MailDetailsTypeRef, {
				recipients,
				body: createTestEntity(BodyTypeRef, { text: BODY_TEXT_1 })
			});
			(0, import_testdouble$31.when)(entity.load(ConversationEntryTypeRef, draft.conversationEntry)).thenResolve(createTestEntity(ConversationEntryTypeRef, { conversationType: ConversationType.FORWARD }));
			const initializedModel = await model.initWithDraft(draft, draftDetails, [], new Map());
			dist_default(initializedModel.getConversationType()).equals(ConversationType.FORWARD);
			dist_default(initializedModel.getSubject()).equals(draft.subject);
			dist_default(initializedModel.getBody()).equals(BODY_TEXT_1);
			dist_default(initializedModel.getDraft()).equals(draft);
			dist_default(initializedModel.allRecipients().length).equals(2)("Only MailAddresses with a valid address will be accepted as recipients");
			dist_default(initializedModel.toRecipients().length).equals(1);
			dist_default(initializedModel.ccRecipients().length).equals(1);
			dist_default(initializedModel.bccRecipients().length).equals(0);
			dist_default(initializedModel.getSender()).equals(DEFAULT_SENDER_FOR_TESTING);
			dist_default(model.isConfidential()).equals(true);
			dist_default(model.containsExternalRecipients()).equals(true);
			dist_default(initializedModel.getAttachments().length).equals(0);
		});
	});
	dist_default.spec("Adding and removing recipients", function() {
		dist_default.beforeEach(async function() {
			await model.initWithTemplate({}, "", "", [], false, "");
		});
		dist_default("adding duplicate to-recipient", async function() {
			const recipient = {
				name: "sanchez",
				address: "123@test.com",
				contact: null,
				type: null
			};
			model.addRecipient(RecipientField.TO, recipient, ResolveMode.Eager);
			const r1 = model.getRecipient(RecipientField.TO, recipient.address);
			model.addRecipient(RecipientField.TO, recipient, ResolveMode.Eager);
			verify(recipientsModel.resolve(recipient, ResolveMode.Eager), { times: 1 });
			dist_default(model.toRecipients().length).equals(1);
			dist_default(model.ccRecipients().length).equals(0);
			dist_default(model.bccRecipients().length).equals(0);
		});
		dist_default("add different to-recipients", async function() {
			const pablo = {
				name: "pablo",
				address: "pablo94@test.co.uk",
				contact: null,
				type: null
			};
			const cortez = {
				name: "cortez",
				address: "c.asd@test.net",
				contact: null,
				type: null
			};
			model.addRecipient(RecipientField.TO, pablo, ResolveMode.Eager);
			model.addRecipient(RecipientField.TO, cortez, ResolveMode.Eager);
			verify(recipientsModel.resolve(pablo, ResolveMode.Eager));
			verify(recipientsModel.resolve(cortez, ResolveMode.Eager));
			dist_default(model.toRecipients().length).equals(2);
			dist_default(model.ccRecipients().length).equals(0);
			dist_default(model.bccRecipients().length).equals(0);
		});
		dist_default("add duplicate recipients to different fields", async function() {
			const recipient = {
				name: "sanchez",
				address: "123@test.com",
				contact: null,
				type: null
			};
			model.addRecipient(RecipientField.TO, recipient, ResolveMode.Eager);
			model.addRecipient(RecipientField.CC, recipient, ResolveMode.Eager);
			verify(recipientsModel.resolve(recipient, ResolveMode.Eager), { times: 2 });
			dist_default(model.toRecipients().length).equals(1);
			dist_default(model.ccRecipients().length).equals(1);
			dist_default(model.bccRecipients().length).equals(0);
		});
	});
	dist_default.spec("Sending", function() {
		dist_default("completely blank email", async function() {
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			const e = await assertThrows(UserError, () => model.send(method, getConfirmation$1));
			dist_default(e?.message).equals(lang.get("noRecipients_msg"));
			verify(getConfirmation$1(), { times: 0 });
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 0 });
			verify(mailFacade.createDraft(anything$4()), { times: 0 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
		});
		dist_default("blank subject no confirm", async function() {
			model.addRecipient(RecipientField.TO, {
				name: "test",
				address: "test@address.com",
				contact: null
			});
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			const r = await model.send(method, getConfirmation$1);
			dist_default(r).equals(false);
			verify(getConfirmation$1(), { times: 0 });
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 0 });
			verify(mailFacade.createDraft(anything$4()), { times: 0 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
		});
		dist_default("confidential missing password", async function() {
			await model.addRecipient(RecipientField.TO, {
				name: "test",
				address: "test@address.com",
				contact: null
			});
			model.setConfidential(true);
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1(anything$4())).thenResolve(true);
			const e = await assertThrows(UserError, () => model.send(method, getConfirmation$1));
			dist_default(e?.message).equals(lang.get("noPreSharedPassword_msg"));
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 0 });
			verify(mailFacade.createDraft(anything$4()), { times: 0 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
		});
		dist_default("confidential weak password no confirm", async function() {
			const recipient = {
				name: "test",
				address: "test@address.com",
				contact: null
			};
			await model.initWithTemplate({ to: [recipient] }, "subject", "", [], true, "me@tuta.com", false);
			model.setPassword("test@address.com", "abc");
			dist_default(model.getPassword(recipient.address)).equals("abc");
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1(anything$4())).thenResolve(false);
			const r = await model.send(method, getConfirmation$1);
			dist_default(r).equals(false);
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 0 });
			verify(mailFacade.createDraft(anything$4()), { times: 0 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
		});
		dist_default("confidential weak password confirm", async function() {
			const recipient = {
				name: "test",
				address: "test@address.com",
				contact: null
			};
			await model.initWithTemplate({ to: [recipient] }, "did you get that thing i sent ya?", "", [], true, "me@tutanota.de", false);
			const password = WEAK_PASSWORD;
			model.setPassword("test@address.com", password);
			dist_default(model.getPassword(recipient.address)).equals(password);
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1(anything$4())).thenResolve(true);
			const r = await model.send(method, getConfirmation$1);
			dist_default(r).equals(true);
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 1 });
			verify(mailFacade.createDraft(anything$4()), { times: 1 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
			const contact = model.getRecipientList(RecipientField.TO)[0].contact;
			dist_default(contact.presharedPassword).equals(password);
		});
		dist_default("correct password will be returned from getPassword after calling setPassword", function() {
			model.setPassword("address1", "password1");
			model.setPassword("address2", "password2");
			dist_default(model.getPassword("address2")).equals("password2");
			dist_default(model.getPassword("address1")).equals("password1");
		});
		dist_default("confidential strong password", async function() {
			const address = "test@address.com";
			const recipient = {
				name: "test",
				address,
				contact: null
			};
			await model.initWithTemplate({ to: [recipient] }, "subjecttttt", "", [], true, "me@tutanota.de", false);
			const password = STRONG_PASSWORD;
			model.setPassword(address, password);
			const method = MailMethod.NONE;
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			const r = await model.send(method, getConfirmation$1);
			dist_default(r).equals(true);
			verify(getConfirmation$1(anything$4), { times: 0 });
			verify(mailFacade.sendDraft(anything$4(), anything$4(), anything$4()), { times: 1 });
			verify(mailFacade.createDraft(anything$4()), { times: 1 });
			verify(mailFacade.updateDraft(anything$4()), { times: 0 });
			const contact = model.getRecipientList(RecipientField.TO)[0].contact;
			dist_default(contact.presharedPassword).equals(password);
		});
		dist_default("when a recipient has an existing contact, and the saved password changes, then the contact will be updated", async function() {
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			const contact = createTestEntity(ContactTypeRef, {
				_id: testIdGenerator.newIdTuple(),
				firstName: "my",
				lastName: "chippie",
				presharedPassword: "weak password"
			});
			await model.initWithTemplate({ to: [] }, "did you get that thing i sent ya?", "no?", [], true, "me@tutanota.de", false);
			await model.addRecipient(RecipientField.TO, {
				name: "chippie",
				address: "chippie@cinco.net",
				contact
			});
			model.setPassword("chippie@cinco.net", STRONG_PASSWORD);
			await model.send(MailMethod.NONE, getConfirmation$1);
			verify(entity.update(contact), { times: 1 });
		});
	});
	dist_default.spec("Entity Event Updates", function() {
		let existingContact;
		let recipients;
		dist_default.before(function() {
			existingContact = createTestEntity(ContactTypeRef, {
				_id: testIdGenerator.newIdTuple(),
				firstName: "james",
				lastName: "hetfield"
			});
			recipients = [{
				name: "paul gilbert",
				address: "paul@gmail.com",
				contact: null
			}, {
				name: "james hetfield",
				address: "james@tuta.com",
				contact: existingContact
			}];
		});
		dist_default("nonmatching event", async function() {
			await model.handleEntityEvent(downcast(CustomerAccountCreateDataTypeRef));
			await model.handleEntityEvent(downcast(UserTypeRef));
			await model.handleEntityEvent(downcast(CustomerTypeRef));
			await model.handleEntityEvent(downcast(NotificationMailTypeRef));
			await model.handleEntityEvent(downcast(ChallengeTypeRef));
			await model.handleEntityEvent(downcast(MailTypeRef));
			verify(entity.load(anything$4(), anything$4(), anything$4()), { times: 0 });
		});
		dist_default("contact updated email kept", async function() {
			const { app, type } = ContactTypeRef;
			const [instanceListId, instanceId] = existingContact._id;
			const contactForUpdate = {
				firstName: "newfirstname",
				lastName: "newlastname",
				mailAddresses: [createTestEntity(MailAddressTypeRef, { address: "james@tuta.com" }), createTestEntity(MailAddressTypeRef, { address: "address2@hotmail.com" })]
			};
			(0, import_testdouble$31.when)(entity.load(ContactTypeRef, argThat$1((id) => isSameId(id, existingContact._id)))).thenResolve(createContact(Object.assign({ _id: existingContact._id }, contactForUpdate)));
			await model.initWithTemplate({ to: recipients }, "somb", "", [], true, "a@b.c", false);
			await model.handleEntityEvent({
				application: app,
				type,
				operation: OperationType.UPDATE,
				instanceListId,
				instanceId
			});
			dist_default(model.allRecipients().length).equals(2);
			const updatedRecipient = model.allRecipients().find((r) => r.contact && isSameId(r.contact._id, existingContact._id));
			dist_default(updatedRecipient && updatedRecipient.name).equals(getContactDisplayName(downcast(contactForUpdate)));
		});
		dist_default("contact updated email removed or changed", async function() {
			const { app, type } = ContactTypeRef;
			const [instanceListId, instanceId] = existingContact._id;
			const contactForUpdate = {
				firstName: "james",
				lastName: "hetfield",
				mailAddresses: [createTestEntity(MailAddressTypeRef, { address: "nolongerjames@hotmail.com" })]
			};
			(0, import_testdouble$31.when)(entity.load(ContactTypeRef, existingContact._id)).thenResolve(createContact(Object.assign({ _id: existingContact._id }, contactForUpdate)));
			await model.initWithTemplate({ to: recipients }, "b", "c", [], true, "", false);
			await model.handleEntityEvent({
				application: app,
				type,
				operation: OperationType.UPDATE,
				instanceListId,
				instanceId
			});
			dist_default(model.allRecipients().length).equals(1);
			const updatedContact = model.allRecipients().find((r) => r.contact && isSameId(r.contact._id, existingContact._id));
			dist_default(updatedContact ?? null).equals(null);
		});
		dist_default("contact removed", async function() {
			const { app, type } = ContactTypeRef;
			const [instanceListId, instanceId] = existingContact._id;
			await model.initWithTemplate({ to: recipients }, "subj", "", [], true, "a@b.c", false);
			await model.handleEntityEvent({
				application: app,
				type,
				operation: OperationType.DELETE,
				instanceListId,
				instanceId
			});
			dist_default(model.allRecipients().length).equals(1);
			const updatedContact = model.allRecipients().find((r) => r.contact && isSameId(r.contact._id, existingContact._id));
			dist_default(updatedContact == null).equals(true);
		});
		dist_default("too many to recipients dont confirm", async function() {
			const recipients$1 = { to: [] };
			for (let i = 0; i < TOO_MANY_VISIBLE_RECIPIENTS; ++i) recipients$1.to.push({
				name: `person ${i}`,
				address: `person${i}@tutanota.de`
			});
			const subject = "subyekt";
			const body = "bodie";
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1("manyRecipients_msg")).thenResolve(false);
			await model.initWithTemplate(recipients$1, subject, body, [], false, "eggs@tutanota.de", false);
			const hasBeenSent = await model.send(MailMethod.NONE, getConfirmation$1);
			dist_default(hasBeenSent).equals(false)("nothing was sent");
			verify(getConfirmation$1("manyRecipients_msg"), { times: 1 });
		});
		dist_default("too many to recipients confirm", async function() {
			const recipients$1 = { to: [] };
			for (let i = 0; i < TOO_MANY_VISIBLE_RECIPIENTS; ++i) recipients$1.to.push({
				name: `person ${i}`,
				address: `person${i}@tutanota.de`
			});
			const subject = "subyekt";
			const body = "bodie";
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1("manyRecipients_msg")).thenResolve(true);
			await model.initWithTemplate(recipients$1, subject, body, [], false, "eggs@tutanota.de");
			dist_default(await model.send(MailMethod.NONE, getConfirmation$1)).equals(true);
			verify(getConfirmation$1("manyRecipients_msg"), { times: 1 });
		});
		dist_default("too many cc recipients dont confirm", async function() {
			const recipients$1 = { cc: [] };
			for (let i = 0; i < TOO_MANY_VISIBLE_RECIPIENTS; ++i) recipients$1.cc.push({
				name: `person ${i}`,
				address: `person${i}@tutanota.de`
			});
			const subject = "subyekt";
			const body = "bodie";
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1("manyRecipients_msg")).thenResolve(false);
			await model.initWithTemplate(recipients$1, subject, body, [], false, "eggs@tutanota.de");
			dist_default(await model.send(MailMethod.NONE, getConfirmation$1)).equals(false);
			verify(getConfirmation$1("manyRecipients_msg"), { times: 1 });
		});
		dist_default("too many cc recipients confirm", async function() {
			const recipients$1 = { cc: [] };
			for (let i = 0; i < TOO_MANY_VISIBLE_RECIPIENTS; ++i) recipients$1.cc.push({
				name: `person ${i}`,
				address: `person${i}@tutanota.de`
			});
			const subject = "subyekt";
			const body = "bodie";
			const getConfirmation$1 = (0, import_testdouble$31.func)();
			(0, import_testdouble$31.when)(getConfirmation$1("manyRecipients_msg")).thenResolve(true);
			await model.initWithTemplate(recipients$1, subject, body, [], false, "eggs@tutanota.de");
			dist_default(await model.send(MailMethod.NONE, getConfirmation$1)).equals(true);
			verify(getConfirmation$1("manyRecipients_msg"), { times: 1 });
		});
	});
});

//#endregion
//#region tests/misc/OutOfOfficeNotificationTest.ts
dist_default.spec("OutOfOfficeNotificationTest", function() {
	const mockedAttributes = [];
	dist_default.before(function() {
		mockedAttributes.push(mockAttribute(lang, lang.get, function(key, obj) {
			if (key === "activated_label") return "Activated";
else if (key === "deactivated_label") return "Deactivated";
			throw new Error("unexpected translation key: " + key);
		}));
	});
	dist_default.after(function() {
		for (const mockedAttribute of mockedAttributes) unmockAttribute(mockedAttribute);
	});
	dist_default("Active state formatting", function() {
		lang._setLanguageTag("en");
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: null,
			endDate: null
		});
		dist_default(formatActivateState(notification)).equals("Activated");
		notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: new Date(2020, 11, 15),
			endDate: null
		});
		dist_default(formatActivateState(notification)).equals("Activated (12/15/2020)");
		notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: new Date(2020, 11, 15),
			endDate: new Date(2021, 0, 9)
		});
		dist_default(formatActivateState(notification)).equals("Activated (12/15/2020 - 1/8/2021)");
		notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: false,
			startDate: new Date(2020, 11, 15),
			endDate: new Date(2021, 0, 10)
		});
		dist_default(formatActivateState(notification)).equals("Deactivated");
	});
	dist_default("is active with enabled notification", function() {
		const now$1 = new Date();
		const oneDayBefore = getDayShifted(now$1, -1);
		const oneDayAfter = getDayShifted(now$1, 1);
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: null,
			endDate: null
		});
		dist_default(isNotificationCurrentlyActive(notification, now$1)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, oneDayBefore)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, oneDayAfter)).equals(true);
	});
	dist_default("is active with disabled notification", function() {
		const now$1 = new Date();
		const oneDayBefore = getDayShifted(now$1, -1);
		const oneDayAfter = getDayShifted(now$1, 1);
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: false,
			startDate: null,
			endDate: null
		});
		dist_default(isNotificationCurrentlyActive(notification, now$1)).equals(false);
		dist_default(isNotificationCurrentlyActive(notification, oneDayBefore)).equals(false);
		dist_default(isNotificationCurrentlyActive(notification, oneDayAfter)).equals(false);
	});
	dist_default("is active with startDate", function() {
		const now$1 = new Date();
		const oneDayBefore = getDayShifted(now$1, -1);
		const oneDayAfter = getDayShifted(now$1, 1);
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: getStartOfDay(now$1),
			endDate: null
		});
		dist_default(isNotificationCurrentlyActive(notification, now$1)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, oneDayBefore)).equals(false);
		dist_default(isNotificationCurrentlyActive(notification, oneDayAfter)).equals(true);
	});
	dist_default("is active with start and end date", function() {
		const now$1 = new Date();
		const oneDayBefore = getDayShifted(now$1, -1);
		const oneDayAfter = getDayShifted(now$1, 1);
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: getStartOfDay(now$1),
			endDate: getStartOfNextDay(now$1)
		});
		dist_default(isNotificationCurrentlyActive(notification, now$1)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, oneDayBefore)).equals(false);
		dist_default(isNotificationCurrentlyActive(notification, oneDayAfter)).equals(false);
	});
	dist_default("is active with start and end date 2", function() {
		const now$1 = new Date();
		const activeUntil = getDayShifted(now$1, 5);
		const oneDayAfter = getStartOfNextDay(activeUntil);
		let notification = createTestEntity(OutOfOfficeNotificationTypeRef, {
			enabled: true,
			startDate: getStartOfDay(now$1),
			endDate: getStartOfNextDay(activeUntil)
		});
		dist_default(isNotificationCurrentlyActive(notification, now$1)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, activeUntil)).equals(true);
		dist_default(isNotificationCurrentlyActive(notification, oneDayAfter)).equals(false);
	});
});

//#endregion
//#region tests/subscription/priceTestUtils.ts
var import_testdouble$30 = __toESM(require_testdouble(), 1);
const PLAN_PRICES = {
	Free: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "0.00",
		business: false,
		firstYearDiscount: "0",
		includedAliases: "0",
		includedStorage: "1",
		monthlyPrice: "0.00",
		monthlyReferencePrice: "0.00",
		sharing: false,
		whitelabel: false,
		planName: "Free",
		businessPlan: false,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "0",
			whitelabel: false
		})
	}),
	PremiumBusiness: createTestEntity(PlanPricesTypeRef, {
		_id: "",
		_type: undefined,
		customDomains: "",
		sharing: false,
		whitelabel: false,
		additionalUserPriceMonthly: "2.40",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "5",
		includedStorage: "1",
		monthlyPrice: "2.40",
		monthlyReferencePrice: "2.40",
		planName: "PremiumBusiness",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "5",
			whitelabel: false
		})
	}),
	Premium: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "1.20",
		business: false,
		firstYearDiscount: "0",
		includedAliases: "5",
		includedStorage: "1",
		monthlyPrice: "1.20",
		monthlyReferencePrice: "1.20",
		planName: "Premium",
		businessPlan: false,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "5",
			whitelabel: false
		})
	}),
	Pro: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "4.80",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "20",
		includedStorage: "10",
		monthlyPrice: "8.40",
		monthlyReferencePrice: "8.40",
		planName: "Pro",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "20",
			whitelabel: false
		})
	}),
	TeamsBusiness: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "3.60",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "5",
		includedStorage: "10",
		monthlyPrice: "6.00",
		monthlyReferencePrice: "6.00",
		planName: "TeamsBusiness",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "5",
			whitelabel: false
		})
	}),
	Teams: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "2.40",
		business: false,
		firstYearDiscount: "0",
		includedAliases: "5",
		includedStorage: "10",
		monthlyPrice: "4.80",
		monthlyReferencePrice: "4.80",
		planName: "Teams",
		businessPlan: false,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "5",
			whitelabel: false
		})
	}),
	Revolutionary: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "3.60",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "15",
		includedStorage: "20",
		monthlyPrice: "3.60",
		monthlyReferencePrice: "3.60",
		sharing: true,
		whitelabel: false,
		planName: "Revolutionary",
		businessPlan: false,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "15",
			whitelabel: false
		})
	}),
	Legend: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "9.60",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "30",
		includedStorage: "500",
		monthlyPrice: "9.60",
		monthlyReferencePrice: "9.60",
		sharing: true,
		whitelabel: false,
		planName: "Legend",
		businessPlan: false,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "30",
			whitelabel: false
		})
	}),
	Essential: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "7.20",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "15",
		includedStorage: "50",
		monthlyPrice: "7.20",
		monthlyReferencePrice: "7.20",
		sharing: true,
		whitelabel: false,
		planName: "Essential",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "15",
			whitelabel: false
		})
	}),
	Advanced: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "9.60",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "30",
		includedStorage: "500",
		monthlyPrice: "9.60",
		monthlyReferencePrice: "9.60",
		sharing: true,
		whitelabel: false,
		planName: "Advanced",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "30",
			whitelabel: false
		})
	}),
	Unlimited: createTestEntity(PlanPricesTypeRef, {
		additionalUserPriceMonthly: "14.40",
		business: true,
		firstYearDiscount: "0",
		includedAliases: "30",
		includedStorage: "1000",
		monthlyPrice: "14.40",
		monthlyReferencePrice: "14.40",
		sharing: true,
		whitelabel: true,
		planName: "Unlimited",
		businessPlan: true,
		planConfiguration: createTestEntity(PlanConfigurationTypeRef, {
			nbrOfAliases: "30",
			whitelabel: true
		})
	})
};
function createUpgradePriceServiceMock(planPrices = PLAN_PRICES, registrationDataId = null, bonusMonths = 0) {
	const executorMock = (0, import_testdouble$30.object)();
	(0, import_testdouble$30.when)(executorMock.get(UpgradePriceService, import_testdouble$30.matchers.anything())).thenResolve({
		premiumPrices: planPrices.Premium,
		premiumBusinessPrices: planPrices.PremiumBusiness,
		teamsPrices: planPrices.Teams,
		teamsBusinessPrices: planPrices.TeamsBusiness,
		proPrices: planPrices.Pro,
		revolutionaryPrices: planPrices.Revolutionary,
		legendaryPrices: planPrices.Legend,
		essentialPrices: planPrices.Essential,
		advancedPrices: planPrices.Advanced,
		unlimitedPrices: planPrices.Unlimited,
		freePrices: planPrices.Free,
		bonusMonthsForYearlyPlan: String(bonusMonths),
		plans: Object.values(planPrices)
	});
	return executorMock;
}

//#endregion
//#region tests/subscription/PriceUtilsTest.ts
dist_default.spec("PriceUtilsTest", function() {
	dist_default.before(async function() {
		lang.init(en_default);
	});
	dist_default("getSubscriptionPrice premium yearly price", async function() {
		const provider = await initPriceAndConfigProvider();
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanReferencePrice)).equals(12);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanActualPrice)).equals(12);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.AdditionalUserPrice)).equals(12);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanNextYearsPrice)).equals(12);
	});
	dist_default("getSubscriptionPrice premium monthly price", async function() {
		const provider = await initPriceAndConfigProvider();
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanReferencePrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanActualPrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.AdditionalUserPrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanNextYearsPrice)).equals(1.2);
	});
	dist_default("getSubscriptionPrice Premium discount yearly", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		discountPlanPrices.Premium.firstYearDiscount = "12";
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanReferencePrice)).equals(12);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanActualPrice)).equals(0);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.AdditionalUserPrice)).equals(12);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Premium, UpgradePriceType.PlanNextYearsPrice)).equals(12);
	});
	dist_default("getSubscriptionPrice Pro discount yearly", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		discountPlanPrices.Pro.firstYearDiscount = "84";
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Pro, UpgradePriceType.PlanReferencePrice)).equals(84);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Pro, UpgradePriceType.PlanActualPrice)).equals(0);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Pro, UpgradePriceType.AdditionalUserPrice)).equals(48);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Pro, UpgradePriceType.PlanNextYearsPrice)).equals(84);
	});
	dist_default("getSubscriptionPrice Premium discount monthly", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		discountPlanPrices.Premium.firstYearDiscount = "12";
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanReferencePrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanActualPrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.AdditionalUserPrice)).equals(1.2);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Premium, UpgradePriceType.PlanNextYearsPrice)).equals(1.2);
	});
	dist_default("getSubscriptionPrice Revolutionary discount monthly", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		discountPlanPrices.Premium.firstYearDiscount = "36";
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Revolutionary, UpgradePriceType.PlanReferencePrice)).equals(3.6);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Revolutionary, UpgradePriceType.PlanActualPrice)).equals(3.6);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Revolutionary, UpgradePriceType.AdditionalUserPrice)).equals(3.6);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Monthly, PlanType.Revolutionary, UpgradePriceType.PlanNextYearsPrice)).equals(3.6);
	});
	dist_default("getSubscriptionPrice Revolutionary discount yearly", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		discountPlanPrices.Revolutionary.firstYearDiscount = "36";
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Revolutionary, UpgradePriceType.PlanReferencePrice)).equals(36);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Revolutionary, UpgradePriceType.PlanActualPrice)).equals(0);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Revolutionary, UpgradePriceType.AdditionalUserPrice)).equals(36);
		dist_default(provider.getSubscriptionPrice(PaymentInterval.Yearly, PlanType.Revolutionary, UpgradePriceType.PlanNextYearsPrice)).equals(36);
	});
	dist_default("formatMonthlyPrices", function() {
		dist_default(formatMonthlyPrice(0, 12)).equals("0");
		dist_default(formatMonthlyPrice(0, 1)).equals("0");
		dist_default(formatMonthlyPrice(12, 12)).equals("1");
		dist_default(formatMonthlyPrice(12, 1)).equals("12");
		dist_default(formatMonthlyPrice(1.2, 12)).equals("0.10");
		dist_default(formatMonthlyPrice(1.2, 1)).equals("1.20");
	});
	dist_default("getPriceInfoMessage - default", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getPriceInfoMessage()).equals(null);
	});
	dist_default("getPriceInfoMessage - bonus months", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices, null, 12);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, null);
		dist_default(provider.getPriceInfoMessage()).equals("chooseYearlyForOffer_msg");
	});
	dist_default("getPriceInfoMessage - referral code", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices, null, 1);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, "abc");
		dist_default(provider.getPriceInfoMessage()).equals("referralSignup_msg");
	});
	dist_default("getPriceInfoMessage - referral code invalid", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices, null, 0);
		const provider = await PriceAndConfigProvider.getInitializedInstance(null, priceServiceMock, "abc");
		dist_default(provider.getPriceInfoMessage()).equals("referralSignupInvalid_msg");
	});
	dist_default("getPriceInfoMessage - referral code and registration id not allowed", async function() {
		const discountPlanPrices = clone(PLAN_PRICES);
		const priceServiceMock = createUpgradePriceServiceMock(discountPlanPrices, null, 0);
		try {
			await PriceAndConfigProvider.getInitializedInstance("reg-data-id", priceServiceMock, "abc");
			throw new Error("exception expected");
		} catch (e) {
			dist_default(e instanceof UserError).equals(true);
		}
	});
});
dist_default.spec("PaymentInterval", function() {
	dist_default("asPaymentInterval correct values", function() {
		dist_default(asPaymentInterval(1)).equals(PaymentInterval.Monthly);
		dist_default(asPaymentInterval(12)).equals(PaymentInterval.Yearly);
		dist_default(asPaymentInterval("1")).equals(PaymentInterval.Monthly);
		dist_default(asPaymentInterval("12")).equals(PaymentInterval.Yearly);
	});
	dist_default("asPaymentInterval rejects invalid values", function() {
		dist_default(() => asPaymentInterval(0)).throws(ProgrammingError);
		dist_default(() => asPaymentInterval("0")).throws(ProgrammingError);
		dist_default(() => asPaymentInterval("")).throws(ProgrammingError);
		dist_default(() => asPaymentInterval(null)).throws(ProgrammingError);
		dist_default(() => asPaymentInterval(undefined)).throws(ProgrammingError);
	});
});
async function initPriceAndConfigProvider() {
	const serviceExecutor = createUpgradePriceServiceMock();
	return PriceAndConfigProvider.getInitializedInstance(null, serviceExecutor, null);
}

//#endregion
//#region tests/subscription/SubscriptionUtilsTest.ts
dist_default.spec("SubscriptionUtilsTest", function() {
	let serviceExecutor;
	dist_default.beforeEach(async function() {
		serviceExecutor = createUpgradePriceServiceMock(clone(PLAN_PRICES));
	});
	dist_default.spec("getAvailableMatchingPlans", function() {
		dist_default("no filter returns all plans", async function() {
			dist_default(await getAvailableMatchingPlans(serviceExecutor, () => true)).deepEquals(NewPaidPlans);
		});
		dist_default("filter for whitelabel", async function() {
			dist_default(await getAvailableMatchingPlans(serviceExecutor, (configuration) => configuration.whitelabel)).deepEquals([PlanType.Unlimited]);
		});
	});
});

//#endregion
//#region tests/subscription/CreditCardViewModelTest.ts
var import_testdouble$29 = __toESM(require_testdouble(), 1);
dist_default.spec("inferExpirationDate month", function() {
	dist_default("starting with invalid character returns empty string", function() {
		dist_default(inferExpirationDate("a")).equals("");
		dist_default(inferExpirationDate("a12")).equals("");
		dist_default(inferExpirationDate("/")).equals("");
		dist_default(inferExpirationDate("/23")).equals("");
		dist_default(inferExpirationDate("?")).equals("");
		dist_default(inferExpirationDate("?01/24")).equals("");
		dist_default(inferExpirationDate("")).equals("");
	});
	dist_default("starting with definite month returns expanded month", function() {
		dist_default(inferExpirationDate("2")).equals("02 / ");
		dist_default(inferExpirationDate("3")).equals("03 / ");
		dist_default(inferExpirationDate("4")).equals("04 / ");
		dist_default(inferExpirationDate("5")).equals("05 / ");
		dist_default(inferExpirationDate("6")).equals("06 / ");
		dist_default(inferExpirationDate("7")).equals("07 / ");
		dist_default(inferExpirationDate("8")).equals("08 / ");
		dist_default(inferExpirationDate("9")).equals("09 / ");
		dist_default(inferExpirationDate("2/")).equals("02 / ");
		dist_default(inferExpirationDate("3/")).equals("03 / ");
		dist_default(inferExpirationDate("4/")).equals("04 / ");
		dist_default(inferExpirationDate("5/")).equals("05 / ");
		dist_default(inferExpirationDate("6/")).equals("06 / ");
		dist_default(inferExpirationDate("7/")).equals("07 / ");
		dist_default(inferExpirationDate("8/")).equals("08 / ");
		dist_default(inferExpirationDate("9/")).equals("09 / ");
	});
	dist_default.spec("starting with indefinite month", function() {
		dist_default("starting with 1 returns 1", function() {
			dist_default(inferExpirationDate("1")).equals("1");
		});
		dist_default("starting with 0 returns 0", function() {
			dist_default(inferExpirationDate("0")).equals("0");
		});
		dist_default("starting with 1/ returns 01/", function() {
			dist_default(inferExpirationDate("1/")).equals("01 / ");
		});
		dist_default("starting with 10, 11, 12 gives input plus slash, strips invalid suffix", function() {
			dist_default(inferExpirationDate("10")).equals("10 / ");
			dist_default(inferExpirationDate("11")).equals("11 / ");
			dist_default(inferExpirationDate("12")).equals("12 / ");
			dist_default(inferExpirationDate("10 /")).equals("10 / ");
			dist_default(inferExpirationDate("11 /")).equals("11 / ");
			dist_default(inferExpirationDate("12 /")).equals("12 / ");
			dist_default(inferExpirationDate("10 / a")).equals("10 / ");
			dist_default(inferExpirationDate("11/ ?")).equals("11 / ");
			dist_default(inferExpirationDate("11//")).equals("11 / ");
			dist_default(inferExpirationDate("12 / 3")).equals("12 / 3");
		});
		dist_default("starting with 13-19 infers january and uses rest of input", function() {
			dist_default(inferExpirationDate("13")).equals("01 / 3");
			dist_default(inferExpirationDate("14")).equals("01 / 4");
			dist_default(inferExpirationDate("15")).equals("01 / 5");
			dist_default(inferExpirationDate("16")).equals("01 / 6");
			dist_default(inferExpirationDate("17")).equals("01 / 7");
			dist_default(inferExpirationDate("18")).equals("01 / 8");
			dist_default(inferExpirationDate("19")).equals("01 / 9");
		});
		dist_default("starting with 0x x={0 or non digit} returns 0", function() {
			dist_default(inferExpirationDate("0/")).equals("0");
			dist_default(inferExpirationDate("00")).equals("0");
			dist_default(inferExpirationDate("0W")).equals("0");
			dist_default(inferExpirationDate("0//")).equals("0");
			dist_default(inferExpirationDate("0 ")).equals("0");
			dist_default(inferExpirationDate("0 ?")).equals("0");
		});
		dist_default("starting with 01 - 09 returns input, potentially with slash", function() {
			dist_default(inferExpirationDate("01")).equals("01 / ");
			dist_default(inferExpirationDate("02")).equals("02 / ");
			dist_default(inferExpirationDate("03")).equals("03 / ");
			dist_default(inferExpirationDate("04")).equals("04 / ");
			dist_default(inferExpirationDate("05")).equals("05 / ");
			dist_default(inferExpirationDate("06")).equals("06 / ");
			dist_default(inferExpirationDate("07")).equals("07 / ");
			dist_default(inferExpirationDate("08")).equals("08 / ");
			dist_default(inferExpirationDate("09")).equals("09 / ");
			dist_default(inferExpirationDate("012")).equals("01 / 2");
			dist_default(inferExpirationDate("022")).equals("02 / 2");
			dist_default(inferExpirationDate("032")).equals("03 / 2");
			dist_default(inferExpirationDate("042")).equals("04 / 2");
			dist_default(inferExpirationDate("052")).equals("05 / 2");
			dist_default(inferExpirationDate("062")).equals("06 / 2");
			dist_default(inferExpirationDate("072")).equals("07 / 2");
			dist_default(inferExpirationDate("082")).equals("08 / 2");
			dist_default(inferExpirationDate("092")).equals("09 / 2");
		});
		dist_default("adding a slash to a complete month adds that slash with whitespace", function() {
			dist_default(inferExpirationDate("01/")).equals("01 / ");
			dist_default(inferExpirationDate("02/")).equals("02 / ");
			dist_default(inferExpirationDate("03/")).equals("03 / ");
			dist_default(inferExpirationDate("04/")).equals("04 / ");
			dist_default(inferExpirationDate("05/")).equals("05 / ");
			dist_default(inferExpirationDate("06/")).equals("06 / ");
			dist_default(inferExpirationDate("07/")).equals("07 / ");
			dist_default(inferExpirationDate("08/")).equals("08 / ");
			dist_default(inferExpirationDate("09/")).equals("09 / ");
		});
		dist_default("four digit input with valid month gets slash", function() {
			dist_default(inferExpirationDate("0123")).equals("01 / 23");
			dist_default(inferExpirationDate("0224")).equals("02 / 24");
			dist_default(inferExpirationDate("0325")).equals("03 / 25");
			dist_default(inferExpirationDate("4205")).equals("04 / 205");
		});
		dist_default("four digit input and slash with valid month returns same", function() {
			dist_default(inferExpirationDate("01/23")).equals("01 / 23");
			dist_default(inferExpirationDate("02/24")).equals("02 / 24");
			dist_default(inferExpirationDate("03/25")).equals("03 / 25");
		});
		dist_default("six digit input with valid month gets slash", function() {
			dist_default(inferExpirationDate("012030")).equals("01 / 2030");
			dist_default(inferExpirationDate("022045")).equals("02 / 2045");
			dist_default(inferExpirationDate("032023")).equals("03 / 2023");
			dist_default(inferExpirationDate("122020")).equals("12 / 2020");
		});
		dist_default("six digit input and slash with valid month return same", function() {
			dist_default(inferExpirationDate("01/2030")).equals("01 / 2030");
			dist_default(inferExpirationDate("02/2045")).equals("02 / 2045");
			dist_default(inferExpirationDate("03/2023")).equals("03 / 2023");
			dist_default(inferExpirationDate("12/2020")).equals("12 / 2020");
			dist_default(inferExpirationDate("12//2020")).equals("12 / 2020");
		});
		dist_default("year contains non digit chars that stops the rest from getting parsed", function() {
			dist_default(inferExpirationDate("01/21%30")).equals("01 / 21");
			dist_default(inferExpirationDate("02/2!445")).equals("02 / 2");
			dist_default(inferExpirationDate("03/202_ 3")).equals("03 / 202");
		});
		dist_default("does not parse the rest if the year has already 4 digits", function() {
			dist_default(inferExpirationDate("01 / 2030sd")).equals("01 / 2030");
			dist_default(inferExpirationDate("02/20452")).equals("02 / 2045");
			dist_default(inferExpirationDate("03/2023__ ")).equals("03 / 2023");
		});
		dist_default("pasting valid format ignores any whitespace", function() {
			dist_default(inferExpirationDate(" \n	1	\n  2 /2\n02 4	\n\n")).equals("12 / 2024");
			dist_default(inferExpirationDate(" \n	0	\n  6 /       2 6	\n\n")).equals("06 / 26");
		});
		dist_default("using backspace removes first year digit and trailing separator", function() {
			dist_default(inferExpirationDate("01 / ", "01 / 5")).equals("01");
			dist_default(inferExpirationDate("1", "11")).equals("1");
			dist_default(inferExpirationDate("01 / 2", "01 / 24")).equals("01 / 2");
		});
		dist_default("typing / backspacing across the slash works as intended", function() {
			dist_default(inferExpirationDate("01 / ", "01 / 2")).equals("01");
			dist_default(inferExpirationDate("01", "0")).equals("01 / ");
			dist_default(inferExpirationDate("01 /", "01 / 2")).equals("01");
			dist_default(inferExpirationDate("01 ", "01 / 2")).equals("01");
			dist_default(inferExpirationDate("01", "0")).equals("01 / ");
			dist_default(inferExpirationDate("03 / ", "03 / 2")).equals("03");
		});
	});
});
dist_default.spec("inferExpirationDate integration", function() {
	dist_default("all dates we may care about at the moment can be typed in four-digit-year format, with leading zero on month", function() {
		const currentYear = new Date().getFullYear();
		let currentMonth = new Date().getMonth() + 1;
		for (let y = currentYear; y < currentYear + 15; y = y + 1) {
			for (currentMonth; currentMonth < 13; currentMonth = currentMonth + 1) {
				const correctDateAsTyped = `${currentMonth.toString().padStart(2, "0")}/${currentYear}`;
				const correctDateAsShown = correctDateAsTyped.replace("/", " / ");
				let lastVal = "";
				for (const c of correctDateAsTyped) lastVal = inferExpirationDate(lastVal + c, lastVal);
				dist_default(lastVal).equals(correctDateAsShown);
			}
			currentMonth = 1;
		}
	});
	dist_default("all dates we may care about at the moment can be typed in two-digit-year format, without leading zero on month", function() {
		const currentYear = new Date().getFullYear();
		let currentMonth = new Date().getMonth() + 1;
		for (let y = currentYear; y < currentYear + 15; y = y + 1) {
			for (currentMonth; currentMonth < 13; currentMonth = currentMonth + 1) {
				const correctDateAsTyped = `${currentMonth}/${currentYear.toString().slice(2)}`;
				const correctDateAsShown = correctDateAsTyped.padStart(5, "0").replace("/", " / ");
				let lastVal = "";
				for (const c of correctDateAsTyped) lastVal = inferExpirationDate(lastVal + c, lastVal);
				dist_default(lastVal).equals(correctDateAsShown);
			}
			currentMonth = 1;
		}
	});
});
dist_default.spec("detectCreditCardIssuer", function() {
	dist_default("amex", function() {
		dist_default(getCardTypeRange("34")).equals(CardType.Amex);
		dist_default(getCardTypeRange("37")).equals(CardType.Amex);
		dist_default(getCardTypeRange("340")).equals(CardType.Amex);
		dist_default(getCardTypeRange("371")).equals(CardType.Amex);
		dist_default(getCardTypeRange("35")).notEquals(CardType.Amex);
		dist_default(getCardTypeRange("374283089890073")).equals(CardType.Amex);
		dist_default(getCardTypeRange("347562087582806")).equals(CardType.Amex);
		dist_default(getCardTypeRange("377118013765255")).equals(CardType.Amex);
		dist_default(getCardTypeRange("377188176009494")).equals(CardType.Amex);
	});
	dist_default("visa", function() {
		dist_default(getCardTypeRange("4")).equals(CardType.Visa);
		dist_default(getCardTypeRange("40")).equals(CardType.Visa);
		dist_default(getCardTypeRange("48")).equals(CardType.Visa);
		dist_default(getCardTypeRange("04")).notEquals(CardType.Visa);
		dist_default(getCardTypeRange("4219430910018892")).equals(CardType.Visa);
		dist_default(getCardTypeRange("4020964956067842")).equals(CardType.Visa);
		dist_default(getCardTypeRange("4522131094541")).equals(CardType.Visa);
		dist_default(getCardTypeRange("4398342951138")).equals(CardType.Visa);
		dist_default(getCardTypeRange("4111621867312903")).equals(CardType.Visa);
	});
	dist_default("mastercard", function() {
		dist_default(getCardTypeRange("51")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("55")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("52")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("50")).notEquals(CardType.Mastercard);
		dist_default(getCardTypeRange("2221")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("2720")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("2504")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("23")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("2220")).notEquals(CardType.Mastercard);
		dist_default(getCardTypeRange("5392341340810814")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("5571772194621274")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("5155544629392217")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("5464942746631846")).equals(CardType.Mastercard);
		dist_default(getCardTypeRange("5183606138506219")).equals(CardType.Mastercard);
	});
	dist_default("maestro", function() {
		dist_default(getCardTypeRange("6759")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("676770")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("67677")).notEquals(CardType.Maestro);
		dist_default(getCardTypeRange("5")).notEquals(CardType.Maestro);
		dist_default(getCardTypeRange("5018")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("6762")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("67631")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("67630")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("67644")).notEquals(CardType.Maestro);
		dist_default(getCardTypeRange("676")).notEquals(CardType.Maestro);
		dist_default(getCardTypeRange("503896955559")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("6763964146952")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("63049263291396")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("675990328450529")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("6761384679616833")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("50185787002582074")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("630468508293435054")).equals(CardType.Maestro);
		dist_default(getCardTypeRange("6759033525570348799")).equals(CardType.Maestro);
	});
	dist_default("discover", function() {
		dist_default(getCardTypeRange("6011")).equals(CardType.Discover);
		dist_default(getCardTypeRange("645")).equals(CardType.Discover);
		dist_default(getCardTypeRange("66")).notEquals(CardType.Discover);
		dist_default(getCardTypeRange("64")).notEquals(CardType.Discover);
		dist_default(getCardTypeRange("65")).equals(CardType.Discover);
		dist_default(getCardTypeRange("622126")).equals(CardType.Discover);
		dist_default(getCardTypeRange("6228")).equals(CardType.Discover);
		dist_default(getCardTypeRange("6221299974430470")).equals(CardType.Discover);
		dist_default(getCardTypeRange("6497238438147624")).equals(CardType.Discover);
		dist_default(getCardTypeRange("6457995163050848")).equals(CardType.Discover);
		dist_default(getCardTypeRange("6225765854038001")).equals(CardType.Discover);
	});
	dist_default("other", function() {
		dist_default(getCardTypeRange("")).equals(CardType.Other);
		dist_default(getCardTypeRange(" ")).equals(CardType.Other);
		dist_default(getCardTypeRange("0")).equals(CardType.Other);
		dist_default(getCardTypeRange("00")).equals(CardType.Other);
		dist_default(getCardTypeRange("02")).equals(CardType.Other);
	});
});
dist_default.spec("inferCreditCardNumber", function() {
	dist_default("non-digits are stripped and the remaining input is reduced to at most 20 digits", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		model.creditCardNumber = "aath55\n5s ";
		dist_default(model.creditCardNumber).equals("555");
		model.creditCardNumber = "";
		model.creditCardNumber = "555";
		dist_default(model.creditCardNumber).equals("555");
		model.creditCardNumber = "";
		model.creditCardNumber = "111122223333444412346666";
		dist_default(model.creditCardNumber).equals("1111 2222 3333 4444 1234");
		model.creditCardNumber = "";
		model.creditCardNumber = "341111111111111";
		dist_default(model.creditCardNumber).equals("3411 111111 11111");
		model.creditCardNumber = "1234-2222-3333-4444-5555";
		dist_default(model.creditCardNumber).equals("1234 2222 3333 4444 5555");
		model.creditCardNumber = "";
		model.creditCardNumber = "1234/5678/3333/44";
		dist_default(model.creditCardNumber).equals("1234 5678 3333 44");
		model.creditCardNumber = "";
		model.creditCardNumber = "	1111 22223333aoeu[{---+/+++ tsnh 4444555566667777";
		dist_default(model.creditCardNumber).equals("1111 2222 3333 4444 5555");
	});
	dist_default("non-digits are ignored", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		model.creditCardNumber = "1234-";
		dist_default(model.creditCardNumber).equals("1234");
		model.creditCardNumber = "";
		model.creditCardNumber = "12345 ";
		dist_default(model.creditCardNumber).equals("1234 5");
	});
	dist_default("backspace is handled correctly", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		model.creditCardNumber = "1234 5";
		model.creditCardNumber = "1234 ";
		dist_default(model.creditCardNumber).equals("1234");
		model.creditCardNumber = "";
		model.creditCardNumber = "1234 5678";
		model.creditCardNumber = "1234 567";
		dist_default(model.creditCardNumber).equals("1234 567");
	});
});
dist_default.spec("inferCreditCardNumber integration", function() {
	dist_default("it's possible to type a credit card number", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		const numberAsTyped = "1234567890123456";
		const numberAsShown = "1234 5678 9012 3456";
		model.creditCardNumber = "";
		for (const c of numberAsTyped) model.creditCardNumber = model.creditCardNumber + c;
		dist_default(model.creditCardNumber).equals(numberAsShown);
	});
	dist_default("it's possible to type an amex credit card number", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		const numberAsTyped = "345678901234567";
		const numberAsShown = "3456 789012 34567";
		model.creditCardNumber = "";
		for (const c of numberAsTyped) model.creditCardNumber = model.creditCardNumber + c;
		dist_default(model.creditCardNumber).equals(numberAsShown);
	});
	dist_default("it's possible to type an overlong credit card number", function() {
		const model = new SimplifiedCreditCardViewModel((0, import_testdouble$29.object)());
		const numberAsTyped = "345678901234567890890";
		const numberAsShown = "3456 789012 34567 89089";
		model.creditCardNumber = "";
		for (const c of numberAsTyped) model.creditCardNumber = model.creditCardNumber + c;
		dist_default(model.creditCardNumber).equals(numberAsShown);
	});
});

//#endregion
//#region tests/mail/TemplateSearchFilterTest.ts
dist_default.spec("TemplateSearchFilter", function() {
	const abcTemplate = createTestEntity(EmailTemplateTypeRef, {
		tag: "aBc_tag",
		title: "aBc_title",
		contents: [createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "en",
			text: "aBc english"
		}), createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "de",
			text: "aBc deutsch"
		})]
	});
	const defTemplate = createTestEntity(EmailTemplateTypeRef, {
		tag: "dEf_tag",
		title: "dEf_title",
		contents: [createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "en",
			text: "dEf english"
		}), createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "de",
			text: "dEf deutsch"
		})]
	});
	const abcdefTemplate = createTestEntity(EmailTemplateTypeRef, {
		tag: "abcdef_tag",
		title: "abcdef_title",
		contents: [createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "en",
			text: "abcdef english"
		}), createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "de",
			text: "abcdef deutsch"
		})]
	});
	const emailTemplates = [
		abcTemplate,
		defTemplate,
		abcdefTemplate
	];
	dist_default("find nothing ", function() {
		dist_default(searchInTemplates("xyz", emailTemplates)).deepEquals([]);
		dist_default(searchInTemplates("123 xyz", emailTemplates)).deepEquals([]);
	});
	dist_default("no words", function() {
		dist_default(searchInTemplates("", emailTemplates)).deepEquals(emailTemplates);
		dist_default(searchInTemplates("", emailTemplates)).deepEquals(emailTemplates);
	});
	dist_default("finds in tag", function() {
		dist_default(searchInTemplates("tag", emailTemplates)).deepEquals(emailTemplates);
		dist_default(searchInTemplates("AbC_Tag", emailTemplates)).deepEquals([abcTemplate]);
		dist_default(searchInTemplates("def_tag", emailTemplates)).deepEquals([defTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("cdef_tag", emailTemplates)).deepEquals([abcdefTemplate]);
		dist_default(searchInTemplates("cdef_tag ", emailTemplates)).deepEquals([abcdefTemplate]);
	});
	dist_default("tag search", function() {
		dist_default(searchInTemplates("#abc_tag", emailTemplates)).deepEquals([abcTemplate]);
		dist_default(searchInTemplates("#abc 123", emailTemplates)).deepEquals([abcTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("#abc_title", emailTemplates)).deepEquals([]);
		dist_default(searchInTemplates("#abc", emailTemplates)).deepEquals([abcTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("#def_", emailTemplates)).deepEquals([defTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("#tag", emailTemplates)).deepEquals(emailTemplates);
		dist_default(searchInTemplates("#def", emailTemplates)).deepEquals([defTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("#_", emailTemplates)).deepEquals(emailTemplates);
	});
	dist_default("finds in title", function() {
		dist_default(searchInTemplates("title", emailTemplates)).deepEquals(emailTemplates);
		dist_default(searchInTemplates("abc_title", emailTemplates)).deepEquals([abcTemplate]);
		dist_default(searchInTemplates("def_title", emailTemplates)).deepEquals([defTemplate, abcdefTemplate]);
		dist_default(searchInTemplates("abcdef_title", emailTemplates)).deepEquals([abcdefTemplate]);
	});
	dist_default("finds in content", function() {
		dist_default(searchInTemplates("english", emailTemplates)).deepEquals(emailTemplates);
		dist_default(searchInTemplates("deutsch", emailTemplates)).deepEquals(emailTemplates);
	});
	dist_default("multiple words - one word must match but result order is changed", function() {
		dist_default(searchInTemplates("abcdef title", emailTemplates)).deepEquals([
			abcdefTemplate,
			abcTemplate,
			defTemplate
		]);
		dist_default(searchInTemplates("#abc tag", emailTemplates)).deepEquals([
			abcTemplate,
			abcdefTemplate,
			defTemplate
		]);
	});
});

//#endregion
//#region tests/mail/KnowledgeBaseSearchFilterTest.ts
dist_default.spec("KnowledgeBaseSearchFilter", function() {
	dist_default("finds in title with two filtered keywords", function() {
		const knowledgebaseEntry1 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "User forgot their password",
			description: "When a user is certain that they do not remember their password anymore, first, ask the user if they tried all passwords that come to mindif the user completed step 1, ask if they can provide proof that they own the account",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "password" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "forgotten" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "reset" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "account" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "access" })
			]
		});
		const knowledgebaseEntry2 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "User cannot access account anymore",
			description: "A general entry for when the user cannot access their account",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "access" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "account" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "lost" })
			]
		});
		const allFakeEntries = [knowledgebaseEntry1, knowledgebaseEntry2];
		dist_default(knowledgeBaseSearch("password", allFakeEntries)).deepEquals([knowledgebaseEntry1]);
	});
	dist_default("finds in title without filtered keywords", function() {
		const knowledgebaseEntry1 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "User forgot their password",
			description: "When a user is certain that they do not remember their password anymorefirst, ask the user if they tried all passwords that come to mindif the user completed step 1, ask if they can provide proof that they own the account",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "password" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "forgotten" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "reset" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "account" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "access" })
			]
		});
		const knowledgebaseEntry2 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "User cannot access account anymore",
			description: "A general entry for when the user cannot access their accountask user whether its because of the password or other factors as to why they cannot access their account",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "access" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "account" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "lost" })
			]
		});
		const allFakeEntries = [knowledgebaseEntry1, knowledgebaseEntry2];
		dist_default(knowledgeBaseSearch("user", allFakeEntries)).deepEquals([knowledgebaseEntry1, knowledgebaseEntry2]);
	});
	dist_default("more than one filter word", function() {
		const knowledgebaseEntry1 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "Payment has been booked but features arent accessible",
			description: "Something went wrong and the payment registered, but the user believes their features arent accessible yetfirst, check how long the time between payment and contact has beenif it has been more than X days, ask the user to provide a bill or payment proof",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "payment" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "features" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "inaccessible" })
			]
		});
		const knowledgebaseEntry2 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "Payment hasn't been booked yet, features aren't accessible either",
			description: "Something went wrong and the payment never registeredask user if they can provide a bill or payment proofif provided, re-do the booking and enable the features for the user",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "payment" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "unregistered" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "inaccessible" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "features" })
			]
		});
		const knowledgebaseEntry3 = createTestEntity(KnowledgeBaseEntryTypeRef, {
			title: "Features don't work as intended, or are buggy",
			description: "The user has reported features that do not work as intended and hinder the users' experienceif needed, ask user if they can elaborate on their issueif the problem is known, explain that the team is working on a fix, or explain a temporary fixif its a new problem, tell the user that it has been reported to the team and will be taken care of",
			keywords: [
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "functionality" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "not" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "working" }),
				createTestEntity(KnowledgeBaseEntryKeywordTypeRef, { keyword: "bug" })
			]
		});
		const fakeEntries = [
			knowledgebaseEntry1,
			knowledgebaseEntry2,
			knowledgebaseEntry3
		];
		dist_default(knowledgeBaseSearch("payment functionality", fakeEntries)).deepEquals([
			knowledgebaseEntry1,
			knowledgebaseEntry2,
			knowledgebaseEntry3
		]);
	});
});

//#endregion
//#region tests/api/worker/facades/MailExportTokenFacadeTest.ts
var import_testdouble$28 = __toESM(require_testdouble(), 1);
dist_default.spec("MailExportTokenFacade", () => {
	let facade;
	let serviceExecutor;
	dist_default.beforeEach(() => {
		serviceExecutor = (0, import_testdouble$28.object)();
		facade = new MailExportTokenFacade(serviceExecutor);
	});
	dist_default.spec("loading", () => {
		const validToken = "my token";
		const expiredToken = "my expired token";
		dist_default.test("when there's no token, a new one is requested", async () => {
			const expected = "result";
			const cb = (0, import_testdouble$28.func)();
			(0, import_testdouble$28.when)(cb(validToken)).thenResolve(expected);
			(0, import_testdouble$28.when)(serviceExecutor.post(MailExportTokenService, null, import_testdouble$28.matchers.anything())).thenResolve(createMailExportTokenServicePostOut({ mailExportToken: validToken }));
			const result = await facade.loadWithToken(cb);
			dist_default(result).equals(expected);
		});
		dist_default.test("when there is a valid token it is used", async () => {
			const expected = "result";
			const cb = (0, import_testdouble$28.func)();
			(0, import_testdouble$28.when)(cb(validToken)).thenResolve(expected);
			facade._setCurrentExportToken(validToken);
			const result = await facade.loadWithToken(cb);
			dist_default(result).equals(expected);
		});
		dist_default.test("when token is expired a new one is requested and used", async () => {
			const expected = "result";
			const cb = (0, import_testdouble$28.func)();
			(0, import_testdouble$28.when)(cb(validToken)).thenResolve(expected);
			(0, import_testdouble$28.when)(cb(expiredToken)).thenReject(new AccessExpiredError("token expired"));
			facade._setCurrentExportToken(expiredToken);
			(0, import_testdouble$28.when)(serviceExecutor.post(MailExportTokenService, null, import_testdouble$28.matchers.anything())).thenResolve(createMailExportTokenServicePostOut({ mailExportToken: validToken }));
			const result = await facade.loadWithToken(cb);
			dist_default(result).equals(expected);
		});
		dist_default.test("when requesting token fails none are stored", async () => {
			const cb = (0, import_testdouble$28.func)();
			(0, import_testdouble$28.when)(cb(expiredToken)).thenReject(new AccessExpiredError("token expired"));
			(0, import_testdouble$28.when)(serviceExecutor.post(MailExportTokenService, null, import_testdouble$28.matchers.anything())).thenReject(new TooManyRequestsError("no more tokens :("));
			await dist_default(() => facade.loadWithToken(cb)).asyncThrows(TooManyRequestsError);
			dist_default(facade._getCurrentExportToken()).equals(null);
		});
	});
});

//#endregion
//#region tests/mail/export/ExporterTest.ts
dist_default.spec("Exporter", function() {
	dist_default.spec("mail to eml", function() {
		dist_default("most minimal eml", function() {
			const now$1 = Date.now();
			const mostMinimalBundle = {
				mailId: ["", ""],
				subject: "",
				body: "",
				sender: { address: "complaints@johnbotr.is" },
				to: [],
				cc: [],
				bcc: [],
				replyTo: [],
				isDraft: false,
				isRead: true,
				sentOn: now$1,
				receivedOn: now$1,
				headers: null,
				attachments: []
			};
			const actual = mailToEml(mostMinimalBundle);
			const expected = `From: complaints@johnbotr.is\r\n\
MIME-Version: 1.0\r\n\
Subject: \r\n\
Date: ${_formatSmtpDateTime(new Date(now$1))}\r\n\
Content-Type: multipart/related; boundary="------------79Bu5A16qPEYcVIZL@tutanota"\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota\r\n\
Content-Type: text/html; charset=UTF-8\r\n\
Content-transfer-encoding: base64\r\n\
\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota--`;
			const actualLines = actual.split("\r\n");
			const expectedLines = expected.split("\r\n");
			dist_default(actualLines.length).equals(expectedLines.length);
			for (let i = 0; i < Math.min(expectedLines.length, actualLines.length); ++i) dist_default(actualLines[i]).equals(expectedLines[i])(`Line: ${i}`);
		});
		dist_default("non minimal eml with no headers", function() {
			const now$1 = Date.now();
			const subject = "Hey, I know that guy, hes a nihilist.";
			const body = `Im the Dude, so thats what you call me. That or, uh, His Dudeness, or uh, Duder, or El Duderino, if youre not into the whole brevity thing. <img src="cid:cid123" />`;
			const attachment1 = createDataFile("file1.txt", "text/plain", stringToUtf8Uint8Array("this is a text file"));
			const attachment2 = createDataFile("icon10x10.png", "image/png", base64ToUint8Array("iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAMAAAC67D+PAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAgVBMVEWgHiCgHh+gHiEAAACfHyGgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiD////HdIxaAAAAKXRSTlMAAAAAAImrqvvx5OX+oGaj1/r1w1MjV7P5lwEPjO+dIRb83pU8BnMqAyX2q3sAAAABYktHRCpTvtSeAAAACXBIWXMAAAcDAAAHAwGHNB/CAAAAB3RJTUUH5AkBDTcdD3SpngAAAE5JREFUCNc9ykUSgDAABMGFCIHg7q7//yCVhGJOfRgw7ug4g3i+BJ4/RdeT0jcMwihODNMsL8qqNm/TousVh3GChRnLuu0HbEIpzusG0b05dgnLISKbuAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wOS0wMVQxMTo1NToyOSswMjowMNbkv24AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMDktMDFUMTE6NTU6MjkrMDI6MDCnuQfSAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg=="));
			attachment2.cid = "123cid";
			const bundle = {
				mailId: ["", ""],
				subject,
				body,
				sender: {
					address: "lorem@ipsum.net",
					name: ""
				},
				to: [
					{
						name: "guy1",
						address: "guy1@guys.net"
					},
					{
						name: "guy2",
						address: "guy2@guys.net"
					},
					{ address: "guy2.5@guys.net" }
				],
				cc: [{ address: "guy3@guys.net" }, {
					name: "Dennis Dennisman",
					address: "guy4@guys.net"
				}],
				bcc: [{ address: "guy5@guys.net" }, {
					name: "Sixth guy",
					address: "guy6@guys.net"
				}],
				replyTo: [{ address: "guy7@guys.net" }, {
					name: "guy8",
					address: "guy8@guys.net"
				}],
				isDraft: false,
				isRead: true,
				sentOn: now$1,
				receivedOn: now$1,
				headers: null,
				attachments: [attachment1, attachment2]
			};
			const actual = mailToEml(bundle);
			const expected = `From: lorem@ipsum.net\r\n\
MIME-Version: 1.0\r\n\
To: guy1 <guy1@guys.net>,guy2 <guy2@guys.net>,<guy2.5@guys.net>\r\n\
CC: <guy3@guys.net>,Dennis Dennisman <guy4@guys.net>\r\n\
BCC: <guy5@guys.net>,Sixth guy <guy6@guys.net>\r\n\
Subject: =?UTF-8?B?SGV5LCBJIGtub3cgdGhhdCBndXksIGhl4oCZcyBhIG5paGlsaXN0Lg==?=\r\n\
Date: ${_formatSmtpDateTime(new Date(now$1))}\r\n\
Content-Type: multipart/related; boundary="------------79Bu5A16qPEYcVIZL@tutanota"\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota\r\n\
Content-Type: text/html; charset=UTF-8\r\n\
Content-transfer-encoding: base64\r\n\
\r\n\
SeKAmW0gdGhlIER1ZGUsIHNvIHRoYXTigJlzIHdoYXQgeW91IGNhbGwgbWUuIFRoYXQgb3IsIHVoLC\r\n\
BIaXMgRHVkZW5lc3MsIG9yIHVoLCBEdWRlciwgb3IgRWwgRHVkZXJpbm8sIGlmIHlvdeKAmXJlIG5v\r\n\
dCBpbnRvIHRoZSB3aG9sZSBicmV2aXR5IHRoaW5nLiA8aW1nIHNyYz0iY2lkOmNpZDEyMyIgLz4=\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota\r\n\
Content-Type: text/plain;\r\n\
 name==?UTF-8?B?ZmlsZTEudHh0?=\r\n\
Content-Transfer-Encoding: base64\r\n\
Content-Disposition: attachment;\r\n\
 filename==?UTF-8?B?ZmlsZTEudHh0?=\r\n\
\r\n\
dGhpcyBpcyBhIHRleHQgZmlsZQ==\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota\r\n\
Content-Type: image/png;\r\n\
 name==?UTF-8?B?aWNvbjEweDEwLnBuZw==?=\r\n\
Content-Transfer-Encoding: base64\r\n\
Content-Disposition: attachment;\r\n\
 filename==?UTF-8?B?aWNvbjEweDEwLnBuZw==?=\r\n\
Content-Id: <123cid>\r\n\
\r\n\
iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAMAAAC67D+PAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAA\r\n\
B6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAgVBMVEWgHiCgHh+gHiEAAACfHyGg\r\n\
HiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHi\r\n\
CgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiCgHiD////HdIxa\r\n\
AAAAKXRSTlMAAAAAAImrqvvx5OX+oGaj1/r1w1MjV7P5lwEPjO+dIRb83pU8BnMqAyX2q3sAAAABYk\r\n\
tHRCpTvtSeAAAACXBIWXMAAAcDAAAHAwGHNB/CAAAAB3RJTUUH5AkBDTcdD3SpngAAAE5JREFUCNc9\r\n\
ykUSgDAABMGFCIHg7q7//yCVhGJOfRgw7ug4g3i+BJ4/RdeT0jcMwihODNMsL8qqNm/TousVh3GChR\r\n\
nLuu0HbEIpzusG0b05dgnLISKbuAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMC0wOS0wMVQxMTo1NToy\r\n\
OSswMjowMNbkv24AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjAtMDktMDFUMTE6NTU6MjkrMDI6MDCnuQ\r\n\
fSAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAABJRU5ErkJggg==\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota--`;
			const actualLines = actual.split("\r\n");
			const expectedLines = expected.split("\r\n");
			dist_default(actualLines.length).equals(expectedLines.length)("check length");
			for (let i = 0; i < Math.min(expectedLines.length, actualLines.length); ++i) dist_default(actualLines[i]).equals(expectedLines[i])(`Line: ${i}`);
		});
		dist_default("email with headers", function() {
			const headers = `Received: from x.y.test\n\
   by example.net\n\
   via TCP\n\
   with ESMTP\r\n\
   id ABC12345\r\n\
   for <mary@example.net>;  21 Nov 1997 10:05:43 -0600\r\n\
Received: from node.example by x.y.test; 21 Nov 1997 10:01:22 -0600\r\n\
From: John Doe <jdoe@node.example>\r\n\
To: Mary Smith <mary@example.net>\r\n\
Subject: Saying Hello\r\n\
Date: Fri, 21 Nov 1997 09:55:06 -0600\r\n\
Message-ID: <1234@local.node.example>`;
			const now$1 = Date.now();
			const bundle = {
				mailId: ["", ""],
				subject: "Saying hello",
				body: "",
				sender: { address: "jdoe@node.example" },
				to: [{ address: "mary@example.net" }],
				cc: [],
				bcc: [],
				replyTo: [],
				isDraft: false,
				isRead: true,
				sentOn: now$1,
				receivedOn: now$1,
				headers,
				attachments: []
			};
			const actual = mailToEml(bundle);
			const expected = `Received: from x.y.test\r\n\
   by example.net\r\n\
   via TCP\r\n\
   with ESMTP\r\n\
   id ABC12345\r\n\
   for <mary@example.net>;  21 Nov 1997 10:05:43 -0600\r\n\
Received: from node.example by x.y.test; 21 Nov 1997 10:01:22 -0600\r\n\
From: John Doe <jdoe@node.example>\r\n\
To: Mary Smith <mary@example.net>\r\n\
Subject: Saying Hello\r\n\
Date: Fri, 21 Nov 1997 09:55:06 -0600\r\n\
Message-ID: <1234@local.node.example>\r\n\
Content-Type: multipart/related; boundary="------------79Bu5A16qPEYcVIZL@tutanota"\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota\r\n\
Content-Type: text/html; charset=UTF-8\r\n\
Content-transfer-encoding: base64\r\n\
\r\n\
\r\n\
--------------79Bu5A16qPEYcVIZL@tutanota--`;
			const actualLines = actual.split("\r\n");
			const expectedLines = expected.split("\r\n");
			dist_default(actualLines.length).equals(expectedLines.length);
			for (let i = 0; i < Math.min(expectedLines.length, actualLines.length); ++i) dist_default(actualLines[i]).equals(expectedLines[i])(`Line: ${i}`);
		});
	});
});

//#endregion
//#region tests/mail/export/BundlerTest.ts
var import_testdouble$27 = __toESM(require_testdouble(), 1);
dist_default.spec("Bundler", function() {
	let entityClientMock;
	let fileControllerMock;
	let sanitizerMock;
	let mailFacadeMock;
	let cryptoMock;
	dist_default.beforeEach(function() {
		entityClientMock = (0, import_testdouble$27.object)();
		fileControllerMock = (0, import_testdouble$27.object)();
		sanitizerMock = (0, import_testdouble$27.object)();
		mailFacadeMock = (0, import_testdouble$27.object)();
		cryptoMock = (0, import_testdouble$27.object)();
	});
	dist_default("make mail bundle non compressed headers", async function() {
		const mailId$1 = ["maillistid", "maillid"];
		const subject = "hello";
		const sanitizedBodyText = "this is the sanitized body text of the email";
		const sender = {
			address: "sender@mycoolsite.co.uk",
			name: "the sender"
		};
		const sentOn = new Date();
		const receivedOn = new Date();
		const attachmentListId = "attachmentListId";
		const attachmentIds = [
			"attachmentId1",
			"attachmentId2",
			"attachmentId3"
		];
		const attachments = attachmentIds.map((id) => {
			return {
				_type: "DataFile",
				id: undefined,
				name: id,
				cid: id,
				data: new Uint8Array(),
				size: 4,
				mimeType: "test"
			};
		});
		const bodyText = "This is the body text of the body of the email";
		const body = createTestEntity(BodyTypeRef, { text: bodyText });
		const toValues = {
			address: "to@mycoolsite.co.uk",
			name: "the to"
		};
		const ccValues = {
			address: "cc@mycoolsite.co.uk",
			name: "the cc"
		};
		const bccValues = {
			address: "bcc@mycoolsite.co.uk",
			name: "the bcc"
		};
		const recipients = createTestEntity(RecipientsTypeRef, {
			toRecipients: [createTestEntity(MailAddressTypeRef, toValues)],
			ccRecipients: [createTestEntity(MailAddressTypeRef, ccValues)],
			bccRecipients: [createTestEntity(MailAddressTypeRef, bccValues)]
		});
		const headersText = "this is the headers";
		const replyToValues = {
			address: "replyto@mycoolsite.co.uk",
			name: "the replyto"
		};
		const mailDetails = createTestEntity(MailDetailsTypeRef, {
			_id: "detailsId",
			headers: createTestEntity(HeaderTypeRef, { headers: headersText }),
			body,
			recipients,
			sentDate: new Date(sentOn),
			replyTos: [createTestEntity(MailAddressTypeRef, replyToValues)]
		});
		const mailDetailsBlob = createTestEntity(MailDetailsBlobTypeRef, {
			_id: ["archiveId", mailDetails._id],
			details: mailDetails
		});
		const mail = createTestEntity(MailTypeRef, {
			_id: mailId$1,
			subject,
			sender: createTestEntity(MailAddressTypeRef, sender),
			state: MailState.RECEIVED,
			unread: false,
			receivedDate: new Date(receivedOn),
			attachments: attachmentIds.map((id) => [attachmentListId, id]),
			mailDetails: mailDetailsBlob._id
		});
		(0, import_testdouble$27.when)(mailFacadeMock.loadMailDetailsBlob(mail)).thenResolve(mailDetails);
		for (const attachment of attachments) {
			(0, import_testdouble$27.when)(entityClientMock.load(FileTypeRef, [attachmentListId, attachment.name])).thenResolve(`file ${attachment.name}`);
			(0, import_testdouble$27.when)(fileControllerMock.getAsDataFile(`file ${attachment.name}`)).thenResolve(attachment);
		}
		(0, import_testdouble$27.when)(sanitizerMock.sanitizeHTML(bodyText, {
			blockExternalContent: false,
			allowRelativeLinks: false,
			usePlaceholderForInlineImages: false
		})).thenReturn({ html: sanitizedBodyText });
		const attachmentsCaptor = import_testdouble$27.matchers.captor();
		(0, import_testdouble$27.when)(cryptoMock.enforceSessionKeyUpdateIfNeeded(mail, attachmentsCaptor.capture())).thenDo((mail$1, attachments$1) => Promise.resolve(attachments$1));
		const bundle = await downloadMailBundle(mail, mailFacadeMock, entityClientMock, fileControllerMock, sanitizerMock, cryptoMock);
		(0, import_testdouble$27.verify)(cryptoMock.enforceSessionKeyUpdateIfNeeded(mail, attachments.map((a) => `file ${a.name}`)));
		dist_default(bundle).deepEquals({
			mailId: mailId$1,
			subject,
			sender,
			body: sanitizedBodyText,
			to: [toValues],
			cc: [ccValues],
			bcc: [bccValues],
			replyTo: [replyToValues],
			isDraft: false,
			isRead: true,
			headers: headersText,
			attachments,
			sentOn: sentOn.getTime(),
			receivedOn: receivedOn.getTime()
		});
	});
});

//#endregion
//#region tests/api/common/utils/FileUtilsTest.ts
dist_default.spec("FileUtilsTest", function() {
	dist_default("sanitizeFilename", function() {
		dist_default(sanitizeFilename("hello")).equals("hello");
		dist_default(sanitizeFilename("foo/bar")).equals("foo_bar");
		dist_default(sanitizeFilename("\x001/./  ")).equals("_1_.__");
		dist_default(sanitizeFilename("test.")).equals("test_");
	});
	dist_default.spec("deduplicate filenames", function() {
		dist_default("no duplicates", function() {
			const filenames = [
				"abc",
				"def",
				"ghi",
				"jkl"
			];
			const taken = new Set([
				"mno",
				"pqr",
				"stu"
			]);
			const actual = deduplicateFilenames(filenames, taken);
			const expected = {
				abc: ["abc"],
				def: ["def"],
				ghi: ["ghi"],
				jkl: ["jkl"]
			};
			dist_default(actual).deepEquals(expected);
		});
		dist_default("yes duplicates, no taken", function() {
			const filenames = [
				"abc",
				"abc",
				"Abc",
				"def",
				"DEF",
				"ghi",
				"jkl"
			];
			const taken = new Set();
			const actual = deduplicateFilenames(filenames, taken);
			const expected = {
				abc: ["abc", "abc (1)"],
				Abc: ["Abc (2)"],
				def: ["def"],
				DEF: ["DEF (1)"],
				ghi: ["ghi"],
				jkl: ["jkl"]
			};
			dist_default(actual).deepEquals(expected);
		});
		dist_default("yes duplicates, yes taken with no duplicates", function() {
			const filenames = [
				"abc",
				"abc",
				"Abc",
				"def",
				"DEF",
				"ghi",
				"jkl"
			];
			const taken = new Set([
				"mno",
				"pqr",
				"stu"
			]);
			const actual = deduplicateFilenames(filenames, taken);
			const expected = {
				abc: ["abc", "abc (1)"],
				Abc: ["Abc (2)"],
				def: ["def"],
				DEF: ["DEF (1)"],
				ghi: ["ghi"],
				jkl: ["jkl"]
			};
			dist_default(actual).deepEquals(expected);
		});
		dist_default("yes duplicates, yes taken with yes duplicates", function() {
			const filenames = [
				"abc",
				"abc",
				"Abc",
				"def",
				"DEF",
				"ghi",
				"jkl",
				"file.txt",
				"FILE.txt",
				"FILE.TXT",
				"file1.txt"
			];
			const taken = new Set([
				"ghi",
				"JKL",
				"mno",
				"pqr",
				"stu"
			]);
			const actual = deduplicateFilenames(filenames, taken);
			const expected = {
				abc: ["abc", "abc (1)"],
				Abc: ["Abc (2)"],
				def: ["def"],
				DEF: ["DEF (1)"],
				ghi: ["ghi (1)"],
				jkl: ["jkl (1)"],
				"file.txt": ["file.txt"],
				"FILE.txt": ["FILE (1).txt"],
				"FILE.TXT": ["FILE (2).TXT"],
				"file1.txt": ["file1.txt"]
			};
			dist_default(actual).deepEquals(expected);
		});
	});
});

//#endregion
//#region tests/gui/GuiUtilsTest.ts
dist_default.spec("GuiUtils", function() {
	dist_default.spec("getConfirmation ok", function() {
		dist_default.beforeEach(function() {
			Dialog.confirm = spy(function(...args) {
				return Promise.resolve(true);
			});
		});
		dist_default("calls confirmed", async function() {
			const confirmAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).confirmed(confirmAction);
			await confirmation.result;
			dist_default(confirmAction.callCount).equals(1);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
		dist_default("calls cancelled", async function() {
			const cancelAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).cancelled(cancelAction);
			await confirmation.result;
			dist_default(cancelAction.callCount).equals(0);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
		dist_default("calls confirmed and cancelled", async function() {
			const confirmAction = spy(() => {});
			const cancelAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).confirmed(confirmAction).cancelled(cancelAction);
			await confirmation.result;
			dist_default(confirmAction.callCount).equals(1);
			dist_default(cancelAction.callCount).equals(0);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
	});
	dist_default.spec("getConfirmation !ok", function() {
		dist_default.beforeEach(function() {
			Dialog.confirm = spy(function(...args) {
				return Promise.resolve(false);
			});
		});
		dist_default("calls confirmed", async function() {
			const confirmAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).confirmed(confirmAction);
			await confirmation.result;
			dist_default(confirmAction.callCount).equals(0);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
		dist_default("calls cancelled", async function() {
			const cancelAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).cancelled(cancelAction);
			await confirmation.result;
			dist_default(cancelAction.callCount).equals(1);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
		dist_default("calls confirmed and cancelled", async function() {
			const confirmAction = spy(() => {});
			const cancelAction = spy(() => {});
			const confirmation = getConfirmation(downcast("message"), downcast("ok action")).confirmed(confirmAction).cancelled(cancelAction);
			await confirmation.result;
			dist_default(confirmAction.callCount).equals(0);
			dist_default(cancelAction.callCount).equals(1);
			dist_default(Dialog.confirm.callCount).equals(1);
			dist_default(Dialog.confirm.args).deepEquals(["message", "ok action"]);
		});
	});
});

//#endregion
//#region ../src/common/misc/parsing/CsvParser.ts
const DEFAULT_CSV_PARSE_OPTIONS = { delimiter: "," };
function parseCsv(input, options) {
	const { delimiter } = Object.assign({}, DEFAULT_CSV_PARSE_OPTIONS, options);
	const lineDelimiterParser = makeOneOrMoreParser(makeCharacterParser("\n"));
	const parser = makeSeparatedByParser(lineDelimiterParser, makeRowParser(delimiter));
	const rows = parser(new StringIterator(input.replace(/\r\n/g, "\n")));
	return { rows };
}
function makeRowParser(delimiter) {
	return makeSeparatedByParser(makeCharacterParser(delimiter), makeColumnParser(delimiter));
}
function makeColumnParser(delimiter) {
	return makeEitherParser(quotedColumnParser, makeUnquotedColumnParser(delimiter));
}
const quotedColumnParser = mapParser(combineParsers(makeZeroOrMoreParser(makeCharacterParser(" ")), parseQuotedColumn, makeZeroOrMoreParser(makeCharacterParser(" "))), (result) => result[1]);
/**
* Parse a column that is nonempty, doesn't contain any quotes, newlines, or delimiters
* @param delimiter
* @returns {Parser<*>}
*/
function makeUnquotedColumnParser(delimiter) {
	return mapParser(makeZeroOrMoreParser(makeNotOneOfCharactersParser([
		"\"",
		"\n",
		delimiter
	])), (arr) => arr.join(""));
}
/**
* Parse the inside of a double-quote quoted string, returning the string without the outer double-quotes
* @param iterator
*/
function parseQuotedColumn(iterator) {
	const initial = iterator.next();
	if (initial.done || initial.value !== "\"") throw new ParserError("expected quote");
	let result = "";
	while (true) {
		const token = iterator.next();
		if (token.done) throw new ParserError("unexpected end of input");
		if (token.value === "\"") if (iterator.peek() === "\"") {
			iterator.next();
			result += "\"";
		} else break;
else result += token.value;
	}
	return result;
}

//#endregion
//#region tests/misc/ParserTest.ts
dist_default.spec("Parser combinator test", function() {});
dist_default.spec("CSV parsing test", function() {
	dist_default("Parse good csv no quotes no empty columns no surrounding spaces", function() {
		const csv = "foo,bar,baz,quux\nshrek and fiona,donkey,farquaad";
		const actual = parseCsv(csv).rows;
		const expected = [[
			"foo",
			"bar",
			"baz",
			"quux"
		], [
			"shrek and fiona",
			"donkey",
			"farquaad"
		]];
		dist_default(actual).deepEquals(expected);
	});
	dist_default("Parse good csv no quotes no empty columns", function() {
		const csv = " foo , bar ,  baz  ,  quux  \n  shrek and fiona  , donkey , farquaad ";
		const actual = parseCsv(csv).rows;
		const expected = [[
			" foo ",
			" bar ",
			"  baz  ",
			"  quux  "
		], [
			"  shrek and fiona  ",
			" donkey ",
			" farquaad "
		]];
		dist_default(actual).deepEquals(expected);
	});
	dist_default("Parse good csv no quotes", function() {
		const csv = " foo,,  ,quux\n shrek and fiona  , donkey ,farquaad";
		const actual = parseCsv(csv).rows;
		const expected = [[
			" foo",
			"",
			"  ",
			"quux"
		], [
			" shrek and fiona  ",
			" donkey ",
			"farquaad"
		]];
		dist_default(actual).deepEquals(expected);
	});
	dist_default("Parse good csv with quotes and surrounding spaces and empty columns", function() {
		const csv = ` "foo","","  ", " quux " \n" shrek and fiona"  ," donkey" ,"farquaad"`;
		const actual = parseCsv(csv).rows;
		const expected = [[
			"foo",
			"",
			"  ",
			" quux "
		], [
			" shrek and fiona",
			" donkey",
			"farquaad"
		]];
		dist_default(actual).deepEquals(expected);
	});
	dist_default("Parse good csv with empty lines", function() {
		const csv = `\n\nfoo,bar,baz,quux\n\n\nshrek and fiona,donkey,farquaad\n,  ,\n phoebe,rachael,monica,chandler,joey,ross\n\n`;
		const actual = parseCsv(csv).rows;
		const expected = [
			[""],
			[
				"foo",
				"bar",
				"baz",
				"quux"
			],
			[
				"shrek and fiona",
				"donkey",
				"farquaad"
			],
			[
				"",
				"  ",
				""
			],
			[
				" phoebe",
				"rachael",
				"monica",
				"chandler",
				"joey",
				"ross"
			],
			[""]
		];
		dist_default(actual).deepEquals(expected);
	});
	dist_default("Parse good csv with quotes inside quotes", function() {
		const csv = `"""this is a quote"" - some guy", "this is a regular quoted column, that has a comma in it"\n"this is the second line with a single quoted column"`;
		const actual = parseCsv(csv).rows;
		const expected = [[`"this is a quote" - some guy`, "this is a regular quoted column, that has a comma in it"], ["this is the second line with a single quoted column"]];
		dist_default(actual).deepEquals(expected);
	});
});

//#endregion
//#region tests/misc/news/items/ReferralLinkNewsTest.ts
var import_testdouble$26 = __toESM(require_testdouble(), 1);
dist_default.spec("ReferralLinkNews", function() {
	let dateProvider$1;
	let newsModel;
	let referralViewModel;
	let referralLinkNews;
	let userController;
	let locator$1 = (0, import_testdouble$26.object)();
	let domainConfig = {
		firstPartyDomain: true,
		partneredDomainTransitionUrl: "https://test.tutanota.com",
		apiUrl: "https://app.test.tuta.com",
		paymentUrl: "https://pay.test.tutanota.com/braintree.html",
		webauthnUrl: "https://app.test.tuta.com/webauthn",
		legacyWebauthnUrl: "https://test.tutanota.com/webauthn",
		webauthnMobileUrl: "https://app.test.tuta.com/webauthnmobile",
		legacyWebauthnMobileUrl: "https://test.tutanota.com/webauthnmobile",
		webauthnRpId: "tuta.com",
		u2fAppId: "https://app.test.tuta.com/u2f-appid.json",
		giftCardBaseUrl: "https://app.test.tuta.com/giftcard",
		referralBaseUrl: "https://app.test.tuta.com/signup",
		websiteBaseUrl: "https://tuta.com"
	};
	dist_default.beforeEach(function() {
		initCommonLocator(locator$1);
		dateProvider$1 = (0, import_testdouble$26.object)();
		newsModel = (0, import_testdouble$26.object)();
		referralViewModel = (0, import_testdouble$26.object)();
		userController = (0, import_testdouble$26.object)();
		const user = (0, import_testdouble$26.object)();
		const customer = (0, import_testdouble$26.object)();
		(0, import_testdouble$26.replace)(userController, "user", user);
		(0, import_testdouble$26.replace)(user, "customer", timestampToGeneratedId(0));
		(0, import_testdouble$26.replace)(customer, "referralCode", "referralCodeId");
		(0, import_testdouble$26.when)(userController.loadCustomer()).thenResolve(customer);
		referralLinkNews = new ReferralLinkNews(newsModel, dateProvider$1, userController);
	});
	dist_default("ReferralLinkNews not shown if account is not old enough", async function() {
		(0, import_testdouble$26.when)(locator$1.domainConfigProvider()).thenReturn({ getCurrentDomainConfig: () => domainConfig });
		(0, import_testdouble$26.when)(userController.isGlobalAdmin()).thenReturn(true);
		(0, import_testdouble$26.when)(dateProvider$1.now()).thenReturn(getDayShifted(new Date(0), 6).getTime());
		dist_default(await referralLinkNews.isShown()).equals(false);
	});
	dist_default("ReferralLinkNews shown if account is old enough", async function() {
		(0, import_testdouble$26.when)(locator$1.domainConfigProvider()).thenReturn({ getCurrentDomainConfig: () => domainConfig });
		(0, import_testdouble$26.when)(userController.isGlobalAdmin()).thenReturn(true);
		(0, import_testdouble$26.when)(dateProvider$1.now()).thenReturn(getDayShifted(new Date(0), 7).getTime());
		dist_default(await referralLinkNews.isShown()).equals(true);
	});
	dist_default("ReferralLinkNews not shown if account is not old admin", async function() {
		(0, import_testdouble$26.when)(locator$1.domainConfigProvider()).thenReturn({ getCurrentDomainConfig: () => domainConfig });
		(0, import_testdouble$26.when)(userController.isGlobalAdmin()).thenReturn(false);
		(0, import_testdouble$26.when)(dateProvider$1.now()).thenReturn(getDayShifted(new Date(0), 7).getTime());
		dist_default(await referralLinkNews.isShown()).equals(false);
	});
});

//#endregion
//#region tests/settings/TemplateEditorModelTest.ts
dist_default.spec("TemplateEditorModel", function() {
	let entityClient$1;
	dist_default.beforeEach(function() {
		entityClient$1 = downcast({});
	});
	dist_default("content languages", function() {
		const template = createTestEntity(EmailTemplateTypeRef, { contents: [createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "en",
			text: ""
		}), createTestEntity(EmailTemplateContentTypeRef, {
			languageCode: "de",
			text: ""
		})] });
		const templateGroupRoot = createTestEntity(TemplateGroupRootTypeRef);
		const model = new TemplateEditorModel(template, templateGroupRoot, entityClient$1);
		const addedLanguages = model.getAddedLanguages();
		const additionalLanguages = model.getAdditionalLanguages();
		dist_default(additionalLanguages).deepEquals(languages.filter((language) => language.code !== "en" && language.code !== "de"));
		dist_default(addedLanguages).deepEquals([{
			code: "en",
			textId: LanguageNames.en
		}, {
			code: "de",
			textId: LanguageNames.de
		}]);
	});
});

//#endregion
//#region tests/settings/mailaddress/MailAddressTableModelTest.ts
var import_testdouble$25 = __toESM(require_testdouble(), 1);
dist_default.spec("MailAddressTableModel", function() {
	let model;
	let nameChanger;
	let mailAddressFacade;
	let entityClient$1;
	let userGroupInfo;
	dist_default.beforeEach(function() {
		nameChanger = (0, import_testdouble$25.object)();
		mailAddressFacade = (0, import_testdouble$25.object)();
		const priceServiceMock = createUpgradePriceServiceMock(clone(PLAN_PRICES));
		entityClient$1 = (0, import_testdouble$25.object)();
		userGroupInfo = (0, import_testdouble$25.object)();
		model = new MailAddressTableModel(entityClient$1, priceServiceMock, mailAddressFacade, (0, import_testdouble$25.object)(), (0, import_testdouble$25.object)(), userGroupInfo, nameChanger, noOp);
	});
	dist_default("suggest buying plans with more mail addresses - some new paid plans provide more aliases", async function() {
		(0, import_testdouble$25.when)(mailAddressFacade.addMailAlias(import_testdouble$25.matchers.anything(), import_testdouble$25.matchers.anything())).thenReject(new LimitReachedError("limit reached"));
		const alias1 = createTestEntity(MailAddressAliasTypeRef);
		userGroupInfo.mailAddressAliases = Array(15).fill(alias1);
		const error = await assertThrows(UpgradeRequiredError, () => model.addAlias("overthelimit@tuta.com", "Over, the Limit"));
		dist_default(error.constructor.name).equals(UpgradeRequiredError.name);
		dist_default(error.plans).deepEquals([
			PlanType.Legend,
			PlanType.Advanced,
			PlanType.Unlimited
		]);
	});
	dist_default("suggest buying plans with more mail addresses - no other plans available", async function() {
		(0, import_testdouble$25.when)(mailAddressFacade.addMailAlias(import_testdouble$25.matchers.anything(), import_testdouble$25.matchers.anything())).thenReject(new LimitReachedError("limit reached"));
		const alias1 = createTestEntity(MailAddressAliasTypeRef);
		userGroupInfo.mailAddressAliases = Array(30).fill(alias1);
		await dist_default(() => model.addAlias("overthelimit@tuta.com", "Over, the Limit")).asyncThrows(UserError);
	});
	dist_default("suggest buying plans with more mail addresses - inactive email aliases", async function() {
		(0, import_testdouble$25.when)(mailAddressFacade.addMailAlias(import_testdouble$25.matchers.anything(), import_testdouble$25.matchers.anything())).thenReject(new LimitReachedError("limit reached"));
		const alias1 = createTestEntity(MailAddressAliasTypeRef, { enabled: false });
		userGroupInfo.mailAddressAliases = Array(30).fill(alias1);
		await dist_default(() => model.addAlias("overthelimit@tuta.com", "Over, the Limit")).asyncThrows(UserError);
	});
});

//#endregion
//#region ../src/common/settings/UserDataExporter.ts
async function loadUserExportData(entityClient$1, logins, counterFacade) {
	const { user } = logins.getUserController();
	const { userGroups } = await entityClient$1.load(CustomerTypeRef, assertNotNull(user.customer));
	const groupsAdministeredByUser = await entityClient$1.loadAll(GroupInfoTypeRef, userGroups);
	const usedCustomerStorageCounterValues = await counterFacade.readAllCustomerCounterValues(CounterType.UserStorageLegacy, neverNull(user.customer));
	return pMap(groupsAdministeredByUser, async (info) => {
		const group = await entityClient$1.load(GroupTypeRef, info.group);
		const userStorageCounterValue = usedCustomerStorageCounterValues.find((counterValue) => counterValue.counterId === group.storageCounter);
		const usedStorage = userStorageCounterValue != null ? Number(userStorageCounterValue.value) : 0;
		return {
			name: info.name,
			mailAddress: info.mailAddress ?? "",
			created: info.created,
			deleted: info.deleted,
			usedStorage,
			aliases: info.mailAddressAliases.map((alias) => alias.mailAddress)
		};
	});
}

//#endregion
//#region tests/settings/UserDataExportTest.ts
var import_testdouble$24 = __toESM(require_testdouble(), 1);
dist_default.spec("user data export", function() {
	const customerId = "customerId";
	const userGroupsId = "userGroupsId";
	const user = {
		_id: "userId",
		customer: customerId
	};
	let allUserGroupInfos;
	let entityClientMock;
	let counterFacadeMock;
	let loginsMock;
	let fileControllerMock;
	dist_default.beforeEach(function() {
		allUserGroupInfos = [];
		loginsMock = (0, import_testdouble$24.object)();
		(0, import_testdouble$24.when)(loginsMock.getUserController()).thenReturn({
			user,
			isGlobalAdmin: () => true
		});
		entityClientMock = (0, import_testdouble$24.object)();
		(0, import_testdouble$24.when)(entityClientMock.load(CustomerTypeRef, customerId)).thenResolve({ userGroups: userGroupsId });
		(0, import_testdouble$24.when)(entityClientMock.loadAll(GroupInfoTypeRef, userGroupsId)).thenResolve(allUserGroupInfos);
		counterFacadeMock = (0, import_testdouble$24.object)();
		fileControllerMock = (0, import_testdouble$24.object)();
	});
	dist_default("should load and return correct user data ", async function() {
		const oneCreated = new Date(16552944e5);
		const oneDeleted = new Date(1655469e6);
		const twoCreated = new Date(16578864e5);
		addUser("my name", "mail1@mail.com", oneCreated, oneDeleted, 100, ["alias1@alias.com", "alias2@alias.com"], "user1", "group1", "storage1");
		addUser("eman ym", "mail2@mail.com", twoCreated, null, null, [], "user2", "group2", "storage2");
		(0, import_testdouble$24.when)(counterFacadeMock.readAllCustomerCounterValues(CounterType.UserStorageLegacy, customerId)).thenResolve([createTestEntity(CounterValueTypeRef, {
			counterId: "storage1",
			value: "100"
		}), createTestEntity(CounterValueTypeRef, {
			counterId: "wrongId",
			value: "42"
		})]);
		const [first, second] = await loadUserExportData(entityClientMock, loginsMock, counterFacadeMock);
		dist_default(first.name).equals("my name");
		dist_default(second.name).equals("eman ym");
		dist_default(first.mailAddress).equals("mail1@mail.com");
		dist_default(second.mailAddress).equals("mail2@mail.com");
		dist_default(formatDateTimeUTC(first.created)).equals("20220615T120000Z");
		dist_default(formatDateTimeUTC(second.created)).equals("20220715T120000Z");
		dist_default(formatDateTimeUTC(first.deleted)).equals("20220617T123000Z");
		dist_default(second.deleted).equals(null);
		dist_default(first.usedStorage).equals(100);
		dist_default(second.usedStorage).equals(0);
		dist_default(first.aliases).deepEquals(["alias1@alias.com", "alias2@alias.com"]);
		dist_default(second.aliases).deepEquals([]);
	});
	function addUser(name, mailAddress, created, deleted, usedStorage, aliases, userId$1, groupId, storageCounterId) {
		allUserGroupInfos.push({
			name,
			mailAddress,
			created,
			deleted,
			mailAddressAliases: aliases.map((alias) => ({ mailAddress: alias })),
			group: groupId
		});
		const group = { storageCounter: storageCounterId };
		(0, import_testdouble$24.when)(entityClientMock.load(GroupTypeRef, groupId)).thenResolve({ storageCounter: group.storageCounter });
	}
});

//#endregion
//#region ../src/common/settings/login/secondfactor/SecondFactorEditModel.ts
var import_qrcode = __toESM(require_qrcode(), 1);
let VerificationStatus = function(VerificationStatus$1) {
	VerificationStatus$1["Initial"] = "Initial";
	VerificationStatus$1["Progress"] = "Progress";
	VerificationStatus$1["Failed"] = "Failed";
	VerificationStatus$1["Success"] = "Success";
	return VerificationStatus$1;
}({});
const DEFAULT_U2F_NAME = "U2F";
const DEFAULT_TOTP_NAME = "TOTP";
let NameValidationStatus = function(NameValidationStatus$1) {
	NameValidationStatus$1[NameValidationStatus$1["Valid"] = 0] = "Valid";
	NameValidationStatus$1[NameValidationStatus$1["Invalid"] = 1] = "Invalid";
	return NameValidationStatus$1;
}({});
const SecondFactorTypeToNameTextId = Object.freeze({
	[SecondFactorType.totp]: "totpAuthenticator_label",
	[SecondFactorType.u2f]: "u2fSecurityKey_label",
	[SecondFactorType.webauthn]: "u2fSecurityKey_label"
});
var SecondFactorEditModel = class {
	totpCode = "";
	selectedType;
	name = "";
	nameValidationStatus = NameValidationStatus.Valid;
	verificationStatus = VerificationStatus.Initial;
	otpInfo;
	u2fRegistrationData = null;
	constructor(entityClient$1, user, webauthnClient, totpKeys, webauthnSupported, loginFacade, hostname, domainConfig, updateViewCallback, token) {
		this.entityClient = entityClient$1;
		this.user = user;
		this.webauthnClient = webauthnClient;
		this.totpKeys = totpKeys;
		this.webauthnSupported = webauthnSupported;
		this.loginFacade = loginFacade;
		this.hostname = hostname;
		this.domainConfig = domainConfig;
		this.updateViewCallback = updateViewCallback;
		this.token = token;
		this.selectedType = webauthnSupported ? SecondFactorType.webauthn : SecondFactorType.totp;
		this.setDefaultNameIfNeeded();
		this.otpInfo = new LazyLoaded(async () => {
			const url = await this.getOtpAuthUrl(this.totpKeys.readableKey);
			const totpQRCodeSvg = isApp() ? null : htmlSanitizer.sanitizeSVG(new import_qrcode.default({
				height: 150,
				width: 150,
				content: url,
				padding: 2,
				xmlDeclaration: false
			}).svg()).html;
			return {
				qrCodeSvg: totpQRCodeSvg,
				url
			};
		});
		this.otpInfo.getAsync().then(() => this.updateViewCallback());
	}
	/**
	* if the user cancels the second factor creation while it's already talking to webAuthn, we want to cancel that
	* process before closing the dialog.
	*/
	abort() {
		this.webauthnClient.abortCurrentOperation();
	}
	/**
	* validation message for use in dialog validators
	*/
	validationMessage() {
		return this.nameValidationStatus === NameValidationStatus.Valid ? null : "textTooLong_msg";
	}
	/**
	* get a list of supported second factor types
	*/
	getFactorTypesOptions() {
		const options = [];
		options.push(SecondFactorType.totp);
		if (this.webauthnSupported) options.push(SecondFactorType.webauthn);
		return options;
	}
	/**
	* call when the selected second factor type changes
	*/
	onTypeSelected(newValue) {
		this.selectedType = newValue;
		this.verificationStatus = newValue === SecondFactorType.webauthn ? VerificationStatus.Initial : VerificationStatus.Progress;
		this.setDefaultNameIfNeeded();
		this.updateNameValidation();
		if (newValue !== SecondFactorType.webauthn) this.webauthnClient.abortCurrentOperation();
	}
	/**
	* call when the display name of the second factor instance changes
	*/
	onNameChange(newValue) {
		this.name = newValue;
		this.updateNameValidation();
	}
	/**
	* call when the validation code for setting up TOTP changes
	*/
	async onTotpValueChange(newValue) {
		this.totpCode = newValue;
		let cleanedValue = newValue.replace(/ /g, "");
		if (cleanedValue.length === 6) {
			const expectedCode = Number(cleanedValue);
			this.verificationStatus = await this.tryCodes(expectedCode, this.totpKeys.key);
		} else this.verificationStatus = VerificationStatus.Progress;
		this.updateViewCallback();
	}
	/**
	* re-validates the input and makes the server calls to actually create a second factor
	* returns the user that the second factor was created in case any follow-up operations
	* are needed
	*/
	async save() {
		this.setDefaultNameIfNeeded();
		if (this.selectedType === SecondFactorType.webauthn) {
			if (this.verificationStatus === VerificationStatus.Progress) return null;
			try {
				this.u2fRegistrationData = await this.webauthnClient.register(this.user._id, this.name);
				this.verificationStatus = VerificationStatus.Success;
			} catch (e) {
				console.log("Webauthn registration failed: ", e);
				this.u2fRegistrationData = null;
				this.verificationStatus = VerificationStatus.Failed;
				return null;
			}
		}
		this.updateViewCallback();
		if (this.selectedType === SecondFactorType.u2f) throw new ProgrammingError(`invalid factor type: ${this.selectedType}`);
		const sf = createSecondFactor({
			_ownerGroup: this.user._ownerGroup,
			name: this.name,
			type: this.selectedType,
			otpSecret: null,
			u2f: null
		});
		if (this.selectedType === SecondFactorType.webauthn) if (this.verificationStatus !== VerificationStatus.Success) throw new UserError("unrecognizedU2fDevice_msg");
else sf.u2f = this.u2fRegistrationData;
else if (this.selectedType === SecondFactorType.totp) if (this.verificationStatus === VerificationStatus.Failed) throw new UserError("totpCodeWrong_msg");
else if (this.verificationStatus === VerificationStatus.Initial || this.verificationStatus === VerificationStatus.Progress) throw new UserError("totpCodeEnter_msg");
else sf.otpSecret = this.totpKeys.key;
		await this.entityClient.setup(assertNotNull(this.user.auth).secondFactors, sf, this.token ? { token: this.token } : undefined);
		return this.user;
	}
	/** see https://github.com/google/google-authenticator/wiki/Key-Uri-Format */
	async getOtpAuthUrl(secret) {
		const userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, this.user.userGroup.groupInfo);
		const issuer = this.domainConfig.firstPartyDomain ? "Tutanota" : this.hostname;
		const account = encodeURI(issuer + ":" + neverNull(userGroupInfo.mailAddress));
		const url = new URL("otpauth://totp/" + account);
		url.searchParams.set("issuer", issuer);
		url.searchParams.set("secret", secret.replace(/ /g, ""));
		url.searchParams.set("algorithm", "SHA1");
		url.searchParams.set("digits", "6");
		url.searchParams.set("period", "30");
		return url.toString();
	}
	/**
	* re-check if the given display name is valid for the current second factor type
	*/
	updateNameValidation() {
		this.nameValidationStatus = this.selectedType !== SecondFactorType.webauthn || validateWebauthnDisplayName(this.name) ? NameValidationStatus.Valid : NameValidationStatus.Invalid;
	}
	/**
	* empty names sometimes lead to errors, so we make sure we have something semi-sensible set in the field.
	*/
	setDefaultNameIfNeeded() {
		const trimmed = this.name.trim();
		if (this.selectedType === SecondFactorType.webauthn && (trimmed === DEFAULT_TOTP_NAME || trimmed.length === 0)) this.name = DEFAULT_U2F_NAME;
else if (this.selectedType === SecondFactorType.totp && (trimmed === DEFAULT_U2F_NAME || trimmed.length === 0)) this.name = DEFAULT_TOTP_NAME;
	}
	/**
	* check if the given validation code is the current, next or last code for the TOTP
	*/
	async tryCodes(expectedCode, key) {
		const time = Math.floor(new Date().getTime() / 1e3 / 30);
		const number = await this.loginFacade.generateTotpCode(time, key);
		if (number === expectedCode) return VerificationStatus.Success;
		const number2 = await this.loginFacade.generateTotpCode(time - 1, key);
		if (number2 === expectedCode) return VerificationStatus.Success;
		const number3 = await this.loginFacade.generateTotpCode(time + 1, key);
		if (number3 === expectedCode) return VerificationStatus.Success;
		return VerificationStatus.Failed;
	}
};

//#endregion
//#region tests/settings/login/secondfactor/SecondFactorEditModelTest.ts
var import_testdouble$23 = __toESM(require_testdouble(), 1);
function createTotpKeys() {
	const key = new Uint8Array(16);
	const readableKey = TotpVerifier.readableKey(key);
	return {
		key,
		readableKey
	};
}
dist_default.spec("SecondFactorEditModel", function() {
	let entityClientMock;
	let userMock;
	let webAuthnClientMock;
	let loginFacadeMock;
	const totpKeys = createTotpKeys();
	const validName = "myU2Fkey";
	const invalidName = "";
	const hostname = "testhostname";
	async function createSecondFactorModel(params) {
		const model = new SecondFactorEditModel(params.entityClient ?? entityClientMock, params.user ?? userMock, params.webAuthnClient ?? webAuthnClientMock, totpKeys, params.webauthnSupported ?? true, loginFacadeMock, hostname, domainConfigStub, params.updateView ?? noOp);
		await model.otpInfo.getAsync();
		return model;
	}
	dist_default.beforeEach(function() {
		entityClientMock = (0, import_testdouble$23.object)();
		(0, import_testdouble$23.when)(entityClientMock.load(GroupInfoTypeRef, import_testdouble$23.matchers.anything())).thenResolve(createTestEntity(GroupInfoTypeRef, { mailAddress: "testaddress@tutanota.de" }));
		userMock = (0, import_testdouble$23.object)();
		webAuthnClientMock = (0, import_testdouble$23.object)();
		loginFacadeMock = (0, import_testdouble$23.object)();
	});
	dist_default.spec("getFactorTypesOptions", function() {
		dist_default("if webauthn is not supported, we get only one option", async function() {
			const model = await createSecondFactorModel({ webauthnSupported: false });
			const options = model.getFactorTypesOptions();
			dist_default(options.length).equals(1);
			dist_default(options.find((o$1) => o$1 === SecondFactorType.webauthn)).equals(undefined);
		});
		dist_default("if webauthn is supported, we get it as an option", async function() {
			const model = await createSecondFactorModel({});
			const options = model.getFactorTypesOptions();
			dist_default(options.filter((o$1) => o$1 === SecondFactorType.webauthn).length).equals(1);
		});
	});
	dist_default.spec("onTypeChange", function() {
		dist_default("when the type changes, we set the default name if necessary", async function() {
			const model = await createSecondFactorModel({});
			model.onTypeSelected(SecondFactorType.totp);
			model.onNameChange("");
			model.onTypeSelected(SecondFactorType.webauthn);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
			dist_default(model.name).equals(DEFAULT_U2F_NAME);
			model.onNameChange("");
			model.onTypeSelected(SecondFactorType.totp);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
			dist_default(model.name).equals(DEFAULT_TOTP_NAME);
			model.onTypeSelected(SecondFactorType.webauthn);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
			dist_default(model.name).equals(DEFAULT_U2F_NAME);
		});
		dist_default("when name too long changing the factor updates name validation status", async function() {
			const model = await createSecondFactorModel({});
			model.onTypeSelected(SecondFactorType.totp);
			model.onNameChange(invalidName);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
			model.onTypeSelected(SecondFactorType.webauthn);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Invalid);
			dist_default(model.name).equals(invalidName);
			model.onNameChange(validName);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
			model.onNameChange(invalidName);
			model.onTypeSelected(SecondFactorType.totp);
			dist_default(model.nameValidationStatus).equals(NameValidationStatus.Valid);
		});
	});
	dist_default.spec("saving a second factor", function() {
		dist_default("saving a u2f key, happy path", async function() {
			const redrawMock = (0, import_testdouble$23.function)("redrawMock");
			(0, import_testdouble$23.when)(entityClientMock.setup(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything())).thenResolve("randomID");
			(0, import_testdouble$23.when)(webAuthnClientMock.register(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything())).thenResolve({});
			const model = await createSecondFactorModel({ updateView: redrawMock });
			model.onTypeSelected(SecondFactorType.webauthn);
			model.onNameChange(" 	 ");
			const user = await model.save();
			dist_default(user).deepEquals(userMock);
			(0, import_testdouble$23.verify)(redrawMock(), { times: 2 });
			(0, import_testdouble$23.verify)(entityClientMock.setup(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything()), { times: 1 });
		});
		dist_default("saving a totp key, happy path", async function() {
			const redrawMock = (0, import_testdouble$23.function)("redrawMock");
			(0, import_testdouble$23.when)(entityClientMock.setup(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything())).thenResolve("randomID");
			(0, import_testdouble$23.when)(webAuthnClientMock.register(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything())).thenResolve({});
			(0, import_testdouble$23.when)(loginFacadeMock.generateTotpCode(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything())).thenResolve(123456);
			const model = await createSecondFactorModel({ updateView: redrawMock });
			model.onTypeSelected(SecondFactorType.totp);
			model.onNameChange(" 	 ");
			await model.onTotpValueChange("123456");
			const user = await model.save();
			dist_default(user).deepEquals(userMock);
			(0, import_testdouble$23.verify)(redrawMock(), { times: 3 });
			(0, import_testdouble$23.verify)(entityClientMock.setup(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything()), { times: 1 });
		});
	});
	dist_default.spec("TOTP value changed", function() {
		dist_default("don't generate totp codes when the validation code has the wrong length", async function() {
			const model = await createSecondFactorModel({});
			await model.onTotpValueChange("1234567");
			(0, import_testdouble$23.verify)(loginFacadeMock.generateTotpCode(import_testdouble$23.matchers.anything(), import_testdouble$23.matchers.anything()), { times: 0 });
		});
	});
});

//#endregion
//#region tests/misc/SchedulerTest.ts
dist_default.spec("Scheduler", function() {
	let dateProvider$1;
	let scheduler;
	let timeoutMock;
	let now$1;
	dist_default.beforeEach(function() {
		now$1 = DateTime.fromISO("2020-04-21T22:00:00");
		dateProvider$1 = {
			now: () => now$1.toMillis(),
			timeZone: () => "Europe/Berlin"
		};
		timeoutMock = new TimeoutMock();
		scheduler = new SchedulerImpl(dateProvider$1, downcast(timeoutMock), new IntervalMock());
	});
	dist_default("scheduleAt close", function() {
		const cb = spy();
		const duration = Duration.fromObject({ minutes: 10 });
		const scheduleTime = now$1.plus(duration);
		scheduler.scheduleAt(cb, scheduleTime.toJSDate());
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([duration.toMillis()]);
		dist_default(cb.callCount).equals(0)("Not called earlier");
		assertNotNull(timeoutMock.scheduledAfter.get(duration.toMillis())).thunk();
		dist_default(cb.callCount).equals(1)("Was called after timeout");
	});
	dist_default("scheduleAt far", function() {
		const cb = spy();
		const duration = Duration.fromObject({ milliseconds: SET_TIMEOUT_LIMIT + 2e3 });
		const scheduleTime = now$1.plus(duration);
		scheduler.scheduleAt(cb, scheduleTime.toJSDate());
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([SET_TIMEOUT_LIMIT]);
		dist_default(cb.callCount).equals(0)("Not called earlier");
		const intermediateTimeout = assertNotNull(timeoutMock.scheduledAfter.get(SET_TIMEOUT_LIMIT));
		timeoutMock.scheduledAfter.clear();
		now$1 = now$1.plus({ milliseconds: SET_TIMEOUT_LIMIT });
		intermediateTimeout.thunk();
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([2e3]);
		dist_default(cb.callCount).equals(0)("Not called after later");
		const newTimeout = assertNotNull(timeoutMock.scheduledAfter.get(2e3));
		newTimeout.thunk();
		dist_default(cb.callCount).equals(1)("Was called after timeout");
	});
	dist_default("scheduleAt far, cancelled intermediate timeout", function() {
		const cb = spy();
		const duration = Duration.fromObject({ milliseconds: SET_TIMEOUT_LIMIT + 2e3 });
		const scheduleTime = now$1.plus(duration);
		const scheduledId = scheduler.scheduleAt(cb, scheduleTime.toJSDate());
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([SET_TIMEOUT_LIMIT]);
		dist_default(cb.callCount).equals(0)("Not called earlier");
		const intermediateTimeout = assertNotNull(timeoutMock.scheduledAfter.get(SET_TIMEOUT_LIMIT));
		scheduler.unscheduleTimeout(scheduledId);
		dist_default(Array.from(timeoutMock.cancelled.values())).deepEquals([intermediateTimeout.id]);
	});
	dist_default("scheduleAt far, cancelled final timeout", function() {
		const cb = spy();
		const duration = Duration.fromObject({ milliseconds: SET_TIMEOUT_LIMIT + 2e3 });
		const scheduleTime = now$1.plus(duration);
		const scheduledId = scheduler.scheduleAt(cb, scheduleTime.toJSDate());
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([SET_TIMEOUT_LIMIT]);
		dist_default(cb.callCount).equals(0)("Not called earlier");
		const intermediateTimeout = assertNotNull(timeoutMock.scheduledAfter.get(SET_TIMEOUT_LIMIT));
		timeoutMock.scheduledAfter.clear();
		now$1 = now$1.plus({ milliseconds: SET_TIMEOUT_LIMIT });
		intermediateTimeout.thunk();
		dist_default(Array.from(timeoutMock.scheduledAfter.keys())).deepEquals([2e3]);
		const newTimeout = assertNotNull(timeoutMock.scheduledAfter.get(2e3));
		scheduler.unscheduleTimeout(scheduledId);
		dist_default(cb.callCount).equals(0)("Not called after later");
		dist_default(Array.from(timeoutMock.cancelled)).deepEquals([newTimeout.id]);
	});
});
var TimeoutMock = class {
	alarmId;
	scheduledAfter;
	cancelled;
	constructor() {
		this.alarmId = 0;
		this.scheduledAfter = new Map();
		this.cancelled = new Set();
		this.setTimeout.bind(this);
		this.clearTimeout.bind(this);
	}
	setTimeout(callback, ms) {
		const id = this._incAlarmId();
		this.scheduledAfter.set(ms, {
			id,
			thunk: callback
		});
		return id;
	}
	clearTimeout(id) {
		this.cancelled.add(id);
	}
	_incAlarmId() {
		return downcast(this.alarmId++);
	}
};
var IntervalMock = class {
	setInterval(cb, ms) {
		throw new Error("Not implemented");
	}
	clearInterval() {
		throw new Error("Not implemented");
	}
};

//#endregion
//#region tests/misc/parsing/MailAddressParserTest.ts
dist_default.spec("MailAddressParser", function() {
	dist_default("parseMailtoUrl single address", function() {
		let { recipients, subject, body } = parseMailtoUrl("mailto:chris@example.com");
		dist_default(recipients.to).deepEquals([{
			name: "",
			address: "chris@example.com"
		}]);
		dist_default(subject).equals(null);
		dist_default(body).equals(null);
	});
	dist_default("parseMailtoUrl with subject and body", function() {
		let { recipients, subject, body, attach } = parseMailtoUrl("mailto:someone@example.com?subject=This%20is%20the%20subject&cc=someone_else@example.com&body=This%20is%20the%20body%0AKind regards%20someone");
		dist_default(recipients.to).deepEquals([{
			name: "",
			address: "someone@example.com"
		}]);
		dist_default(recipients.cc).deepEquals([{
			name: "",
			address: "someone_else@example.com"
		}]);
		dist_default(subject).equals("This is the subject");
		dist_default(attach).equals(null);
		dist_default(body).equals("This is the body<br>Kind regards someone");
	});
	dist_default("parseMailtoUrl with multiple recipients", function() {
		let { recipients, body } = parseMailtoUrl("mailto:joe1@example.com,joe2@example.com?to=joe3@example.com&cc=bob1@example.com%2C%20bob2@example.com&body=hello&bcc=carol1@example.com%2C%20carol2@example.com");
		dist_default((recipients.to || []).map((to) => to.address)).deepEquals([
			"joe1@example.com",
			"joe2@example.com",
			"joe3@example.com"
		]);
		dist_default((recipients.cc || []).map((cc) => cc.address)).deepEquals(["bob1@example.com", "bob2@example.com"]);
		dist_default((recipients.bcc || []).map((bcc) => bcc.address)).deepEquals(["carol1@example.com", "carol2@example.com"]);
		dist_default(body).equals("hello");
	});
	dist_default("parseMailtoUrl to lower case", function() {
		let { recipients, subject, body } = parseMailtoUrl("	mailto:matthias@test.de?CC=matthias@test.de&BCC=matthias@test.de&Subject=Blah&Body=What%3F%20Everything%20encoded%20in%20mailto%3F");
		dist_default((recipients.to || []).map((to) => to.address)).deepEquals(["matthias@test.de"]);
		dist_default((recipients.cc || []).map((cc) => cc.address)).deepEquals(["matthias@test.de"]);
		dist_default((recipients.bcc || []).map((bcc) => bcc.address)).deepEquals(["matthias@test.de"]);
		dist_default(subject).equals("Blah");
		dist_default(body).equals("What? Everything encoded in mailto?");
	});
	dist_default("parseMailtoUrl with full addressing scheme", function() {
		let { recipients } = parseMailtoUrl("mailto:Fritz%20Eierschale%20%3Ceierschale@irgend.wo%3E");
		dist_default(recipients.to).deepEquals([{
			address: "eierschale@irgend.wo",
			name: "Fritz Eierschale"
		}]);
	});
	dist_default("parseMailtoUrl with attachments", function() {
		let { attach, body } = parseMailtoUrl("mailto:a@b.c?attach=file:///home/user/cat.jpg&body=hello%20world&attach=file:///home/user/dog%20man.jpg&attach=/home/user/pig.jpg");
		dist_default(attach).deepEquals([
			"file:///home/user/cat.jpg",
			"file:///home/user/dog man.jpg",
			"/home/user/pig.jpg"
		]);
		dist_default(body).equals("hello world");
	});
	dist_default("parseMailtoUrl with empty params", function() {
		let { attach, body, recipients } = parseMailtoUrl("mailto:?attach=&body=&bcc=");
		dist_default(attach).deepEquals([""]);
		dist_default(recipients).deepEquals({
			to: undefined,
			cc: undefined,
			bcc: []
		});
		dist_default(body).equals("");
	});
	dist_default("parseMailtoUrl without params", function() {
		let { attach, body, subject, recipients } = parseMailtoUrl("mailto:");
		dist_default(attach).equals(null);
		dist_default(body).equals(null);
		dist_default(subject).equals(null);
		dist_default(recipients).deepEquals({
			to: undefined,
			cc: undefined,
			bcc: undefined
		});
	});
	dist_default("parseMailtoUrl with bogus params", function() {
		let { bogus } = parseMailtoUrl("mailto:?bogus=hello");
		dist_default(bogus).equals(undefined);
	});
	dist_default("isStrictMailAddress", function() {
		dist_default(isMailAddress("a@b.de", true)).equals(true);
		dist_default(isMailAddress("a@hello.c", true)).equals(true);
		dist_default(isMailAddress("a.b@hello.de", true)).equals(true);
		dist_default(isMailAddress("A@b.hello.de", true)).equals(true);
		dist_default(isMailAddress("@b.hello.de", true)).equals(false);
		dist_default(isMailAddress("batello.de", true)).equals(false);
		dist_default(isMailAddress("ba@tello", true)).equals(false);
		dist_default(isMailAddress("@hello.de", true)).equals(false);
		dist_default(isMailAddress("a@@hello.de", true)).equals(false);
		dist_default(isMailAddress("a@h@hello.de", true)).equals(false);
		dist_default(isMailAddress("aa@.de", true)).equals(false);
		dist_default(isMailAddress("aa@", true)).equals(false);
		dist_default(isMailAddress("aa@.", true)).equals(false);
		dist_default(isMailAddress("", true)).equals(false);
		dist_default(isMailAddress(" ", true)).equals(false);
		dist_default(isMailAddress(" ab@cd.de", true)).equals(false);
		dist_default(isMailAddress("a b@cb.de", true)).equals(false);
		dist_default(isMailAddress("ab @cb.de", true)).equals(false);
		dist_default(isMailAddress("ab@ cd.de", true)).equals(false);
		dist_default(isMailAddress("ab@c b.de", true)).equals(false);
		dist_default(isMailAddress("ab@cd .de", true)).equals(false);
		dist_default(isMailAddress("ab@cd. de", true)).equals(false);
		dist_default(isMailAddress("ab@cd.d e", true)).equals(false);
		dist_default(isMailAddress("ab@cd.de ", true)).equals(false);
		dist_default(isMailAddress(new Array(65).join("a") + "@tutanota.de", true)).equals(true);
		dist_default(isMailAddress(new Array(66).join("a") + "@tutanota.de", true)).equals(false);
		dist_default(isMailAddress("aaaaaaaaaa@" + new Array(241).join("a") + ".de", true)).equals(true);
		dist_default(isMailAddress("aaaaaaaaaa@" + new Array(242).join("a") + ".de", true)).equals(false);
		dist_default(isMailAddress("abcefghijklmnopqrstuvwxyzabcefghijklmnopqrstuvwxyzabcefghijklmno@cd.de", true)).equals(true);
		dist_default(isMailAddress("abcefghijklmnopqrstuvwxyzabcefghijklmnopqrstuvwxyzabcefghijklmnop@cd.de", true)).equals(false);
	});
	dist_default("cleanedMailAddress", function() {
		dist_default(getCleanedMailAddress("   a@b.de   ")).equals("a@b.de");
		dist_default(getCleanedMailAddress("xxxx")).equals(null);
	});
	dist_default("stringToNameAndMailAddress", function() {
		dist_default(stringToNameAndMailAddress(" a@b.de ")).deepEquals({
			name: "",
			mailAddress: "a@b.de"
		});
		dist_default(stringToNameAndMailAddress(" <a@b.de > ")).deepEquals({
			name: "",
			mailAddress: "a@b.de"
		});
		dist_default(stringToNameAndMailAddress(" Aas Bos a@b.de")).deepEquals({
			name: "Aas Bos",
			mailAddress: "a@b.de"
		});
		dist_default(stringToNameAndMailAddress(" Aas Bos  <a@b.de>")).deepEquals({
			name: "Aas Bos",
			mailAddress: "a@b.de"
		});
		dist_default(stringToNameAndMailAddress(" Aas Bos<a@b.de>")).deepEquals({
			name: "Aas Bos",
			mailAddress: "a@b.de"
		});
		dist_default(stringToNameAndMailAddress(" Aas Bos  <a@de>")).equals(null);
		dist_default(stringToNameAndMailAddress(" Aas Bos ")).equals(null);
		dist_default(stringToNameAndMailAddress(" Aas Bos  a@de")).equals(null);
	});
	dist_default("fullNameToNameAndMailAddress", function() {
		dist_default(fullNameToFirstAndLastName("Peter Pan")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(fullNameToFirstAndLastName("peter pan")).deepEquals({
			firstName: "peter",
			lastName: "pan"
		});
		dist_default(fullNameToFirstAndLastName("Peter Pater Pan")).deepEquals({
			firstName: "Peter",
			lastName: "Pater Pan"
		});
		dist_default(fullNameToFirstAndLastName(" Peter ")).deepEquals({
			firstName: "Peter",
			lastName: ""
		});
	});
	dist_default("mailAddressToFirstAndLastName", function() {
		dist_default(mailAddressToFirstAndLastName("Peter.Pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter.pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter_pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter-pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter_pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter.pater.pan@x.de")).deepEquals({
			firstName: "Peter",
			lastName: "Pater Pan"
		});
		dist_default(mailAddressToFirstAndLastName("peter@x.de")).deepEquals({
			firstName: "Peter",
			lastName: ""
		});
	});
});

//#endregion
//#region tests/misc/FormatValidatorTest.ts
dist_default.spec("FormatValidatorTest", function() {
	dist_default(" isRegularExpression", function() {
		dist_default(isRegularExpression("")).equals(false);
		dist_default(isRegularExpression("1")).equals(false);
		dist_default(isRegularExpression("$")).equals(false);
		dist_default(isRegularExpression("//")).equals(true);
		dist_default(isRegularExpression("/123/")).equals(true);
		dist_default(isRegularExpression("/[1]*/")).equals(true);
		dist_default(isRegularExpression("/$/")).equals(true);
		dist_default(isRegularExpression("/./")).equals(true);
		dist_default(isRegularExpression("/\\/")).equals(true);
		dist_default(isRegularExpression("/$/")).equals(true);
		dist_default(isRegularExpression("/hey/i")).equals(true);
		dist_default(isRegularExpression("//muy")).equals(true);
		dist_default(isRegularExpression("/hey/x")).equals(false);
	});
	dist_default("credit card validation", function() {
		const goodValues = [
			"378282246310005",
			"371449635398431",
			"36259600000004",
			"6011 0009 9130 0009",
			"3530 1113 3330 0000",
			"6304000000000000",
			"55555555 55554444",
			"2223000048400011",
			"4111111111111111",
			"4005519200000004",
			"400 934 888 888 188 1",
			"4012000033330026",
			"4012000077777777",
			"4012888888881881",
			"4217651111111119",
			" 4500600000000061"
		];
		const badValues = [
			"79927398710",
			"79927398711",
			"79 9273 98712",
			"7992 7398 714",
			"7992 7398715",
			"79927398716",
			"7992 7398 717",
			"79927398718",
			"79927398719",
			"128937asd",
			"i am not a credit card number",
			"601100099a1300009",
			"353011asd1333300000",
			"630400000!000&0000",
			"55555555d5555s 4444",
			"a4111111111111111"
		];
		function testCreditCardNumberValidation(val, isValid) {
			dist_default(isValidCreditCardNumber(val)).equals(isValid)(`${val} is ${isValid ? "valid" : "invalid"}`);
		}
		for (let good of goodValues) testCreditCardNumberValidation(good, true);
		for (let bad of badValues) testCreditCardNumberValidation(bad, false);
	});
	dist_default("isMailAddress", function() {
		dist_default(isMailAddress("abcefghijklmnopqrstuvwxyzabcefghijklmnopqrstuvwxyzabcefghijklmnopqrstuvwxyz@cd.de", false)).equals(true);
		dist_default(isMailAddress("a@d.de", false)).equals(true);
		dist_default(isMailAddress("*@d.de", false)).equals(true);
		dist_default(isMailAddress("asfldawef+@d.de", false)).equals(true);
		dist_default(isMailAddress("asfldawef=@d.de", false)).equals(true);
		dist_default(isMailAddress("+@d.de", false)).equals(true);
		dist_default(isMailAddress("=@d.de", false)).equals(true);
		dist_default(isMailAddress("@d.de", false)).equals(false);
		dist_default(isMailAddress(" @d.de", false)).equals(false);
		dist_default(isMailAddress("	@d.de", false)).equals(false);
		dist_default(isMailAddress("asdf asdf@d.de", false)).equals(false);
		dist_default(isMailAddress("@@d.de", false)).equals(false);
		dist_default(isMailAddress("a@b@d.de", false)).equals(false);
		dist_default(isMailAddress("abc@dh.de", false)).equals(false);
		dist_default(isMailAddress("a,b@d.de", false)).equals(false);
		dist_default(isMailAddress("a)b@d.de", false)).equals(false);
	});
});

//#endregion
//#region ../src/common/settings/whitelabel/CustomColorsEditorViewModel.ts
var import_stream$1 = __toESM(require_stream(), 1);
assertMainOrNode();
var CustomColorsEditorViewModel = class {
	_customizations;
	_whitelabelConfig;
	_whitelabelDomainInfo;
	_accentColor;
	_baseTheme;
	_themeController;
	_entityClient;
	_loginController;
	_themeBeforePreview;
	builtTheme;
	constructor(currentTheme, themeCustomizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController) {
		this._themeBeforePreview = Object.freeze(currentTheme);
		this._customizations = clone(themeCustomizations);
		this._whitelabelDomainInfo = whitelabelDomainInfo;
		this._whitelabelConfig = whitelabelConfig;
		this._themeController = themeController;
		this._entityClient = entityClient$1;
		this._loginController = loginController;
		this.builtTheme = (0, import_stream$1.default)();
		const baseThemeId = themeCustomizations.base ?? "light";
		const accentColor = themeCustomizations.content_accent ?? this._themeController.getDefaultTheme().content_accent;
		this.changeBaseTheme(baseThemeId);
		this.changeAccentColor(accentColor);
	}
	init() {
		this._applyEditedTheme();
	}
	get customColors() {
		const base = this._themeController.getBaseTheme(this.baseThemeId);
		return Object.keys(base).map((key) => key).filter((name) => !this._shallBeExcluded(name)).map((key) => key).sort((a, b) => a.localeCompare(b)).map((key) => {
			const value = this._customizations[key] ?? "";
			const defaultValue = base[key];
			return {
				name: key,
				value,
				defaultValue: assertNotNull(defaultValue),
				valid: this._isValidColorValue(value)
			};
		});
	}
	get accentColor() {
		return this._accentColor;
	}
	get customizations() {
		return this._customizations;
	}
	get baseThemeId() {
		return this._baseTheme;
	}
	getDefaultColor(colorName) {
		return assertNotNull(this._themeController.getBaseTheme(this.baseThemeId)[colorName]);
	}
	changeAccentColor(accentColor) {
		this._accentColor = accentColor;
		this.addCustomization("list_accent_fg", accentColor);
		this.addCustomization("content_accent", accentColor);
		this.addCustomization("content_button_selected", accentColor);
		this.addCustomization("navigation_button_selected", accentColor);
		this.addCustomization("header_button_selected", accentColor);
		this._applyEditedTheme();
	}
	changeBaseTheme(baseThemeId) {
		this._baseTheme = baseThemeId;
		this.addCustomization("base", baseThemeId);
		this._applyEditedTheme();
	}
	/**
	* Try to save changes. if there are invalid color values in the theme doesn't save and returns false, else saves and returns true
	*/
	async save() {
		const colors = Object.keys(this.customizations).filter((name) => name !== "logo" && name !== "themeId" && name !== "base");
		for (let i = 0; i < colors.length; i++) if (!this._isValidColorValue(this.customizations[colors[i]] ?? "")) return false;
		this.addCustomization("themeId", this._whitelabelDomainInfo.domain);
		this._whitelabelConfig.jsonTheme = JSON.stringify(this.customizations);
		await this._entityClient.update(this._whitelabelConfig);
		if (!this._loginController.isWhitelabel()) await this.resetActiveClientTheme();
		return true;
	}
	async resetActiveClientTheme() {
		await this._themeController.applyCustomizations(downcast(Object.assign({}, { base: null }, this._themeBeforePreview)), false);
	}
	addCustomization(nameOfKey, colorValue) {
		this.customizations[nameOfKey] = colorValue;
		this._applyEditedTheme();
	}
	_isValidColorValue(colorValue) {
		return isValidColorCode(colorValue.trim()) || colorValue.trim() === "";
	}
	/**
	* These values shall be excluded when rendering the advanced TextFields
	* @return boolean, true iff provided parameter 'name' shall be excluded
	*/
	_shallBeExcluded(name) {
		const excludedColors = [
			"logo",
			"themeId",
			"base",
			"list_accent_fg",
			"content_button_selected",
			"navigation_button_selected",
			"header_button_selected",
			"content_accent",
			"content_accent_cyber_monday",
			"content_bg_cyber_monday",
			"content_border_cyber_monday"
		];
		return excludedColors.includes(name);
	}
	_applyEditedTheme = debounceStart(100, () => {
		this._removeEmptyCustomizations();
		this._themeController.applyCustomizations(this._filterAndReturnCustomizations(), false);
	});
	_removeEmptyCustomizations() {
		this._customizations = downcast(Object.fromEntries(Object.entries(this.customizations).filter(([k, v]) => v !== "")));
	}
	/**
	*  filters out all invalid color values from ThemeCustomizations whilst keeping logo, base and themeId
	*/
	_filterAndReturnCustomizations() {
		const colorValues = Object.entries(this.customizations).filter(([n, v]) => n !== "themeId" && n !== "base" && n !== "logo");
		const filteredColorValues = colorValues.filter(([n, v]) => this._isValidColorValue(downcast(v)));
		for (const [n, v] of Object.entries(this.customizations)) if (n === "themeId" || n === "base" || n === "logo") filteredColorValues.push([n, v]);
		return downcast(Object.fromEntries(filteredColorValues));
	}
};

//#endregion
//#region tests/settings/whitelabel/CustomColorEditorTest.ts
dist_default.spec("SimpleColorEditor", function() {
	let model;
	let themeController;
	let whitelabelConfig;
	let whitelabelDomainInfo;
	let defaultTheme;
	const defaultCustomizations = downcast({
		list_accent_fg: "#850122",
		content_accent: "#850122",
		content_button_selected: "#850122",
		navigation_button_selected: "#850122",
		header_button_selected: "#850122",
		base: "light"
	});
	let entityClient$1;
	let loginController;
	let isWhitelabelEnabled = false;
	dist_default.beforeEach(function() {
		isWhitelabelEnabled = false;
		themeController = {
			applyCustomizations: spy(),
			getDefaultTheme: () => {
				return themes()["light"];
			}
		};
		whitelabelConfig = createTestEntity(WhitelabelConfigTypeRef);
		whitelabelDomainInfo = createTestEntity(DomainInfoTypeRef);
		whitelabelDomainInfo.domain = "test.domain.com";
		defaultTheme = themeController.getDefaultTheme();
		entityClient$1 = downcast({ update: spy() });
		loginController = downcast({ isWhitelabel: () => {
			return isWhitelabelEnabled;
		} });
	});
	dist_default.spec("openEditor", function() {
		dist_default("open Editor without custom theme, default values should be applied no matter what", function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			dist_default(model.accentColor).equals("#850122");
			dist_default(model.baseThemeId).equals("light");
			dist_default(themeController.applyCustomizations.callCount).equals(1);
		});
		dist_default("open Editor with custom theme, all customizations should be applied", async function() {
			const customizations = downcast({
				themeId: "test.domain.com",
				list_accent_fg: "#ee051f",
				content_accent: "#ee051f",
				content_button_selected: "#ee051f",
				navigation_button_selected: "#ee051f",
				header_button_selected: "#ee051f",
				base: "dark",
				content_bg: "#1df3ed",
				modal_bg: "#1aa1aa"
			});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			dist_default(model.accentColor).equals(customizations.content_accent);
			dist_default(model.baseThemeId).equals(customizations.base);
			await model.save();
			dist_default(entityClient$1.update.callCount).equals(1);
			dist_default(JSON.parse(entityClient$1.update.args[0].jsonTheme)).deepEquals(customizations);
		});
	});
	dist_default.spec("addCustomization", function() {
		dist_default("valid value is applied", async function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.addCustomization("content_button", "#abcdef");
			model.addCustomization("modal_bg", "#fedcba");
			dist_default(model.customizations).deepEquals(downcast(Object.assign({}, defaultCustomizations, {
				content_button: "#abcdef",
				modal_bg: "#fedcba"
			})));
			await model.save();
			dist_default(entityClient$1.update.callCount).equals(1);
			dist_default(JSON.parse(entityClient$1.update.args[0].jsonTheme)).deepEquals(Object.assign({}, defaultCustomizations, {
				content_button: "#abcdef",
				modal_bg: "#fedcba",
				themeId: "test.domain.com"
			}));
		});
		dist_default("invalid value is not applied", function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.addCustomization("modal_bg", "#false");
			model.addCustomization("button_bubble_bg", "#69");
			model.addCustomization("content_fg", "#zzzzzz");
			model.addCustomization("navigation_bg", "#abcdefghi");
			dist_default(model.customizations).deepEquals(downcast(Object.assign({}, defaultCustomizations, {
				modal_bg: "#false",
				button_bubble_bg: "#69",
				content_fg: "#zzzzzz",
				navigation_bg: "#abcdefghi"
			})));
			dist_default(model._filterAndReturnCustomizations()).deepEquals(defaultCustomizations);
		});
		dist_default("valid and invalid, only valid is applied", function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.addCustomization("modal_bg", "#fedcba");
			model.addCustomization("button_bubble_bg", "#69");
			model.addCustomization("content_fg", "#deffed");
			model.addCustomization("navigation_bg", "#abcdefghi");
			model.addCustomization("content_button", "#abcdef");
			dist_default(model.customizations).deepEquals(downcast(Object.assign({}, defaultCustomizations, {
				modal_bg: "#fedcba",
				button_bubble_bg: "#69",
				content_fg: "#deffed",
				navigation_bg: "#abcdefghi",
				content_button: "#abcdef"
			})));
			dist_default(model._filterAndReturnCustomizations()).deepEquals(Object.assign({}, defaultCustomizations, {
				modal_bg: "#fedcba",
				content_fg: "#deffed",
				content_button: "#abcdef"
			}));
		});
		dist_default("empty customizations should be cleared out", function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.addCustomization("modal_bg", "");
			model.addCustomization("content_fg", "");
			model.addCustomization("content_button", "");
			model._removeEmptyCustomizations();
			dist_default(model.customizations).deepEquals(defaultCustomizations);
		});
	});
	dist_default.spec("closeEditor", function() {
		dist_default("pressed cancel, all values should reset", async function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			await model.resetActiveClientTheme();
			dist_default(themeController.applyCustomizations.callCount).equals(2);
			dist_default(themeController.applyCustomizations.args[0]).deepEquals(Object.assign({}, defaultTheme, { base: null }));
		});
		dist_default("pressed save, all custom values should be saved", async function() {
			const customizations = downcast({});
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.addCustomization("modal_bg", "#fedcba");
			model.addCustomization("content_fg", "#deffed");
			model.changeBaseTheme("dark");
			model.changeAccentColor("#aaaaaa");
			await model.save();
			dist_default(entityClient$1.update.callCount).equals(1);
			dist_default(JSON.parse(entityClient$1.update.args[0].jsonTheme)).deepEquals(Object.assign({}, defaultCustomizations, {
				modal_bg: "#fedcba",
				content_fg: "#deffed",
				base: "dark",
				list_accent_fg: "#aaaaaa",
				content_accent: "#aaaaaa",
				content_button_selected: "#aaaaaa",
				navigation_button_selected: "#aaaaaa",
				header_button_selected: "#aaaaaa",
				themeId: "test.domain.com"
			}));
		});
		dist_default("pressed save when on whitelabelDomain, should not revert back to initial theme", async function() {
			const customizations = downcast({});
			isWhitelabelEnabled = true;
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			await model.save();
			dist_default(themeController.applyCustomizations.callCount).equals(1);
		});
	});
	dist_default.spec("changeAccentColor", function() {
		dist_default("changing accent changed preview", async function() {
			const customizations = downcast({});
			const expectedCustomizations = {
				list_accent_fg: "#ff00f2",
				content_accent: "#ff00f2",
				content_button_selected: "#ff00f2",
				navigation_button_selected: "#ff00f2",
				header_button_selected: "#ff00f2",
				themeId: "test.domain.com"
			};
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.changeAccentColor("#ff00f2");
			dist_default(themeController.applyCustomizations.callCount).equals(1);
			await model.save();
			dist_default(entityClient$1.update.callCount).equals(1);
			dist_default(JSON.parse(entityClient$1.update.args[0].jsonTheme)).deepEquals(Object.assign({}, expectedCustomizations, { base: "light" }));
			dist_default(themeController.applyCustomizations.callCount).equals(2);
		});
	});
	dist_default.spec("changeBaseTheme", function() {
		dist_default("does not overwrite custom colors and changes preview", async function() {
			const customizations = downcast({});
			const expectedCustomizations = {
				themeId: "test.domain.com",
				base: "dark"
			};
			model = new CustomColorsEditorViewModel(defaultTheme, customizations, whitelabelConfig, whitelabelDomainInfo, themeController, entityClient$1, loginController);
			model.changeBaseTheme("dark");
			await model.save();
			dist_default(entityClient$1.update.callCount).equals(1);
			dist_default(JSON.parse(entityClient$1.update.args[0].jsonTheme)).deepEquals(Object.assign({}, defaultCustomizations, expectedCustomizations));
		});
	});
});

//#endregion
//#region tests/login/LoginViewModelTest.ts
var import_testdouble$22 = __toESM(require_testdouble(), 1);
const { anything: anything$3 } = import_testdouble$22.matchers;
/**
* A mocked implementation of an ICredentialsProvider
* It's easiest to have the mock still maintain an internal state
* because there is expected to be some consistency between it's methods
* and it's a pain to mock this correctly for any given test
*
* This isn't ideal because rehearsals and verifications might have an effect on the state, so it's not ideal when verifying calls to `store` (for example)
* This means you should be careful when verifying it, but in general it works for most use cases
*/
function getCredentialsProviderStub() {
	const provider = (0, import_testdouble$22.object)();
	let credentials = new Map();
	(0, import_testdouble$22.when)(provider.getCredentialsInfoByUserId(anything$3())).thenDo(async (userId$1) => {
		const persistentCredentials = credentials.get(userId$1);
		return persistentCredentials?.credentialInfo ?? null;
	});
	(0, import_testdouble$22.when)(provider.getDecryptedCredentialsByUserId(anything$3())).thenDo(async (userId$1) => {
		const storedCredentials = credentials.get(userId$1);
		if (!storedCredentials) return null;
		return {
			credentialInfo: {
				userId: storedCredentials.credentialInfo.userId,
				login: storedCredentials.credentialInfo.login,
				type: storedCredentials.credentialInfo.type
			},
			accessToken: utf8Uint8ArrayToString(storedCredentials.accessToken),
			encryptedPassword: storedCredentials.encryptedPassword,
			encryptedPassphraseKey: storedCredentials.encryptedPassphraseKey,
			databaseKey: storedCredentials.databaseKey
		};
	});
	(0, import_testdouble$22.when)(provider.store(anything$3())).thenDo(async (credential) => {
		credentials.set(credential.credentialInfo.userId, {
			credentialInfo: {
				userId: credential.credentialInfo.userId,
				login: credential.credentialInfo.login,
				type: credential.credentialInfo.type
			},
			accessToken: stringToUtf8Uint8Array(credential.accessToken),
			encryptedPassword: credential.encryptedPassword,
			encryptedPassphraseKey: credential.encryptedPassphraseKey,
			databaseKey: credential.databaseKey
		});
	});
	(0, import_testdouble$22.when)(provider.deleteByUserId(anything$3())).thenDo(async (userId$1) => {
		credentials.delete(userId$1);
	});
	(0, import_testdouble$22.when)(provider.getInternalCredentialsInfos()).thenDo(async () => {
		return Array.from(credentials.values()).map((persistentCredentials) => persistentCredentials.credentialInfo);
	});
	(0, import_testdouble$22.when)(provider.getSupportedEncryptionModes()).thenResolve([]);
	(0, import_testdouble$22.when)(provider.clearCredentials(anything$3())).thenDo(() => {
		credentials = new Map();
	});
	return provider;
}
dist_default.spec("LoginViewModelTest", () => {
	const encryptedTestCredentials = Object.freeze({
		credentialInfo: {
			userId: "user-id-1",
			login: "test@example.com",
			type: CredentialType.Internal
		},
		encryptedPassword: "encryptedPassword",
		encryptedPassphraseKey: null,
		accessToken: stringToUtf8Uint8Array("accessToken"),
		databaseKey: null
	});
	const testCredentials = Object.freeze({
		userId: "user-id-1",
		login: "test@example.com",
		encryptedPassword: "encryptedPassword",
		encryptedPassphraseKey: null,
		accessToken: "accessToken",
		type: CredentialType.Internal
	});
	let loginControllerMock;
	let credentialsProviderMock;
	let secondFactorHandlerMock;
	let deviceConfigMock;
	let credentialRemovalHandler;
	let pushServiceApp;
	let appLock;
	dist_default.beforeEach(async () => {
		loginControllerMock = (0, import_testdouble$22.object)();
		const userControllerMock = (0, import_testdouble$22.object)();
		(0, import_testdouble$22.replace)(userControllerMock, "user", createTestEntity(UserTypeRef));
		(0, import_testdouble$22.replace)(userControllerMock, "userGroupInfo", createTestEntity(GroupInfoTypeRef, { mailAddress: "test@example.com" }));
		(0, import_testdouble$22.when)(loginControllerMock.getUserController()).thenReturn(userControllerMock);
		credentialsProviderMock = getCredentialsProviderStub();
		secondFactorHandlerMock = (0, import_testdouble$22.instance)(SecondFactorHandler);
		deviceConfigMock = (0, import_testdouble$22.instance)(DeviceConfig);
		credentialRemovalHandler = (0, import_testdouble$22.object)();
		pushServiceApp = (0, import_testdouble$22.object)();
		appLock = (0, import_testdouble$22.object)();
	});
	/**
	* viewModel.init() relies on some state of the credentials provider, which maight need to be mocked differently
	* on a per test basis, so instead of having a global viewModel to test we just have a factory function to get one in each test
	*/
	async function getViewModel() {
		const viewModel = new LoginViewModel(loginControllerMock, credentialsProviderMock, secondFactorHandlerMock, deviceConfigMock, domainConfigStub, credentialRemovalHandler, pushServiceApp, appLock);
		await viewModel.init();
		return viewModel;
	}
	dist_default.spec("Display mode transitions", function() {
		dist_default("Should switch to form mode if no stored credentials can be found", async function() {
			const viewModel = await getViewModel();
			await viewModel.useUserId(testCredentials.userId);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
		});
		dist_default("Should switch to credentials mode if stored credentials can be found", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			const viewModel = await getViewModel();
			await viewModel.useUserId(testCredentials.userId);
			dist_default(viewModel.displayMode).equals(DisplayMode.Credentials);
		});
		dist_default("Should switch to form mode if stored credentials cannot be found", async function() {
			const viewModel = await getViewModel();
			await viewModel.useUserId(testCredentials.userId);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
		});
		dist_default("Should switch to credentials mode if credentials are set", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			dist_default(viewModel.displayMode).equals(DisplayMode.Credentials);
		});
		dist_default("Should switch to credentials mode", async function() {
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.DeleteCredentials;
			viewModel.switchDeleteState();
			dist_default(viewModel.displayMode).equals(DisplayMode.Credentials);
		});
		dist_default("Should switch to delete credentials mode", async function() {
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.Credentials;
			viewModel.switchDeleteState();
			dist_default(viewModel.displayMode).equals(DisplayMode.DeleteCredentials);
		});
		dist_default("Should throw if in invalid state", async function() {
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.Form;
			await assertThrows(Error, async () => {
				await viewModel.switchDeleteState();
			});
		});
	});
	dist_default.spec("deleteCredentials", function() {
		dist_default("Should switch to form mode if last stored credential is deleted", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.Credentials;
			await viewModel.deleteCredentials(encryptedTestCredentials.credentialInfo);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
		});
		dist_default("Should handle CredentialAuthenticationError", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(credentialsProviderMock.getDecryptedCredentialsByUserId(testCredentials.userId)).thenReject(new CredentialAuthenticationError("test"));
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.DeleteCredentials;
			await viewModel.deleteCredentials(encryptedTestCredentials.credentialInfo);
			dist_default(viewModel.state).equals(LoginState.NotAuthenticated);
			dist_default(viewModel.displayMode).equals(DisplayMode.DeleteCredentials);
			dist_default(viewModel.getSavedCredentials()).deepEquals([encryptedTestCredentials.credentialInfo]);
			(0, import_testdouble$22.verify)(credentialsProviderMock.clearCredentials(anything$3()), { times: 0 });
		});
		dist_default("Should handle KeyPermanentlyInvalidatedError", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(credentialsProviderMock.getDecryptedCredentialsByUserId(testCredentials.userId)).thenReject(new KeyPermanentlyInvalidatedError("test"));
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.DeleteCredentials;
			await viewModel.deleteCredentials(encryptedTestCredentials.credentialInfo);
			dist_default(viewModel.state).equals(LoginState.NotAuthenticated);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
			dist_default(viewModel.getSavedCredentials()).deepEquals([]);
			(0, import_testdouble$22.verify)(credentialsProviderMock.clearCredentials(anything$3()), { times: 1 });
		});
		dist_default("deletes push identifier", async function() {
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.DeleteCredentials;
			const pushIdentifier = "iAmPushIdentifier";
			const credentialsAndKey = credentialsToUnencrypted(testCredentials, null);
			await credentialsProviderMock.store(credentialsAndKey);
			(0, import_testdouble$22.when)(pushServiceApp.loadPushIdentifierFromNative()).thenResolve(pushIdentifier);
			await viewModel.deleteCredentials(encryptedTestCredentials.credentialInfo);
			(0, import_testdouble$22.verify)(credentialRemovalHandler.onCredentialsRemoved(credentialsAndKey.credentialInfo));
			(0, import_testdouble$22.verify)(loginControllerMock.deleteOldSession(credentialsToUnencrypted(testCredentials, null), pushIdentifier));
		});
		dist_default("deletes push identifier when offline and return warning", async function() {
			const viewModel = await getViewModel();
			viewModel.displayMode = DisplayMode.DeleteCredentials;
			const credentialsAndKey = credentialsToUnencrypted(testCredentials, null);
			await credentialsProviderMock.store(credentialsAndKey);
			(0, import_testdouble$22.when)(loginControllerMock.deleteOldSession(credentialsAndKey, null)).thenReject(new ConnectionError("testmessage"));
			const result = await viewModel.deleteCredentials(encryptedTestCredentials.credentialInfo);
			(0, import_testdouble$22.verify)(credentialRemovalHandler.onCredentialsRemoved(credentialsAndKey.credentialInfo));
			dist_default(result).equals("networkError");
		});
	});
	dist_default.spec("Login with stored credentials", function() {
		const offlineTimeRangeDays = 42;
		dist_default.beforeEach(() => {
			(0, import_testdouble$22.when)(deviceConfigMock.getOfflineTimeRangeDays(testCredentials.userId)).thenReturn(offlineTimeRangeDays);
		});
		dist_default("login should succeed with valid stored credentials", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(loginControllerMock.resumeSession(credentialsToUnencrypted(testCredentials, null), null, offlineTimeRangeDays)).thenResolve({ type: "success" });
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
			(0, import_testdouble$22.verify)(appLock.enforce());
		});
		dist_default("login should succeed with valid stored credentials in DeleteCredentials display mode", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(loginControllerMock.resumeSession(credentialsToUnencrypted(testCredentials, null), null, offlineTimeRangeDays)).thenResolve({ type: "success" });
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			viewModel.switchDeleteState();
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
		});
		dist_default("login should fail with invalid stored credentials", async function() {
			const credentialsAndKey = credentialsToUnencrypted(testCredentials, null);
			await credentialsProviderMock.store(credentialsAndKey);
			(0, import_testdouble$22.when)(loginControllerMock.resumeSession(anything$3(), null, offlineTimeRangeDays)).thenReject(new NotAuthenticatedError("test"));
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.InvalidCredentials);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
			(0, import_testdouble$22.verify)(credentialsProviderMock.deleteByUserId(testCredentials.userId));
			(0, import_testdouble$22.verify)(credentialRemovalHandler.onCredentialsRemoved(credentialsAndKey.credentialInfo));
			dist_default(viewModel.getSavedCredentials()).deepEquals([]);
			dist_default(viewModel.autoLoginCredentials).equals(null);
		});
		dist_default("login should fail for expired stored credentials", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(loginControllerMock.resumeSession(anything$3(), null, offlineTimeRangeDays)).thenReject(new AccessExpiredError("test"));
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.AccessExpired);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
		});
		dist_default("should handle KeyPermanentlyInvalidatedError and clear credentials", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(credentialsProviderMock.getDecryptedCredentialsByUserId(testCredentials.userId)).thenReject(new KeyPermanentlyInvalidatedError("oh no"));
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.NotAuthenticated);
			dist_default(viewModel.displayMode).equals(DisplayMode.Form);
			dist_default(viewModel.getSavedCredentials()).deepEquals([]);
			(0, import_testdouble$22.verify)(credentialsProviderMock.clearCredentials(anything$3()), { times: 1 });
		});
		dist_default("should handle error result", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(loginControllerMock.resumeSession(credentialsToUnencrypted(testCredentials, null), null, offlineTimeRangeDays)).thenResolve({
				type: "error",
				reason: ResumeSessionErrorReason.OfflineNotAvailableForFree
			});
			const viewModel = await getViewModel();
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.NotAuthenticated);
		});
		dist_default("handles CredentialAuthenticationError", async () => {
			const unencryptedCredentials = credentialsToUnencrypted(testCredentials, null);
			await credentialsProviderMock.store(unencryptedCredentials);
			(0, import_testdouble$22.when)(credentialsProviderMock.getDecryptedCredentialsByUserId(testCredentials.userId)).thenReject(new KeyPermanentlyInvalidatedError("oh no"));
			const viewModel = await getViewModel();
			(0, import_testdouble$22.when)(appLock.enforce()).thenReject(new CredentialAuthenticationError("test"));
			await viewModel.useCredentials(encryptedTestCredentials.credentialInfo);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.UnknownError);
			dist_default(viewModel.displayMode).equals(DisplayMode.Credentials);
			dist_default(viewModel.getSavedCredentials()).deepEquals([unencryptedCredentials.credentialInfo]);
			dist_default(lang.getTranslationText(viewModel.helpText)).satisfies(textIncludes("test"));
		});
	});
	dist_default.spec("Login with email and password", function() {
		const credentialsWithoutPassword = {
			login: testCredentials.login,
			encryptedPassword: null,
			encryptedPassphraseKey: null,
			accessToken: testCredentials.accessToken,
			userId: testCredentials.userId,
			type: CredentialType.Internal
		};
		const password = "password";
		dist_default("should login and not store password", async function() {
			const viewModel = await getViewModel();
			(0, import_testdouble$22.when)(loginControllerMock.createSession(testCredentials.login, password, SessionType.Login)).thenResolve({ credentials: credentialsWithoutPassword });
			viewModel.showLoginForm();
			viewModel.mailAddress(credentialsWithoutPassword.login);
			viewModel.password(password);
			viewModel.savePassword(false);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
			(0, import_testdouble$22.verify)(credentialsProviderMock.store(import_testdouble$22.matchers.anything()), { times: 0 });
		});
		dist_default("should login and store password", async function() {
			(0, import_testdouble$22.when)(loginControllerMock.createSession(testCredentials.login, password, SessionType.Persistent)).thenResolve({ credentials: testCredentials });
			const viewModel = await getViewModel();
			viewModel.showLoginForm();
			viewModel.mailAddress(testCredentials.login);
			viewModel.password(password);
			viewModel.savePassword(true);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
			(0, import_testdouble$22.verify)(credentialsProviderMock.store(import_testdouble$22.matchers.argThat((unencrypted) => unencrypted.credentialInfo.login === testCredentials.login)), { times: 1 });
			(0, import_testdouble$22.verify)(appLock.enforce());
		});
		dist_default("should login and overwrite existing stored credentials", async function() {
			const oldCredentials = {
				credentialInfo: {
					userId: testCredentials.userId,
					login: testCredentials.login,
					type: CredentialType.Internal
				},
				encryptedPassword: "encPw",
				accessToken: "oldAccessToken",
				encryptedPassphraseKey: null,
				databaseKey: null
			};
			await credentialsProviderMock.store(oldCredentials);
			(0, import_testdouble$22.when)(loginControllerMock.createSession(testCredentials.login, password, SessionType.Persistent)).thenResolve({
				credentials: testCredentials,
				databaseKey: null
			});
			const viewModel = await getViewModel();
			viewModel.showLoginForm();
			viewModel.mailAddress(testCredentials.login);
			viewModel.password(password);
			viewModel.savePassword(true);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
			(0, import_testdouble$22.verify)(credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null)));
			(0, import_testdouble$22.verify)(loginControllerMock.deleteOldSession(oldCredentials), { times: 1 });
		});
		dist_default.spec("Should clear old credentials on login", function() {
			const oldCredentials = Object.assign({}, credentialsWithoutPassword, {
				accessToken: "oldAccessToken",
				encryptedPassword: "encPw"
			});
			dist_default("same address & same user id", async function() {
				await doTest(oldCredentials);
			});
			dist_default("same address & different user id", async function() {
				await doTest(Object.assign({}, oldCredentials, { userId: "differentId" }));
			});
			dist_default("different address & same user id", async function() {
				await doTest(Object.assign({}, oldCredentials, { login: "another@login.de" }));
			});
			async function doTest(oldCredentials$1) {
				(0, import_testdouble$22.when)(loginControllerMock.createSession(credentialsWithoutPassword.login, password, SessionType.Login)).thenResolve({ credentials: credentialsWithoutPassword });
				const unencryptedCredentials = credentialsToUnencrypted(oldCredentials$1, null);
				await credentialsProviderMock.store(unencryptedCredentials);
				const viewModel = await getViewModel();
				viewModel.showLoginForm();
				viewModel.mailAddress(credentialsWithoutPassword.login);
				viewModel.password(password);
				viewModel.savePassword(false);
				await viewModel.login();
				dist_default(viewModel.state).equals(LoginState.LoggedIn);
				(0, import_testdouble$22.verify)(credentialsProviderMock.deleteByUserId(oldCredentials$1.userId, { deleteOfflineDb: false }));
				(0, import_testdouble$22.verify)(loginControllerMock.deleteOldSession(unencryptedCredentials));
			}
		});
		dist_default("Should throw if login controller throws", async function() {
			(0, import_testdouble$22.when)(loginControllerMock.createSession(anything$3(), anything$3(), anything$3())).thenReject(new Error("oops"));
			const viewModel = await getViewModel();
			viewModel.mailAddress(credentialsWithoutPassword.login);
			viewModel.password(password);
			await assertThrows(Error, async () => {
				await viewModel.login();
			});
			dist_default(viewModel.state).equals(LoginState.UnknownError);
		});
		dist_default("should handle KeyPermanentlyInvalidatedError and clear credentials", async function() {
			await credentialsProviderMock.store(credentialsToUnencrypted(testCredentials, null));
			(0, import_testdouble$22.when)(credentialsProviderMock.store(import_testdouble$22.matchers.anything())).thenReject(new KeyPermanentlyInvalidatedError("oops"));
			(0, import_testdouble$22.when)(loginControllerMock.createSession(anything$3(), anything$3(), anything$3())).thenResolve({ credentials: testCredentials });
			const viewModel = await getViewModel();
			viewModel.showLoginForm();
			viewModel.mailAddress(testCredentials.login);
			viewModel.password(password);
			viewModel.savePassword(true);
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.LoggedIn);
			dist_default(viewModel.getSavedCredentials()).deepEquals([]);
			(0, import_testdouble$22.verify)(credentialsProviderMock.clearCredentials(anything$3()), { times: 1 });
		});
		dist_default("should be in error state if email address is empty", async function() {
			const viewModel = await getViewModel();
			viewModel.showLoginForm();
			viewModel.mailAddress("");
			viewModel.password("123");
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.InvalidCredentials);
			dist_default(viewModel.helpText).equals("loginFailed_msg");
			(0, import_testdouble$22.verify)(loginControllerMock.createSession(anything$3(), anything$3(), anything$3()), { times: 0 });
		});
		dist_default("should be in error state if password is empty", async function() {
			const viewModel = await getViewModel();
			viewModel.showLoginForm();
			viewModel.mailAddress("test@example.com");
			viewModel.password("");
			await viewModel.login();
			dist_default(viewModel.state).equals(LoginState.InvalidCredentials);
			dist_default(viewModel.helpText).equals("loginFailed_msg");
			(0, import_testdouble$22.verify)(loginControllerMock.createSession(anything$3(), anything$3(), anything$3()), { times: 0 });
		});
	});
});

//#endregion
//#region tests/misc/credentials/CredentialsProviderTest.ts
var import_testdouble$21 = __toESM(require_testdouble(), 1);
dist_default.spec("CredentialsProvider", function() {
	let credentialsProvider;
	let internalCredentials;
	let internalCredentials2;
	let internalCredentialsBob;
	let internalCredentialsAlice;
	let externalCredentials;
	let encryptedInternalCredentials;
	let encryptedInternalCredentialsBob;
	let encryptedInternalCredentialsAlice;
	let encryptedExternalCredentials;
	let encryptedInternalCredentialsWithoutDatabaseKey;
	let sqlCipherFacadeMock;
	let interWindowEventSenderMock;
	let nativeCredentialFacadeMock;
	dist_default.beforeEach(function() {
		internalCredentials = {
			credentialInfo: {
				login: "test@example.com",
				userId: "789",
				type: CredentialType.Internal
			},
			encryptedPassword: "123",
			encryptedPassphraseKey: null,
			accessToken: "456",
			databaseKey: null
		};
		internalCredentials2 = {
			credentialInfo: {
				login: "test@example.com",
				userId: "789012",
				type: CredentialType.Internal
			},
			encryptedPassword: "123456",
			encryptedPassphraseKey: null,
			accessToken: "456789",
			databaseKey: null
		};
		internalCredentialsAlice = {
			credentialInfo: {
				login: "alice@example.com",
				userId: "789012",
				type: CredentialType.Internal
			},
			encryptedPassword: "123456",
			encryptedPassphraseKey: null,
			accessToken: "456789",
			databaseKey: null
		};
		internalCredentialsBob = {
			credentialInfo: {
				login: "bob@example.com",
				userId: "789012",
				type: CredentialType.Internal
			},
			encryptedPassword: "123456",
			encryptedPassphraseKey: null,
			accessToken: "456789",
			databaseKey: null
		};
		externalCredentials = {
			credentialInfo: {
				login: "test2@example.com",
				userId: "7892",
				type: CredentialType.External
			},
			encryptedPassword: "1232",
			encryptedPassphraseKey: null,
			accessToken: "4562",
			databaseKey: null
		};
		encryptedInternalCredentials = {
			credentialInfo: {
				login: internalCredentials.credentialInfo.login,
				userId: internalCredentials.credentialInfo.userId,
				type: internalCredentials.credentialInfo.type
			},
			encryptedPassword: assertNotNull(internalCredentials.encryptedPassword),
			encryptedPassphraseKey: null,
			accessToken: stringToUtf8Uint8Array(internalCredentials.accessToken),
			databaseKey: new Uint8Array([
				1,
				2,
				3
			])
		};
		encryptedInternalCredentialsAlice = {
			credentialInfo: {
				login: internalCredentialsAlice.credentialInfo.login,
				userId: internalCredentialsAlice.credentialInfo.userId,
				type: internalCredentialsAlice.credentialInfo.type
			},
			encryptedPassword: assertNotNull(internalCredentialsAlice.encryptedPassword),
			encryptedPassphraseKey: null,
			accessToken: stringToUtf8Uint8Array(internalCredentialsAlice.accessToken),
			databaseKey: new Uint8Array([
				1,
				2,
				3
			])
		};
		encryptedInternalCredentialsBob = {
			credentialInfo: {
				login: internalCredentialsBob.credentialInfo.login,
				userId: internalCredentialsBob.credentialInfo.userId,
				type: internalCredentialsBob.credentialInfo.type
			},
			encryptedPassword: assertNotNull(internalCredentialsBob.encryptedPassword),
			encryptedPassphraseKey: null,
			accessToken: stringToUtf8Uint8Array(internalCredentialsBob.accessToken),
			databaseKey: new Uint8Array([
				1,
				2,
				3
			])
		};
		encryptedExternalCredentials = {
			credentialInfo: {
				login: externalCredentials.credentialInfo.login,
				userId: externalCredentials.credentialInfo.userId,
				type: externalCredentials.credentialInfo.type
			},
			encryptedPassword: assertNotNull(externalCredentials.encryptedPassword),
			encryptedPassphraseKey: null,
			accessToken: stringToUtf8Uint8Array(externalCredentials.accessToken),
			databaseKey: new Uint8Array([
				1,
				2,
				3
			])
		};
		encryptedInternalCredentialsWithoutDatabaseKey = {
			credentialInfo: {
				login: internalCredentials.credentialInfo.login,
				userId: internalCredentials.credentialInfo.userId,
				type: internalCredentials.credentialInfo.type
			},
			encryptedPassword: assertNotNull(internalCredentials2.encryptedPassword),
			encryptedPassphraseKey: null,
			accessToken: stringToUtf8Uint8Array(internalCredentials2.accessToken)
		};
		sqlCipherFacadeMock = (0, import_testdouble$21.object)();
		interWindowEventSenderMock = (0, import_testdouble$21.object)();
		nativeCredentialFacadeMock = (0, import_testdouble$21.object)();
		credentialsProvider = new CredentialsProvider(nativeCredentialFacadeMock, sqlCipherFacadeMock, interWindowEventSenderMock);
	});
	dist_default.spec("Storing credentials", function() {
		dist_default("Should store credentials", async function() {
			await credentialsProvider.store(internalCredentials);
			verify(nativeCredentialFacadeMock.store(internalCredentials));
		});
	});
	dist_default.spec("Reading Credentials", function() {
		dist_default.beforeEach(async function() {
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadByUserId(internalCredentials.credentialInfo.userId)).thenResolve(internalCredentials);
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadByUserId(externalCredentials.credentialInfo.userId)).thenResolve(externalCredentials);
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadAll()).thenResolve([encryptedInternalCredentials, encryptedExternalCredentials]);
		});
		dist_default("Should return internal Credentials", async function() {
			const retrievedCredentials = await credentialsProvider.getDecryptedCredentialsByUserId(internalCredentials.credentialInfo.userId);
			dist_default(retrievedCredentials).deepEquals(internalCredentials);
		});
		dist_default("Should return credential infos for internal users", async function() {
			const retrievedCredentials = await credentialsProvider.getInternalCredentialsInfos();
			dist_default(retrievedCredentials).deepEquals([encryptedInternalCredentials.credentialInfo]);
		});
		dist_default("Should return sorted internal credentials regardless of internal ordering", async function() {
			const alice = encryptedInternalCredentialsAlice;
			const bob = encryptedInternalCredentialsBob;
			const test = encryptedInternalCredentials;
			const sorted = [
				alice.credentialInfo,
				bob.credentialInfo,
				test.credentialInfo
			];
			async function testSorted(list) {
				(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadAll()).thenResolve(list);
				const retrieved = await credentialsProvider.getInternalCredentialsInfos();
				dist_default(retrieved).deepEquals(sorted);
			}
			await testSorted([
				alice,
				bob,
				test
			]);
			await testSorted([
				alice,
				test,
				bob
			]);
			await testSorted([
				bob,
				alice,
				test
			]);
			await testSorted([
				bob,
				test,
				alice
			]);
			await testSorted([
				test,
				alice,
				bob
			]);
			await testSorted([
				test,
				bob,
				alice
			]);
		});
	});
	dist_default.spec("Deleting credentials", function() {
		dist_default("Should delete credentials from storage", async function() {
			await credentialsProvider.deleteByUserId(internalCredentials.credentialInfo.userId);
			verify(nativeCredentialFacadeMock.deleteByUserId(internalCredentials.credentialInfo.userId), { times: 1 });
		});
		dist_default("Deletes offline database", async function() {
			await credentialsProvider.deleteByUserId(internalCredentials.credentialInfo.userId);
			verify(sqlCipherFacadeMock.deleteDb(internalCredentials.credentialInfo.userId));
		});
		dist_default("Sends event over EventBus", async function() {
			await credentialsProvider.deleteByUserId(internalCredentials.credentialInfo.userId);
			verify(interWindowEventSenderMock.localUserDataInvalidated(internalCredentials.credentialInfo.userId));
		});
	});
	dist_default.spec("Setting credentials encryption mode", function() {
		dist_default("Enrolling", async function() {
			const newEncryptionMode = CredentialEncryptionMode.DEVICE_LOCK;
			await credentialsProvider.setCredentialEncryptionMode(newEncryptionMode);
			verify(nativeCredentialFacadeMock.setCredentialEncryptionMode(newEncryptionMode), { times: 1 });
		});
	});
	dist_default.spec("Changing credentials encryption mode", function() {
		dist_default("Changing encryption mode", async function() {
			const oldEncryptionMode = CredentialEncryptionMode.SYSTEM_PASSWORD;
			const newEncryptionMode = CredentialEncryptionMode.DEVICE_LOCK;
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.getCredentialEncryptionMode()).thenResolve(oldEncryptionMode);
			await credentialsProvider.setCredentialEncryptionMode(newEncryptionMode);
			verify(nativeCredentialFacadeMock.setCredentialEncryptionMode(newEncryptionMode));
		});
	});
	dist_default.spec("clearCredentials", function() {
		dist_default.beforeEach(function() {
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadAll()).thenResolve([encryptedInternalCredentials, encryptedExternalCredentials]);
		});
		dist_default("deleted credentials, key and mode", async function() {
			await credentialsProvider.clearCredentials("testing");
			verify(nativeCredentialFacadeMock.clear());
		});
	});
	dist_default.spec("replace the stored password", function() {
		const userId$1 = "userId";
		const credentials = {
			login: "login",
			userId: userId$1,
			type: CredentialType.Internal
		};
		const persistentCredentials = {
			credentialInfo: credentials,
			accessToken: stringToUtf8Uint8Array("accessToken"),
			databaseKey: new Uint8Array([
				1,
				2,
				3
			]),
			encryptedPassword: "old encrypted password",
			encryptedPassphraseKey: null
		};
		const newEncryptedPassword = "uhagre2";
		const newEncryptedPassphraseKey = new Uint8Array([
			0,
			14,
			9
		]);
		dist_default.beforeEach(function() {
			(0, import_testdouble$21.when)(nativeCredentialFacadeMock.loadAll()).thenResolve([persistentCredentials]);
		});
		dist_default("replace only", async function() {
			await credentialsProvider.replacePassword(credentials, newEncryptedPassword, newEncryptedPassphraseKey);
			verify(nativeCredentialFacadeMock.storeEncrypted({
				credentialInfo: credentials,
				accessToken: stringToUtf8Uint8Array("accessToken"),
				databaseKey: new Uint8Array([
					1,
					2,
					3
				]),
				encryptedPassword: newEncryptedPassword,
				encryptedPassphraseKey: newEncryptedPassphraseKey
			}));
		});
	});
});

//#endregion
//#region tests/misc/DeviceConfigTest.ts
var import_testdouble$20 = __toESM(require_testdouble(), 1);
dist_default.spec("DeviceConfig", function() {
	dist_default.spec("migrateConfig", function() {
		dist_default("migrating from v2 to v3 preserves internal logins", function() {
			const oldConfig = {
				_version: 2,
				_credentials: [{
					mailAddress: "internal@example.com",
					userId: "internalUserId",
					accessToken: "internalAccessToken",
					encryptedPassword: "internalEncPassword"
				}, {
					mailAddress: "externalUserId",
					userId: "externalUserId",
					accessToken: "externalAccessToken",
					encryptedPassword: "externalEncPassword"
				}]
			};
			migrateConfigV2to3(oldConfig);
			const expectedCredentialsAfterMigration = {
				internalUserId: {
					credentialInfo: {
						login: "internal@example.com",
						userId: "internalUserId",
						type: CredentialType.Internal
					},
					accessToken: "internalAccessToken",
					encryptedPassword: "internalEncPassword",
					encryptedPassphraseKey: null
				},
				externalUserId: {
					credentialInfo: {
						login: "externalUserId",
						userId: "externalUserId",
						type: CredentialType.External
					},
					accessToken: "externalAccessToken",
					encryptedPassword: "externalEncPassword",
					encryptedPassphraseKey: null
				}
			};
			dist_default(oldConfig._credentials).deepEquals(expectedCredentialsAfterMigration);
		});
	});
	dist_default.spec("loading config", function() {
		let localStorageMock;
		dist_default.beforeEach(function() {
			localStorageMock = (0, import_testdouble$20.object)();
		});
		dist_default("Won't write anything to localStorage when signupToken exists and the config version is the same", function() {
			(0, import_testdouble$20.when)(localStorageMock.getItem(DeviceConfig.LocalStorageKey)).thenReturn(JSON.stringify({
				_version: DeviceConfig.Version,
				_signupToken: "somebase64value"
			}));
			new DeviceConfig(DeviceConfig.Version, localStorageMock);
			verify(localStorageMock.setItem(DeviceConfig.LocalStorageKey, import_testdouble$20.matchers.anything()), { times: 0 });
		});
		dist_default("When loading, migrations will not lose any config fields", function() {
			const storedInLocalStorage = {
				_version: 2,
				_credentials: [{
					mailAddress: "internal@example.com",
					userId: "internalUserId",
					accessToken: "internalAccessToken",
					encryptedPassword: "internalEncPassword"
				}],
				_credentialEncryptionMode: CredentialEncryptionMode.DEVICE_LOCK,
				_encryptedCredentialsKey: "somekey",
				acknowledgedNewsItems: [],
				_themeId: "mytheme",
				scheduledAlarmModelVersionPerUser: {},
				_language: "en",
				_defaultCalendarView: {},
				_hiddenCalendars: {},
				expandedMailFolders: {},
				_testDeviceId: "testId",
				_testAssignments: null,
				_signupToken: "signupToken",
				offlineTimeRangeDaysByUser: { userId1: 42 },
				conversationViewShowOnlySelectedMail: false,
				syncContactsWithPhonePreference: {},
				isCalendarDaySelectorExpanded: false,
				mailAutoSelectBehavior: ListAutoSelectBehavior.OLDER,
				isSetupComplete: true,
				lastExternalCalendarSync: {},
				clientOnlyCalendars: new Map(),
				events: [],
				lastRatingPromptedDate: null,
				retryRatingPromptAfter: null
			};
			(0, import_testdouble$20.when)(localStorageMock.getItem(DeviceConfig.LocalStorageKey)).thenReturn(JSON.stringify(storedInLocalStorage));
			let storedJson;
			(0, import_testdouble$20.when)(localStorageMock.setItem(DeviceConfig.LocalStorageKey, import_testdouble$20.matchers.anything())).thenDo((_, json) => {
				storedJson = json;
			});
			new DeviceConfig(DeviceConfig.Version, localStorageMock);
			const migratedConfig = Object.assign({}, storedInLocalStorage, {
				_version: DeviceConfig.Version,
				_credentials: { internalUserId: {
					credentialInfo: {
						login: "internal@example.com",
						userId: "internalUserId",
						type: "internal"
					},
					accessToken: "internalAccessToken",
					encryptedPassword: "internalEncPassword",
					encryptedPassphraseKey: null
				} },
				isSetupComplete: true,
				isCredentialsMigratedToNative: false
			});
			dist_default(JSON.parse(storedJson)).deepEquals(migratedConfig);
		});
	});
});

//#endregion
//#region ../src/calendar-app/calendar/view/EventDragHandler.ts
const DRAG_THRESHOLD = 10;
var EventDragHandler = class {
	data = null;
	dragging = false;
	lastDiffBetweenDates = null;
	hasChanged = false;
	constructor(draggingArea, eventDragCallbacks) {
		this.draggingArea = draggingArea;
		this.eventDragCallbacks = eventDragCallbacks;
	}
	get isDragging() {
		return this.dragging;
	}
	get originalEvent() {
		return this.data?.originalEvent ?? null;
	}
	/**
	* Check if the handler has changed since the last time you called this function
	*/
	queryHasChanged() {
		const isChanged = this.hasChanged;
		this.hasChanged = false;
		return isChanged;
	}
	/**
	* Call on mouse down, to initialize an upcoming drag event.
	* Doesn't start the drag yet, because we want to wait until the mouse has moved beyond some threshhold
	* @param calendarEvent The calendar event for which a drag operation is prepared.
	* @param dateUnderMouse The original date under mouse when preparing the drag.
	* @param mousePos The current position of the mouse.
	* @param keepTime Indicates whether the time on the original event should be kept or modified. In case this is set to true the drag
	* operation just shifts event start by whole days otherwise the time from dateUnderMouse should be used as new time for the event.
	*/
	prepareDrag(calendarEvent, dateUnderMouse, mousePos, keepTime) {
		this.draggingArea.classList.add("cursor-grabbing");
		this.data = {
			originalEvent: calendarEvent,
			originalDateUnderMouse: this.adjustDateUnderMouse(calendarEvent.startTime, dateUnderMouse, keepTime),
			originalMousePos: mousePos,
			keepTime
		};
		this.hasChanged = false;
		this.dragging = false;
	}
	/**
	* Call on mouse move.
	* Will be a no-op if the prepareDrag hasn't been called or if cancelDrag has been called since the last prepareDrag call
	* The dragging doesn't actually begin until the distance between the mouse and its original location is greater than some threshold
	* @param dateUnderMouse The current date under the mouse courser, may include a time.
	* @param mousePos the position of the mouse when the drag ended.
	*/
	handleDrag(dateUnderMouse, mousePos) {
		if (this.data) {
			const dragData = this.data;
			const adjustedDateUnderMouse = this.adjustDateUnderMouse(dragData.originalEvent.startTime, dateUnderMouse, dragData.keepTime);
			const distanceX = dragData.originalMousePos.x - mousePos.x;
			const distanceY = dragData.originalMousePos.y - mousePos.y;
			const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
			if (this.dragging) {
				const diffBetweenDates = this.getDayUnderMouseDiff(dragData, adjustedDateUnderMouse);
				if (diffBetweenDates !== this.lastDiffBetweenDates) {
					this.lastDiffBetweenDates = diffBetweenDates;
					this.eventDragCallbacks.onDragUpdate(diffBetweenDates);
					this.hasChanged = true;
					mithril_default.redraw();
				}
			} else if (distance > DRAG_THRESHOLD) {
				this.dragging = true;
				this.lastDiffBetweenDates = this.getDayUnderMouseDiff(dragData, adjustedDateUnderMouse);
				this.eventDragCallbacks.onDragStart(dragData.originalEvent, this.lastDiffBetweenDates);
				this.hasChanged = true;
				mithril_default.redraw();
			}
		}
	}
	/**
	* Call on mouseup or mouseleave. Ends a drag event if one has been started, and hasn't been cancelled.
	*
	* This function will only trigger when prepareDrag has been called
	*/
	async endDrag(dateUnderMouse, pos) {
		this.draggingArea.classList.remove("cursor-grabbing");
		if (this.dragging && this.data) {
			const dragData = this.data;
			const adjustedDateUnderMouse = this.adjustDateUnderMouse(dragData.originalEvent.startTime, dateUnderMouse, dragData.keepTime);
			this.dragging = false;
			this.data = null;
			const diffBetweenDates = this.getDayUnderMouseDiff(dragData, adjustedDateUnderMouse);
			const { repeatRule, recurrenceId } = dragData.originalEvent;
			const mode = repeatRule != null ? await showModeSelectionDropdown(pos) : recurrenceId != null ? CalendarOperation.EditThis : CalendarOperation.EditAll;
			try {
				await this.eventDragCallbacks.onDragEnd(diffBetweenDates, mode);
			} finally {
				this.hasChanged = true;
				mithril_default.redraw();
			}
		} else this.cancelDrag();
	}
	adjustDateUnderMouse(eventStart, dateUnderMouse, keepTime) {
		if (keepTime) return Time.fromDate(eventStart).toDate(dateUnderMouse);
else return dateUnderMouse;
	}
	getDayUnderMouseDiff(dragData, adjustedDateUnderMouse) {
		const { originalEvent, originalDateUnderMouse } = dragData;
		return isAllDayEvent(originalEvent) ? getAllDayDateUTC(adjustedDateUnderMouse).getTime() - getAllDayDateUTC(originalDateUnderMouse).getTime() : adjustedDateUnderMouse.getTime() - originalDateUnderMouse.getTime();
	}
	cancelDrag() {
		this.draggingArea.classList.remove("cursor-grabbing");
		this.eventDragCallbacks.onDragCancel();
		this.data = null;
		this.dragging = false;
		this.hasChanged = true;
		this.lastDiffBetweenDates = null;
		mithril_default.redraw();
	}
};
async function showModeSelectionDropdown(pos) {
	return new Promise((resolve) => {
		showDropdownAtPosition([{
			label: "updateOneCalendarEvent_action",
			click: () => resolve(CalendarOperation.EditThis)
		}, {
			label: "updateAllCalendarEvents_action",
			click: () => resolve(CalendarOperation.EditAll)
		}], pos.x, pos.y, () => resolve(null));
	});
}

//#endregion
//#region tests/calendar/EventDragHandlerTest.ts
const INIT_MOUSE_POS = {
	x: 0,
	y: 0
};
const NOT_DRAG_MOUSE_POS = {
	x: 0,
	y: 0
};
const DRAG_MOUSE_POS = {
	x: 100,
	y: 0
};
dist_default.spec("Event Drag Handler", function() {
	const zone$3 = "Europe/Berlin";
	dist_default.spec("Dragging", function() {
		const body = downcast({ classList: {
			add: () => {},
			remove: () => {}
		} });
		let callbackMock;
		let handler;
		dist_default.beforeEach(() => {
			callbackMock = downcast({
				onDragStart: spy((draggedEvent, diff) => {}),
				onDragUpdate: spy((diff) => {}),
				onDragEnd: spy((diff) => Promise.resolve()),
				onDragCancel: spy(() => {})
			});
			handler = new EventDragHandler(body, callbackMock);
		});
		dist_default("Noop move drag", function() {
			handler.handleDrag(new Date(2021, 8, 22), {
				x: 0,
				y: 0
			});
			dist_default(handler.isDragging).equals(false);
			dist_default(callbackMock.onDragStart.callCount).equals(0);
		});
		dist_default("Start then drag then change mind is noop", async function() {
			const event = makeEvent("event", new Date(2021, 8, 22), new Date(2021, 8, 23));
			handler.prepareDrag(event, new Date(2021, 8, 22), INIT_MOUSE_POS, true);
			handler.handleDrag(new Date(2021, 8, 21), DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragStart.callCount).equals(1);
			await handler.endDrag(new Date(2021, 8, 22), DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragEnd.callCount).equals(1);
			dist_default(callbackMock.onDragEnd.args[0]).equals(0);
			dist_default(handler.isDragging).equals(false);
		});
		dist_default("Not moving mouse past 10px threshhold is noop", async function() {
			const event = makeEvent("event", new Date(2021, 8, 22), new Date(2021, 8, 23));
			const callback = spy(() => Promise.resolve(true));
			handler.prepareDrag(event, new Date(2021, 8, 22), INIT_MOUSE_POS, true);
			handler.handleDrag(new Date(2021, 8, 21), NOT_DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragStart.callCount).equals(0);
			dist_default(handler.isDragging).equals(false);
			await handler.endDrag(new Date(2021, 8, 21), DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragEnd.callCount).equals(0);
			dist_default(handler.isDragging).equals(false);
		});
		dist_default("Cancel drag", async function() {
			const event = makeEvent("event", new Date(2021, 8, 22), new Date(2021, 8, 23));
			handler.prepareDrag(event, new Date(2021, 8, 22), INIT_MOUSE_POS, true);
			handler.handleDrag(new Date(2021, 8, 24), DRAG_MOUSE_POS);
			dist_default(handler.isDragging).equals(true);
			handler.cancelDrag();
			dist_default(callbackMock.onDragEnd.callCount).equals(0);
			dist_default(callbackMock.onDragCancel.callCount).equals(1);
			dist_default(handler.isDragging).equals(false);
		});
		dist_default("A good drag and drop run", async function() {
			let originalDate = new Date(2021, 8, 22);
			const event = makeEvent("event", originalDate, new Date(2021, 8, 23));
			handler.prepareDrag(event, new Date(2021, 8, 22), INIT_MOUSE_POS, true);
			handler.handleDrag(new Date(2021, 8, 24), DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragStart.callCount).equals(1);
			dist_default(callbackMock.onDragStart.callCount).equals(1);
			const [calendarEvent, timeToMoveBy] = callbackMock.onDragStart.args;
			dist_default(timeToMoveBy).equals(2 * DAY_IN_MILLIS);
			dist_default(handler.isDragging).equals(true);
			let dragDate = new Date(2021, 8, 25);
			handler.handleDrag(dragDate, DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragUpdate.callCount).equals(1);
			const [updateTimeToMoveBy] = callbackMock.onDragUpdate.args;
			dist_default(updateTimeToMoveBy).equals(3 * DAY_IN_MILLIS);
			const deferredCallbackComplete = defer();
			callbackMock.onDragEnd = spy(() => deferredCallbackComplete.promise);
			const endDragPromise = handler.endDrag(dragDate, DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragEnd.callCount).equals(1);
			const [endTimeToMoveBy] = callbackMock.onDragEnd.args;
			dist_default(endTimeToMoveBy).equals(3 * DAY_IN_MILLIS);
			dist_default(handler.isDragging).equals(false);
			deferredCallbackComplete.resolve(true);
			await endDragPromise;
		});
		dist_default("A good drag and drop run from summer to winter time", async function() {
			let originalStartDate = DateTime.fromObject({
				year: 2021,
				month: 10,
				day: 30,
				hour: 13
			}, { zone: zone$3 }).toJSDate();
			let newStartDate = DateTime.fromObject({
				year: 2021,
				month: 10,
				day: 31,
				hour: 13
			}, { zone: zone$3 }).toJSDate();
			const shortEvent = makeEvent("shortEvent", originalStartDate, new Date(2021, 9, 30, 13));
			handler.prepareDrag(shortEvent, originalStartDate, INIT_MOUSE_POS, false);
			handler.handleDrag(newStartDate, DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragStart.callCount).equals(1);
			await handler.endDrag(newStartDate, DRAG_MOUSE_POS);
			const oneDayPlusOneHour = 9e7;
			dist_default(callbackMock.onDragEnd.callCount).equals(1);
			dist_default(callbackMock.onDragEnd.args[0]).equals(oneDayPlusOneHour);
			dist_default(handler.isDragging).equals(false);
		});
		dist_default("A good drag and drop run from summer to winter time with all day event", async function() {
			let originalStartDate = DateTime.fromObject({
				year: 2021,
				month: 10,
				day: 30,
				hour: 13
			}, { zone: zone$3 }).toJSDate();
			let newStartDate = DateTime.fromObject({
				year: 2021,
				month: 10,
				day: 31,
				hour: 13
			}, { zone: zone$3 }).toJSDate();
			originalStartDate = getStartOfDayWithZone(originalStartDate, zone$3);
			newStartDate = getStartOfDayWithZone(newStartDate, zone$3);
			const alldayEvent = makeEvent("alldayEvent", getAllDayDateUTCFromZone(originalStartDate, zone$3), getAllDayDateUTCFromZone(getStartOfNextDayWithZone(originalStartDate, zone$3), zone$3));
			dist_default(isAllDayEvent(alldayEvent)).equals(true)("is all day event");
			handler.prepareDrag(alldayEvent, originalStartDate, INIT_MOUSE_POS, true);
			handler.handleDrag(newStartDate, DRAG_MOUSE_POS);
			dist_default(callbackMock.onDragStart.callCount).equals(1);
			await handler.endDrag(newStartDate, DRAG_MOUSE_POS);
			const oneDay = 864e5;
			dist_default(callbackMock.onDragEnd.callCount).equals(1);
			dist_default(callbackMock.onDragEnd.args[0]).equals(oneDay);
			dist_default(handler.isDragging).equals(false);
		});
	});
});

//#endregion
//#region tests/calendar/CalendarGuiUtilsTest.ts
dist_default.spec("CalendarGuiUtils", function() {
	dist_default("getDateFromMouseClick", function() {
		function input(x, y, targetWidth, targetHeight) {
			return {
				x,
				y,
				targetWidth,
				targetHeight
			};
		}
		const weeks = [
			[
				new Date(0),
				new Date(1),
				new Date(2),
				new Date(3)
			],
			[
				new Date(4),
				new Date(5),
				new Date(6),
				new Date(7)
			],
			[
				new Date(8),
				new Date(9),
				new Date(10),
				new Date(11)
			]
		];
		dist_default(getDateFromMousePos(input(1, 1, 12, 9), weeks).getTime()).equals(0);
		dist_default(getDateFromMousePos(input(4, 1, 12, 9), weeks).getTime()).equals(1);
		dist_default(getDateFromMousePos(input(7, 1, 12, 9), weeks).getTime()).equals(2);
		dist_default(getDateFromMousePos(input(10, 1, 12, 9), weeks).getTime()).equals(3);
		dist_default(getDateFromMousePos(input(1, 4, 12, 9), weeks).getTime()).equals(4);
		dist_default(getDateFromMousePos(input(4, 4, 12, 9), weeks).getTime()).equals(5);
		dist_default(getDateFromMousePos(input(7, 4, 12, 9), weeks).getTime()).equals(6);
		dist_default(getDateFromMousePos(input(10, 4, 12, 9), weeks).getTime()).equals(7);
		dist_default(getDateFromMousePos(input(1, 7, 12, 9), weeks).getTime()).equals(8);
		dist_default(getDateFromMousePos(input(4, 7, 12, 9), weeks).getTime()).equals(9);
		dist_default(getDateFromMousePos(input(7, 7, 12, 9), weeks).getTime()).equals(10);
		dist_default(getDateFromMousePos(input(10, 7, 12, 9), weeks).getTime()).equals(11);
	});
	dist_default("getTimeFromMouseClick", function() {
		function input(y, targetHeight) {
			return {
				x: 0,
				y,
				targetWidth: 0,
				targetHeight
			};
		}
		dist_default(getTimeFromMousePos(input(0, 96), 4).toObject()).deepEquals({
			hours: 0,
			minutes: 0
		});
		dist_default(getTimeFromMousePos(input(1, 96), 4).toObject()).deepEquals({
			hours: 0,
			minutes: 15
		});
		dist_default(getTimeFromMousePos(input(2, 96), 4).toObject()).deepEquals({
			hours: 0,
			minutes: 30
		});
		dist_default(getTimeFromMousePos(input(3, 96), 4).toObject()).deepEquals({
			hours: 0,
			minutes: 45
		});
		dist_default(getTimeFromMousePos(input(4, 96), 4).toObject()).deepEquals({
			hours: 1,
			minutes: 0
		});
		dist_default(getTimeFromMousePos(input(47, 96), 4).toObject()).deepEquals({
			hours: 11,
			minutes: 45
		});
		dist_default(getTimeFromMousePos(input(95, 96), 4).toObject()).deepEquals({
			hours: 23,
			minutes: 45
		});
	});
});

//#endregion
//#region tests/calendar/CalendarViewModelTest.ts
var import_testdouble$19 = __toESM(require_testdouble(), 1);
var import_stream = __toESM(require_stream(), 1);
let saveAndSendMock;
let rescheduleEventMock;
dist_default.spec("CalendarViewModel", function() {
	let entityClientMock;
	function initCalendarViewModel(makeViewModelCallback, eventController) {
		if (eventController == null) eventController = downcast({ addEntityListener: () => Promise.resolve() });
		const progressTracker = {
			registerMonitorSync: () => 1,
			getMonitor: () => {
				return new ProgressMonitor(100, noOp);
			}
		};
		const deviceConfig = downcast({ getHiddenCalendars: (Id) => [] });
		const calendarInvitations = downcast({ init() {
			noOp();
		} });
		const calendarModel = (0, import_testdouble$19.object)();
		const contactModel = (0, import_testdouble$19.object)();
		const eventMapStream = (0, import_stream.default)(new Map());
		const calendarInfosStream = (0, import_stream.default)(new Map());
		const eventsRepository = (0, import_testdouble$19.object)();
		(0, import_testdouble$19.when)(eventsRepository.getEventsForMonths()).thenReturn(eventMapStream);
		(0, import_testdouble$19.when)(calendarModel.getCalendarInfosStream()).thenReturn(calendarInfosStream);
		const userController = makeUserController();
		const isNewPaidPlan = async () => true;
		const loginController = downcast({
			getUserController: () => ({
				...userController,
				isNewPaidPlan
			}),
			isInternalUserLoggedIn: () => true
		});
		const mailboxModel = (0, import_testdouble$19.object)();
		const previewModelFactory = async () => (0, import_testdouble$19.object)();
		const contactPreviewModelFactory = async () => (0, import_testdouble$19.object)();
		const viewModel = new CalendarViewModel(loginController, makeViewModelCallback, previewModelFactory, contactPreviewModelFactory, calendarModel, eventsRepository, new EntityClient(entityClientMock), eventController, progressTracker, deviceConfig, calendarInvitations, zone, mailboxModel, contactModel);
		viewModel.allowDrag = () => true;
		return {
			viewModel,
			calendarModel,
			eventsRepository
		};
	}
	function init$2(events) {
		const month = getMonthRange(getDateInZone("2021-01-01"), zone);
		const eventsForDays = new Map();
		for (let event of events) addDaysForEventInstance(eventsForDays, event, month, zone);
		return {
			days: [
				getDateInZone("2021-01-01"),
				getDateInZone("2021-01-02"),
				getDateInZone("2021-01-03"),
				getDateInZone("2021-01-04"),
				getDateInZone("2021-01-05"),
				getDateInZone("2021-01-06"),
				getDateInZone("2021-01-07")
			],
			eventsForDays,
			month
		};
	}
	dist_default.beforeEach(function() {
		entityClientMock = new EntityRestClientMock();
		saveAndSendMock = spy(() => Promise.resolve(true));
		rescheduleEventMock = spy(() => Promise.resolve());
	});
	dist_default("Can init view model", function() {
		const { viewModel } = initCalendarViewModel(makeCalendarEventModel$1);
		dist_default(viewModel).notEquals(undefined);
		dist_default(viewModel.selectedDate()).deepEquals(getStartOfDay(new Date()));
	});
	dist_default.spec("Dragging Events", function() {
		dist_default("Start then drag then change mind is noop", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventModel$1);
			let originalEventStartTime = new Date(2021, 8, 22);
			const event = makeEvent("event", originalEventStartTime, new Date(2021, 8, 23));
			simulateDrag(event, new Date(2021, 8, 21), viewModel);
			await simulateEndDrag(originalEventStartTime, new Date(2021, 8, 22), viewModel);
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([]);
		});
		dist_default("A good drag and drop run", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventModel$1);
			let originalDate = new Date(2021, 8, 22);
			const event = makeEvent("event", originalDate, new Date(2021, 8, 23));
			simulateDrag(event, new Date(2021, 8, 24), viewModel);
			dist_default(viewModel._draggedEvent?.eventClone.startTime.toISOString()).equals(new Date(2021, 8, 24).toISOString());
			dist_default(viewModel._draggedEvent?.eventClone.endTime.toISOString()).equals(new Date(2021, 8, 25).toISOString());
			const temporaryEvent = neverNull(viewModel._draggedEvent?.eventClone);
			let diff = new Date(2021, 8, 25).getTime() - originalDate.getTime();
			const endDragPromise = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent]);
			await endDragPromise;
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent]);
		});
		dist_default("Complete drag and drop and saving fails", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventEditModelThatFailsSaving);
			let originalDate = new Date(2021, 8, 22);
			const event = makeEvent("event", originalDate, new Date(2021, 8, 23));
			simulateDrag(event, new Date(2021, 8, 24), viewModel);
			await simulateEndDrag(originalDate, new Date(2021, 8, 25), viewModel);
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([]);
		});
		dist_default("Complete drag and drop and saving does an error", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventEditModelThatThrowsOnSaving);
			let originalDate = new Date(2021, 8, 22);
			const event = makeEvent("event", originalDate, new Date(2021, 8, 23));
			simulateDrag(event, new Date(2021, 8, 24), viewModel);
			let diff = new Date(2021, 8, 25).getTime() - originalDate.getTime();
			const endDragPromise = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			await assertThrows(Error, () => endDragPromise);
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([]);
		});
		dist_default("Drag while having temporary events should still work", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventModel$1);
			let origStartDate1 = new Date(2021, 8, 22);
			const event1 = makeEvent("event1", origStartDate1, new Date(2021, 8, 23));
			let origStartDate2 = new Date(2021, 8, 22);
			const event2 = makeEvent("event2", origStartDate2, new Date(2021, 8, 23));
			simulateDrag(event1, new Date(2021, 8, 24), viewModel);
			const temporaryEvent1 = neverNull(viewModel._draggedEvent?.eventClone);
			let diff = new Date(2021, 8, 25).getTime() - origStartDate1.getTime();
			const endDragPromise1 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			simulateDrag(event2, new Date(2021, 8, 24), viewModel);
			const temporaryEvent2 = neverNull(viewModel._draggedEvent?.eventClone);
			dist_default(viewModel._draggedEvent?.eventClone).equals(temporaryEvent2);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1]);
			diff = new Date(2021, 8, 25).getTime() - origStartDate2.getTime();
			const endDragPromise2 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1, temporaryEvent2]);
			await endDragPromise1;
			await endDragPromise2;
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1, temporaryEvent2]);
		});
		dist_default("Drag while having temporary events but the second update failed", async function() {
			let tryCount = 0;
			const { viewModel } = initCalendarViewModel(async () => {
				const eventModel = (0, import_testdouble$19.object)();
				(0, import_testdouble$19.when)(eventModel.apply()).thenDo(() => {
					tryCount++;
					if (tryCount === 1) return EventSaveResult.Saved;
else return EventSaveResult.Failed;
				});
				return eventModel;
			});
			let origStartDate1 = new Date(2021, 8, 22);
			const event1 = makeEvent("event1", origStartDate1, new Date(2021, 8, 23), "uid1");
			let origStartDate2 = new Date(2021, 8, 22);
			const event2 = makeEvent("event2", origStartDate2, new Date(2021, 8, 23), "uid2");
			simulateDrag(event1, new Date(2021, 8, 24), viewModel);
			const temporaryEvent1 = neverNull(viewModel._draggedEvent?.eventClone);
			let diff = new Date(2021, 8, 25).getTime() - origStartDate1.getTime();
			const endDragPromise1 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			await endDragPromise1;
			simulateDrag(event2, new Date(2021, 8, 24), viewModel);
			const temporaryEvent2 = neverNull(viewModel._draggedEvent?.eventClone);
			dist_default(viewModel._draggedEvent?.originalEvent).equals(event2);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1]);
			diff = new Date(2021, 8, 25).getTime() - origStartDate2.getTime();
			const endDragPromise2 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1, temporaryEvent2]);
			await endDragPromise2;
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1]);
		});
		dist_default("Drag while having temporary events and then the first update fails", async function() {
			let tryCount = 0;
			const { viewModel } = initCalendarViewModel(async () => {
				const saveModel = (0, import_testdouble$19.object)();
				(0, import_testdouble$19.when)(saveModel.apply()).thenDo(() => {
					tryCount++;
					if (tryCount === 1) return EventSaveResult.Failed;
else return EventSaveResult.Saved;
				});
				return saveModel;
			});
			let origStartDate1 = new Date(2021, 8, 22);
			const event1 = makeEvent("event1", origStartDate1, new Date(2021, 8, 23), "uid1");
			let origStartDate2 = new Date(2021, 8, 22);
			const event2 = makeEvent("event2", origStartDate2, new Date(2021, 8, 23), "uid2");
			simulateDrag(event1, new Date(2021, 8, 24), viewModel);
			const temporaryEvent1 = assertNotNull(viewModel._draggedEvent?.eventClone, "temporary 1 was null");
			let diff = new Date(2021, 8, 25).getTime() - origStartDate1.getTime();
			const endDragPromise1 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			simulateDrag(event2, new Date(2021, 8, 24), viewModel);
			const temporaryEvent2 = assertNotNull(viewModel._draggedEvent?.eventClone, "temporary 2 was null");
			dist_default(viewModel._draggedEvent?.originalEvent).equals(event2);
			dist_default(viewModel._draggedEvent?.eventClone).equals(temporaryEvent2);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1]);
			diff = new Date(2021, 8, 25).getTime() - origStartDate1.getTime();
			const endDragPromise2 = viewModel.onDragEnd(CalendarOperation.EditAll, diff);
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent1, temporaryEvent2]);
			await endDragPromise1;
			await endDragPromise2;
			dist_default(viewModel._draggedEvent?.originalEvent).equals(undefined);
			dist_default(viewModel._transientEvents).deepEquals([temporaryEvent2]);
		});
		dist_default("Block user from dragging non-editable events", async function() {
			const { viewModel } = initCalendarViewModel(makeCalendarEventModel$1);
			let originalEventStartTime = new Date(2021, 8, 22);
			const event = makeEvent("event", originalEventStartTime, new Date(2021, 8, 23));
			viewModel.allowDrag = () => false;
			simulateDrag(event, new Date(2021, 8, 24), viewModel);
			dist_default(viewModel._draggedEvent?.eventClone).equals(undefined);
		});
	});
	dist_default.spec("Filtering events", function() {
		dist_default("Before drag, input events are all used", async function() {
			const { viewModel, eventsRepository } = initCalendarViewModel(makeCalendarEventModel$1);
			const inputEvents = [
				makeEvent("event1", getDateInZone("2021-01-01"), getDateInZone("2021-01-02"), "uid1"),
				makeEvent("event2", getDateInZone("2021-01-01"), getDateInZone("2021-01-03"), "uid2"),
				makeEvent("event3", getDateInZone("2021-01-03T13:00"), getDateInZone("2021-01-03T14:30"), "uid3")
			];
			const { days, eventsForDays } = init$2(inputEvents);
			const expected = {
				shortEventsPerDay: [
					[],
					[],
					[inputEvents[2]],
					[],
					[],
					[],
					[]
				],
				longEvents: [inputEvents[0], inputEvents[1]]
			};
			eventsRepository.getEventsForMonths()(eventsForDays);
			const { shortEventsPerDay, longEvents } = viewModel.getEventsOnDaysToRender(days);
			dist_default({
				shortEventsPerDay,
				longEvents: Array.from(longEvents)
			}).deepEquals(expected);
		});
		dist_default("During drag, temporary event overrides the original version", async function() {
			const { viewModel, eventsRepository } = initCalendarViewModel(makeCalendarEventModel$1);
			const inputEvents = [
				makeEvent("event1", getDateInZone("2021-01-01"), getDateInZone("2021-01-02"), "uid1"),
				makeEvent("event2", getDateInZone("2021-01-01"), getDateInZone("2021-01-03"), "uid2"),
				makeEvent("event3", getDateInZone("2021-01-03T13:00"), getDateInZone("2021-01-03T14:30"), "uid3")
			];
			const { days, eventsForDays } = init$2(inputEvents);
			eventsRepository.getEventsForMonths()(eventsForDays);
			simulateDrag(inputEvents[2], getDateInZone("2021-01-04T13:00"), viewModel);
			const expected = {
				shortEvents: [
					[],
					[],
					[],
					[viewModel._draggedEvent?.eventClone],
					[],
					[],
					[]
				],
				longEvents: [inputEvents[0], inputEvents[1]]
			};
			const { shortEventsPerDay, longEvents } = viewModel.getEventsOnDaysToRender(days);
			dist_default(shortEventsPerDay).deepEquals(expected.shortEvents);
			dist_default(Array.from(longEvents)).deepEquals(expected.longEvents);
		});
		dist_default("After drop, before load", async function() {
			const { viewModel, eventsRepository } = initCalendarViewModel(makeCalendarEventModel$1);
			let originalDateForDraggedEvent = getDateInZone("2021-01-03T13:00");
			const inputEvents = [
				makeEvent("event1", getDateInZone("2021-01-01"), getDateInZone("2021-01-02"), "uid1"),
				makeEvent("event2", getDateInZone("2021-01-01"), getDateInZone("2021-01-03"), "uid2"),
				makeEvent("event3", originalDateForDraggedEvent, getDateInZone("2021-01-03T14:30"), "uid3")
			];
			const { days, eventsForDays } = init$2(inputEvents);
			eventsRepository.getEventsForMonths()(eventsForDays);
			simulateDrag(inputEvents[2], getDateInZone("2021-01-04T13:00"), viewModel);
			await simulateEndDrag(originalDateForDraggedEvent, getDateInZone("2021-01-05T13:00"), viewModel);
			const expected = {
				shortEvents: [
					[],
					[],
					[],
					[],
					[viewModel._transientEvents[0]],
					[],
					[]
				],
				longEvents: [inputEvents[0], inputEvents[1]]
			};
			const { shortEventsPerDay, longEvents } = viewModel.getEventsOnDaysToRender(days);
			dist_default(shortEventsPerDay).deepEquals(expected.shortEvents);
			dist_default(Array.from(longEvents)).deepEquals(expected.longEvents);
		});
	});
	dist_default.spec("entityEventsReceived", function() {
		dist_default("transient event is removed on update", async function() {
			const entityListeners = [];
			const eventController = downcast({ addEntityListener(listener) {
				entityListeners.push(listener);
			} });
			const { viewModel, eventsRepository } = initCalendarViewModel(makeCalendarEventModel$1, eventController);
			const originalDateForDraggedEvent = new Date(2021, 0, 3, 13, 0);
			let eventToDrag = makeEvent("event3", originalDateForDraggedEvent, new Date(2021, 0, 3, 14, 30), "uid3");
			const inputEvents = [
				makeEvent("event1", new Date(2021, 0, 1), new Date(2021, 0, 2), "uid1"),
				makeEvent("event2", new Date(2021, 0, 1), new Date(2021, 0, 3), "uid2"),
				eventToDrag
			];
			const { days, eventsForDays, month } = init$2(inputEvents);
			eventsRepository.getEventsForMonths()(eventsForDays);
			simulateDrag(inputEvents[2], new Date(2021, 0, 4, 13, 0), viewModel);
			const newData = new Date(2021, 0, 5, 13, 0);
			await simulateEndDrag(originalDateForDraggedEvent, newData, viewModel);
			dist_default(viewModel.temporaryEvents.some((e) => e.uid === eventToDrag.uid)).equals(true)("Has transient event");
			dist_default(entityListeners.length).equals(1)("Listener was added");
			const entityUpdate = {
				application: "tutanota",
				type: "CalendarEvent",
				instanceListId: getListId(eventToDrag),
				instanceId: getElementId(eventToDrag),
				operation: OperationType.CREATE
			};
			const updatedEventFromServer = makeEvent(getElementId(eventToDrag), newData, new Date(2021, 0, 5, 14, 30), assertNotNull(eventToDrag.uid));
			entityClientMock.addListInstances(updatedEventFromServer);
			await entityListeners[0]([entityUpdate], eventToDrag._ownerGroup);
			dist_default(viewModel.temporaryEvents.some((e) => e.uid === eventToDrag.uid)).equals(false)("Transient event removed");
		});
	});
});
function simulateDrag(originalEvent, newDate, viewModel) {
	let diff = newDate.getTime() - originalEvent.startTime.getTime();
	viewModel.onDragStart(originalEvent, diff);
	return diff;
}
async function simulateEndDrag(originalDate, newDate, viewModel) {
	let diff = newDate.getTime() - originalDate.getTime();
	await viewModel.onDragEnd(diff, CalendarOperation.EditAll);
}
async function makeCalendarEventModel$1(mode, existingEvent) {
	const eventModel = (0, import_testdouble$19.object)();
	(0, import_testdouble$19.when)(eventModel.apply()).thenResolve(EventSaveResult.Saved);
	return eventModel;
}
async function makeCalendarEventEditModelThatFailsSaving(mode, existingEvent) {
	const eventModel = (0, import_testdouble$19.object)();
	(0, import_testdouble$19.when)(eventModel.apply()).thenResolve(EventSaveResult.Failed);
	return eventModel;
}
async function makeCalendarEventEditModelThatThrowsOnSaving(mode, existingEvent) {
	const eventModel = (0, import_testdouble$19.object)();
	(0, import_testdouble$19.when)(eventModel.apply()).thenReject(new Error("whoopsie"));
	return eventModel;
}

//#endregion
//#region tests/calendar/eventeditor/CalendarNotificationModelTest.ts
var import_testdouble$18 = __toESM(require_testdouble(), 1);
dist_default.spec("CalendarNotificationModel", function() {
	let userController;
	let customer;
	let logins;
	dist_default.beforeEach(function() {
		userController = (0, import_testdouble$18.object)();
		customer = (0, import_testdouble$18.object)();
		logins = (0, import_testdouble$18.object)();
		(0, import_testdouble$18.when)(userController.loadCustomer()).thenResolve(customer);
		(0, import_testdouble$18.when)(logins.getUserController()).thenReturn(userController);
	});
	dist_default.spec("hasPlanWithInvites", function() {
		dist_default("available for users with new paid plan that contains invites", async function() {
			(0, import_testdouble$18.when)(userController.isNewPaidPlan()).thenResolve(true);
			(0, import_testdouble$18.when)(userController.getPlanConfig()).thenResolve(createTestEntity(PlanConfigurationTypeRef, { eventInvites: true }));
			(0, import_testdouble$18.replace)(userController, "user", { accountType: AccountType.PAID });
			(0, import_testdouble$18.replace)(customer, "customizations", []);
			dist_default(await hasPlanWithInvites(logins)).equals(true);
		});
		dist_default("not available for users with new paid plan that does not contain invites", async function() {
			(0, import_testdouble$18.when)(userController.isNewPaidPlan()).thenResolve(true);
			(0, import_testdouble$18.when)(userController.getPlanConfig()).thenResolve(createTestEntity(PlanConfigurationTypeRef, { eventInvites: false }));
			(0, import_testdouble$18.replace)(userController, "user", { accountType: AccountType.PAID });
			dist_default(await hasPlanWithInvites(logins)).equals(false);
		});
		dist_default("not available for free users will is true for free accounts", async function() {
			(0, import_testdouble$18.when)(userController.isNewPaidPlan()).thenResolve(false);
			(0, import_testdouble$18.replace)(userController, "user", { accountType: AccountType.FREE });
			(0, import_testdouble$18.replace)(customer, "customizations", []);
			dist_default(await hasPlanWithInvites(logins)).equals(false);
		});
		dist_default("available for premium users with business subscription", async function() {
			(0, import_testdouble$18.when)(userController.isNewPaidPlan()).thenResolve(false);
			(0, import_testdouble$18.replace)(userController, "user", { accountType: AccountType.PAID });
			(0, import_testdouble$18.when)(userController.getPlanConfig()).thenResolve({ eventInvites: true });
			(0, import_testdouble$18.replace)(customer, "customizations", [{ feature: FeatureType.BusinessFeatureEnabled }]);
			dist_default(await hasPlanWithInvites(logins)).equals(true);
		});
		dist_default("not available for external users", async function() {
			(0, import_testdouble$18.when)(userController.isNewPaidPlan()).thenResolve(false);
			(0, import_testdouble$18.replace)(userController, "user", { accountType: AccountType.EXTERNAL });
			dist_default(await hasPlanWithInvites(logins)).equals(false);
		});
	});
});

//#endregion
//#region tests/misc/webauthn/WebauthnClientTest.ts
var import_testdouble$17 = __toESM(require_testdouble(), 1);
dist_default.spec("WebauthnClient", function() {
	let webauthn;
	let client$1;
	let domainConfigProvider;
	const tutanotaWebauthnUrl = "https://mail.tutanota.com/webauthn";
	const tutanotaApiBaseUrl = "https://mail.tutanota.com";
	const tutanotaWebauthnMobileUrl = "https://mail.tutanota.com/webauthnmobile";
	let isApp$1;
	async function testSelectedKey(givenKeys, expectedDomain) {
		const keys = givenKeys.map((appId) => createTestEntity(U2fKeyTypeRef, {
			appId,
			keyHandle: stringToUtf8Uint8Array(appId)
		}));
		const challenge = createTestEntity(U2fChallengeTypeRef, { keys });
		const expectedKeys = keys.map((key) => {
			return { id: key.keyHandle };
		});
		(0, import_testdouble$17.when)(webauthn.sign({
			challenge: import_testdouble$17.matchers.anything(),
			keys: expectedKeys,
			domain: expectedDomain
		})).thenResolve({
			rawId: new Uint8Array(1),
			clientDataJSON: new Uint8Array(1),
			signature: new Uint8Array(1),
			authenticatorData: new Uint8Array(1)
		});
		return client$1.authenticate(challenge);
	}
	dist_default.beforeEach(function() {
		webauthn = (0, import_testdouble$17.object)();
		domainConfigProvider = (0, import_testdouble$17.object)();
		(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("mail.tutanota.com", "https:", import_testdouble$17.matchers.anything())).thenReturn({
			...domainConfigStub,
			legacyWebauthnUrl: tutanotaWebauthnUrl,
			webauthnUrl: tutanotaWebauthnUrl,
			apiUrl: tutanotaApiBaseUrl,
			webauthnMobileUrl: tutanotaWebauthnMobileUrl
		});
		client$1 = new WebauthnClient(webauthn, domainConfigProvider, isApp$1);
	});
	dist_default.spec("not running as a mobile app", function() {
		dist_default.before(function() {
			isApp$1 = false;
		});
		dist_default.spec("auth", function() {
			dist_default.spec("keys for different domains", function() {
				dist_default("tutanota webauthn key", async function() {
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn({
						...domainConfigStub,
						legacyWebauthnUrl: tutanotaWebauthnUrl
					});
					const result = await testSelectedKey([
						"tutanota.com",
						"another.domain.com",
						"https://tutanota.com/u2f-appid.json",
						"https://legacy.another.domain/u2f-appid.json"
					], tutanotaWebauthnUrl);
					dist_default(result.apiBaseUrl).equals(tutanotaApiBaseUrl);
				});
				dist_default("another webauthn key", async function() {
					const domainConfig = {
						...domainConfigStub,
						webauthnUrl: "https://another.domain.com/webauthn",
						apiUrl: "https://another.domain.com"
					};
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn(domainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("another.domain.com", "https:", import_testdouble$17.matchers.anything())).thenReturn(domainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("another.domain.com", "https:")).thenReturn(domainConfig);
					const result = await testSelectedKey([
						"another.domain.com",
						"https://tutanota.com/u2f-appid.json",
						"https://legacy.another.domain/u2f-appid.json"
					], "https://another.domain.com/webauthn");
					dist_default(result.apiBaseUrl).equals("https://another.domain.com");
				});
				dist_default("tutanota legacy key", async function() {
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn({
						...domainConfigStub,
						legacyWebauthnUrl: tutanotaWebauthnUrl
					});
					const result = await testSelectedKey(["https://tutanota.com/u2f-appid.json", "https://legacy.another.domain/u2f-appid.json"], tutanotaWebauthnUrl);
					dist_default(result.apiBaseUrl).equals(tutanotaApiBaseUrl);
				});
				dist_default("whitelabel legacy key", async function() {
					const domainConfig = {
						...domainConfigStub,
						legacyWebauthnUrl: "https://legacy.another.domain/webauthn",
						webauthnUrl: "https://legacy.another.domain/webauthn",
						apiUrl: "https:///legacy.another.domain"
					};
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn(domainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("legacy.another.domain", "https:", import_testdouble$17.matchers.anything())).thenReturn(domainConfig);
					const result = await testSelectedKey(["https://legacy.another.domain/u2f-appid.json", "https://legacy.more.domain/u2f-appid.json"], "https://legacy.another.domain/webauthn");
					dist_default(result.apiBaseUrl).equals("https:///legacy.another.domain");
				});
				dist_default("tuta.com key, on tuta.com domain", async function() {
					const domainConfig = {
						...domainConfigStub,
						legacyWebauthnUrl: "https://mail.tutanota.com/webauthn",
						webauthnUrl: "https://app.tuta.com/webauthn",
						apiUrl: "https:///app.tuta.com"
					};
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn(domainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("app.tuta.com", "https:", import_testdouble$17.matchers.anything())).thenReturn(domainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("app.tuta.com", "https:")).thenReturn(domainConfig);
					const result = await testSelectedKey(["app.tuta.com"], "https://app.tuta.com/webauthn");
					dist_default(result.apiBaseUrl).equals("https:///app.tuta.com");
				});
				dist_default("tuta.com key, on tutanota.com domain", async function() {
					const tutaDomainConfig = {
						...domainConfigStub,
						legacyWebauthnUrl: "https://mail.tutanota.com/webauthn",
						webauthnUrl: "https://app.tuta.com/webauthn",
						apiUrl: "https:///app.tuta.com"
					};
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn(tutaDomainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("app.tuta.com", "https:", import_testdouble$17.matchers.anything())).thenReturn(tutaDomainConfig);
					const result = await testSelectedKey(["tuta.com"], "https://app.tuta.com/webauthn");
					dist_default(result.apiBaseUrl).equals("https:///app.tuta.com");
				});
				dist_default("tutanota.com key, on tuta.com domain", async function() {
					const tutaDomainConfig = {
						...domainConfigStub,
						legacyWebauthnUrl: "https://mail.tutanota.com/webauthn",
						webauthnUrl: "https://app.tuta.com/webauthn",
						apiUrl: "https:///app.tuta.com"
					};
					(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn(tutaDomainConfig);
					(0, import_testdouble$17.when)(domainConfigProvider.getDomainConfigForHostname("app.tuta.com")).thenReturn(tutaDomainConfig);
					const result = await testSelectedKey(["tutanota.com"], tutanotaWebauthnUrl);
					dist_default(result.apiBaseUrl).equals("https://mail.tutanota.com");
				});
			});
		});
	});
	dist_default.spec("when running as an app", function() {
		dist_default.before(function() {
			isApp$1 = true;
		});
		dist_default("tutanota webauthn key", async function() {
			(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn({
				...domainConfigStub,
				legacyWebauthnMobileUrl: tutanotaWebauthnMobileUrl
			});
			const result = await testSelectedKey([
				"tutanota.com",
				"another.domain.com",
				"https://tutanota.com/u2f-appid.json",
				"https://legacy.another.domain/u2f-appid.json"
			], tutanotaWebauthnMobileUrl);
			dist_default(result.apiBaseUrl).equals(tutanotaApiBaseUrl);
		});
		dist_default("tuta webauthn key", async function() {
			(0, import_testdouble$17.when)(domainConfigProvider.getCurrentDomainConfig()).thenReturn({
				...domainConfigStub,
				webauthnMobileUrl: tutanotaWebauthnMobileUrl
			});
			const result = await testSelectedKey([
				"tuta.com",
				"another.domain.com",
				"https://tutanota.com/u2f-appid.json",
				"https://legacy.another.domain/u2f-appid.json"
			], tutanotaWebauthnMobileUrl);
			dist_default(result.apiBaseUrl).equals(tutanotaApiBaseUrl);
		});
	});
});

//#endregion
//#region tests/translations/TranslationKeysTest.ts
dist_default.spec("synchronisation of translation keys", function() {
	dist_default("en, de and de_sie have exactly the same keys", async function() {
		const enKeys = Object.keys(en_default.keys);
		const deKeys = Object.keys(de_default.keys);
		const deSieKeys = Object.keys(de_sie_default.keys);
		const extraKeysInEn = difference(enKeys, deKeys);
		const extraKeysInDe = difference(deKeys, enKeys);
		const extraKeysInDeSie = difference(deSieKeys, deKeys);
		const keysNotInDeSie = difference(deKeys, deSieKeys);
		dist_default(extraKeysInEn).deepEquals([])("extra keys in en");
		dist_default(extraKeysInDe).deepEquals([])("extra keys in de");
		dist_default(extraKeysInDeSie).deepEquals([])("extra keys in de_sie");
		dist_default(keysNotInDeSie).deepEquals([])("keys not in de_sie");
	});
});

//#endregion
//#region tests/misc/UsageTestModelTest.ts
var import_testdouble$16 = __toESM(require_testdouble(), 1);
const { anything: anything$2 } = import_testdouble$16.matchers;
dist_default.spec("UsageTestModel", function() {
	let usageTestModel;
	let serviceExecutor;
	let entityClient$1;
	let persistentStorage;
	let ephemeralStorage;
	let userControllerMock;
	let loginControllerMock;
	let eventControllerMock;
	let usageTestController;
	const testDeviceId = "123testDeviceId321";
	const dateProvider$1 = {
		now() {
			return Date.now();
		},
		timeZone() {
			throw new Error("Not implemented by this provider");
		}
	};
	const oldAssignment = createTestEntity(UsageTestAssignmentTypeRef, {
		name: "oldAssignment",
		variant: "3",
		stages: [],
		sendPings: true,
		testId: "testId123"
	});
	const assignmentData = {
		updatedAt: dateProvider$1.now() - ASSIGNMENT_UPDATE_INTERVAL_MS * 2,
		usageModelVersion: ModelInfo_default$1.version,
		assignments: [oldAssignment]
	};
	const newAssignment = createTestEntity(UsageTestAssignmentTypeRef, {
		name: "assignment1",
		variant: "1",
		stages: [],
		sendPings: true,
		testId: "testId123"
	});
	dist_default.beforeEach(function() {
		serviceExecutor = (0, import_testdouble$16.object)();
		entityClient$1 = (0, import_testdouble$16.object)();
		userControllerMock = (0, import_testdouble$16.object)();
		loginControllerMock = (0, import_testdouble$16.object)();
		(0, import_testdouble$16.replace)(loginControllerMock, "isUserLoggedIn", () => true);
		eventControllerMock = (0, import_testdouble$16.object)();
		usageTestController = (0, import_testdouble$16.object)();
		(0, import_testdouble$16.when)(loginControllerMock.getUserController()).thenReturn(userControllerMock);
		ephemeralStorage = new EphemeralUsageTestStorage();
		persistentStorage = new EphemeralUsageTestStorage();
		usageTestModel = new UsageTestModel({
			[StorageBehavior.Persist]: persistentStorage,
			[StorageBehavior.Ephemeral]: ephemeralStorage
		}, dateProvider$1, serviceExecutor, entityClient$1, loginControllerMock, eventControllerMock, () => usageTestController);
		(0, import_testdouble$16.replace)(usageTestModel, "customerProperties", createTestEntity(CustomerPropertiesTypeRef, { usageDataOptedOut: false }));
		(0, import_testdouble$16.replace)(userControllerMock, "userSettingsGroupRoot", createTestEntity(UserSettingsGroupRootTypeRef, { usageDataOptedIn: true }));
	});
	async function assertStored(storage, result, assignment) {
		dist_default(result[0].testId).equals(assignment.testId);
		const storedAssignment = await storage.getAssignments();
		dist_default(storedAssignment?.assignments[0].testId).equals(assignment.testId);
		dist_default(await storage.getTestDeviceId()).equals(testDeviceId);
	}
	dist_default.spec("usage tests", function() {
		dist_default.spec("usage test model loading assignments", function() {
			dist_default("when there's no deviceId it does POST", async function() {
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, {}), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, newAssignment);
			});
			dist_default("loads from server because model version has changed", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				await ephemeralStorage.storeAssignments({
					assignments: [],
					usageModelVersion: -1,
					updatedAt: dateProvider$1.now() - 1
				});
				(0, import_testdouble$16.when)(serviceExecutor.put(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, { testDeviceId }), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, newAssignment);
			});
			dist_default("loads from server and stores if nothing is stored", async function() {
				(0, import_testdouble$16.when)(serviceExecutor.put(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, { testDeviceId }), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, newAssignment);
			});
			dist_default("returns result from storage if it's there", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				assignmentData.updatedAt = dateProvider$1.now();
				await ephemeralStorage.storeAssignments(assignmentData);
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, oldAssignment);
			});
			dist_default("data outdated, loads from the server and stores", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				await ephemeralStorage.storeAssignments(assignmentData);
				(0, import_testdouble$16.when)(serviceExecutor.put(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, { testDeviceId }), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, newAssignment);
			});
			dist_default("data not outdated, returns result from storage", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				const nonOutdatedAssignmentData = clone(assignmentData);
				nonOutdatedAssignmentData.updatedAt = dateProvider$1.now() - ASSIGNMENT_UPDATE_INTERVAL_MS / 2;
				await ephemeralStorage.storeAssignments(nonOutdatedAssignmentData);
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(ephemeralStorage, result, oldAssignment);
			});
		});
		dist_default.spec("sendPing", function() {
			dist_default("sends ping", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				const usageTest = new UsageTest("testId", "testName", 1, true);
				usageTest.pingAdapter = usageTestModel;
				const stage = new Stage(0, usageTest, 1, 1);
				usageTest.addStage(stage);
				const metric = {
					name: "foo",
					value: "bar"
				};
				stage.setMetric(metric);
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestParticipationService, createTestEntity(UsageTestParticipationInTypeRef, {
					testId: usageTest.testId,
					metrics: [createUsageTestMetricData(metric)],
					stage: stage.number.toString(),
					testDeviceId
				}))).thenResolve(undefined);
				await usageTestModel.sendPing(usageTest, stage);
				(0, import_testdouble$16.verify)(serviceExecutor.post(UsageTestParticipationService, anything$2()), {
					times: 1,
					ignoreExtraArgs: true
				});
			});
			dist_default("sends pings in correct order", async function() {
				await ephemeralStorage.storeTestDeviceId(testDeviceId);
				const usageTest = new UsageTest("testId", "testName", 1, true);
				usageTest.pingAdapter = usageTestModel;
				for (let i = 0; i < 3; i++) {
					const stage = new Stage(i, usageTest, 1, 1);
					usageTest.addStage(stage);
				}
				const pingOrder = [];
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestParticipationService, createTestEntity(UsageTestParticipationInTypeRef, {
					testId: usageTest.testId,
					stage: "0",
					testDeviceId
				}), anything$2())).thenDo(async () => {
					await new Promise((resolve) => setTimeout(resolve, 15));
					pingOrder.push("0");
				});
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestParticipationService, createTestEntity(UsageTestParticipationInTypeRef, {
					testId: usageTest.testId,
					stage: "1",
					testDeviceId
				}), anything$2())).thenDo(async () => {
					await new Promise((resolve) => setTimeout(resolve, 10));
					pingOrder.push("1");
				});
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestParticipationService, createTestEntity(UsageTestParticipationInTypeRef, {
					testId: usageTest.testId,
					stage: "2",
					testDeviceId
				}), anything$2())).thenDo(async () => {
					pingOrder.push("2");
				});
				usageTest.getStage(0).complete();
				usageTest.getStage(1).complete();
				await usageTest.getStage(2).complete();
				dist_default(pingOrder).deepEquals([
					"0",
					"1",
					"2"
				]);
			});
		});
		dist_default.spec("setting the storage behavior", function() {
			dist_default("uses correct storage backend after the behavior has been set", async function() {
				usageTestModel.setStorageBehavior(StorageBehavior.Persist);
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, {}), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				const result = await usageTestModel.loadActiveUsageTests();
				await assertStored(persistentStorage, result, newAssignment);
				(0, import_testdouble$16.verify)(ephemeralStorage.getTestDeviceId(), { times: 0 });
			});
			dist_default("nothing is stored if customer has opted out", async function() {
				(0, import_testdouble$16.replace)(usageTestModel, "customerProperties", createTestEntity(CustomerPropertiesTypeRef, { usageDataOptedOut: true }));
				usageTestModel.setStorageBehavior(StorageBehavior.Persist);
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, {}), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				await usageTestModel.loadActiveUsageTests();
				dist_default(await persistentStorage.getAssignments()).equals(null);
				(0, import_testdouble$16.verify)(ephemeralStorage.getTestDeviceId(), { times: 0 });
			});
			dist_default("nothing is stored if user has not opted in", async function() {
				(0, import_testdouble$16.replace)(userControllerMock, "userSettingsGroupRoot", createTestEntity(UserSettingsGroupRootTypeRef, { usageDataOptedIn: false }));
				usageTestModel.setStorageBehavior(StorageBehavior.Persist);
				(0, import_testdouble$16.when)(serviceExecutor.post(UsageTestAssignmentService, createTestEntity(UsageTestAssignmentInTypeRef, {}), { suspensionBehavior: SuspensionBehavior.Throw })).thenResolve(createTestEntity(UsageTestAssignmentOutTypeRef, {
					assignments: [newAssignment],
					testDeviceId
				}));
				await usageTestModel.loadActiveUsageTests();
				dist_default(await persistentStorage.getAssignments()).equals(null);
				(0, import_testdouble$16.verify)(ephemeralStorage.getTestDeviceId(), { times: 0 });
			});
		});
	});
});

//#endregion
//#region tests/misc/NewsModelTest.ts
var import_testdouble$15 = __toESM(require_testdouble(), 1);
dist_default.spec("NewsModel", function() {
	let newsModel;
	let serviceExecutor;
	let storage;
	let newsIds;
	const DummyNews = class {
		render(newsId) {
			return null;
		}
		isShown() {
			return Promise.resolve(true);
		}
	};
	dist_default.beforeEach(function() {
		serviceExecutor = (0, import_testdouble$15.object)();
		storage = (0, import_testdouble$15.object)();
		newsModel = new NewsModel(serviceExecutor, storage, async () => new DummyNews());
		newsIds = [createTestEntity(NewsIdTypeRef, {
			newsItemId: "ID:dummyNews",
			newsItemName: "dummyNews"
		})];
		(0, import_testdouble$15.when)(serviceExecutor.get(NewsService, null)).thenResolve(createTestEntity(NewsOutTypeRef, { newsItemIds: newsIds }));
	});
	dist_default.spec("news", function() {
		dist_default("correctly loads news", async function() {
			await newsModel.loadNewsIds();
			dist_default(newsModel.liveNewsIds[0].newsItemId).equals(newsIds[0].newsItemId);
			dist_default(Object.keys(newsModel.liveNewsListItems).length).equals(1);
		});
		dist_default("correctly acknowledges news", async function() {
			await newsModel.loadNewsIds();
			await newsModel.acknowledgeNews(newsIds[0].newsItemId);
			const expectedNewsIn = createTestEntity(NewsInTypeRef, { newsItemId: newsIds[0].newsItemId });
			(0, import_testdouble$15.verify)(serviceExecutor.post(NewsService, expectedNewsIn));
		});
	});
});

//#endregion
//#region tests/file/FileControllerTest.ts
var import_testdouble$14 = __toESM(require_testdouble(), 1);
const { anything: anything$1, argThat } = import_testdouble$14.matchers;
const guiDownload = async function(somePromise, progress) {
	return somePromise;
};
dist_default.spec("FileControllerTest", function() {
	let blobFacadeMock;
	dist_default.beforeEach(function() {
		blobFacadeMock = (0, import_testdouble$14.object)();
	});
	dist_default.spec("native", function() {
		let fileAppMock;
		let fileController;
		let oldEnv;
		dist_default.beforeEach(function() {
			fileAppMock = (0, import_testdouble$14.object)();
			fileController = new FileControllerNative(blobFacadeMock, guiDownload, fileAppMock);
			oldEnv = globalThis.env;
			globalThis.env = {
				mode: Mode.App,
				platformId: "android"
			};
		});
		dist_default.afterEach(function() {
			globalThis.env = oldEnv;
		});
		dist_default("should download non-legacy file natively using the blob service", async function() {
			const blobs = [createTestEntity(BlobTypeRef)];
			const file = createTestEntity(FileTypeRef, {
				blobs,
				name: "test.txt",
				mimeType: "plain/text",
				_id: ["fileListId", "fileElementId"]
			});
			const fileReference = (0, import_testdouble$14.object)();
			(0, import_testdouble$14.when)(blobFacadeMock.downloadAndDecryptNative(anything$1(), anything$1(), anything$1(), anything$1())).thenResolve(fileReference);
			const result = await fileController.downloadAndDecrypt(file);
			(0, import_testdouble$14.verify)(blobFacadeMock.downloadAndDecryptNative(ArchiveDataType.Attachments, argThat((referencingInstance) => {
				return referencingInstance.entity === file;
			}), file.name, neverNull(file.mimeType)));
			dist_default(result).equals(fileReference);
		});
		dist_default.spec("download with connection errors", function() {
			dist_default("immediately no connection", async function() {
				const testableFileController = new FileControllerNative(blobFacadeMock, guiDownload, fileAppMock);
				const blobs = [createTestEntity(BlobTypeRef)];
				const file = createTestEntity(FileTypeRef, {
					blobs,
					name: "test.txt",
					mimeType: "plain/text",
					_id: ["fileListId", "fileElementId"]
				});
				(0, import_testdouble$14.when)(blobFacadeMock.downloadAndDecryptNative(anything$1(), anything$1(), anything$1(), anything$1())).thenReject(new ConnectionError("no connection"));
				await assertThrows(ConnectionError, async () => await testableFileController.download(file));
				(0, import_testdouble$14.verify)(fileAppMock.deleteFile(anything$1()), { times: 0 });
			});
			dist_default("connection lost after 1 already downloaded attachment- already downloaded attachments are processed", async function() {
				const testableFileController = new FileControllerNative(blobFacadeMock, guiDownload, fileAppMock);
				const blobs = [createTestEntity(BlobTypeRef)];
				const fileWorks = createTestEntity(FileTypeRef, {
					blobs,
					name: "works.txt",
					mimeType: "plain/text",
					_id: ["fileListId", "fileElementId"]
				});
				const fileNotWorks = createTestEntity(FileTypeRef, {
					blobs,
					name: "broken.txt",
					mimeType: "plain/text",
					_id: ["fileListId", "fileElementId"]
				});
				const fileReferenceWorks = {
					name: "works.txt",
					mimeType: "plain/text",
					location: "somepath/works.txt",
					size: 512,
					_type: "FileReference"
				};
				(0, import_testdouble$14.when)(blobFacadeMock.downloadAndDecryptNative(anything$1(), anything$1(), "works.txt", anything$1())).thenResolve(fileReferenceWorks);
				(0, import_testdouble$14.when)(blobFacadeMock.downloadAndDecryptNative(anything$1(), anything$1(), "broken.txt", anything$1())).thenReject(new ConnectionError("no connection"));
				await assertThrows(ConnectionError, async () => await testableFileController.downloadAll([fileWorks, fileNotWorks]));
				(0, import_testdouble$14.verify)(fileAppMock.deleteFile(anything$1()), { times: 1 });
			});
		});
	});
	dist_default.spec("browser", function() {
		let fileController;
		dist_default.beforeEach(function() {
			fileController = new FileControllerBrowser(blobFacadeMock, guiDownload);
		});
		dist_default("should download non-legacy file non-natively using the blob service", async function() {
			const blobs = [createTestEntity(BlobTypeRef)];
			const file = createTestEntity(FileTypeRef, {
				blobs,
				name: "test.txt",
				mimeType: "plain/text",
				_id: ["fileListId", "fileElementId"]
			});
			const data$1 = new Uint8Array([
				1,
				2,
				3
			]);
			(0, import_testdouble$14.when)(blobFacadeMock.downloadAndDecrypt(anything$1(), anything$1())).thenResolve(data$1);
			const result = await fileController.downloadAndDecrypt(file);
			(0, import_testdouble$14.verify)(blobFacadeMock.downloadAndDecrypt(ArchiveDataType.Attachments, argThat((referencingInstance) => referencingInstance.entity === file)));
			dist_default(result).deepEquals({
				_type: "DataFile",
				name: file.name,
				mimeType: neverNull(file.mimeType),
				data: data$1,
				size: data$1.byteLength,
				id: file._id,
				cid: undefined
			});
		});
	});
});

//#endregion
//#region tests/api/worker/rest/CustomCacheHandlerTest.ts
var import_testdouble$13 = __toESM(require_testdouble(), 1);
dist_default.spec("Custom calendar events handler", function() {
	const entityRestClientMock = (0, import_testdouble$13.instance)(EntityRestClient);
	const cacheHandler = new CustomCalendarEventCacheHandler(entityRestClientMock);
	const offlineStorageMock = (0, import_testdouble$13.instance)(LateInitializedCacheStorageImpl);
	const listId = "listId";
	let timestamp = Date.now();
	const ids = [
		0,
		1,
		2,
		3,
		4,
		5,
		6
	].map((n) => createEventElementId(timestamp, n));
	const allList = [
		0,
		1,
		2,
		3,
		4,
		5,
		6
	].map((n) => createTestEntity(CalendarEventTypeRef, { _id: [listId, ids[n]] }));
	const bigListId = "bigListId";
	const bigListIds = numberRange(0, 299).map((n) => createEventElementId(timestamp, n));
	const bigList = numberRange(0, 299).map((n) => createTestEntity(CalendarEventTypeRef, { _id: [bigListId, bigListIds[n]] }));
	const toElementId = (e) => e._id[1];
	dist_default.spec("Load elements from cache", function() {
		dist_default.beforeEach(function() {
			(0, import_testdouble$13.when)(offlineStorageMock.getWholeList(CalendarEventTypeRef, listId)).thenResolve(allList);
			(0, import_testdouble$13.when)(offlineStorageMock.getRangeForList(CalendarEventTypeRef, listId)).thenResolve({
				lower: CUSTOM_MIN_ID,
				upper: CUSTOM_MAX_ID
			});
		});
		dist_default("load range returns n elements following but excluding start id", async function() {
			const res = await cacheHandler.loadRange(offlineStorageMock, listId, ids[0], 3, false);
			dist_default(res.map(toElementId)).deepEquals(allList.map(toElementId).slice(1, 4));
		});
		dist_default("load range reverse returns n elements before but excluding start id in reverse order", async function() {
			const res = await cacheHandler.loadRange(offlineStorageMock, listId, ids[6], 3, true);
			dist_default(res.map(toElementId)).deepEquals(allList.map(toElementId).slice(3, 6).reverse());
		});
	});
	dist_default.spec("Load elements from server when they are not in cache", function() {
		dist_default.beforeEach(function() {
			(0, import_testdouble$13.when)(offlineStorageMock.getRangeForList(CalendarEventTypeRef, listId)).thenResolve(null);
		});
		dist_default("result of server request is inserted into cache and the range is set.", async function() {
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, listId, CUSTOM_MIN_ID, LOAD_MULTIPLE_LIMIT, false)).thenResolve(allList);
			const res = await cacheHandler.loadRange(offlineStorageMock, listId, ids[0], 3, false);
			dist_default(res.map(toElementId)).deepEquals(allList.map(toElementId).slice(1, 4))("count elements are returned");
			(0, import_testdouble$13.verify)(offlineStorageMock.put(import_testdouble$13.matchers.anything()), { times: allList.length });
			(0, import_testdouble$13.verify)(offlineStorageMock.setNewRangeForList(CalendarEventTypeRef, listId, CUSTOM_MIN_ID, CUSTOM_MAX_ID));
		});
		dist_default("result of server request is inserted into cache and the range is set. Loads more than 100, but only count elements are returned.", async function() {
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, CUSTOM_MIN_ID, LOAD_MULTIPLE_LIMIT, false)).thenResolve(bigList.slice(0, 100));
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, bigListIds[99], LOAD_MULTIPLE_LIMIT, false)).thenResolve(bigList.slice(100, 200));
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, bigListIds[199], LOAD_MULTIPLE_LIMIT, false)).thenResolve(bigList.slice(200, 300));
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, bigListIds[299], LOAD_MULTIPLE_LIMIT, false)).thenResolve([]);
			const res = await cacheHandler.loadRange(offlineStorageMock, bigListId, bigListIds[0], 3, false);
			dist_default(res.map(toElementId)).deepEquals(allList.map(toElementId).slice(1, 4))("count elements are returned");
			(0, import_testdouble$13.verify)(offlineStorageMock.put(import_testdouble$13.matchers.anything()), { times: bigList.length });
			(0, import_testdouble$13.verify)(offlineStorageMock.setNewRangeForList(CalendarEventTypeRef, bigListId, CUSTOM_MIN_ID, CUSTOM_MAX_ID));
			(0, import_testdouble$13.verify)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, import_testdouble$13.matchers.anything(), LOAD_MULTIPLE_LIMIT, false), { times: 4 });
		});
		dist_default("result of server request is inserted into cache and the range is set. No elements on the server. No elements are returned.", async function() {
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, bigListId, CUSTOM_MIN_ID, LOAD_MULTIPLE_LIMIT, false)).thenResolve([]);
			const res = await cacheHandler.loadRange(offlineStorageMock, bigListId, bigListIds[0], 3, false);
			dist_default(res.map(toElementId)).deepEquals([])("no elements are returned");
			(0, import_testdouble$13.verify)(offlineStorageMock.put(import_testdouble$13.matchers.anything()), { times: 0 });
			(0, import_testdouble$13.verify)(offlineStorageMock.setNewRangeForList(CalendarEventTypeRef, bigListId, CUSTOM_MIN_ID, CUSTOM_MAX_ID));
		});
		dist_default("result of server request is inserted into cache and the range is set. Less elements on the server than requested. Only elements that are on the server are returned.", async function() {
			(0, import_testdouble$13.when)(entityRestClientMock.loadRange(CalendarEventTypeRef, listId, CUSTOM_MIN_ID, LOAD_MULTIPLE_LIMIT, false)).thenResolve(allList);
			const res = await cacheHandler.loadRange(offlineStorageMock, listId, CUSTOM_MIN_ID, 30, false);
			dist_default(res.map(toElementId)).deepEquals(allList.map(toElementId))("allList is returned");
			(0, import_testdouble$13.verify)(offlineStorageMock.put(import_testdouble$13.matchers.anything()), { times: allList.length });
			(0, import_testdouble$13.verify)(offlineStorageMock.setNewRangeForList(CalendarEventTypeRef, listId, CUSTOM_MIN_ID, CUSTOM_MAX_ID));
		});
	});
});

//#endregion
//#region tests/misc/RecipientsModelTest.ts
var import_testdouble$12 = __toESM(require_testdouble(), 1);
dist_default.spec("RecipientsModel", function() {
	const contactListId = "contactListId";
	const contactElementId = "contactElementId";
	const contactId = [contactListId, contactElementId];
	const tutanotaAddress = "test@tuta.com";
	const otherAddress$1 = "test@dudanoda.com";
	let contactModelMock;
	let userControllerMock;
	let loginControllerMock;
	let mailFacadeMock;
	let entityClientMock;
	let model;
	dist_default.beforeEach(function() {
		contactModelMock = (0, import_testdouble$12.object)();
		userControllerMock = {
			user: createTestEntity(UserTypeRef, { memberships: [createTestEntity(GroupMembershipTypeRef, { groupType: GroupType.Contact })] }),
			userGroupInfo: createTestEntity(GroupInfoTypeRef, { mailAddress: "test@example.com" })
		};
		loginControllerMock = (0, import_testdouble$12.object)();
		(0, import_testdouble$12.when)(loginControllerMock.getUserController()).thenReturn(userControllerMock);
		mailFacadeMock = (0, import_testdouble$12.instance)(MailFacade);
		entityClientMock = (0, import_testdouble$12.instance)(EntityClient);
		model = new RecipientsModel(contactModelMock, loginControllerMock, mailFacadeMock, entityClientMock);
	});
	dist_default("initializes with provided contact", function() {
		const contact = makeContactStub(contactId, otherAddress$1);
		dist_default(model.resolve({
			address: otherAddress$1,
			contact
		}, ResolveMode.Eager).contact).deepEquals(contact);
	});
	dist_default("doesn't try to resolve contact if contact is provided", async function() {
		const contact = makeContactStub(contactId, otherAddress$1);
		const recipient = await model.resolve({
			address: otherAddress$1,
			contact
		}, ResolveMode.Eager).resolved();
		dist_default(recipient.contact).deepEquals(contact);
		verify(entityClientMock.load(ContactTypeRef, contactId), { times: 0 });
		verify(contactModelMock.searchForContact(otherAddress$1), { times: 0 });
	});
	dist_default("loads contact with id", async function() {
		const contact = makeContactStub(contactId, otherAddress$1);
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		(0, import_testdouble$12.when)(entityClientMock.load(ContactTypeRef, contactId)).thenResolve(contact);
		const recipient = await model.resolve({
			address: otherAddress$1,
			contact: contactId
		}, ResolveMode.Eager).resolved();
		dist_default(recipient.contact).deepEquals(contact);
	});
	dist_default("searches for contact by mail address", async function() {
		const contactId$1 = "contactElementId";
		const id = [contactListId, contactId$1];
		const contact = makeContactStub(id, otherAddress$1);
		(0, import_testdouble$12.when)(contactModelMock.searchForContact(otherAddress$1)).thenResolve(contact);
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		const recipient = await model.resolve({ address: otherAddress$1 }, ResolveMode.Eager).resolved();
		dist_default(recipient.contact).deepEquals(contact);
	});
	dist_default("prioritises name that was passed in", async function() {
		const recipient = await model.resolve({
			address: tutanotaAddress,
			name: "Pizza Tonno",
			contact: makeContactStub(contactId, tutanotaAddress, "Pizza", "Hawaii")
		}, ResolveMode.Eager).resolved();
		dist_default(recipient.name).equals("Pizza Tonno");
	});
	dist_default("uses name from contact if name not provided", async function() {
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		const recipient = await model.resolve({
			address: tutanotaAddress,
			contact: makeContactStub(contactId, tutanotaAddress, "Pizza", "Hawaii")
		}, ResolveMode.Eager).resolved();
		dist_default(recipient.name).equals("Pizza Hawaii");
	});
	dist_default("infers internal recipient from tutanota address, otherwise unknown", async function() {
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		dist_default(model.resolve({ address: tutanotaAddress }, ResolveMode.Lazy).type).equals(RecipientType.INTERNAL)("Tutanota address");
		dist_default(model.resolve({ address: otherAddress$1 }, ResolveMode.Lazy).type).equals(RecipientType.UNKNOWN)("Internal address");
	});
	dist_default("correctly resolves type for non tutanota addresses", async function() {
		const internalAddress = "internal@email.com";
		const externalAddress = "external@email.com";
		(0, import_testdouble$12.when)(mailFacadeMock.getRecipientKeyData(internalAddress)).thenResolve(createTestEntity(PublicKeyGetOutTypeRef));
		(0, import_testdouble$12.when)(mailFacadeMock.getRecipientKeyData(externalAddress)).thenResolve(null);
		const internal = await model.resolve({ address: internalAddress }, ResolveMode.Eager).resolved();
		const external = await model.resolve({ address: externalAddress }, ResolveMode.Eager).resolved();
		dist_default(internal.type).equals(RecipientType.INTERNAL)("key data existed so it is INTERNAL");
		dist_default(external.type).equals(RecipientType.EXTERNAL)("key data did not exist so it is EXTERNAL");
	});
	dist_default("ignores wrong type when tutanota address is passed in", async function() {
		const recipient = await model.resolve({
			address: tutanotaAddress,
			type: RecipientType.EXTERNAL
		}, ResolveMode.Eager).resolved();
		dist_default(recipient.type).equals(RecipientType.INTERNAL);
	});
	dist_default("doesn't try to resolve type when type is not unknown", async function() {
		await model.resolve({
			address: otherAddress$1,
			type: RecipientType.EXTERNAL
		}, ResolveMode.Eager).resolved();
		await model.resolve({
			address: otherAddress$1,
			type: RecipientType.INTERNAL
		}, ResolveMode.Eager).resolved();
		await model.resolve({ address: tutanotaAddress }, ResolveMode.Eager).resolved();
		verify(mailFacadeMock.getRecipientKeyData(otherAddress$1), { times: 0 });
	});
	dist_default("non-lazy resolution starts right away", async function() {
		const deferred = defer();
		const recipient = model.resolve({ address: tutanotaAddress }, ResolveMode.Eager);
		recipient.whenResolved(deferred.resolve);
		await deferred.promise;
		dist_default(recipient.isResolved()).equals(true);
	});
	dist_default("lazy resolution isn't triggered until `resolved` is called", async function() {
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		const recipient = model.resolve({ address: otherAddress$1 }, ResolveMode.Lazy);
		await delay(5);
		verify(contactModelMock.searchForContact(otherAddress$1), { times: 0 });
		verify(mailFacadeMock.getRecipientKeyData(otherAddress$1), { times: 0 });
		dist_default(recipient.isResolved()).equals(false);
		await recipient.resolved();
		verify(contactModelMock.searchForContact(otherAddress$1), { times: 1 });
		verify(mailFacadeMock.getRecipientKeyData(otherAddress$1), { times: 1 });
		dist_default(recipient.isResolved()).equals(true);
	});
	dist_default("passes resolved recipient to callback", async function() {
		const contact = makeContactStub(contactId, otherAddress$1, "Re", "Cipient");
		(0, import_testdouble$12.when)(contactModelMock.searchForContact(otherAddress$1)).thenResolve(contact);
		(0, import_testdouble$12.when)(contactModelMock.getContactListId()).thenResolve("contactListId");
		(0, import_testdouble$12.when)(mailFacadeMock.getRecipientKeyData(otherAddress$1)).thenResolve(null);
		const handler = (0, import_testdouble$12.func)();
		await model.resolve({
			address: otherAddress$1,
			name: "Re Cipient"
		}, ResolveMode.Eager).whenResolved(handler).resolved();
		verify(handler({
			address: otherAddress$1,
			name: "Re Cipient",
			type: RecipientType.EXTERNAL,
			contact
		}));
	});
});
function makeContactStub(id, mailAddress, firstName, lastName) {
	return createTestEntity(ContactTypeRef, {
		_id: id,
		mailAddresses: [createTestEntity(ContactMailAddressTypeRef, { address: mailAddress })],
		firstName: firstName ?? "",
		lastName: lastName ?? ""
	});
}

//#endregion
//#region tests/api/worker/facades/MailAddressFacadeTest.ts
var import_testdouble$11 = __toESM(require_testdouble(), 1);
dist_default.spec("MailAddressFacadeTest", function() {
	let worker;
	let userFacade;
	let groupManagementFacade;
	let countersFacade;
	let rsa;
	let entityClient$1;
	let serviceExecutor;
	let nonCachingEntityClient;
	let facade;
	dist_default.beforeEach(function() {
		userFacade = (0, import_testdouble$11.object)();
		groupManagementFacade = (0, import_testdouble$11.object)();
		serviceExecutor = (0, import_testdouble$11.object)();
		nonCachingEntityClient = (0, import_testdouble$11.object)();
		facade = new MailAddressFacade(userFacade, groupManagementFacade, serviceExecutor, nonCachingEntityClient);
	});
	dist_default.spec("getSenderNames", function() {
		dist_default("when there is existing MailboxProperties it returns the names", async function() {
			const mailGroupId = "mailGroupId";
			const viaUser = "viaUser";
			const mailboxPropertiesId = "mailboxPropertiesId";
			const mailboxGroupRoot = createTestEntity(MailboxGroupRootTypeRef, {
				_ownerGroup: mailGroupId,
				mailboxProperties: mailboxPropertiesId
			});
			const mailGroupKey = freshVersioned([
				1,
				2,
				3
			]);
			const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef, { mailAddressProperties: [createTestEntity(MailAddressPropertiesTypeRef, {
				mailAddress: "a@a.com",
				senderName: "a"
			}), createTestEntity(MailAddressPropertiesTypeRef, {
				mailAddress: "b@b.com",
				senderName: "b"
			})] });
			(0, import_testdouble$11.when)(groupManagementFacade.getCurrentGroupKeyViaUser(mailGroupId, viaUser)).thenResolve(mailGroupKey);
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId)).thenResolve(mailboxGroupRoot);
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxPropertiesId, import_testdouble$11.matchers.argThat(async (opts) => {
				const providedMailGroupKey = await opts.ownerKeyProvider(mailGroupKey.version);
				return arrayEquals(mailGroupKey.object, providedMailGroupKey);
			}))).thenResolve(mailboxProperties);
			const result = await facade.getSenderNames(mailGroupId, viaUser);
			dist_default(mapToObject(result)).deepEquals({
				"a@a.com": "a",
				"b@b.com": "b"
			});
		});
		dist_default("when there's no existing MailboxProperties it creates and returns one", async function() {
			const mailGroupId = "mailGroupId";
			const viaUser = "viaUser";
			const mailboxPropertiesId = "mailboxProeprtiesId";
			const mailboxGroupRoot = createTestEntity(MailboxGroupRootTypeRef, {
				_ownerGroup: mailGroupId,
				mailboxProperties: null
			});
			const mailGroupKey = freshVersioned([
				1,
				2,
				3
			]);
			const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef, {
				_id: mailboxPropertiesId,
				_ownerGroup: mailGroupId,
				reportMovedMails: "",
				mailAddressProperties: []
			});
			const userGroupInfoId = ["groupInfoListId", "groupInfoId"];
			const user = createTestEntity(UserTypeRef, {
				_id: viaUser,
				userGroup: createTestEntity(GroupMembershipTypeRef, { groupInfo: userGroupInfoId })
			});
			const userGroupInfo = createTestEntity(GroupInfoTypeRef, {
				_id: userGroupInfoId,
				name: "User name",
				mailAddress: "primary@example.com",
				mailAddressAliases: [createTestEntity(MailAddressAliasTypeRef, {
					mailAddress: "a@a.com",
					enabled: true
				})]
			});
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(UserTypeRef, viaUser)).thenResolve(user);
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(GroupInfoTypeRef, userGroupInfoId)).thenResolve(userGroupInfo);
			(0, import_testdouble$11.when)(groupManagementFacade.getCurrentGroupKeyViaUser(mailGroupId, viaUser)).thenResolve(mailGroupKey);
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(MailboxGroupRootTypeRef, mailGroupId)).thenResolve(mailboxGroupRoot);
			(0, import_testdouble$11.when)(nonCachingEntityClient.setup(null, import_testdouble$11.matchers.anything(), undefined, { ownerKey: mailGroupKey })).thenResolve(mailboxPropertiesId);
			(0, import_testdouble$11.when)(nonCachingEntityClient.load(MailboxPropertiesTypeRef, mailboxPropertiesId, import_testdouble$11.matchers.argThat(async (opts) => {
				const providedMailGroupKey = await opts.ownerKeyProvider(mailGroupKey.version);
				return arrayEquals(mailGroupKey.object, providedMailGroupKey);
			}))).thenResolve(mailboxProperties);
			const result = await facade.getSenderNames(mailGroupId, viaUser);
			dist_default(mapToObject(result)).deepEquals({
				"primary@example.com": "User name",
				"a@a.com": "User name"
			});
		});
	});
});

//#endregion
//#region tests/mail/model/FolderSystemTest.ts
dist_default.spec("FolderSystem", function() {
	const listId = "listId";
	const inbox = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "inbox"],
		folderType: MailSetKind.INBOX
	});
	const archive = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "archive"],
		folderType: MailSetKind.ARCHIVE
	});
	const customFolder = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "custom"],
		folderType: MailSetKind.CUSTOM,
		name: "X"
	});
	const customSubfolder = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "customSub"],
		folderType: MailSetKind.CUSTOM,
		parentFolder: customFolder._id,
		name: "AA",
		mails: "customSubMailList"
	});
	const customSubSubfolder = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "customSubSub"],
		folderType: MailSetKind.CUSTOM,
		parentFolder: customSubfolder._id,
		name: "B"
	});
	const customSubSubfolderAnother = createTestEntity(MailFolderTypeRef, {
		_id: [listId, "customSubSubAnother"],
		folderType: MailSetKind.CUSTOM,
		parentFolder: customSubfolder._id,
		name: "A"
	});
	const mail = createTestEntity(MailTypeRef, {
		_id: ["mailListId", "inbox"],
		sets: [customSubfolder._id]
	});
	const allFolders = [
		archive,
		inbox,
		customFolder,
		customSubfolder,
		customSubSubfolder,
		customSubSubfolderAnother
	];
	dist_default("correctly builds the subtrees", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.systemSubtrees).deepEquals([{
			folder: inbox,
			children: []
		}, {
			folder: archive,
			children: []
		}])("system subtrees");
		dist_default(system.customSubtrees).deepEquals([{
			folder: customFolder,
			children: [{
				folder: customSubfolder,
				children: [{
					folder: customSubSubfolderAnother,
					children: []
				}, {
					folder: customSubSubfolder,
					children: []
				}]
			}]
		}])("custom subtrees");
	});
	dist_default("indented list sorts folders correctly on the same level", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getIndentedList()).deepEquals([
			{
				level: 0,
				folder: inbox
			},
			{
				level: 0,
				folder: archive
			},
			{
				level: 0,
				folder: customFolder
			},
			{
				level: 1,
				folder: customSubfolder
			},
			{
				level: 2,
				folder: customSubSubfolderAnother
			},
			{
				level: 2,
				folder: customSubSubfolder
			}
		]);
	});
	dist_default("indented list sorts stepsiblings correctly", function() {
		const customFolderAnother = createTestEntity(MailFolderTypeRef, {
			_id: [listId, "customAnother"],
			folderType: MailSetKind.CUSTOM,
			name: "Another top-level custom"
		});
		const customFolderAnotherSub = createTestEntity(MailFolderTypeRef, {
			_id: [listId, "customAnotherSub"],
			folderType: MailSetKind.CUSTOM,
			parentFolder: customFolderAnother._id,
			name: "Y"
		});
		const system = new FolderSystem([
			...allFolders,
			customFolderAnother,
			customFolderAnotherSub
		]);
		dist_default(system.getIndentedList()).deepEquals([
			{
				level: 0,
				folder: inbox
			},
			{
				level: 0,
				folder: archive
			},
			{
				level: 0,
				folder: customFolderAnother
			},
			{
				level: 1,
				folder: customFolderAnotherSub
			},
			{
				level: 0,
				folder: customFolder
			},
			{
				level: 1,
				folder: customSubfolder
			},
			{
				level: 2,
				folder: customSubSubfolderAnother
			},
			{
				level: 2,
				folder: customSubSubfolder
			}
		]);
	});
	dist_default("indented list will not return folder or descendants of given folder", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getIndentedList(customSubfolder)).deepEquals([
			{
				level: 0,
				folder: inbox
			},
			{
				level: 0,
				folder: archive
			},
			{
				level: 0,
				folder: customFolder
			}
		]);
	});
	dist_default("getSystemFolderByType", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getSystemFolderByType(MailSetKind.ARCHIVE)).deepEquals(archive);
	});
	dist_default("getFolderById", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getFolderById(getElementId(archive))).deepEquals(archive);
	});
	dist_default("getFolderById not there returns null", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getFolderById("randomId")).equals(null);
	});
	dist_default("getFolderByMail", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getFolderByMail(mail)).equals(customSubfolder);
	});
	dist_default("getCustomFoldersOfParent", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getCustomFoldersOfParent(customSubfolder._id)).deepEquals([customSubSubfolderAnother, customSubSubfolder]);
	});
	dist_default("getPathToFolder", function() {
		const system = new FolderSystem(allFolders);
		dist_default(system.getPathToFolder(customSubSubfolder._id)).deepEquals([
			customFolder,
			customSubfolder,
			customSubSubfolder
		]);
	});
});

//#endregion
//#region tests/mail/model/MailListModelTest.ts
var import_testdouble$10 = __toESM(require_testdouble(), 1);
otest_default.spec("MailListModelTest", () => {
	let model;
	const mailboxDetail = {
		mailbox: createTestEntity(MailBoxTypeRef),
		mailGroupInfo: createTestEntity(GroupInfoTypeRef),
		mailGroup: createTestEntity(GroupTypeRef),
		mailboxGroupRoot: createTestEntity(MailboxGroupRootTypeRef)
	};
	const mailSetEntriesListId = "entries";
	const _ownerGroup = "me";
	const labels = [createTestEntity(MailFolderTypeRef, {
		_id: ["mailFolderList", "tutaRed"],
		color: tutaRed,
		folderType: MailSetKind.LABEL,
		isMailSet: true,
		name: "Tuta Red Label",
		parentFolder: null
	}), createTestEntity(MailFolderTypeRef, {
		_id: ["mailFolderList", "tutaDunkel"],
		color: tutaDunkel,
		folderType: MailSetKind.LABEL,
		isMailSet: true,
		name: "Tuta Dunkel Label",
		parentFolder: null
	})];
	let mailSet;
	let conversationPrefProvider;
	let entityClient$1;
	let mailModel;
	let inboxRuleHandler;
	let cacheStorage;
	otest_default.beforeEach(() => {
		mailSet = createTestEntity(MailFolderTypeRef, {
			_id: ["mailFolderList", "mailFolderId"],
			folderType: MailSetKind.CUSTOM,
			isMailSet: true,
			name: "My Folder",
			entries: mailSetEntriesListId,
			parentFolder: null
		});
		conversationPrefProvider = (0, import_testdouble$10.object)();
		entityClient$1 = (0, import_testdouble$10.object)();
		mailModel = (0, import_testdouble$10.object)();
		inboxRuleHandler = (0, import_testdouble$10.object)();
		cacheStorage = (0, import_testdouble$10.object)();
		model = new MailListModel(mailSet, conversationPrefProvider, entityClient$1, mailModel, inboxRuleHandler, cacheStorage);
		(0, import_testdouble$10.when)(mailModel.getMailboxDetailsForMailFolder(mailSet)).thenResolve(mailboxDetail);
	});
	function makeMailId(index) {
		const mailBag = index % 10;
		return [`${mailBag}`, pad(index, GENERATED_MAX_ID.length)];
	}
	function makeMailSetElementId(index) {
		return constructMailSetEntryId(new Date(index * 100), elementIdPart(makeMailId(index)));
	}
	function mailSetElementIdToIndex(mailSetElementId) {
		return Number(deconstructMailSetEntryId(mailSetElementId).mailId);
	}
	async function setUpTestData(count, initialLabels, offline) {
		const mailSetEntries = [];
		const mails = [
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[],
			[]
		];
		for (let i = 0; i < count; i++) {
			const mailBag = i % 10;
			const mailId$1 = makeMailId(i);
			const mail = createTestEntity(MailTypeRef, {
				_id: mailId$1,
				sets: [mailSet._id, ...initialLabels.map((l) => l._id)]
			});
			mails[mailBag].push(mail);
			mailSetEntries.push(createMailSetEntry({
				_id: [mailSetEntriesListId, makeMailSetElementId(i)],
				_ownerGroup,
				_permissions: "1234",
				mail: mailId$1
			}));
		}
		(0, import_testdouble$10.when)(mailModel.getLabelsForMail(import_testdouble$10.matchers.anything())).thenDo((mail) => {
			const sets = [];
			for (const set of mail.sets) {
				const setToAdd = labels.find((label) => isSameId(label._id, set));
				if (setToAdd) sets.push(setToAdd);
			}
			return sets;
		});
		async function getMailSetEntryMock(_mailSetEntry, _listId, startingId, count$1, _reverse) {
			let endingIndex;
			if (startingId === CUSTOM_MAX_ID) endingIndex = mailSetEntries.length;
else endingIndex = mailSetElementIdToIndex(startingId);
			endingIndex = clamp(endingIndex, 0, mailSetEntries.length);
			let startingIndex = clamp(endingIndex - count$1, 0, endingIndex);
			return mailSetEntries.slice(startingIndex, endingIndex);
		}
		async function getMailsMock(_mailTypeRef, mailBag, elements) {
			const mailsInMailBag = mails[Number(mailBag)] ?? [];
			return mailsInMailBag.filter((mail) => elements.includes(getElementId(mail)));
		}
		(0, import_testdouble$10.when)(cacheStorage.provideFromRange(MailSetEntryTypeRef, mailSetEntriesListId, import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), true)).thenDo(getMailSetEntryMock);
		(0, import_testdouble$10.when)(cacheStorage.provideMultiple(MailTypeRef, import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything())).thenDo(getMailsMock);
		if (offline) {
			(0, import_testdouble$10.when)(entityClient$1.loadRange(import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything())).thenReject(new ConnectionError("sorry we are offline"));
			(0, import_testdouble$10.when)(entityClient$1.loadMultiple(import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything())).thenReject(new ConnectionError("sorry we are offline"));
		} else {
			(0, import_testdouble$10.when)(entityClient$1.loadRange(MailSetEntryTypeRef, mailSetEntriesListId, import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything(), true)).thenDo(getMailSetEntryMock);
			(0, import_testdouble$10.when)(entityClient$1.loadMultiple(MailTypeRef, import_testdouble$10.matchers.anything(), import_testdouble$10.matchers.anything())).thenDo(getMailsMock);
		}
	}
	otest_default.test("loads PageSize items and sets labels correctly", async () => {
		await setUpTestData(PageSize, labels, false);
		await model.loadInitial();
		otest_default(model.items.length).equals(PageSize);
		for (const mail of model.items) otest_default(model.getLabelsForMail(mail)).deepEquals(labels);
		(0, import_testdouble$10.verify)(cacheStorage.provideFromRange(MailSetEntryTypeRef, mailSetEntriesListId, CUSTOM_MAX_ID, PageSize, true), { times: 0 });
		(0, import_testdouble$10.verify)(mailModel.getMailboxDetailsForMailFolder(import_testdouble$10.matchers.anything()), { times: 0 });
		(0, import_testdouble$10.verify)(inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, import_testdouble$10.matchers.anything(), true), { times: 0 });
	});
	otest_default.test("loads PageSize items while offline and sets labels correctly", async () => {
		await setUpTestData(PageSize, labels, true);
		await model.loadInitial();
		otest_default(model.items.length).equals(PageSize);
		for (const mail of model.items) otest_default(model.getLabelsForMail(mail)).deepEquals(labels);
		(0, import_testdouble$10.verify)(cacheStorage.provideFromRange(MailSetEntryTypeRef, mailSetEntriesListId, CUSTOM_MAX_ID, PageSize, true), { times: 1 });
		(0, import_testdouble$10.verify)(mailModel.getMailboxDetailsForMailFolder(import_testdouble$10.matchers.anything()), { times: 0 });
		(0, import_testdouble$10.verify)(inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, import_testdouble$10.matchers.anything(), true), { times: 0 });
	});
	otest_default.test("applies inbox rules if inbox", async () => {
		mailSet.folderType = MailSetKind.INBOX;
		(0, import_testdouble$10.when)(inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, import_testdouble$10.matchers.argThat((mail) => isSameId(mail._id, makeMailId(25))), true)).thenResolve({});
		await setUpTestData(PageSize, labels, false);
		await model.loadInitial();
		otest_default(model.items.length).equals(PageSize - 1);
		for (const mail of model.items) otest_default(model.getLabelsForMail(mail)).deepEquals(labels);
		(0, import_testdouble$10.verify)(cacheStorage.provideFromRange(MailSetEntryTypeRef, mailSetEntriesListId, CUSTOM_MAX_ID, PageSize, true), { times: 0 });
		(0, import_testdouble$10.verify)(mailModel.getMailboxDetailsForMailFolder(import_testdouble$10.matchers.anything()), { times: 1 });
		(0, import_testdouble$10.verify)(inboxRuleHandler.findAndApplyMatchingRule(mailboxDetail, import_testdouble$10.matchers.anything(), true), { times: 100 });
	});
	otest_default.test("loadMore eventually loads more mails", async () => {
		const pages = 5;
		await setUpTestData(PageSize * pages, labels, false);
		await model.loadInitial();
		const unloadedMail = makeMailSetElementId(1);
		for (let loadedPageCount = 1; loadedPageCount < pages; loadedPageCount++) {
			otest_default(model.items.length).equals(PageSize * loadedPageCount);
			const mail$1 = model.getMailSetEntry(unloadedMail);
			otest_default(mail$1).equals(null);
			await model.loadMore();
		}
		otest_default(model.items.length).equals(PageSize * pages);
		const mail = model.getMailSetEntry(unloadedMail);
		otest_default(mail).notEquals(null);
	});
	otest_default.test("loadAndSelect selects by mail id", async () => {
		await setUpTestData(PageSize * 5, labels, false);
		await model.loadInitial();
		const unloadedMail = elementIdPart(makeMailId(1));
		const mail = model.getMail(unloadedMail);
		otest_default(mail).equals(null);
		const loadedMail = await model.loadAndSelect(unloadedMail, () => false);
		otest_default(loadedMail).notEquals(null);
		otest_default(loadedMail).equals(model.getMail(unloadedMail));
	});
	otest_default.spec("handleEntityUpdate", () => {
		otest_default.test("mailset update updates labels", async () => {
			await setUpTestData(PageSize, [labels[0]], false);
			await model.loadInitial();
			const someIndex = 50;
			const someMail = {
				...model._loadedMails()[someIndex],
				labels: [labels[0], labels[1]]
			};
			someMail.mail.sets.push(labels[1]._id);
			model._updateSingleMail(someMail);
			otest_default(model.getLabelsForMail(someMail.mail)[1]).deepEquals(labels[1]);
			labels[1] = {
				...labels[1],
				name: "Mint",
				color: "#00FFAA"
			};
			otest_default(model.getLabelsForMail(someMail.mail)[1]).notDeepEquals(labels[1]);
			const entityUpdateData = {
				application: MailFolderTypeRef.app,
				type: MailFolderTypeRef.type,
				instanceListId: getListId(labels[1]),
				instanceId: getElementId(labels[1]),
				operation: OperationType.DELETE
			};
			entityUpdateData.operation = OperationType.UPDATE;
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.getLabelsForMail(someMail.mail)[1]).deepEquals(labels[1]);
			(0, import_testdouble$10.verify)(mailModel.getLabelsForMail(someMail.mail), { times: 2 });
			(0, import_testdouble$10.verify)(mailModel.getLabelsForMail(model.items[someIndex + 1]), { times: 1 });
		});
		otest_default.test("mailset delete does nothing", async () => {
			await setUpTestData(PageSize, [labels[0]], false);
			await model.loadInitial();
			const entityUpdateData = {
				application: MailFolderTypeRef.app,
				type: MailFolderTypeRef.type,
				instanceListId: getListId(labels[1]),
				instanceId: getElementId(labels[1]),
				operation: OperationType.DELETE
			};
			entityUpdateData.operation = OperationType.DELETE;
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.items.length).equals(PageSize);
		});
		otest_default.test("deleting a mail set entry", async () => {
			await setUpTestData(PageSize, labels, false);
			await model.loadInitial();
			const someIndex = 22;
			const someMail = model._loadedMails()[someIndex];
			const entityUpdateData = {
				application: MailSetEntryTypeRef.app,
				type: MailSetEntryTypeRef.type,
				instanceListId: getListId(someMail.mailSetEntry),
				instanceId: getElementId(someMail.mailSetEntry),
				operation: OperationType.DELETE
			};
			const oldItems = model.items;
			const newItems = [...oldItems];
			newItems.splice(someIndex, 1);
			otest_default(model.items).deepEquals(oldItems);
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.items).deepEquals(newItems);
			otest_default(model.getMail(getElementId(someMail.mail))).equals(null);
		});
		function createInsertedMail(forEntries) {
			const newMail = createTestEntity(MailTypeRef, {
				_id: ["new mail!!!", "the mail!!!"],
				sets: [mailSet._id, labels[1]._id]
			});
			const newEntry = createMailSetEntry({
				_id: [forEntries, CUSTOM_MAX_ID],
				mail: newMail._id
			});
			const entityUpdateData = {
				application: MailSetEntryTypeRef.app,
				type: MailSetEntryTypeRef.type,
				instanceListId: getListId(newEntry),
				instanceId: getElementId(newEntry),
				operation: OperationType.CREATE
			};
			(0, import_testdouble$10.when)(entityClient$1.load(MailSetEntryTypeRef, newEntry._id)).thenResolve(newEntry);
			(0, import_testdouble$10.when)(entityClient$1.loadMultiple(MailTypeRef, getListId(newMail), [getElementId(newMail)])).thenResolve([newMail]);
			return {
				mail: newMail,
				mailSetEntry: newEntry,
				entityUpdateData,
				mailLabels: [labels[1]]
			};
		}
		otest_default.test("creating a mail set entry of the same set adds the element", async () => {
			await setUpTestData(PageSize, labels, false);
			await model.loadInitial();
			const { mail, entityUpdateData, mailLabels } = createInsertedMail(mailSet.entries);
			const oldItems = model.items;
			const newItems = [mail, ...oldItems];
			otest_default(model.items).deepEquals(oldItems);
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.items).deepEquals(newItems);
			otest_default(model.getMail(getElementId(mail))).deepEquals(mail);
			otest_default(model.getLabelsForMail(mail)).deepEquals(mailLabels);
		});
		otest_default.test("creating a mail set entry in a different set does nothing", async () => {
			await setUpTestData(PageSize, labels, false);
			await model.loadInitial();
			const { mail, entityUpdateData } = createInsertedMail("something else");
			const oldItems = model.items;
			const newItems = [...oldItems];
			otest_default(model.items).deepEquals(oldItems);
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.items).deepEquals(newItems);
			otest_default(model.getMail(getElementId(mail))).equals(null);
		});
		otest_default.test("updating a mail updates the contents", async () => {
			await setUpTestData(PageSize, labels, false);
			await model.loadInitial();
			const mail = { ...model.items[2] };
			mail.subject = "hey it's a subject";
			mail.sets = [mailSet._id];
			const entityUpdateData = {
				application: MailTypeRef.app,
				type: MailTypeRef.type,
				instanceListId: getListId(mail),
				instanceId: getElementId(mail),
				operation: OperationType.UPDATE
			};
			(0, import_testdouble$10.when)(entityClient$1.load(MailTypeRef, mail._id)).thenResolve(mail);
			entityUpdateData.operation = OperationType.UPDATE;
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.getMail(getElementId(mail))).deepEquals(mail);
			otest_default(model.getLabelsForMail(mail)).deepEquals([]);
		});
		otest_default.test("mail delete does nothing", async () => {
			await setUpTestData(PageSize, labels, false);
			await model.loadInitial();
			const mail = { ...model.items[2] };
			const entityUpdateData = {
				application: MailTypeRef.app,
				type: MailTypeRef.type,
				instanceListId: getListId(mail),
				instanceId: getElementId(mail),
				operation: OperationType.UPDATE
			};
			(0, import_testdouble$10.when)(entityClient$1.load(MailTypeRef, mail._id)).thenResolve(mail);
			entityUpdateData.operation = OperationType.DELETE;
			await model.handleEntityUpdate(entityUpdateData);
			otest_default(model.getMail(getElementId(mail))).deepEquals(mail);
		});
	});
});

//#endregion
//#region tests/gui/ScopedRouterTest.ts
dist_default.spec("ScopedRouter", function() {
	dist_default.spec("route matches prefix", function() {
		dist_default("matches exact prefix", function() {
			dist_default(routeMatchesPrefix("contact", "/contact")).equals(true);
		});
		dist_default("matches with list id", function() {
			dist_default(routeMatchesPrefix("contact", "/contact/teuckeon")).equals(true);
		});
		dist_default("matches with list and element id", function() {
			dist_default(routeMatchesPrefix("contact", "/contact/teuckeon/onteuckoec")).equals(true);
		});
		dist_default("does not match another prefix", function() {
			dist_default(routeMatchesPrefix("contact", "/contactlist")).equals(false);
		});
		dist_default("does not match with id", function() {
			dist_default(routeMatchesPrefix("contact", "/contactlist/teuckeon")).equals(false);
		});
		dist_default("does not match empty", function() {
			dist_default(routeMatchesPrefix("contact", "/")).equals(false);
		});
		dist_default("route with query matches prefix", function() {
			dist_default(routeMatchesPrefix("contact", "/contact?test=1")).equals(true);
		});
	});
});

//#endregion
//#region ../node_modules/ospec/ospec.js
var require_ospec = __commonJS({ "../node_modules/ospec/ospec.js"(exports, module) {
	(function(m) {
		if (typeof module !== "undefined") module["exports"] = m();
else window.o = m();
	})(function init$2(name) {
		var spec = {}, subjects = [], results, only = [], ctx = spec, start, stack = 0, nextTickish, hasProcess = typeof process === "object", hasOwn = {}.hasOwnProperty;
		var ospecFileName = getStackName(ensureStackTrace(new Error()), /[\/\\](.*?):\d+:\d+/), timeoutStackName;
		var globalTimeout = noTimeoutRightNow;
		var currentTestError = null;
		if (name != null) spec[name] = ctx = {};
		try {
			throw new Error();
		} catch (e) {
			var ospecFileName = e.stack && /[\/\\](.*?):\d+:\d+/.test(e.stack) ? e.stack.match(/[\/\\](.*?):\d+:\d+/)[1] : null;
		}
		function o$1(subject, predicate) {
			if (predicate === undefined) {
				if (!isRunning()) throw new Error("Assertions should not occur outside test definitions");
				return new Assert(subject);
			} else {
				if (isRunning()) throw new Error("Test definitions and hooks shouldn't be nested. To group tests use `o.spec()`");
				subject = String(subject);
				if (subject.charCodeAt(0) === 1) throw new Error("test names starting with '\\x01' are reserved for internal use");
				ctx[unique(subject)] = new Task(predicate, ensureStackTrace(new Error()));
			}
		}
		o$1.before = hook("before");
		o$1.after = hook("after");
		o$1.beforeEach = hook("beforeEach");
		o$1.afterEach = hook("afterEach");
		o$1.specTimeout = function(t) {
			if (isRunning()) throw new Error("o.specTimeout() can only be called before o.run()");
			if (hasOwn.call(ctx, "specTimeout")) throw new Error("A default timeout has already been defined in this context");
			if (typeof t !== "number") throw new Error("o.specTimeout() expects a number as argument");
			ctx["specTimeout"] = t;
		};
		o$1.new = init$2;
		o$1.spec = function(subject, predicate) {
			var parent = ctx;
			ctx = ctx[unique(subject)] = {};
			predicate();
			ctx = parent;
		};
		o$1.only = function(subject, predicate, silent) {
			if (!silent) console.log(highlight("/!\\ WARNING /!\\ o.only() mode") + "\n" + o$1.cleanStackTrace(ensureStackTrace(new Error())) + "\n", cStyle("red"), "");
			only.push(predicate);
			o$1(subject, predicate);
		};
		o$1.spy = function(fn) {
			var spy$1 = function() {
				spy$1.this = this;
				spy$1.args = [].slice.call(arguments);
				spy$1.calls.push({
					this: this,
					args: spy$1.args
				});
				spy$1.callCount++;
				if (fn) return fn.apply(this, arguments);
			};
			if (fn) Object.defineProperties(spy$1, {
				length: { value: fn.length },
				name: { value: fn.name }
			});
			spy$1.args = [];
			spy$1.calls = [];
			spy$1.callCount = 0;
			return spy$1;
		};
		o$1.cleanStackTrace = function(error) {
			if (error.stack == null) return "";
			var i = 0, header = error.message ? error.name + ": " + error.message : error.name, stack$1;
			if (error.stack.indexOf(header) === 0) {
				stack$1 = error.stack.slice(header.length).split(/\r?\n/);
				stack$1.shift();
			} else stack$1 = error.stack.split(/\r?\n/);
			if (ospecFileName == null) return stack$1.join("\n");
			while (stack$1[i] != null && stack$1[i].indexOf(ospecFileName) !== -1) i++;
			return stack$1[i];
		};
		o$1.timeout = function(n) {
			globalTimeout(n);
		};
		o$1.run = function(reporter) {
			results = [];
			start = new Date();
			test(
				spec,
				[],
				[],
				new Task(function() {
					setTimeout(function() {
						timeoutStackName = getStackName({ stack: o$1.cleanStackTrace(ensureStackTrace(new Error())) }, /([\w \.]+?:\d+:\d+)/);
						if (typeof reporter === "function") reporter(results);
else {
							var errCount = o$1.report(results);
							if (hasProcess && errCount !== 0) process.exit(1);
						}
					});
				}, null),
				200
				/*default timeout delay*/
);
			function test(spec$1, pre, post, finalize, defaultDelay) {
				if (hasOwn.call(spec$1, "specTimeout")) defaultDelay = spec$1["specTimeout"];
				pre = [].concat(pre, spec$1["beforeEach"] || []);
				post = [].concat(spec$1["afterEach"] || [], post);
				series([].concat(spec$1["before"] || [], Object.keys(spec$1).reduce(function(tasks, key) {
					if (key.charCodeAt(0) !== 1 && (only.length === 0 || only.indexOf(spec$1[key].fn) !== -1 || !(spec$1[key] instanceof Task))) tasks.push(new Task(function(done) {
						o$1.timeout(Infinity);
						subjects.push(key);
						var pop = new Task(function pop$1() {
							subjects.pop(), done();
						}, null);
						if (spec$1[key] instanceof Task) series([].concat(pre, spec$1[key], post, pop), defaultDelay);
else test(spec$1[key], pre, post, pop, defaultDelay);
					}, null));
					return tasks;
				}, []), spec$1["after"] || [], finalize), defaultDelay);
			}
			function series(tasks, defaultDelay) {
				var cursor = 0;
				next();
				function next() {
					if (cursor === tasks.length) return;
					var task = tasks[cursor++];
					var fn = task.fn;
					currentTestError = task.err;
					var timeout = 0, delay$1 = defaultDelay, s = new Date();
					var current = cursor;
					var arg;
					globalTimeout = setDelay;
					var isDone = false;
					function done(err$1) {
						if (!isDone) isDone = true;
else throw new Error("`" + arg + "()` should only be called once");
						if (timeout === undefined) console.warn("# elapsed: " + Math.round(new Date() - s) + "ms, expected under " + delay$1 + "ms\n" + o$1.cleanStackTrace(task.err));
						finalizeAsync(err$1);
					}
					function finalizeAsync(err$1) {
						if (err$1 == null) {
							if (task.err != null) succeed(new Assert());
						} else if (err$1 instanceof Error) fail(new Assert(), err$1.message, err$1);
else fail(new Assert(), String(err$1), null);
						if (timeout !== undefined) timeout = clearTimeout(timeout);
						if (current === cursor) next();
					}
					function startTimer() {
						timeout = setTimeout(function() {
							timeout = undefined;
							finalizeAsync("async test timed out after " + delay$1 + "ms");
						}, Math.min(delay$1, 2147483647));
					}
					function setDelay(t) {
						if (typeof t !== "number") throw new Error("timeout() and o.timeout() expect a number as argument");
						delay$1 = t;
					}
					if (fn.length > 0) {
						var body = fn.toString();
						arg = (body.match(/^(.+?)(?:\s|\/\*[\s\S]*?\*\/|\/\/.*?\n)*=>/) || body.match(/\((?:\s|\/\*[\s\S]*?\*\/|\/\/.*?\n)*(.+?)(?:\s|\/\*[\s\S]*?\*\/|\/\/.*?\n)*[,\)]/) || []).pop();
						if (body.indexOf(arg) === body.lastIndexOf(arg)) {
							var e = new Error();
							e.stack = "`" + arg + "()` should be called at least once\n" + o$1.cleanStackTrace(task.err);
							throw e;
						}
						try {
							fn(done, setDelay);
						} catch (e$1) {
							if (task.err != null) finalizeAsync(e$1);
else throw e$1;
						}
						if (timeout === 0) startTimer();
					} else try {
						var p = fn();
						if (p && p.then) {
							startTimer();
							p.then(function() {
								done();
							}, done);
						} else nextTickish(next);
					} catch (e$1) {
						if (task.err != null) finalizeAsync(e$1);
else throw e$1;
					}
					globalTimeout = noTimeoutRightNow;
				}
			}
		};
		function unique(subject) {
			if (hasOwn.call(ctx, subject)) {
				console.warn("A test or a spec named `" + subject + "` was already defined");
				while (hasOwn.call(ctx, subject)) subject += "*";
			}
			return subject;
		}
		function hook(name$1) {
			return function(predicate) {
				if (ctx[name$1]) throw new Error("This hook should be defined outside of a loop or inside a nested test group:\n" + predicate);
				ctx[name$1] = new Task(predicate, ensureStackTrace(new Error()));
			};
		}
		define("equals", "should equal", function(a, b) {
			return a === b;
		});
		define("notEquals", "should not equal", function(a, b) {
			return a !== b;
		});
		define("deepEquals", "should deep equal", deepEqual$1);
		define("notDeepEquals", "should not deep equal", function(a, b) {
			return !deepEqual$1(a, b);
		});
		define("throws", "should throw a", throws);
		define("notThrows", "should not throw a", function(a, b) {
			return !throws(a, b);
		});
		function isArguments(a) {
			if ("callee" in a) {
				for (var i in a) if (i === "callee") return false;
				return true;
			}
		}
		function deepEqual$1(a, b) {
			if (a === b) return true;
			if (a === null ^ b === null || a === undefined ^ b === undefined) return false;
			if (typeof a === "object" && typeof b === "object") {
				var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
				if (a.constructor === Object && b.constructor === Object && !aIsArgs && !bIsArgs) {
					for (var i in a) if (!(i in b) || !deepEqual$1(a[i], b[i])) return false;
					for (var i in b) if (!(i in a)) return false;
					return true;
				}
				if (a.length === b.length && (a instanceof Array && b instanceof Array || aIsArgs && bIsArgs)) {
					var aKeys = Object.getOwnPropertyNames(a), bKeys = Object.getOwnPropertyNames(b);
					if (aKeys.length !== bKeys.length) return false;
					for (var i = 0; i < aKeys.length; i++) if (!hasOwn.call(b, aKeys[i]) || !deepEqual$1(a[aKeys[i]], b[aKeys[i]])) return false;
					return true;
				}
				if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
				if (typeof Buffer === "function" && a instanceof Buffer && b instanceof Buffer) {
					for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
					return true;
				}
				if (a.valueOf() === b.valueOf()) return true;
			}
			return false;
		}
		function throws(a, b) {
			try {
				a();
			} catch (e) {
				if (typeof b === "string") return e.message === b;
else return e instanceof b;
			}
			return false;
		}
		function isRunning() {
			return results != null;
		}
		function Assert(value) {
			this.value = value;
			this.i = results.length;
			results.push({
				pass: null,
				context: "",
				message: "Incomplete assertion in the test definition starting at...",
				error: currentTestError,
				testError: currentTestError
			});
		}
		function Task(fn, err$1) {
			this.fn = fn;
			this.err = err$1;
		}
		function define(name$1, verb, compare) {
			Assert.prototype[name$1] = function assert(value) {
				var self$1 = this;
				var message = serialize(self$1.value) + "\n  " + verb + "\n" + serialize(value);
				if (compare(self$1.value, value)) {
					succeed(self$1, message);
					return function(message$1) {
						if (!self$1.pass) self$1.message = message$1 + "\n\n" + self$1.message;
					};
				} else fail(self$1, message);
			};
		}
		function succeed(assertion, message) {
			results[assertion.i].pass = true;
			results[assertion.i].context = subjects.join(" > ");
			results[assertion.i].message = message;
		}
		function fail(assertion, message, error) {
			results[assertion.i].pass = false;
			results[assertion.i].context = subjects.join(" > ");
			results[assertion.i].message = message;
			results[assertion.i].error = error != null ? error : ensureStackTrace(new Error());
		}
		function serialize(value) {
			if (hasProcess) return __require("util").inspect(value);
			if (value === null || typeof value === "object" && !(value instanceof Array) || typeof value === "number") return String(value);
else if (typeof value === "function") return value.name || "<anonymous function>";
			try {
				return JSON.stringify(value);
			} catch (e) {
				return String(value);
			}
		}
		function noTimeoutRightNow() {
			throw new Error("o.timeout must be called snchronously from within a test definition or a hook");
		}
		var colorCodes = {
			red: "31m",
			red2: "31;1m",
			green: "32;1m"
		};
		function highlight(message, color) {
			var code = colorCodes[color] || colorCodes.red;
			return hasProcess ? process.stdout.isTTY ? "\x1B[" + code + message + "\x1B[0m" : message : "%c" + message + "%c ";
		}
		function cStyle(color, bold) {
			return hasProcess || !color ? "" : "color:" + color + (bold ? ";font-weight:bold" : "");
		}
		function ensureStackTrace(error) {
			if (error.stack === undefined) try {
				throw error;
			} catch (e) {
				return e;
			}
else return error;
		}
		function getStackName(e, exp) {
			return e.stack && exp.test(e.stack) ? e.stack.match(exp)[1] : null;
		}
		o$1.report = function(results$1) {
			var errCount = 0;
			for (var i = 0, r; r = results$1[i]; i++) {
				if (r.pass == null) {
					r.testError.stack = r.message + "\n" + o$1.cleanStackTrace(r.testError);
					r.testError.message = r.message;
					throw r.testError;
				}
				if (!r.pass) {
					var stackTrace = o$1.cleanStackTrace(r.error);
					var couldHaveABetterStackTrace = !stackTrace || timeoutStackName != null && stackTrace.indexOf(timeoutStackName) !== -1;
					if (couldHaveABetterStackTrace) stackTrace = r.testError != null ? o$1.cleanStackTrace(r.testError) : r.error.stack || "";
					console.error((hasProcess ? "\n" : "") + highlight(r.context + ":", "red2") + "\n" + highlight(r.message, "red") + (stackTrace ? "\n" + stackTrace + "\n" : ""), cStyle("black", true), "", cStyle("red"), cStyle("black"));
					errCount++;
				}
			}
			var pl = results$1.length === 1 ? "" : "s";
			var resultSummary = errCount === 0 ? highlight((pl ? "All " : "The ") + results$1.length + " assertion" + pl + " passed", "green") : highlight(errCount + " out of " + results$1.length + " assertion" + pl + " failed", "red2");
			var runningTime = " in " + Math.round(Date.now() - start) + "ms";
			console.log((hasProcess ? "\n" : "") + (name ? name + ": " : "") + resultSummary + runningTime, cStyle(errCount === 0 ? "green" : "red", true), "");
			return errCount;
		};
		if (hasProcess) nextTickish = process.nextTick;
else nextTickish = function fakeFastNextTick(next) {
			if (stack++ < 5e3) next();
else setTimeout(next, stack = 0);
		};
		return o$1;
	});
} });

//#endregion
//#region tests/contacts/ContactListEditorTest.ts
var import_ospec = __toESM(require_ospec(), 1);
import_ospec.default.spec("ContactListEditorModelTest", function() {
	let contactListEditorModel;
	import_ospec.default.beforeEach(() => {
		contactListEditorModel = new ContactListEditorModel([]);
	});
	import_ospec.default.spec("adding addresses", function() {
		(0, import_ospec.default)("adding address adds it to the address list", function() {
			const newEmail = "test@test.com";
			contactListEditorModel.addRecipient(newEmail);
			(0, import_ospec.default)(contactListEditorModel.newAddresses.length).equals(1);
			(0, import_ospec.default)(contactListEditorModel.newAddresses[0]).equals(newEmail);
		});
		(0, import_ospec.default)("adding address already in list does not add it to the address list", function() {
			const newEmail = "test@test.com";
			contactListEditorModel.addRecipient(newEmail);
			contactListEditorModel.addRecipient(newEmail);
			(0, import_ospec.default)(contactListEditorModel.newAddresses.length).equals(1);
			(0, import_ospec.default)(contactListEditorModel.newAddresses[0]).equals(newEmail);
		});
	});
	(0, import_ospec.default)("removing address removes address from address list", function() {
		const newEmail = "test@test.com";
		contactListEditorModel.addRecipient(newEmail);
		contactListEditorModel.addRecipient("test1@test.com");
		contactListEditorModel.addRecipient("test2@test.com");
		contactListEditorModel.removeRecipient(newEmail);
		(0, import_ospec.default)(contactListEditorModel.newAddresses.length).equals(2);
		(0, import_ospec.default)(contactListEditorModel.newAddresses.includes(newEmail)).equals(false);
	});
});

//#endregion
//#region tests/login/PostLoginUtilsTest.ts
var import_testdouble$9 = __toESM(require_testdouble(), 1);
dist_default.spec("PostLoginUtils", () => {
	dist_default.spec("shouldShowUpgradeReminder", () => {
		let userController;
		let customerInfo;
		let customerProperties;
		let customer;
		const date = new Date("2023-09-05");
		dist_default.beforeEach(() => {
			userController = (0, import_testdouble$9.object)();
			customerInfo = createTestEntity(CustomerInfoTypeRef, {});
			customerProperties = createTestEntity(CustomerPropertiesTypeRef, {});
			customer = createTestEntity(CustomerTypeRef);
			(0, import_testdouble$9.when)(userController.loadCustomerInfo()).thenResolve(customerInfo);
			(0, import_testdouble$9.when)(userController.loadCustomerProperties()).thenResolve(customerProperties);
			(0, import_testdouble$9.when)(userController.loadCustomer()).thenResolve(customer);
		});
		dist_default("should show for free accounts for the first time if they are old enough", async () => {
			customerInfo.creationTime = new Date(date.getTime() - Const.INITIAL_UPGRADE_REMINDER_INTERVAL_MS - 10);
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			customerProperties.lastUpgradeReminder = null;
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(true);
		});
		dist_default("should not show for free accounts for the first time if they are not old enough", async () => {
			customerInfo.creationTime = new Date(date.getTime() - Const.INITIAL_UPGRADE_REMINDER_INTERVAL_MS + 10);
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			customerProperties.lastUpgradeReminder = null;
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(false);
		});
		dist_default("should show for legacy paid accounts if reminder was never shown but the account is old enough", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(false);
			customerInfo.creationTime = new Date(date.getTime() - Const.INITIAL_UPGRADE_REMINDER_INTERVAL_MS - 10);
			customerProperties.lastUpgradeReminder = null;
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(true);
		});
		dist_default("SHOULD show for PRIVATE legacy paid accounts if enough time has passed", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(false);
			customerProperties.lastUpgradeReminder = new Date(date.getTime() - Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS - 10);
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(true);
		});
		dist_default("SHOULD NOT show for BUSINESS legacy paid accounts even if enough time has passed", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(false);
			customer.businessUse = true;
			customerProperties.lastUpgradeReminder = new Date(date.getTime() - Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS - 10);
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(false);
		});
		dist_default("should not show for legacy paid accounts if it has been reminded after the cutoff date", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(false);
			customerProperties.lastUpgradeReminder = new Date(reminderCutoffDate.getTime() + 10);
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(false);
		});
		dist_default("should not show for new paid accounts even if enough time has passed", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(true);
			customerProperties.lastUpgradeReminder = new Date(date.getTime() - Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS - 10);
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(false);
		});
		dist_default("should not show for non-admin users that would normally get shown because legacy", async () => {
			(0, import_testdouble$9.when)(userController.isFreeAccount()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isGlobalAdmin()).thenReturn(false);
			(0, import_testdouble$9.when)(userController.isPremiumAccount()).thenReturn(true);
			(0, import_testdouble$9.when)(userController.isNewPaidPlan()).thenResolve(false);
			customerProperties.lastUpgradeReminder = new Date(date.getTime() - Const.REPEATED_UPGRADE_REMINDER_INTERVAL_MS - 10);
			dist_default(await shouldShowUpgradeReminder(userController, date)).equals(false);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/KyberFacadeTest.ts
dist_default.spec("KyberFacade", function() {
	let kyberFacade$1;
	dist_default.before(async () => {
		kyberFacade$1 = new WASMKyberFacade(await loadLibOQSWASM());
	});
	dist_default("encoding roundtrip", async function() {
		const keyPair = await kyberFacade$1.generateKeypair();
		dist_default(bytesToKyberPublicKey(kyberPublicKeyToBytes(keyPair.publicKey))).deepEquals(keyPair.publicKey);
		dist_default(bytesToKyberPrivateKey(kyberPrivateKeyToBytes(keyPair.privateKey))).deepEquals(keyPair.privateKey);
	});
	dist_default("encryptionDecryptionRoundtrip", async function() {
		const keyPairBob = await kyberFacade$1.generateKeypair();
		const encapsulation = await kyberFacade$1.encapsulate(keyPairBob.publicKey);
		const sharedSecretAlice = encapsulation.sharedSecret;
		const sharedSecretBob = await kyberFacade$1.decapsulate(keyPairBob.privateKey, encapsulation.ciphertext);
		dist_default(sharedSecretAlice).deepEquals(sharedSecretBob);
	});
});

//#endregion
//#region ../node_modules/pako/dist/pako.esm.mjs
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
	let len = buf.length;
	while (--len >= 0) buf[len] = 0;
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = new Uint8Array([
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	1,
	1,
	1,
	1,
	2,
	2,
	2,
	2,
	3,
	3,
	3,
	3,
	4,
	4,
	4,
	4,
	5,
	5,
	5,
	5,
	0
]);
const extra_dbits = new Uint8Array([
	0,
	0,
	0,
	0,
	1,
	1,
	2,
	2,
	3,
	3,
	4,
	4,
	5,
	5,
	6,
	6,
	7,
	7,
	8,
	8,
	9,
	9,
	10,
	10,
	11,
	11,
	12,
	12,
	13,
	13
]);
const extra_blbits = new Uint8Array([
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	2,
	3,
	7
]);
const bl_order = new Uint8Array([
	16,
	17,
	18,
	0,
	8,
	7,
	9,
	6,
	10,
	5,
	11,
	4,
	12,
	3,
	13,
	2,
	14,
	1,
	15
]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
	this.static_tree = static_tree;
	this.extra_bits = extra_bits;
	this.extra_base = extra_base;
	this.elems = elems;
	this.max_length = max_length;
	this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
	this.dyn_tree = dyn_tree;
	this.max_code = 0;
	this.stat_desc = stat_desc;
}
const d_code = (dist) => {
	return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
	s.pending_buf[s.pending++] = w & 255;
	s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
	if (s.bi_valid > Buf_size - length) {
		s.bi_buf |= value << s.bi_valid & 65535;
		put_short(s, s.bi_buf);
		s.bi_buf = value >> Buf_size - s.bi_valid;
		s.bi_valid += length - Buf_size;
	} else {
		s.bi_buf |= value << s.bi_valid & 65535;
		s.bi_valid += length;
	}
};
const send_code = (s, c, tree) => {
	send_bits(
		s,
		tree[c * 2],
		tree[c * 2 + 1]
		/*.Len*/
);
};
const bi_reverse = (code, len) => {
	let res = 0;
	do {
		res |= code & 1;
		code >>>= 1;
		res <<= 1;
	} while (--len > 0);
	return res >>> 1;
};
const bi_flush = (s) => {
	if (s.bi_valid === 16) {
		put_short(s, s.bi_buf);
		s.bi_buf = 0;
		s.bi_valid = 0;
	} else if (s.bi_valid >= 8) {
		s.pending_buf[s.pending++] = s.bi_buf & 255;
		s.bi_buf >>= 8;
		s.bi_valid -= 8;
	}
};
const gen_bitlen = (s, desc) => {
	const tree = desc.dyn_tree;
	const max_code = desc.max_code;
	const stree = desc.stat_desc.static_tree;
	const has_stree = desc.stat_desc.has_stree;
	const extra = desc.stat_desc.extra_bits;
	const base = desc.stat_desc.extra_base;
	const max_length = desc.stat_desc.max_length;
	let h;
	let n, m;
	let bits;
	let xbits;
	let f;
	let overflow = 0;
	for (bits = 0; bits <= MAX_BITS$1; bits++) s.bl_count[bits] = 0;
	tree[s.heap[s.heap_max] * 2 + 1] = 0;
	for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
		n = s.heap[h];
		bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
		if (bits > max_length) {
			bits = max_length;
			overflow++;
		}
		tree[n * 2 + 1] = bits;
		if (n > max_code) continue;
		s.bl_count[bits]++;
		xbits = 0;
		if (n >= base) xbits = extra[n - base];
		f = tree[n * 2];
		s.opt_len += f * (bits + xbits);
		if (has_stree) s.static_len += f * (stree[n * 2 + 1] + xbits);
	}
	if (overflow === 0) return;
	do {
		bits = max_length - 1;
		while (s.bl_count[bits] === 0) bits--;
		s.bl_count[bits]--;
		s.bl_count[bits + 1] += 2;
		s.bl_count[max_length]--;
		overflow -= 2;
	} while (overflow > 0);
	for (bits = max_length; bits !== 0; bits--) {
		n = s.bl_count[bits];
		while (n !== 0) {
			m = s.heap[--h];
			if (m > max_code) continue;
			if (tree[m * 2 + 1] !== bits) {
				s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
				tree[m * 2 + 1] = bits;
			}
			n--;
		}
	}
};
const gen_codes = (tree, max_code, bl_count) => {
	const next_code = new Array(MAX_BITS$1 + 1);
	let code = 0;
	let bits;
	let n;
	for (bits = 1; bits <= MAX_BITS$1; bits++) {
		code = code + bl_count[bits - 1] << 1;
		next_code[bits] = code;
	}
	for (n = 0; n <= max_code; n++) {
		let len = tree[n * 2 + 1];
		if (len === 0) continue;
		tree[n * 2] = bi_reverse(next_code[len]++, len);
	}
};
const tr_static_init = () => {
	let n;
	let bits;
	let length;
	let code;
	let dist;
	const bl_count = new Array(MAX_BITS$1 + 1);
	length = 0;
	for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
		base_length[code] = length;
		for (n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
	}
	_length_code[length - 1] = code;
	dist = 0;
	for (code = 0; code < 16; code++) {
		base_dist[code] = dist;
		for (n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
	}
	dist >>= 7;
	for (; code < D_CODES$1; code++) {
		base_dist[code] = dist << 7;
		for (n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
	}
	for (bits = 0; bits <= MAX_BITS$1; bits++) bl_count[bits] = 0;
	n = 0;
	while (n <= 143) {
		static_ltree[n * 2 + 1] = 8;
		n++;
		bl_count[8]++;
	}
	while (n <= 255) {
		static_ltree[n * 2 + 1] = 9;
		n++;
		bl_count[9]++;
	}
	while (n <= 279) {
		static_ltree[n * 2 + 1] = 7;
		n++;
		bl_count[7]++;
	}
	while (n <= 287) {
		static_ltree[n * 2 + 1] = 8;
		n++;
		bl_count[8]++;
	}
	gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
	for (n = 0; n < D_CODES$1; n++) {
		static_dtree[n * 2 + 1] = 5;
		static_dtree[n * 2] = bi_reverse(n, 5);
	}
	static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
	static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
	static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
	let n;
	for (n = 0; n < L_CODES$1; n++) s.dyn_ltree[n * 2] = 0;
	for (n = 0; n < D_CODES$1; n++) s.dyn_dtree[n * 2] = 0;
	for (n = 0; n < BL_CODES$1; n++) s.bl_tree[n * 2] = 0;
	s.dyn_ltree[END_BLOCK * 2] = 1;
	s.opt_len = s.static_len = 0;
	s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
	if (s.bi_valid > 8) put_short(s, s.bi_buf);
else if (s.bi_valid > 0) s.pending_buf[s.pending++] = s.bi_buf;
	s.bi_buf = 0;
	s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) => {
	const _n2 = n * 2;
	const _m2 = m * 2;
	return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k) => {
	const v = s.heap[k];
	let j = k << 1;
	while (j <= s.heap_len) {
		if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) j++;
		if (smaller(tree, v, s.heap[j], s.depth)) break;
		s.heap[k] = s.heap[j];
		k = j;
		j <<= 1;
	}
	s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
	let dist;
	let lc;
	let sx = 0;
	let code;
	let extra;
	if (s.sym_next !== 0) do {
		dist = s.pending_buf[s.sym_buf + sx++] & 255;
		dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
		lc = s.pending_buf[s.sym_buf + sx++];
		if (dist === 0) send_code(s, lc, ltree);
else {
			code = _length_code[lc];
			send_code(s, code + LITERALS$1 + 1, ltree);
			extra = extra_lbits[code];
			if (extra !== 0) {
				lc -= base_length[code];
				send_bits(s, lc, extra);
			}
			dist--;
			code = d_code(dist);
			send_code(s, code, dtree);
			extra = extra_dbits[code];
			if (extra !== 0) {
				dist -= base_dist[code];
				send_bits(s, dist, extra);
			}
		}
	} while (sx < s.sym_next);
	send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
	const tree = desc.dyn_tree;
	const stree = desc.stat_desc.static_tree;
	const has_stree = desc.stat_desc.has_stree;
	const elems = desc.stat_desc.elems;
	let n, m;
	let max_code = -1;
	let node$1;
	s.heap_len = 0;
	s.heap_max = HEAP_SIZE$1;
	for (n = 0; n < elems; n++) if (tree[n * 2] !== 0) {
		s.heap[++s.heap_len] = max_code = n;
		s.depth[n] = 0;
	} else tree[n * 2 + 1] = 0;
	while (s.heap_len < 2) {
		node$1 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
		tree[node$1 * 2] = 1;
		s.depth[node$1] = 0;
		s.opt_len--;
		if (has_stree) s.static_len -= stree[node$1 * 2 + 1];
	}
	desc.max_code = max_code;
	for (n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
	node$1 = elems;
	do {
		/*** pqremove ***/
		n = s.heap[1];
		s.heap[1] = s.heap[s.heap_len--];
		pqdownheap(
			s,
			tree,
			1
			/*SMALLEST*/
);
		m = s.heap[1];
		s.heap[--s.heap_max] = n;
		s.heap[--s.heap_max] = m;
		tree[node$1 * 2] = tree[n * 2] + tree[m * 2];
		s.depth[node$1] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
		tree[n * 2 + 1] = tree[m * 2 + 1] = node$1;
		s.heap[1] = node$1++;
		pqdownheap(
			s,
			tree,
			1
			/*SMALLEST*/
);
	} while (s.heap_len >= 2);
	s.heap[--s.heap_max] = s.heap[1];
	gen_bitlen(s, desc);
	gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
	let n;
	let prevlen = -1;
	let curlen;
	let nextlen = tree[1];
	let count = 0;
	let max_count = 7;
	let min_count = 4;
	if (nextlen === 0) {
		max_count = 138;
		min_count = 3;
	}
	tree[(max_code + 1) * 2 + 1] = 65535;
	for (n = 0; n <= max_code; n++) {
		curlen = nextlen;
		nextlen = tree[(n + 1) * 2 + 1];
		if (++count < max_count && curlen === nextlen) continue;
else if (count < min_count) s.bl_tree[curlen * 2] += count;
else if (curlen !== 0) {
			if (curlen !== prevlen) s.bl_tree[curlen * 2]++;
			s.bl_tree[REP_3_6 * 2]++;
		} else if (count <= 10) s.bl_tree[REPZ_3_10 * 2]++;
else s.bl_tree[REPZ_11_138 * 2]++;
		count = 0;
		prevlen = curlen;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		} else if (curlen === nextlen) {
			max_count = 6;
			min_count = 3;
		} else {
			max_count = 7;
			min_count = 4;
		}
	}
};
const send_tree = (s, tree, max_code) => {
	let n;
	let prevlen = -1;
	let curlen;
	let nextlen = tree[1];
	let count = 0;
	let max_count = 7;
	let min_count = 4;
	if (nextlen === 0) {
		max_count = 138;
		min_count = 3;
	}
	for (n = 0; n <= max_code; n++) {
		curlen = nextlen;
		nextlen = tree[(n + 1) * 2 + 1];
		if (++count < max_count && curlen === nextlen) continue;
else if (count < min_count) do 
			send_code(s, curlen, s.bl_tree);
		while (--count !== 0);
else if (curlen !== 0) {
			if (curlen !== prevlen) {
				send_code(s, curlen, s.bl_tree);
				count--;
			}
			send_code(s, REP_3_6, s.bl_tree);
			send_bits(s, count - 3, 2);
		} else if (count <= 10) {
			send_code(s, REPZ_3_10, s.bl_tree);
			send_bits(s, count - 3, 3);
		} else {
			send_code(s, REPZ_11_138, s.bl_tree);
			send_bits(s, count - 11, 7);
		}
		count = 0;
		prevlen = curlen;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		} else if (curlen === nextlen) {
			max_count = 6;
			min_count = 3;
		} else {
			max_count = 7;
			min_count = 4;
		}
	}
};
const build_bl_tree = (s) => {
	let max_blindex;
	scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
	build_tree(s, s.bl_desc);
	for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) break;
	s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
	return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
	let rank$1;
	send_bits(s, lcodes - 257, 5);
	send_bits(s, dcodes - 1, 5);
	send_bits(s, blcodes - 4, 4);
	for (rank$1 = 0; rank$1 < blcodes; rank$1++) send_bits(s, s.bl_tree[bl_order[rank$1] * 2 + 1], 3);
	send_tree(s, s.dyn_ltree, lcodes - 1);
	send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
	let block_mask = 4093624447;
	let n;
	for (n = 0; n <= 31; n++, block_mask >>>= 1) if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) return Z_BINARY;
	if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0) return Z_TEXT;
	for (n = 32; n < LITERALS$1; n++) if (s.dyn_ltree[n * 2] !== 0) return Z_TEXT;
	return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
	if (!static_init_done) {
		tr_static_init();
		static_init_done = true;
	}
	s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
	s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
	s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
	s.bi_buf = 0;
	s.bi_valid = 0;
	init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last$1) => {
	send_bits(s, (STORED_BLOCK << 1) + (last$1 ? 1 : 0), 3);
	bi_windup(s);
	put_short(s, stored_len);
	put_short(s, ~stored_len);
	if (stored_len) s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
	s.pending += stored_len;
};
const _tr_align$1 = (s) => {
	send_bits(s, STATIC_TREES << 1, 3);
	send_code(s, END_BLOCK, static_ltree);
	bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last$1) => {
	let opt_lenb, static_lenb;
	let max_blindex = 0;
	if (s.level > 0) {
		if (s.strm.data_type === Z_UNKNOWN$1) s.strm.data_type = detect_data_type(s);
		build_tree(s, s.l_desc);
		build_tree(s, s.d_desc);
		max_blindex = build_bl_tree(s);
		opt_lenb = s.opt_len + 3 + 7 >>> 3;
		static_lenb = s.static_len + 3 + 7 >>> 3;
		if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
	} else opt_lenb = static_lenb = stored_len + 5;
	if (stored_len + 4 <= opt_lenb && buf !== -1) _tr_stored_block$1(s, buf, stored_len, last$1);
else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
		send_bits(s, (STATIC_TREES << 1) + (last$1 ? 1 : 0), 3);
		compress_block(s, static_ltree, static_dtree);
	} else {
		send_bits(s, (DYN_TREES << 1) + (last$1 ? 1 : 0), 3);
		send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
		compress_block(s, s.dyn_ltree, s.dyn_dtree);
	}
	init_block(s);
	if (last$1) bi_windup(s);
};
const _tr_tally$1 = (s, dist, lc) => {
	s.pending_buf[s.sym_buf + s.sym_next++] = dist;
	s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
	s.pending_buf[s.sym_buf + s.sym_next++] = lc;
	if (dist === 0) s.dyn_ltree[lc * 2]++;
else {
		s.matches++;
		dist--;
		s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
		s.dyn_dtree[d_code(dist) * 2]++;
	}
	return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
	let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
	while (len !== 0) {
		n = len > 2e3 ? 2e3 : len;
		len -= n;
		do {
			s1 = s1 + buf[pos++] | 0;
			s2 = s2 + s1 | 0;
		} while (--n);
		s1 %= 65521;
		s2 %= 65521;
	}
	return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
	let c, table = [];
	for (var n = 0; n < 256; n++) {
		c = n;
		for (var k = 0; k < 8; k++) c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
		table[n] = c;
	}
	return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
	const t = crcTable;
	const end = pos + len;
	crc ^= -1;
	for (let i = pos; i < end; i++) crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
	return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
	2: "need dictionary",
	1: "stream end",
	0: "",
	"-1": "file error",
	"-2": "stream error",
	"-3": "data error",
	"-4": "insufficient memory",
	"-5": "buffer error",
	"-6": "incompatible version"
};
var constants$2 = {
	Z_NO_FLUSH: 0,
	Z_PARTIAL_FLUSH: 1,
	Z_SYNC_FLUSH: 2,
	Z_FULL_FLUSH: 3,
	Z_FINISH: 4,
	Z_BLOCK: 5,
	Z_TREES: 6,
	Z_OK: 0,
	Z_STREAM_END: 1,
	Z_NEED_DICT: 2,
	Z_ERRNO: -1,
	Z_STREAM_ERROR: -2,
	Z_DATA_ERROR: -3,
	Z_MEM_ERROR: -4,
	Z_BUF_ERROR: -5,
	Z_NO_COMPRESSION: 0,
	Z_BEST_SPEED: 1,
	Z_BEST_COMPRESSION: 9,
	Z_DEFAULT_COMPRESSION: -1,
	Z_FILTERED: 1,
	Z_HUFFMAN_ONLY: 2,
	Z_RLE: 3,
	Z_FIXED: 4,
	Z_DEFAULT_STRATEGY: 0,
	Z_BINARY: 0,
	Z_TEXT: 1,
	Z_UNKNOWN: 2,
	Z_DEFLATED: 8
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
	strm.msg = messages[errorCode];
	return errorCode;
};
const rank = (f) => {
	return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
	let len = buf.length;
	while (--len >= 0) buf[len] = 0;
};
const slide_hash = (s) => {
	let n, m;
	let p;
	let wsize = s.w_size;
	n = s.hash_size;
	p = n;
	do {
		m = s.head[--p];
		s.head[p] = m >= wsize ? m - wsize : 0;
	} while (--n);
	n = wsize;
	p = n;
	do {
		m = s.prev[--p];
		s.prev[p] = m >= wsize ? m - wsize : 0;
	} while (--n);
};
let HASH_ZLIB = (s, prev, data$1) => (prev << s.hash_shift ^ data$1) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
	const s = strm.state;
	let len = s.pending;
	if (len > strm.avail_out) len = strm.avail_out;
	if (len === 0) return;
	strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
	strm.next_out += len;
	s.pending_out += len;
	strm.total_out += len;
	strm.avail_out -= len;
	s.pending -= len;
	if (s.pending === 0) s.pending_out = 0;
};
const flush_block_only = (s, last$1) => {
	_tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last$1);
	s.block_start = s.strstart;
	flush_pending(s.strm);
};
const put_byte = (s, b) => {
	s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
	s.pending_buf[s.pending++] = b >>> 8 & 255;
	s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
	let len = strm.avail_in;
	if (len > size) len = size;
	if (len === 0) return 0;
	strm.avail_in -= len;
	buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
	if (strm.state.wrap === 1) strm.adler = adler32_1(strm.adler, buf, len, start);
else if (strm.state.wrap === 2) strm.adler = crc32_1(strm.adler, buf, len, start);
	strm.next_in += len;
	strm.total_in += len;
	return len;
};
const longest_match = (s, cur_match) => {
	let chain_length = s.max_chain_length;
	let scan = s.strstart;
	let match;
	let len;
	let best_len = s.prev_length;
	let nice_match = s.nice_match;
	const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
	const _win = s.window;
	const wmask = s.w_mask;
	const prev = s.prev;
	const strend = s.strstart + MAX_MATCH;
	let scan_end1 = _win[scan + best_len - 1];
	let scan_end = _win[scan + best_len];
	if (s.prev_length >= s.good_match) chain_length >>= 2;
	if (nice_match > s.lookahead) nice_match = s.lookahead;
	do {
		match = cur_match;
		if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) continue;
		scan += 2;
		match++;
		do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
		len = MAX_MATCH - (strend - scan);
		scan = strend - MAX_MATCH;
		if (len > best_len) {
			s.match_start = cur_match;
			best_len = len;
			if (len >= nice_match) break;
			scan_end1 = _win[scan + best_len - 1];
			scan_end = _win[scan + best_len];
		}
	} while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
	if (best_len <= s.lookahead) return best_len;
	return s.lookahead;
};
const fill_window = (s) => {
	const _w_size = s.w_size;
	let n, more, str;
	do {
		more = s.window_size - s.lookahead - s.strstart;
		if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
			s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
			s.match_start -= _w_size;
			s.strstart -= _w_size;
			s.block_start -= _w_size;
			if (s.insert > s.strstart) s.insert = s.strstart;
			slide_hash(s);
			more += _w_size;
		}
		if (s.strm.avail_in === 0) break;
		n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
		s.lookahead += n;
		if (s.lookahead + s.insert >= MIN_MATCH) {
			str = s.strstart - s.insert;
			s.ins_h = s.window[str];
			s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
			while (s.insert) {
				s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
				s.prev[str & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = str;
				str++;
				s.insert--;
				if (s.lookahead + s.insert < MIN_MATCH) break;
			}
		}
	} while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
	let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
	let len, left, have, last$1 = 0;
	let used = s.strm.avail_in;
	do {
		len = 65535;
		have = s.bi_valid + 42 >> 3;
		if (s.strm.avail_out < have) break;
		have = s.strm.avail_out - have;
		left = s.strstart - s.block_start;
		if (len > left + s.strm.avail_in) len = left + s.strm.avail_in;
		if (len > have) len = have;
		if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) break;
		last$1 = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
		_tr_stored_block(s, 0, 0, last$1);
		s.pending_buf[s.pending - 4] = len;
		s.pending_buf[s.pending - 3] = len >> 8;
		s.pending_buf[s.pending - 2] = ~len;
		s.pending_buf[s.pending - 1] = ~len >> 8;
		flush_pending(s.strm);
		if (left) {
			if (left > len) left = len;
			s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
			s.strm.next_out += left;
			s.strm.avail_out -= left;
			s.strm.total_out += left;
			s.block_start += left;
			len -= left;
		}
		if (len) {
			read_buf(s.strm, s.strm.output, s.strm.next_out, len);
			s.strm.next_out += len;
			s.strm.avail_out -= len;
			s.strm.total_out += len;
		}
	} while (last$1 === 0);
	used -= s.strm.avail_in;
	if (used) {
		if (used >= s.w_size) {
			s.matches = 2;
			s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
			s.strstart = s.w_size;
			s.insert = s.strstart;
		} else {
			if (s.window_size - s.strstart <= used) {
				s.strstart -= s.w_size;
				s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
				if (s.matches < 2) s.matches++;
				if (s.insert > s.strstart) s.insert = s.strstart;
			}
			s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
			s.strstart += used;
			s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
		}
		s.block_start = s.strstart;
	}
	if (s.high_water < s.strstart) s.high_water = s.strstart;
	if (last$1) return BS_FINISH_DONE;
	if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) return BS_BLOCK_DONE;
	have = s.window_size - s.strstart;
	if (s.strm.avail_in > have && s.block_start >= s.w_size) {
		s.block_start -= s.w_size;
		s.strstart -= s.w_size;
		s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
		if (s.matches < 2) s.matches++;
		have += s.w_size;
		if (s.insert > s.strstart) s.insert = s.strstart;
	}
	if (have > s.strm.avail_in) have = s.strm.avail_in;
	if (have) {
		read_buf(s.strm, s.window, s.strstart, have);
		s.strstart += have;
		s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
	}
	if (s.high_water < s.strstart) s.high_water = s.strstart;
	have = s.bi_valid + 42 >> 3;
	have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
	min_block = have > s.w_size ? s.w_size : have;
	left = s.strstart - s.block_start;
	if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
		len = left > have ? have : left;
		last$1 = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
		_tr_stored_block(s, s.block_start, len, last$1);
		s.block_start += len;
		flush_pending(s.strm);
	}
	return last$1 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
	let hash_head;
	let bflush;
	for (;;) {
		if (s.lookahead < MIN_LOOKAHEAD) {
			fill_window(s);
			if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
			if (s.lookahead === 0) break;
		}
		hash_head = 0;
		if (s.lookahead >= MIN_MATCH) {
			/*** INSERT_STRING(s, s.strstart, hash_head); ***/
			s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
			hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
			s.head[s.ins_h] = s.strstart;
		}
		if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) s.match_length = longest_match(s, hash_head);
		if (s.match_length >= MIN_MATCH) {
			/*** _tr_tally_dist(s, s.strstart - s.match_start,
			s.match_length - MIN_MATCH, bflush); ***/
			bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
			s.lookahead -= s.match_length;
			if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
				s.match_length--;
				do {
					s.strstart++;
					/*** INSERT_STRING(s, s.strstart, hash_head); ***/
					s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
					hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
					s.head[s.ins_h] = s.strstart;
				} while (--s.match_length !== 0);
				s.strstart++;
			} else {
				s.strstart += s.match_length;
				s.match_length = 0;
				s.ins_h = s.window[s.strstart];
				s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
			}
		} else {
			/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
			bflush = _tr_tally(s, 0, s.window[s.strstart]);
			s.lookahead--;
			s.strstart++;
		}
		if (bflush) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
	}
	s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	if (flush === Z_FINISH$3) {
		/*** FLUSH_BLOCK(s, 1); ***/
		flush_block_only(s, true);
		if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
		return BS_FINISH_DONE;
	}
	if (s.sym_next) {
		/*** FLUSH_BLOCK(s, 0); ***/
		flush_block_only(s, false);
		if (s.strm.avail_out === 0) return BS_NEED_MORE;
	}
	return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
	let hash_head;
	let bflush;
	let max_insert;
	for (;;) {
		if (s.lookahead < MIN_LOOKAHEAD) {
			fill_window(s);
			if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
			if (s.lookahead === 0) break;
		}
		hash_head = 0;
		if (s.lookahead >= MIN_MATCH) {
			/*** INSERT_STRING(s, s.strstart, hash_head); ***/
			s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
			hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
			s.head[s.ins_h] = s.strstart;
		}
		s.prev_length = s.match_length;
		s.prev_match = s.match_start;
		s.match_length = MIN_MATCH - 1;
		if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
			s.match_length = longest_match(s, hash_head);
			if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) s.match_length = MIN_MATCH - 1;
		}
		if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
			max_insert = s.strstart + s.lookahead - MIN_MATCH;
			/***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
			s.prev_length - MIN_MATCH, bflush);***/
			bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
			s.lookahead -= s.prev_length - 1;
			s.prev_length -= 2;
			do 
				if (++s.strstart <= max_insert) {
					/*** INSERT_STRING(s, s.strstart, hash_head); ***/
					s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
					hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
					s.head[s.ins_h] = s.strstart;
				}
			while (--s.prev_length !== 0);
			s.match_available = 0;
			s.match_length = MIN_MATCH - 1;
			s.strstart++;
			if (bflush) {
				/*** FLUSH_BLOCK(s, 0); ***/
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		} else if (s.match_available) {
			/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
			bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
			if (bflush)
 /*** FLUSH_BLOCK_ONLY(s, 0) ***/
			flush_block_only(s, false);
			s.strstart++;
			s.lookahead--;
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		} else {
			s.match_available = 1;
			s.strstart++;
			s.lookahead--;
		}
	}
	if (s.match_available) {
		/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
		bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
		s.match_available = 0;
	}
	s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
	if (flush === Z_FINISH$3) {
		/*** FLUSH_BLOCK(s, 1); ***/
		flush_block_only(s, true);
		if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
		return BS_FINISH_DONE;
	}
	if (s.sym_next) {
		/*** FLUSH_BLOCK(s, 0); ***/
		flush_block_only(s, false);
		if (s.strm.avail_out === 0) return BS_NEED_MORE;
	}
	return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
	let bflush;
	let prev;
	let scan, strend;
	const _win = s.window;
	for (;;) {
		if (s.lookahead <= MAX_MATCH) {
			fill_window(s);
			if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
			if (s.lookahead === 0) break;
		}
		s.match_length = 0;
		if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
			scan = s.strstart - 1;
			prev = _win[scan];
			if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
				strend = s.strstart + MAX_MATCH;
				do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
				s.match_length = MAX_MATCH - (strend - scan);
				if (s.match_length > s.lookahead) s.match_length = s.lookahead;
			}
		}
		if (s.match_length >= MIN_MATCH) {
			/*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
			bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
			s.lookahead -= s.match_length;
			s.strstart += s.match_length;
			s.match_length = 0;
		} else {
			/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
			bflush = _tr_tally(s, 0, s.window[s.strstart]);
			s.lookahead--;
			s.strstart++;
		}
		if (bflush) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
	}
	s.insert = 0;
	if (flush === Z_FINISH$3) {
		/*** FLUSH_BLOCK(s, 1); ***/
		flush_block_only(s, true);
		if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
		return BS_FINISH_DONE;
	}
	if (s.sym_next) {
		/*** FLUSH_BLOCK(s, 0); ***/
		flush_block_only(s, false);
		if (s.strm.avail_out === 0) return BS_NEED_MORE;
	}
	return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
	let bflush;
	for (;;) {
		if (s.lookahead === 0) {
			fill_window(s);
			if (s.lookahead === 0) {
				if (flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
				break;
			}
		}
		s.match_length = 0;
		/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
		bflush = _tr_tally(s, 0, s.window[s.strstart]);
		s.lookahead--;
		s.strstart++;
		if (bflush) {
			/*** FLUSH_BLOCK(s, 0); ***/
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
	}
	s.insert = 0;
	if (flush === Z_FINISH$3) {
		/*** FLUSH_BLOCK(s, 1); ***/
		flush_block_only(s, true);
		if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
		return BS_FINISH_DONE;
	}
	if (s.sym_next) {
		/*** FLUSH_BLOCK(s, 0); ***/
		flush_block_only(s, false);
		if (s.strm.avail_out === 0) return BS_NEED_MORE;
	}
	return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func$10) {
	this.good_length = good_length;
	this.max_lazy = max_lazy;
	this.nice_length = nice_length;
	this.max_chain = max_chain;
	this.func = func$10;
}
const configuration_table = [
	new Config(0, 0, 0, 0, deflate_stored),
	new Config(4, 4, 8, 4, deflate_fast),
	new Config(4, 5, 16, 8, deflate_fast),
	new Config(4, 6, 32, 32, deflate_fast),
	new Config(4, 4, 16, 16, deflate_slow),
	new Config(8, 16, 32, 32, deflate_slow),
	new Config(8, 16, 128, 128, deflate_slow),
	new Config(8, 32, 128, 256, deflate_slow),
	new Config(32, 128, 258, 1024, deflate_slow),
	new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s) => {
	s.window_size = 2 * s.w_size;
	/*** CLEAR_HASH(s); ***/
	zero(s.head);
	s.max_lazy_match = configuration_table[s.level].max_lazy;
	s.good_match = configuration_table[s.level].good_length;
	s.nice_match = configuration_table[s.level].nice_length;
	s.max_chain_length = configuration_table[s.level].max_chain;
	s.strstart = 0;
	s.block_start = 0;
	s.lookahead = 0;
	s.insert = 0;
	s.match_length = s.prev_length = MIN_MATCH - 1;
	s.match_available = 0;
	s.ins_h = 0;
};
function DeflateState() {
	this.strm = null;
	this.status = 0;
	this.pending_buf = null;
	this.pending_buf_size = 0;
	this.pending_out = 0;
	this.pending = 0;
	this.wrap = 0;
	this.gzhead = null;
	this.gzindex = 0;
	this.method = Z_DEFLATED$2;
	this.last_flush = -1;
	this.w_size = 0;
	this.w_bits = 0;
	this.w_mask = 0;
	this.window = null;
	this.window_size = 0;
	this.prev = null;
	this.head = null;
	this.ins_h = 0;
	this.hash_size = 0;
	this.hash_bits = 0;
	this.hash_mask = 0;
	this.hash_shift = 0;
	this.block_start = 0;
	this.match_length = 0;
	this.prev_match = 0;
	this.match_available = 0;
	this.strstart = 0;
	this.match_start = 0;
	this.lookahead = 0;
	this.prev_length = 0;
	this.max_chain_length = 0;
	this.max_lazy_match = 0;
	this.level = 0;
	this.strategy = 0;
	this.good_match = 0;
	this.nice_match = 0;
	this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
	this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
	this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
	zero(this.dyn_ltree);
	zero(this.dyn_dtree);
	zero(this.bl_tree);
	this.l_desc = null;
	this.d_desc = null;
	this.bl_desc = null;
	this.bl_count = new Uint16Array(MAX_BITS + 1);
	this.heap = new Uint16Array(2 * L_CODES + 1);
	zero(this.heap);
	this.heap_len = 0;
	this.heap_max = 0;
	this.depth = new Uint16Array(2 * L_CODES + 1);
	zero(this.depth);
	this.sym_buf = 0;
	this.lit_bufsize = 0;
	this.sym_next = 0;
	this.sym_end = 0;
	this.opt_len = 0;
	this.static_len = 0;
	this.matches = 0;
	this.insert = 0;
	this.bi_buf = 0;
	this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
	if (!strm) return 1;
	const s = strm.state;
	if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) return 1;
	return 0;
};
const deflateResetKeep = (strm) => {
	if (deflateStateCheck(strm)) return err(strm, Z_STREAM_ERROR$2);
	strm.total_in = strm.total_out = 0;
	strm.data_type = Z_UNKNOWN;
	const s = strm.state;
	s.pending = 0;
	s.pending_out = 0;
	if (s.wrap < 0) s.wrap = -s.wrap;
	s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
	strm.adler = s.wrap === 2 ? 0 : 1;
	s.last_flush = -2;
	_tr_init(s);
	return Z_OK$3;
};
const deflateReset = (strm) => {
	const ret = deflateResetKeep(strm);
	if (ret === Z_OK$3) lm_init(strm.state);
	return ret;
};
const deflateSetHeader = (strm, head) => {
	if (deflateStateCheck(strm) || strm.state.wrap !== 2) return Z_STREAM_ERROR$2;
	strm.state.gzhead = head;
	return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
	if (!strm) return Z_STREAM_ERROR$2;
	let wrap = 1;
	if (level === Z_DEFAULT_COMPRESSION$1) level = 6;
	if (windowBits < 0) {
		wrap = 0;
		windowBits = -windowBits;
	} else if (windowBits > 15) {
		wrap = 2;
		windowBits -= 16;
	}
	if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) return err(strm, Z_STREAM_ERROR$2);
	if (windowBits === 8) windowBits = 9;
	const s = new DeflateState();
	strm.state = s;
	s.strm = strm;
	s.status = INIT_STATE;
	s.wrap = wrap;
	s.gzhead = null;
	s.w_bits = windowBits;
	s.w_size = 1 << s.w_bits;
	s.w_mask = s.w_size - 1;
	s.hash_bits = memLevel + 7;
	s.hash_size = 1 << s.hash_bits;
	s.hash_mask = s.hash_size - 1;
	s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
	s.window = new Uint8Array(s.w_size * 2);
	s.head = new Uint16Array(s.hash_size);
	s.prev = new Uint16Array(s.w_size);
	s.lit_bufsize = 1 << memLevel + 6;
	s.pending_buf_size = s.lit_bufsize * 4;
	s.pending_buf = new Uint8Array(s.pending_buf_size);
	s.sym_buf = s.lit_bufsize;
	s.sym_end = (s.lit_bufsize - 1) * 3;
	s.level = level;
	s.strategy = strategy;
	s.method = method;
	return deflateReset(strm);
};
const deflateInit = (strm, level) => {
	return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
	if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
	const s = strm.state;
	if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
	const old_flush = s.last_flush;
	s.last_flush = flush;
	if (s.pending !== 0) {
		flush_pending(strm);
		if (strm.avail_out === 0) {
			s.last_flush = -1;
			return Z_OK$3;
		}
	} else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) return err(strm, Z_BUF_ERROR$1);
	if (s.status === FINISH_STATE && strm.avail_in !== 0) return err(strm, Z_BUF_ERROR$1);
	if (s.status === INIT_STATE && s.wrap === 0) s.status = BUSY_STATE;
	if (s.status === INIT_STATE) {
		let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
		let level_flags = -1;
		if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) level_flags = 0;
else if (s.level < 6) level_flags = 1;
else if (s.level === 6) level_flags = 2;
else level_flags = 3;
		header |= level_flags << 6;
		if (s.strstart !== 0) header |= PRESET_DICT;
		header += 31 - header % 31;
		putShortMSB(s, header);
		if (s.strstart !== 0) {
			putShortMSB(s, strm.adler >>> 16);
			putShortMSB(s, strm.adler & 65535);
		}
		strm.adler = 1;
		s.status = BUSY_STATE;
		flush_pending(strm);
		if (s.pending !== 0) {
			s.last_flush = -1;
			return Z_OK$3;
		}
	}
	if (s.status === GZIP_STATE) {
		strm.adler = 0;
		put_byte(s, 31);
		put_byte(s, 139);
		put_byte(s, 8);
		if (!s.gzhead) {
			put_byte(s, 0);
			put_byte(s, 0);
			put_byte(s, 0);
			put_byte(s, 0);
			put_byte(s, 0);
			put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
			put_byte(s, OS_CODE);
			s.status = BUSY_STATE;
			flush_pending(strm);
			if (s.pending !== 0) {
				s.last_flush = -1;
				return Z_OK$3;
			}
		} else {
			put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
			put_byte(s, s.gzhead.time & 255);
			put_byte(s, s.gzhead.time >> 8 & 255);
			put_byte(s, s.gzhead.time >> 16 & 255);
			put_byte(s, s.gzhead.time >> 24 & 255);
			put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
			put_byte(s, s.gzhead.os & 255);
			if (s.gzhead.extra && s.gzhead.extra.length) {
				put_byte(s, s.gzhead.extra.length & 255);
				put_byte(s, s.gzhead.extra.length >> 8 & 255);
			}
			if (s.gzhead.hcrc) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
			s.gzindex = 0;
			s.status = EXTRA_STATE;
		}
	}
	if (s.status === EXTRA_STATE) {
		if (s.gzhead.extra) {
			let beg = s.pending;
			let left = (s.gzhead.extra.length & 65535) - s.gzindex;
			while (s.pending + left > s.pending_buf_size) {
				let copy = s.pending_buf_size - s.pending;
				s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
				s.pending = s.pending_buf_size;
				if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
				s.gzindex += copy;
				flush_pending(strm);
				if (s.pending !== 0) {
					s.last_flush = -1;
					return Z_OK$3;
				}
				beg = 0;
				left -= copy;
			}
			let gzhead_extra = new Uint8Array(s.gzhead.extra);
			s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
			s.pending += left;
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
			s.gzindex = 0;
		}
		s.status = NAME_STATE;
	}
	if (s.status === NAME_STATE) {
		if (s.gzhead.name) {
			let beg = s.pending;
			let val;
			do {
				if (s.pending === s.pending_buf_size) {
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
					flush_pending(strm);
					if (s.pending !== 0) {
						s.last_flush = -1;
						return Z_OK$3;
					}
					beg = 0;
				}
				if (s.gzindex < s.gzhead.name.length) val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
else val = 0;
				put_byte(s, val);
			} while (val !== 0);
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
			s.gzindex = 0;
		}
		s.status = COMMENT_STATE;
	}
	if (s.status === COMMENT_STATE) {
		if (s.gzhead.comment) {
			let beg = s.pending;
			let val;
			do {
				if (s.pending === s.pending_buf_size) {
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
					flush_pending(strm);
					if (s.pending !== 0) {
						s.last_flush = -1;
						return Z_OK$3;
					}
					beg = 0;
				}
				if (s.gzindex < s.gzhead.comment.length) val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
else val = 0;
				put_byte(s, val);
			} while (val !== 0);
			if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
		}
		s.status = HCRC_STATE;
	}
	if (s.status === HCRC_STATE) {
		if (s.gzhead.hcrc) {
			if (s.pending + 2 > s.pending_buf_size) {
				flush_pending(strm);
				if (s.pending !== 0) {
					s.last_flush = -1;
					return Z_OK$3;
				}
			}
			put_byte(s, strm.adler & 255);
			put_byte(s, strm.adler >> 8 & 255);
			strm.adler = 0;
		}
		s.status = BUSY_STATE;
		flush_pending(strm);
		if (s.pending !== 0) {
			s.last_flush = -1;
			return Z_OK$3;
		}
	}
	if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
		let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
		if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) s.status = FINISH_STATE;
		if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
			if (strm.avail_out === 0) s.last_flush = -1;
			return Z_OK$3;
		}
		if (bstate === BS_BLOCK_DONE) {
			if (flush === Z_PARTIAL_FLUSH) _tr_align(s);
else if (flush !== Z_BLOCK$1) {
				_tr_stored_block(s, 0, 0, false);
				if (flush === Z_FULL_FLUSH$1) {
					/*** CLEAR_HASH(s); ***/ zero(s.head);
					if (s.lookahead === 0) {
						s.strstart = 0;
						s.block_start = 0;
						s.insert = 0;
					}
				}
			}
			flush_pending(strm);
			if (strm.avail_out === 0) {
				s.last_flush = -1;
				return Z_OK$3;
			}
		}
	}
	if (flush !== Z_FINISH$3) return Z_OK$3;
	if (s.wrap <= 0) return Z_STREAM_END$3;
	if (s.wrap === 2) {
		put_byte(s, strm.adler & 255);
		put_byte(s, strm.adler >> 8 & 255);
		put_byte(s, strm.adler >> 16 & 255);
		put_byte(s, strm.adler >> 24 & 255);
		put_byte(s, strm.total_in & 255);
		put_byte(s, strm.total_in >> 8 & 255);
		put_byte(s, strm.total_in >> 16 & 255);
		put_byte(s, strm.total_in >> 24 & 255);
	} else {
		putShortMSB(s, strm.adler >>> 16);
		putShortMSB(s, strm.adler & 65535);
	}
	flush_pending(strm);
	if (s.wrap > 0) s.wrap = -s.wrap;
	return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
	if (deflateStateCheck(strm)) return Z_STREAM_ERROR$2;
	const status = strm.state.status;
	strm.state = null;
	return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
	let dictLength = dictionary.length;
	if (deflateStateCheck(strm)) return Z_STREAM_ERROR$2;
	const s = strm.state;
	const wrap = s.wrap;
	if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR$2;
	if (wrap === 1) strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
	s.wrap = 0;
	if (dictLength >= s.w_size) {
		if (wrap === 0) {
			/*** CLEAR_HASH(s); ***/
			zero(s.head);
			s.strstart = 0;
			s.block_start = 0;
			s.insert = 0;
		}
		let tmpDict = new Uint8Array(s.w_size);
		tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
		dictionary = tmpDict;
		dictLength = s.w_size;
	}
	const avail = strm.avail_in;
	const next = strm.next_in;
	const input = strm.input;
	strm.avail_in = dictLength;
	strm.next_in = 0;
	strm.input = dictionary;
	fill_window(s);
	while (s.lookahead >= MIN_MATCH) {
		let str = s.strstart;
		let n = s.lookahead - (MIN_MATCH - 1);
		do {
			s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
			s.prev[str & s.w_mask] = s.head[s.ins_h];
			s.head[s.ins_h] = str;
			str++;
		} while (--n);
		s.strstart = str;
		s.lookahead = MIN_MATCH - 1;
		fill_window(s);
	}
	s.strstart += s.lookahead;
	s.block_start = s.strstart;
	s.insert = s.lookahead;
	s.lookahead = 0;
	s.match_length = s.prev_length = MIN_MATCH - 1;
	s.match_available = 0;
	strm.next_in = next;
	strm.input = input;
	strm.avail_in = avail;
	s.wrap = wrap;
	return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo
};
const _has = (obj, key) => {
	return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
	const sources = Array.prototype.slice.call(arguments, 1);
	while (sources.length) {
		const source = sources.shift();
		if (!source) continue;
		if (typeof source !== "object") throw new TypeError(source + "must be non-object");
		for (const p in source) if (_has(source, p)) obj[p] = source[p];
	}
	return obj;
};
var flattenChunks = (chunks) => {
	let len = 0;
	for (let i = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
	const result = new Uint8Array(len);
	for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
		let chunk = chunks[i];
		result.set(chunk, pos);
		pos += chunk.length;
	}
	return result;
};
var common = {
	assign,
	flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
	String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
	STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
	if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(str);
	let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
	for (m_pos = 0; m_pos < str_len; m_pos++) {
		c = str.charCodeAt(m_pos);
		if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
			c2 = str.charCodeAt(m_pos + 1);
			if ((c2 & 64512) === 56320) {
				c = 65536 + (c - 55296 << 10) + (c2 - 56320);
				m_pos++;
			}
		}
		buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
	}
	buf = new Uint8Array(buf_len);
	for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
		c = str.charCodeAt(m_pos);
		if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
			c2 = str.charCodeAt(m_pos + 1);
			if ((c2 & 64512) === 56320) {
				c = 65536 + (c - 55296 << 10) + (c2 - 56320);
				m_pos++;
			}
		}
		if (c < 128) buf[i++] = c;
else if (c < 2048) {
			buf[i++] = 192 | c >>> 6;
			buf[i++] = 128 | c & 63;
		} else if (c < 65536) {
			buf[i++] = 224 | c >>> 12;
			buf[i++] = 128 | c >>> 6 & 63;
			buf[i++] = 128 | c & 63;
		} else {
			buf[i++] = 240 | c >>> 18;
			buf[i++] = 128 | c >>> 12 & 63;
			buf[i++] = 128 | c >>> 6 & 63;
			buf[i++] = 128 | c & 63;
		}
	}
	return buf;
};
const buf2binstring = (buf, len) => {
	if (len < 65534) {
		if (buf.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
	}
	let result = "";
	for (let i = 0; i < len; i++) result += String.fromCharCode(buf[i]);
	return result;
};
var buf2string = (buf, max) => {
	const len = max || buf.length;
	if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(buf.subarray(0, max));
	let i, out;
	const utf16buf = new Array(len * 2);
	for (out = 0, i = 0; i < len;) {
		let c = buf[i++];
		if (c < 128) {
			utf16buf[out++] = c;
			continue;
		}
		let c_len = _utf8len[c];
		if (c_len > 4) {
			utf16buf[out++] = 65533;
			i += c_len - 1;
			continue;
		}
		c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
		while (c_len > 1 && i < len) {
			c = c << 6 | buf[i++] & 63;
			c_len--;
		}
		if (c_len > 1) {
			utf16buf[out++] = 65533;
			continue;
		}
		if (c < 65536) utf16buf[out++] = c;
else {
			c -= 65536;
			utf16buf[out++] = 55296 | c >> 10 & 1023;
			utf16buf[out++] = 56320 | c & 1023;
		}
	}
	return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
	max = max || buf.length;
	if (max > buf.length) max = buf.length;
	let pos = max - 1;
	while (pos >= 0 && (buf[pos] & 192) === 128) pos--;
	if (pos < 0) return max;
	if (pos === 0) return max;
	return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
	string2buf,
	buf2string,
	utf8border
};
function ZStream() {
	this.input = null;
	this.next_in = 0;
	this.avail_in = 0;
	this.total_in = 0;
	this.output = null;
	this.next_out = 0;
	this.avail_out = 0;
	this.total_out = 0;
	this.msg = "";
	this.state = null;
	this.data_type = 2;
	this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2;
/**
* class Deflate
*
* Generic JS-style wrapper for zlib calls. If you don't need
* streaming behaviour - use more simple functions: [[deflate]],
* [[deflateRaw]] and [[gzip]].
**/
/**
* Deflate.result -> Uint8Array
*
* Compressed result, generated by default [[Deflate#onData]]
* and [[Deflate#onEnd]] handlers. Filled after you push last chunk
* (call [[Deflate#push]] with `Z_FINISH` / `true` param).
**/
/**
* Deflate.err -> Number
*
* Error code after deflate finished. 0 (Z_OK) on success.
* You will not need it in real life, because deflate errors
* are possible only on wrong options or bad `onData` / `onEnd`
* custom handlers.
**/
/**
* Deflate.msg -> String
*
* Error message, if [[Deflate.err]] != 0
**/
/**
* new Deflate(options)
* - options (Object): zlib deflate options.
*
* Creates new deflator instance with specified params. Throws exception
* on bad params. Supported options:
*
* - `level`
* - `windowBits`
* - `memLevel`
* - `strategy`
* - `dictionary`
*
* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
* for more information on these.
*
* Additional options, for internal needs:
*
* - `chunkSize` - size of generated data chunks (16K by default)
* - `raw` (Boolean) - do raw deflate
* - `gzip` (Boolean) - create gzip wrapper
* - `header` (Object) - custom header for gzip
*   - `text` (Boolean) - true if compressed data believed to be text
*   - `time` (Number) - modification time, unix timestamp
*   - `os` (Number) - operation system code
*   - `extra` (Array) - array of bytes with extra data (max 65536)
*   - `name` (String) - file name (binary string)
*   - `comment` (String) - comment (binary string)
*   - `hcrc` (Boolean) - true if header crc should be added
*
* ##### Example:
*
* ```javascript
* const pako = require('pako')
*   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
*   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
*
* const deflate = new pako.Deflate({ level: 3});
*
* deflate.push(chunk1, false);
* deflate.push(chunk2, true);  // true -> last chunk
*
* if (deflate.err) { throw new Error(deflate.err); }
*
* console.log(deflate.result);
* ```
**/
function Deflate$1(options) {
	this.options = common.assign({
		level: Z_DEFAULT_COMPRESSION,
		method: Z_DEFLATED$1,
		chunkSize: 16384,
		windowBits: 15,
		memLevel: 8,
		strategy: Z_DEFAULT_STRATEGY
	}, options || {});
	let opt = this.options;
	if (opt.raw && opt.windowBits > 0) opt.windowBits = -opt.windowBits;
else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) opt.windowBits += 16;
	this.err = 0;
	this.msg = "";
	this.ended = false;
	this.chunks = [];
	this.strm = new zstream();
	this.strm.avail_out = 0;
	let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
	if (status !== Z_OK$2) throw new Error(messages[status]);
	if (opt.header) deflate_1$2.deflateSetHeader(this.strm, opt.header);
	if (opt.dictionary) {
		let dict;
		if (typeof opt.dictionary === "string") dict = strings.string2buf(opt.dictionary);
else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") dict = new Uint8Array(opt.dictionary);
else dict = opt.dictionary;
		status = deflate_1$2.deflateSetDictionary(this.strm, dict);
		if (status !== Z_OK$2) throw new Error(messages[status]);
		this._dict_set = true;
	}
}
/**
* Deflate#push(data[, flush_mode]) -> Boolean
* - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
*   converted to utf8 byte sequence.
* - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
*   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
*
* Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
* new compressed chunks. Returns `true` on success. The last data block must
* have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
* buffers and call [[Deflate#onEnd]].
*
* On fail call [[Deflate#onEnd]] with error code and return false.
*
* ##### Example
*
* ```javascript
* push(chunk, false); // push one of data chunks
* ...
* push(chunk, true);  // push last chunk
* ```
**/
Deflate$1.prototype.push = function(data$1, flush_mode) {
	const strm = this.strm;
	const chunkSize = this.options.chunkSize;
	let status, _flush_mode;
	if (this.ended) return false;
	if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
	if (typeof data$1 === "string") strm.input = strings.string2buf(data$1);
else if (toString$1.call(data$1) === "[object ArrayBuffer]") strm.input = new Uint8Array(data$1);
else strm.input = data$1;
	strm.next_in = 0;
	strm.avail_in = strm.input.length;
	for (;;) {
		if (strm.avail_out === 0) {
			strm.output = new Uint8Array(chunkSize);
			strm.next_out = 0;
			strm.avail_out = chunkSize;
		}
		if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
			this.onData(strm.output.subarray(0, strm.next_out));
			strm.avail_out = 0;
			continue;
		}
		status = deflate_1$2.deflate(strm, _flush_mode);
		if (status === Z_STREAM_END$2) {
			if (strm.next_out > 0) this.onData(strm.output.subarray(0, strm.next_out));
			status = deflate_1$2.deflateEnd(this.strm);
			this.onEnd(status);
			this.ended = true;
			return status === Z_OK$2;
		}
		if (strm.avail_out === 0) {
			this.onData(strm.output);
			continue;
		}
		if (_flush_mode > 0 && strm.next_out > 0) {
			this.onData(strm.output.subarray(0, strm.next_out));
			strm.avail_out = 0;
			continue;
		}
		if (strm.avail_in === 0) break;
	}
	return true;
};
/**
* Deflate#onData(chunk) -> Void
* - chunk (Uint8Array): output data.
*
* By default, stores data blocks in `chunks[]` property and glue
* those in `onEnd`. Override this handler, if you need another behaviour.
**/
Deflate$1.prototype.onData = function(chunk) {
	this.chunks.push(chunk);
};
/**
* Deflate#onEnd(status) -> Void
* - status (Number): deflate status. 0 (Z_OK) on success,
*   other if not.
*
* Called once after you tell deflate that the input stream is
* complete (Z_FINISH). By default - join collected chunks,
* free memory and fill `results` / `err` properties.
**/
Deflate$1.prototype.onEnd = function(status) {
	if (status === Z_OK$2) this.result = common.flattenChunks(this.chunks);
	this.chunks = [];
	this.err = status;
	this.msg = this.strm.msg;
};
/**
* deflate(data[, options]) -> Uint8Array
* - data (Uint8Array|ArrayBuffer|String): input data to compress.
* - options (Object): zlib deflate options.
*
* Compress `data` with deflate algorithm and `options`.
*
* Supported options are:
*
* - level
* - windowBits
* - memLevel
* - strategy
* - dictionary
*
* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
* for more information on these.
*
* Sugar (options):
*
* - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
*   negative windowBits implicitly.
*
* ##### Example:
*
* ```javascript
* const pako = require('pako')
* const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
*
* console.log(pako.deflate(data));
* ```
**/
function deflate$1(input, options) {
	const deflator = new Deflate$1(options);
	deflator.push(input, true);
	if (deflator.err) throw deflator.msg || messages[deflator.err];
	return deflator.result;
}
/**
* deflateRaw(data[, options]) -> Uint8Array
* - data (Uint8Array|ArrayBuffer|String): input data to compress.
* - options (Object): zlib deflate options.
*
* The same as [[deflate]], but creates raw data, without wrapper
* (header and adler32 crc).
**/
function deflateRaw$1(input, options) {
	options = options || {};
	options.raw = true;
	return deflate$1(input, options);
}
/**
* gzip(data[, options]) -> Uint8Array
* - data (Uint8Array|ArrayBuffer|String): input data to compress.
* - options (Object): zlib deflate options.
*
* The same as [[deflate]], but create gzip wrapper instead of
* deflate one.
**/
function gzip$1(input, options) {
	options = options || {};
	options.gzip = true;
	return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
	let _in;
	let last$1;
	let _out;
	let beg;
	let end;
	let dmax;
	let wsize;
	let whave;
	let wnext;
	let s_window;
	let hold;
	let bits;
	let lcode;
	let dcode;
	let lmask;
	let dmask;
	let here;
	let op;
	let len;
	let dist;
	let from;
	let from_source;
	let input, output;
	const state = strm.state;
	_in = strm.next_in;
	input = strm.input;
	last$1 = _in + (strm.avail_in - 5);
	_out = strm.next_out;
	output = strm.output;
	beg = _out - (start - strm.avail_out);
	end = _out + (strm.avail_out - 257);
	dmax = state.dmax;
	wsize = state.wsize;
	whave = state.whave;
	wnext = state.wnext;
	s_window = state.window;
	hold = state.hold;
	bits = state.bits;
	lcode = state.lencode;
	dcode = state.distcode;
	lmask = (1 << state.lenbits) - 1;
	dmask = (1 << state.distbits) - 1;
	top: do {
		if (bits < 15) {
			hold += input[_in++] << bits;
			bits += 8;
			hold += input[_in++] << bits;
			bits += 8;
		}
		here = lcode[hold & lmask];
		dolen: for (;;) {
			op = here >>> 24;
			hold >>>= op;
			bits -= op;
			op = here >>> 16 & 255;
			if (op === 0) output[_out++] = here & 65535;
else if (op & 16) {
				len = here & 65535;
				op &= 15;
				if (op) {
					if (bits < op) {
						hold += input[_in++] << bits;
						bits += 8;
					}
					len += hold & (1 << op) - 1;
					hold >>>= op;
					bits -= op;
				}
				if (bits < 15) {
					hold += input[_in++] << bits;
					bits += 8;
					hold += input[_in++] << bits;
					bits += 8;
				}
				here = dcode[hold & dmask];
				dodist: for (;;) {
					op = here >>> 24;
					hold >>>= op;
					bits -= op;
					op = here >>> 16 & 255;
					if (op & 16) {
						dist = here & 65535;
						op &= 15;
						if (bits < op) {
							hold += input[_in++] << bits;
							bits += 8;
							if (bits < op) {
								hold += input[_in++] << bits;
								bits += 8;
							}
						}
						dist += hold & (1 << op) - 1;
						if (dist > dmax) {
							strm.msg = "invalid distance too far back";
							state.mode = BAD$1;
							break top;
						}
						hold >>>= op;
						bits -= op;
						op = _out - beg;
						if (dist > op) {
							op = dist - op;
							if (op > whave) {
								if (state.sane) {
									strm.msg = "invalid distance too far back";
									state.mode = BAD$1;
									break top;
								}
							}
							from = 0;
							from_source = s_window;
							if (wnext === 0) {
								from += wsize - op;
								if (op < len) {
									len -= op;
									do 
										output[_out++] = s_window[from++];
									while (--op);
									from = _out - dist;
									from_source = output;
								}
							} else if (wnext < op) {
								from += wsize + wnext - op;
								op -= wnext;
								if (op < len) {
									len -= op;
									do 
										output[_out++] = s_window[from++];
									while (--op);
									from = 0;
									if (wnext < len) {
										op = wnext;
										len -= op;
										do 
											output[_out++] = s_window[from++];
										while (--op);
										from = _out - dist;
										from_source = output;
									}
								}
							} else {
								from += wnext - op;
								if (op < len) {
									len -= op;
									do 
										output[_out++] = s_window[from++];
									while (--op);
									from = _out - dist;
									from_source = output;
								}
							}
							while (len > 2) {
								output[_out++] = from_source[from++];
								output[_out++] = from_source[from++];
								output[_out++] = from_source[from++];
								len -= 3;
							}
							if (len) {
								output[_out++] = from_source[from++];
								if (len > 1) output[_out++] = from_source[from++];
							}
						} else {
							from = _out - dist;
							do {
								output[_out++] = output[from++];
								output[_out++] = output[from++];
								output[_out++] = output[from++];
								len -= 3;
							} while (len > 2);
							if (len) {
								output[_out++] = output[from++];
								if (len > 1) output[_out++] = output[from++];
							}
						}
					} else if ((op & 64) === 0) {
						here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
						continue dodist;
					} else {
						strm.msg = "invalid distance code";
						state.mode = BAD$1;
						break top;
					}
					break;
				}
			} else if ((op & 64) === 0) {
				here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
				continue dolen;
			} else if (op & 32) {
				state.mode = TYPE$1;
				break top;
			} else {
				strm.msg = "invalid literal/length code";
				state.mode = BAD$1;
				break top;
			}
			break;
		}
	} while (_in < last$1 && _out < end);
	len = bits >> 3;
	_in -= len;
	bits -= len << 3;
	hold &= (1 << bits) - 1;
	strm.next_in = _in;
	strm.next_out = _out;
	strm.avail_in = _in < last$1 ? 5 + (last$1 - _in) : 5 - (_in - last$1);
	strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
	state.hold = hold;
	state.bits = bits;
	return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	13,
	15,
	17,
	19,
	23,
	27,
	31,
	35,
	43,
	51,
	59,
	67,
	83,
	99,
	115,
	131,
	163,
	195,
	227,
	258,
	0,
	0
]);
const lext = new Uint8Array([
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	17,
	17,
	17,
	17,
	18,
	18,
	18,
	18,
	19,
	19,
	19,
	19,
	20,
	20,
	20,
	20,
	21,
	21,
	21,
	21,
	16,
	72,
	78
]);
const dbase = new Uint16Array([
	1,
	2,
	3,
	4,
	5,
	7,
	9,
	13,
	17,
	25,
	33,
	49,
	65,
	97,
	129,
	193,
	257,
	385,
	513,
	769,
	1025,
	1537,
	2049,
	3073,
	4097,
	6145,
	8193,
	12289,
	16385,
	24577,
	0,
	0
]);
const dext = new Uint8Array([
	16,
	16,
	16,
	16,
	17,
	17,
	18,
	18,
	19,
	19,
	20,
	20,
	21,
	21,
	22,
	22,
	23,
	23,
	24,
	24,
	25,
	25,
	26,
	26,
	27,
	27,
	28,
	28,
	29,
	29,
	64,
	64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
	const bits = opts.bits;
	let len = 0;
	let sym = 0;
	let min = 0, max = 0;
	let root = 0;
	let curr = 0;
	let drop = 0;
	let left = 0;
	let used = 0;
	let huff = 0;
	let incr;
	let fill;
	let low;
	let mask;
	let next;
	let base = null;
	let match;
	const count = new Uint16Array(MAXBITS + 1);
	const offs = new Uint16Array(MAXBITS + 1);
	let extra = null;
	let here_bits, here_op, here_val;
	for (len = 0; len <= MAXBITS; len++) count[len] = 0;
	for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
	root = bits;
	for (max = MAXBITS; max >= 1; max--) if (count[max] !== 0) break;
	if (root > max) root = max;
	if (max === 0) {
		table[table_index++] = 20971520;
		table[table_index++] = 20971520;
		opts.bits = 1;
		return 0;
	}
	for (min = 1; min < max; min++) if (count[min] !== 0) break;
	if (root < min) root = min;
	left = 1;
	for (len = 1; len <= MAXBITS; len++) {
		left <<= 1;
		left -= count[len];
		if (left < 0) return -1;
	}
	if (left > 0 && (type === CODES$1 || max !== 1)) return -1;
	offs[1] = 0;
	for (len = 1; len < MAXBITS; len++) offs[len + 1] = offs[len] + count[len];
	for (sym = 0; sym < codes; sym++) if (lens[lens_index + sym] !== 0) work[offs[lens[lens_index + sym]]++] = sym;
	if (type === CODES$1) {
		base = extra = work;
		match = 20;
	} else if (type === LENS$1) {
		base = lbase;
		extra = lext;
		match = 257;
	} else {
		base = dbase;
		extra = dext;
		match = 0;
	}
	huff = 0;
	sym = 0;
	len = min;
	next = table_index;
	curr = root;
	drop = 0;
	low = -1;
	used = 1 << root;
	mask = used - 1;
	if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) return 1;
	for (;;) {
		here_bits = len - drop;
		if (work[sym] + 1 < match) {
			here_op = 0;
			here_val = work[sym];
		} else if (work[sym] >= match) {
			here_op = extra[work[sym] - match];
			here_val = base[work[sym] - match];
		} else {
			here_op = 96;
			here_val = 0;
		}
		incr = 1 << len - drop;
		fill = 1 << curr;
		min = fill;
		do {
			fill -= incr;
			table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
		} while (fill !== 0);
		incr = 1 << len - 1;
		while (huff & incr) incr >>= 1;
		if (incr !== 0) {
			huff &= incr - 1;
			huff += incr;
		} else huff = 0;
		sym++;
		if (--count[len] === 0) {
			if (len === max) break;
			len = lens[lens_index + work[sym]];
		}
		if (len > root && (huff & mask) !== low) {
			if (drop === 0) drop = root;
			next += min;
			curr = len - drop;
			left = 1 << curr;
			while (curr + drop < max) {
				left -= count[curr + drop];
				if (left <= 0) break;
				curr++;
				left <<= 1;
			}
			used += 1 << curr;
			if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) return 1;
			low = huff & mask;
			table[low] = root << 24 | curr << 16 | next - table_index | 0;
		}
	}
	if (huff !== 0) table[next + huff] = len - drop << 24 | 4194304;
	opts.bits = root;
	return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
	return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
	this.strm = null;
	this.mode = 0;
	this.last = false;
	this.wrap = 0;
	this.havedict = false;
	this.flags = 0;
	this.dmax = 0;
	this.check = 0;
	this.total = 0;
	this.head = null;
	this.wbits = 0;
	this.wsize = 0;
	this.whave = 0;
	this.wnext = 0;
	this.window = null;
	this.hold = 0;
	this.bits = 0;
	this.length = 0;
	this.offset = 0;
	this.extra = 0;
	this.lencode = null;
	this.distcode = null;
	this.lenbits = 0;
	this.distbits = 0;
	this.ncode = 0;
	this.nlen = 0;
	this.ndist = 0;
	this.have = 0;
	this.next = null;
	this.lens = new Uint16Array(320);
	this.work = new Uint16Array(288);
	this.lendyn = null;
	this.distdyn = null;
	this.sane = 0;
	this.back = 0;
	this.was = 0;
}
const inflateStateCheck = (strm) => {
	if (!strm) return 1;
	const state = strm.state;
	if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) return 1;
	return 0;
};
const inflateResetKeep = (strm) => {
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	const state = strm.state;
	strm.total_in = strm.total_out = state.total = 0;
	strm.msg = "";
	if (state.wrap) strm.adler = state.wrap & 1;
	state.mode = HEAD;
	state.last = 0;
	state.havedict = 0;
	state.flags = -1;
	state.dmax = 32768;
	state.head = null;
	state.hold = 0;
	state.bits = 0;
	state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
	state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
	state.sane = 1;
	state.back = -1;
	return Z_OK$1;
};
const inflateReset = (strm) => {
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	const state = strm.state;
	state.wsize = 0;
	state.whave = 0;
	state.wnext = 0;
	return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
	let wrap;
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	const state = strm.state;
	if (windowBits < 0) {
		wrap = 0;
		windowBits = -windowBits;
	} else {
		wrap = (windowBits >> 4) + 5;
		if (windowBits < 48) windowBits &= 15;
	}
	if (windowBits && (windowBits < 8 || windowBits > 15)) return Z_STREAM_ERROR$1;
	if (state.window !== null && state.wbits !== windowBits) state.window = null;
	state.wrap = wrap;
	state.wbits = windowBits;
	return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
	if (!strm) return Z_STREAM_ERROR$1;
	const state = new InflateState();
	strm.state = state;
	state.strm = strm;
	state.window = null;
	state.mode = HEAD;
	const ret = inflateReset2(strm, windowBits);
	if (ret !== Z_OK$1) strm.state = null;
	return ret;
};
const inflateInit = (strm) => {
	return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
	if (virgin) {
		lenfix = new Int32Array(512);
		distfix = new Int32Array(32);
		let sym = 0;
		while (sym < 144) state.lens[sym++] = 8;
		while (sym < 256) state.lens[sym++] = 9;
		while (sym < 280) state.lens[sym++] = 7;
		while (sym < 288) state.lens[sym++] = 8;
		inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
		sym = 0;
		while (sym < 32) state.lens[sym++] = 5;
		inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
		virgin = false;
	}
	state.lencode = lenfix;
	state.lenbits = 9;
	state.distcode = distfix;
	state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
	let dist;
	const state = strm.state;
	if (state.window === null) {
		state.wsize = 1 << state.wbits;
		state.wnext = 0;
		state.whave = 0;
		state.window = new Uint8Array(state.wsize);
	}
	if (copy >= state.wsize) {
		state.window.set(src.subarray(end - state.wsize, end), 0);
		state.wnext = 0;
		state.whave = state.wsize;
	} else {
		dist = state.wsize - state.wnext;
		if (dist > copy) dist = copy;
		state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
		copy -= dist;
		if (copy) {
			state.window.set(src.subarray(end - copy, end), 0);
			state.wnext = copy;
			state.whave = state.wsize;
		} else {
			state.wnext += dist;
			if (state.wnext === state.wsize) state.wnext = 0;
			if (state.whave < state.wsize) state.whave += dist;
		}
	}
	return 0;
};
const inflate$2 = (strm, flush) => {
	let state;
	let input, output;
	let next;
	let put;
	let have, left;
	let hold;
	let bits;
	let _in, _out;
	let copy;
	let from;
	let from_source;
	let here = 0;
	let here_bits, here_op, here_val;
	let last_bits, last_op, last_val;
	let len;
	let ret;
	const hbuf = new Uint8Array(4);
	let opts;
	let n;
	const order = new Uint8Array([
		16,
		17,
		18,
		0,
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15
	]);
	if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) return Z_STREAM_ERROR$1;
	state = strm.state;
	if (state.mode === TYPE) state.mode = TYPEDO;
	put = strm.next_out;
	output = strm.output;
	left = strm.avail_out;
	next = strm.next_in;
	input = strm.input;
	have = strm.avail_in;
	hold = state.hold;
	bits = state.bits;
	_in = have;
	_out = left;
	ret = Z_OK$1;
	inf_leave: for (;;) switch (state.mode) {
		case HEAD:
			if (state.wrap === 0) {
				state.mode = TYPEDO;
				break;
			}
			while (bits < 16) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if (state.wrap & 2 && hold === 35615) {
				if (state.wbits === 0) state.wbits = 15;
				state.check = 0;
				hbuf[0] = hold & 255;
				hbuf[1] = hold >>> 8 & 255;
				state.check = crc32_1(state.check, hbuf, 2, 0);
				hold = 0;
				bits = 0;
				state.mode = FLAGS;
				break;
			}
			if (state.head) state.head.done = false;
			if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
				strm.msg = "incorrect header check";
				state.mode = BAD;
				break;
			}
			if ((hold & 15) !== Z_DEFLATED) {
				strm.msg = "unknown compression method";
				state.mode = BAD;
				break;
			}
			hold >>>= 4;
			bits -= 4;
			len = (hold & 15) + 8;
			if (state.wbits === 0) state.wbits = len;
			if (len > 15 || len > state.wbits) {
				strm.msg = "invalid window size";
				state.mode = BAD;
				break;
			}
			state.dmax = 1 << state.wbits;
			state.flags = 0;
			strm.adler = state.check = 1;
			state.mode = hold & 512 ? DICTID : TYPE;
			hold = 0;
			bits = 0;
			break;
		case FLAGS:
			while (bits < 16) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			state.flags = hold;
			if ((state.flags & 255) !== Z_DEFLATED) {
				strm.msg = "unknown compression method";
				state.mode = BAD;
				break;
			}
			if (state.flags & 57344) {
				strm.msg = "unknown header flags set";
				state.mode = BAD;
				break;
			}
			if (state.head) state.head.text = hold >> 8 & 1;
			if (state.flags & 512 && state.wrap & 4) {
				hbuf[0] = hold & 255;
				hbuf[1] = hold >>> 8 & 255;
				state.check = crc32_1(state.check, hbuf, 2, 0);
			}
			hold = 0;
			bits = 0;
			state.mode = TIME;
		case TIME:
			while (bits < 32) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if (state.head) state.head.time = hold;
			if (state.flags & 512 && state.wrap & 4) {
				hbuf[0] = hold & 255;
				hbuf[1] = hold >>> 8 & 255;
				hbuf[2] = hold >>> 16 & 255;
				hbuf[3] = hold >>> 24 & 255;
				state.check = crc32_1(state.check, hbuf, 4, 0);
			}
			hold = 0;
			bits = 0;
			state.mode = OS;
		case OS:
			while (bits < 16) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if (state.head) {
				state.head.xflags = hold & 255;
				state.head.os = hold >> 8;
			}
			if (state.flags & 512 && state.wrap & 4) {
				hbuf[0] = hold & 255;
				hbuf[1] = hold >>> 8 & 255;
				state.check = crc32_1(state.check, hbuf, 2, 0);
			}
			hold = 0;
			bits = 0;
			state.mode = EXLEN;
		case EXLEN:
			if (state.flags & 1024) {
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.length = hold;
				if (state.head) state.head.extra_len = hold;
				if (state.flags & 512 && state.wrap & 4) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32_1(state.check, hbuf, 2, 0);
				}
				hold = 0;
				bits = 0;
			} else if (state.head) state.head.extra = null;
			state.mode = EXTRA;
		case EXTRA:
			if (state.flags & 1024) {
				copy = state.length;
				if (copy > have) copy = have;
				if (copy) {
					if (state.head) {
						len = state.head.extra_len - state.length;
						if (!state.head.extra) state.head.extra = new Uint8Array(state.head.extra_len);
						state.head.extra.set(
							input.subarray(
								next,
								// extra field is limited to 65536 bytes
								// - no need for additional size check
								next + copy
),
							/*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
							len
);
					}
					if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy, next);
					have -= copy;
					next += copy;
					state.length -= copy;
				}
				if (state.length) break inf_leave;
			}
			state.length = 0;
			state.mode = NAME;
		case NAME:
			if (state.flags & 2048) {
				if (have === 0) break inf_leave;
				copy = 0;
				do {
					len = input[next + copy++];
					if (state.head && len && state.length < 65536) state.head.name += String.fromCharCode(len);
				} while (len && copy < have);
				if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy, next);
				have -= copy;
				next += copy;
				if (len) break inf_leave;
			} else if (state.head) state.head.name = null;
			state.length = 0;
			state.mode = COMMENT;
		case COMMENT:
			if (state.flags & 4096) {
				if (have === 0) break inf_leave;
				copy = 0;
				do {
					len = input[next + copy++];
					if (state.head && len && state.length < 65536) state.head.comment += String.fromCharCode(len);
				} while (len && copy < have);
				if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy, next);
				have -= copy;
				next += copy;
				if (len) break inf_leave;
			} else if (state.head) state.head.comment = null;
			state.mode = HCRC;
		case HCRC:
			if (state.flags & 512) {
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.wrap & 4 && hold !== (state.check & 65535)) {
					strm.msg = "header crc mismatch";
					state.mode = BAD;
					break;
				}
				hold = 0;
				bits = 0;
			}
			if (state.head) {
				state.head.hcrc = state.flags >> 9 & 1;
				state.head.done = true;
			}
			strm.adler = state.check = 0;
			state.mode = TYPE;
			break;
		case DICTID:
			while (bits < 32) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			strm.adler = state.check = zswap32(hold);
			hold = 0;
			bits = 0;
			state.mode = DICT;
		case DICT:
			if (state.havedict === 0) {
				strm.next_out = put;
				strm.avail_out = left;
				strm.next_in = next;
				strm.avail_in = have;
				state.hold = hold;
				state.bits = bits;
				return Z_NEED_DICT$1;
			}
			strm.adler = state.check = 1;
			state.mode = TYPE;
		case TYPE: if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
		case TYPEDO:
			if (state.last) {
				hold >>>= bits & 7;
				bits -= bits & 7;
				state.mode = CHECK;
				break;
			}
			while (bits < 3) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			state.last = hold & 1;
			hold >>>= 1;
			bits -= 1;
			switch (hold & 3) {
				case 0:
					state.mode = STORED;
					break;
				case 1:
					fixedtables(state);
					state.mode = LEN_;
					if (flush === Z_TREES) {
						hold >>>= 2;
						bits -= 2;
						break inf_leave;
					}
					break;
				case 2:
					state.mode = TABLE;
					break;
				case 3:
					strm.msg = "invalid block type";
					state.mode = BAD;
			}
			hold >>>= 2;
			bits -= 2;
			break;
		case STORED:
			hold >>>= bits & 7;
			bits -= bits & 7;
			while (bits < 32) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
				strm.msg = "invalid stored block lengths";
				state.mode = BAD;
				break;
			}
			state.length = hold & 65535;
			hold = 0;
			bits = 0;
			state.mode = COPY_;
			if (flush === Z_TREES) break inf_leave;
		case COPY_: state.mode = COPY;
		case COPY:
			copy = state.length;
			if (copy) {
				if (copy > have) copy = have;
				if (copy > left) copy = left;
				if (copy === 0) break inf_leave;
				output.set(input.subarray(next, next + copy), put);
				have -= copy;
				next += copy;
				left -= copy;
				put += copy;
				state.length -= copy;
				break;
			}
			state.mode = TYPE;
			break;
		case TABLE:
			while (bits < 14) {
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			state.nlen = (hold & 31) + 257;
			hold >>>= 5;
			bits -= 5;
			state.ndist = (hold & 31) + 1;
			hold >>>= 5;
			bits -= 5;
			state.ncode = (hold & 15) + 4;
			hold >>>= 4;
			bits -= 4;
			if (state.nlen > 286 || state.ndist > 30) {
				strm.msg = "too many length or distance symbols";
				state.mode = BAD;
				break;
			}
			state.have = 0;
			state.mode = LENLENS;
		case LENLENS:
			while (state.have < state.ncode) {
				while (bits < 3) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.lens[order[state.have++]] = hold & 7;
				hold >>>= 3;
				bits -= 3;
			}
			while (state.have < 19) state.lens[order[state.have++]] = 0;
			state.lencode = state.lendyn;
			state.lenbits = 7;
			opts = { bits: state.lenbits };
			ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
			state.lenbits = opts.bits;
			if (ret) {
				strm.msg = "invalid code lengths set";
				state.mode = BAD;
				break;
			}
			state.have = 0;
			state.mode = CODELENS;
		case CODELENS:
			while (state.have < state.nlen + state.ndist) {
				for (;;) {
					here = state.lencode[hold & (1 << state.lenbits) - 1];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (here_val < 16) {
					hold >>>= here_bits;
					bits -= here_bits;
					state.lens[state.have++] = here_val;
				} else {
					if (here_val === 16) {
						n = here_bits + 2;
						while (bits < n) {
							if (have === 0) break inf_leave;
							have--;
							hold += input[next++] << bits;
							bits += 8;
						}
						hold >>>= here_bits;
						bits -= here_bits;
						if (state.have === 0) {
							strm.msg = "invalid bit length repeat";
							state.mode = BAD;
							break;
						}
						len = state.lens[state.have - 1];
						copy = 3 + (hold & 3);
						hold >>>= 2;
						bits -= 2;
					} else if (here_val === 17) {
						n = here_bits + 3;
						while (bits < n) {
							if (have === 0) break inf_leave;
							have--;
							hold += input[next++] << bits;
							bits += 8;
						}
						hold >>>= here_bits;
						bits -= here_bits;
						len = 0;
						copy = 3 + (hold & 7);
						hold >>>= 3;
						bits -= 3;
					} else {
						n = here_bits + 7;
						while (bits < n) {
							if (have === 0) break inf_leave;
							have--;
							hold += input[next++] << bits;
							bits += 8;
						}
						hold >>>= here_bits;
						bits -= here_bits;
						len = 0;
						copy = 11 + (hold & 127);
						hold >>>= 7;
						bits -= 7;
					}
					if (state.have + copy > state.nlen + state.ndist) {
						strm.msg = "invalid bit length repeat";
						state.mode = BAD;
						break;
					}
					while (copy--) state.lens[state.have++] = len;
				}
			}
			if (state.mode === BAD) break;
			if (state.lens[256] === 0) {
				strm.msg = "invalid code -- missing end-of-block";
				state.mode = BAD;
				break;
			}
			state.lenbits = 9;
			opts = { bits: state.lenbits };
			ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
			state.lenbits = opts.bits;
			if (ret) {
				strm.msg = "invalid literal/lengths set";
				state.mode = BAD;
				break;
			}
			state.distbits = 6;
			state.distcode = state.distdyn;
			opts = { bits: state.distbits };
			ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
			state.distbits = opts.bits;
			if (ret) {
				strm.msg = "invalid distances set";
				state.mode = BAD;
				break;
			}
			state.mode = LEN_;
			if (flush === Z_TREES) break inf_leave;
		case LEN_: state.mode = LEN;
		case LEN:
			if (have >= 6 && left >= 258) {
				strm.next_out = put;
				strm.avail_out = left;
				strm.next_in = next;
				strm.avail_in = have;
				state.hold = hold;
				state.bits = bits;
				inffast(strm, _out);
				put = strm.next_out;
				output = strm.output;
				left = strm.avail_out;
				next = strm.next_in;
				input = strm.input;
				have = strm.avail_in;
				hold = state.hold;
				bits = state.bits;
				if (state.mode === TYPE) state.back = -1;
				break;
			}
			state.back = 0;
			for (;;) {
				here = state.lencode[hold & (1 << state.lenbits) - 1];
				here_bits = here >>> 24;
				here_op = here >>> 16 & 255;
				here_val = here & 65535;
				if (here_bits <= bits) break;
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if (here_op && (here_op & 240) === 0) {
				last_bits = here_bits;
				last_op = here_op;
				last_val = here_val;
				for (;;) {
					here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (last_bits + here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				hold >>>= last_bits;
				bits -= last_bits;
				state.back += last_bits;
			}
			hold >>>= here_bits;
			bits -= here_bits;
			state.back += here_bits;
			state.length = here_val;
			if (here_op === 0) {
				state.mode = LIT;
				break;
			}
			if (here_op & 32) {
				state.back = -1;
				state.mode = TYPE;
				break;
			}
			if (here_op & 64) {
				strm.msg = "invalid literal/length code";
				state.mode = BAD;
				break;
			}
			state.extra = here_op & 15;
			state.mode = LENEXT;
		case LENEXT:
			if (state.extra) {
				n = state.extra;
				while (bits < n) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.length += hold & (1 << state.extra) - 1;
				hold >>>= state.extra;
				bits -= state.extra;
				state.back += state.extra;
			}
			state.was = state.length;
			state.mode = DIST;
		case DIST:
			for (;;) {
				here = state.distcode[hold & (1 << state.distbits) - 1];
				here_bits = here >>> 24;
				here_op = here >>> 16 & 255;
				here_val = here & 65535;
				if (here_bits <= bits) break;
				if (have === 0) break inf_leave;
				have--;
				hold += input[next++] << bits;
				bits += 8;
			}
			if ((here_op & 240) === 0) {
				last_bits = here_bits;
				last_op = here_op;
				last_val = here_val;
				for (;;) {
					here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (last_bits + here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				hold >>>= last_bits;
				bits -= last_bits;
				state.back += last_bits;
			}
			hold >>>= here_bits;
			bits -= here_bits;
			state.back += here_bits;
			if (here_op & 64) {
				strm.msg = "invalid distance code";
				state.mode = BAD;
				break;
			}
			state.offset = here_val;
			state.extra = here_op & 15;
			state.mode = DISTEXT;
		case DISTEXT:
			if (state.extra) {
				n = state.extra;
				while (bits < n) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.offset += hold & (1 << state.extra) - 1;
				hold >>>= state.extra;
				bits -= state.extra;
				state.back += state.extra;
			}
			if (state.offset > state.dmax) {
				strm.msg = "invalid distance too far back";
				state.mode = BAD;
				break;
			}
			state.mode = MATCH;
		case MATCH:
			if (left === 0) break inf_leave;
			copy = _out - left;
			if (state.offset > copy) {
				copy = state.offset - copy;
				if (copy > state.whave) {
					if (state.sane) {
						strm.msg = "invalid distance too far back";
						state.mode = BAD;
						break;
					}
				}
				if (copy > state.wnext) {
					copy -= state.wnext;
					from = state.wsize - copy;
				} else from = state.wnext - copy;
				if (copy > state.length) copy = state.length;
				from_source = state.window;
			} else {
				from_source = output;
				from = put - state.offset;
				copy = state.length;
			}
			if (copy > left) copy = left;
			left -= copy;
			state.length -= copy;
			do 
				output[put++] = from_source[from++];
			while (--copy);
			if (state.length === 0) state.mode = LEN;
			break;
		case LIT:
			if (left === 0) break inf_leave;
			output[put++] = state.length;
			left--;
			state.mode = LEN;
			break;
		case CHECK:
			if (state.wrap) {
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold |= input[next++] << bits;
					bits += 8;
				}
				_out -= left;
				strm.total_out += _out;
				state.total += _out;
				if (state.wrap & 4 && _out) strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
				_out = left;
				if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
					strm.msg = "incorrect data check";
					state.mode = BAD;
					break;
				}
				hold = 0;
				bits = 0;
			}
			state.mode = LENGTH;
		case LENGTH:
			if (state.wrap && state.flags) {
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
					strm.msg = "incorrect length check";
					state.mode = BAD;
					break;
				}
				hold = 0;
				bits = 0;
			}
			state.mode = DONE;
		case DONE:
			ret = Z_STREAM_END$1;
			break inf_leave;
		case BAD:
			ret = Z_DATA_ERROR$1;
			break inf_leave;
		case MEM: return Z_MEM_ERROR$1;
		case SYNC:
		default: return Z_STREAM_ERROR$1;
	}
	strm.next_out = put;
	strm.avail_out = left;
	strm.next_in = next;
	strm.avail_in = have;
	state.hold = hold;
	state.bits = bits;
	if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
		if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out));
	}
	_in -= strm.avail_in;
	_out -= strm.avail_out;
	strm.total_in += _in;
	strm.total_out += _out;
	state.total += _out;
	if (state.wrap & 4 && _out) strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
	strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) ret = Z_BUF_ERROR;
	return ret;
};
const inflateEnd = (strm) => {
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	let state = strm.state;
	if (state.window) state.window = null;
	strm.state = null;
	return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	const state = strm.state;
	if ((state.wrap & 2) === 0) return Z_STREAM_ERROR$1;
	state.head = head;
	head.done = false;
	return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
	const dictLength = dictionary.length;
	let state;
	let dictid;
	let ret;
	if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
	state = strm.state;
	if (state.wrap !== 0 && state.mode !== DICT) return Z_STREAM_ERROR$1;
	if (state.mode === DICT) {
		dictid = 1;
		dictid = adler32_1(dictid, dictionary, dictLength, 0);
		if (dictid !== state.check) return Z_DATA_ERROR$1;
	}
	ret = updatewindow(strm, dictionary, dictLength, dictLength);
	if (ret) {
		state.mode = MEM;
		return Z_MEM_ERROR$1;
	}
	state.havedict = 1;
	return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo
};
function GZheader() {
	this.text = 0;
	this.time = 0;
	this.xflags = 0;
	this.os = 0;
	this.extra = null;
	this.extra_len = 0;
	this.name = "";
	this.comment = "";
	this.hcrc = 0;
	this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2;
/**
* class Inflate
*
* Generic JS-style wrapper for zlib calls. If you don't need
* streaming behaviour - use more simple functions: [[inflate]]
* and [[inflateRaw]].
**/
/**
* Inflate.result -> Uint8Array|String
*
* Uncompressed result, generated by default [[Inflate#onData]]
* and [[Inflate#onEnd]] handlers. Filled after you push last chunk
* (call [[Inflate#push]] with `Z_FINISH` / `true` param).
**/
/**
* Inflate.err -> Number
*
* Error code after inflate finished. 0 (Z_OK) on success.
* Should be checked if broken data possible.
**/
/**
* Inflate.msg -> String
*
* Error message, if [[Inflate.err]] != 0
**/
/**
* new Inflate(options)
* - options (Object): zlib inflate options.
*
* Creates new inflator instance with specified params. Throws exception
* on bad params. Supported options:
*
* - `windowBits`
* - `dictionary`
*
* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
* for more information on these.
*
* Additional options, for internal needs:
*
* - `chunkSize` - size of generated data chunks (16K by default)
* - `raw` (Boolean) - do raw inflate
* - `to` (String) - if equal to 'string', then result will be converted
*   from utf8 to utf16 (javascript) string. When string output requested,
*   chunk length can differ from `chunkSize`, depending on content.
*
* By default, when no options set, autodetect deflate/gzip data format via
* wrapper header.
*
* ##### Example:
*
* ```javascript
* const pako = require('pako')
* const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
* const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
*
* const inflate = new pako.Inflate({ level: 3});
*
* inflate.push(chunk1, false);
* inflate.push(chunk2, true);  // true -> last chunk
*
* if (inflate.err) { throw new Error(inflate.err); }
*
* console.log(inflate.result);
* ```
**/
function Inflate$1(options) {
	this.options = common.assign({
		chunkSize: 65536,
		windowBits: 15,
		to: ""
	}, options || {});
	const opt = this.options;
	if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
		opt.windowBits = -opt.windowBits;
		if (opt.windowBits === 0) opt.windowBits = -15;
	}
	if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) opt.windowBits += 32;
	if (opt.windowBits > 15 && opt.windowBits < 48) {
		if ((opt.windowBits & 15) === 0) opt.windowBits |= 15;
	}
	this.err = 0;
	this.msg = "";
	this.ended = false;
	this.chunks = [];
	this.strm = new zstream();
	this.strm.avail_out = 0;
	let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
	if (status !== Z_OK) throw new Error(messages[status]);
	this.header = new gzheader();
	inflate_1$2.inflateGetHeader(this.strm, this.header);
	if (opt.dictionary) {
		if (typeof opt.dictionary === "string") opt.dictionary = strings.string2buf(opt.dictionary);
else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") opt.dictionary = new Uint8Array(opt.dictionary);
		if (opt.raw) {
			status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
			if (status !== Z_OK) throw new Error(messages[status]);
		}
	}
}
/**
* Inflate#push(data[, flush_mode]) -> Boolean
* - data (Uint8Array|ArrayBuffer): input data
* - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
*   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
*   `true` means Z_FINISH.
*
* Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
* new output chunks. Returns `true` on success. If end of stream detected,
* [[Inflate#onEnd]] will be called.
*
* `flush_mode` is not needed for normal operation, because end of stream
* detected automatically. You may try to use it for advanced things, but
* this functionality was not tested.
*
* On fail call [[Inflate#onEnd]] with error code and return false.
*
* ##### Example
*
* ```javascript
* push(chunk, false); // push one of data chunks
* ...
* push(chunk, true);  // push last chunk
* ```
**/
Inflate$1.prototype.push = function(data$1, flush_mode) {
	const strm = this.strm;
	const chunkSize = this.options.chunkSize;
	const dictionary = this.options.dictionary;
	let status, _flush_mode, last_avail_out;
	if (this.ended) return false;
	if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
	if (toString.call(data$1) === "[object ArrayBuffer]") strm.input = new Uint8Array(data$1);
else strm.input = data$1;
	strm.next_in = 0;
	strm.avail_in = strm.input.length;
	for (;;) {
		if (strm.avail_out === 0) {
			strm.output = new Uint8Array(chunkSize);
			strm.next_out = 0;
			strm.avail_out = chunkSize;
		}
		status = inflate_1$2.inflate(strm, _flush_mode);
		if (status === Z_NEED_DICT && dictionary) {
			status = inflate_1$2.inflateSetDictionary(strm, dictionary);
			if (status === Z_OK) status = inflate_1$2.inflate(strm, _flush_mode);
else if (status === Z_DATA_ERROR) status = Z_NEED_DICT;
		}
		while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data$1[strm.next_in] !== 0) {
			inflate_1$2.inflateReset(strm);
			status = inflate_1$2.inflate(strm, _flush_mode);
		}
		switch (status) {
			case Z_STREAM_ERROR:
			case Z_DATA_ERROR:
			case Z_NEED_DICT:
			case Z_MEM_ERROR:
				this.onEnd(status);
				this.ended = true;
				return false;
		}
		last_avail_out = strm.avail_out;
		if (strm.next_out) {
			if (strm.avail_out === 0 || status === Z_STREAM_END) if (this.options.to === "string") {
				let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
				let tail = strm.next_out - next_out_utf8;
				let utf8str = strings.buf2string(strm.output, next_out_utf8);
				strm.next_out = tail;
				strm.avail_out = chunkSize - tail;
				if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
				this.onData(utf8str);
			} else this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
		}
		if (status === Z_OK && last_avail_out === 0) continue;
		if (status === Z_STREAM_END) {
			status = inflate_1$2.inflateEnd(this.strm);
			this.onEnd(status);
			this.ended = true;
			return true;
		}
		if (strm.avail_in === 0) break;
	}
	return true;
};
/**
* Inflate#onData(chunk) -> Void
* - chunk (Uint8Array|String): output data. When string output requested,
*   each chunk will be string.
*
* By default, stores data blocks in `chunks[]` property and glue
* those in `onEnd`. Override this handler, if you need another behaviour.
**/
Inflate$1.prototype.onData = function(chunk) {
	this.chunks.push(chunk);
};
/**
* Inflate#onEnd(status) -> Void
* - status (Number): inflate status. 0 (Z_OK) on success,
*   other if not.
*
* Called either after you tell inflate that the input stream is
* complete (Z_FINISH). By default - join collected chunks,
* free memory and fill `results` / `err` properties.
**/
Inflate$1.prototype.onEnd = function(status) {
	if (status === Z_OK) if (this.options.to === "string") this.result = this.chunks.join("");
else this.result = common.flattenChunks(this.chunks);
	this.chunks = [];
	this.err = status;
	this.msg = this.strm.msg;
};
/**
* inflate(data[, options]) -> Uint8Array|String
* - data (Uint8Array|ArrayBuffer): input data to decompress.
* - options (Object): zlib inflate options.
*
* Decompress `data` with inflate/ungzip and `options`. Autodetect
* format via wrapper header by default. That's why we don't provide
* separate `ungzip` method.
*
* Supported options are:
*
* - windowBits
*
* [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
* for more information.
*
* Sugar (options):
*
* - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
*   negative windowBits implicitly.
* - `to` (String) - if equal to 'string', then result will be converted
*   from utf8 to utf16 (javascript) string. When string output requested,
*   chunk length can differ from `chunkSize`, depending on content.
*
*
* ##### Example:
*
* ```javascript
* const pako = require('pako');
* const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
* let output;
*
* try {
*   output = pako.inflate(input);
* } catch (err) {
*   console.log(err);
* }
* ```
**/
function inflate$1(input, options) {
	const inflator = new Inflate$1(options);
	inflator.push(input);
	if (inflator.err) throw inflator.msg || messages[inflator.err];
	return inflator.result;
}
/**
* inflateRaw(data[, options]) -> Uint8Array|String
* - data (Uint8Array|ArrayBuffer): input data to decompress.
* - options (Object): zlib inflate options.
*
* The same as [[inflate]], but creates raw data, without wrapper
* (header and adler32 crc).
**/
function inflateRaw$1(input, options) {
	options = options || {};
	options.raw = true;
	return inflate$1(input, options);
}
/**
* ungzip(data[, options]) -> Uint8Array|String
* - data (Uint8Array|ArrayBuffer): input data to decompress.
* - options (Object): zlib inflate options.
*
* Just shortcut to [[inflate]], because it autodetects format
* by header.content. Done for convenience.
**/
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
};

//#endregion
//#region tests/api/worker/pdf/DeflaterTest.ts
dist_default.spec("Deflater", function() {
	dist_default("correctly deflate", async function() {
		const input = new Uint8Array([
			1,
			7,
			35,
			232
		]);
		const expected = pako.deflate(input);
		const actual = await new Deflater().deflate(input);
		dist_default(actual).deepEquals(expected);
	});
});

//#endregion
//#region tests/api/worker/pdf/PdfWriterTest.ts
dist_default.spec("PdfWriter", function() {
	const textEncoder = new TextEncoder();
	dist_default("Correctly parse object references to reference strings", function() {
		const writer = new PdfWriter(textEncoder, fetch);
		writer.createObject(PDF_DEFAULT_OBJECTS[0].dictionary, PDF_DEFAULT_OBJECTS[0].refId);
		writer.createObject(new Map(), "PAGES");
		writer.createObject(new Map(), "PAGE1");
		dist_default(writer.pdfReferenceToString({ refId: "CATALOG" })).equals("1 0 R");
		dist_default(writer.pdfReferenceToString({ refId: "PAGES" })).equals("2 0 R");
		dist_default(writer.pdfReferenceToString({ refId: "PAGE1" })).equals("3 0 R");
		dist_default(writer.pdfListToString([{ refId: "PAGE1" }, { refId: "CATALOG" }])).equals("[ 3 0 R 1 0 R ]");
		dist_default(writer.pdfListToString([{ refId: "CATALOG" }, { refId: "PAGES" }])).equals("[ 1 0 R 2 0 R ]");
		dist_default(writer.pdfDictionaryToString(new Map([["ref", { refId: "CATALOG" }], ["nonRef", "meow"]]))).equals("<< /ref 1 0 R /nonRef meow >>");
		dist_default(writer.pdfDictionaryToString(new Map())).equals("<< >>");
	});
	dist_default("Resolve deeply nested object references correctly", function() {
		const writer = new PdfWriter(textEncoder, fetch);
		writer.createObject(new Map(), "ListRef");
		writer.createObject(new Map(), "RefVal");
		writer.createObject(new Map(), "NestedRefVal");
		writer.createObject(new Map(), "DeviousRefVal");
		const nestedMap = new Map([
			["Foo", "Bar"],
			["List", [
				"One",
				"Two",
				{ refId: "ListRef" }
			]],
			["Ref", { refId: "RefVal" }],
			["Map", new Map([["NestedFoo", "NestedBar"], ["NestedRef", { refId: "NestedRefVal" }]])],
			["SuperEvilListWithANestedDictionary", [new Map([["DeviousRef", { refId: "DeviousRefVal" }]])]]
		]);
		dist_default(mapToObject(writer.resolveReferences(nestedMap))).deepEquals(mapToObject(new Map([
			["Foo", "Bar"],
			["List", "[ One Two 1 0 R ]"],
			["Ref", "2 0 R"],
			["Map", "<< /NestedFoo NestedBar /NestedRef 3 0 R >>"],
			["SuperEvilListWithANestedDictionary", "[ << /DeviousRef 4 0 R >> ]"]
		])));
	});
	dist_default("Can retrieve objects with a refId", function() {
		const writer = new PdfWriter(textEncoder, fetch);
		writer.createObject(new Map(), "Pablo");
		writer.createObject(new Map(), "Valerie");
		dist_default(writer.getObjectByRefId("Pablo")).deepEquals(new PdfObject(1, new Map()));
		dist_default(writer.getObjectByRefId("Valerie")).deepEquals(new PdfObject(2, new Map()));
		dist_default(() => writer.getObjectByRefId("Zach")).throws(Error);
	});
	dist_default("Xref table is created correctly", function() {
		const writer = new PdfWriter(textEncoder, fetch);
		dist_default(writer.makeXRefTable()).equals("xref\n0 1\n0000000000 65535 f \n");
		writer.createObject(new Map(), "CATALOG");
		dist_default(() => writer.makeXRefTable()).throws(Error);
		const generatedObject = writer.getObjectByRefId("CATALOG");
		writer.calculateBytePositions(generatedObject, generatedObject.encodeToUInt8Array(textEncoder));
		dist_default(writer.makeXRefTable()).equals(`xref\n0 2\n0000000000 65535 f \n0000000015 00000 n \n`);
	});
	dist_default("Trailer is created correctly", function() {
		const writer = new PdfWriter(textEncoder, fetch);
		const now$1 = Date.now().toString();
		dist_default(() => writer.makeTrailer(now$1)).throws(Error);
		writer.createObject(new Map(), "CATALOG");
		dist_default(writer.makeTrailer(now$1)).equals(`trailer\n<<\n/Size 2/Root 1 0 R/ID [(${now$1})(${now$1})]\n>>\nstartxref\n15\n%%EOF`);
	});
});

//#endregion
//#region tests/api/worker/pdf/PdfObjectTest.ts
dist_default.spec("PdfObject", function() {
	const emptyObject = new PdfObject(3, new Map());
	const someObject = new PdfObject(92, new Map([["Key1", "Val1"], ["Key2", "[ meow ]"]]));
	const forbiddenObject = new PdfObject(2, new Map([["Key1", "Val1"], ["Key2", { refId: "UNRESOLVED" }]]));
	const streamObject = new PdfStreamObject(45, new Map([["Kiwi", "Valorant"], ["Banana", "Apple"]]), new Uint8Array([
		34,
		32,
		30
	]), PdfStreamEncoding.DCT);
	dist_default("PDF object head is properly generated", function() {
		dist_default(emptyObject.parseObjectHead()).equals("3 0 obj\n<<\n\n>>\n");
		dist_default(someObject.parseObjectHead()).equals("92 0 obj\n<<\n/Key1 Val1/Key2 [ meow ]\n>>\n");
		dist_default(streamObject.parseObjectHead()).equals("45 0 obj\n<<\n/Kiwi Valorant/Banana Apple/Filter /DCTDecode/Length 3\n>>\nstream\n");
		dist_default(() => forbiddenObject.parseObjectHead()).throws(Error);
	});
	dist_default("PDF object tail is properly generated", function() {
		dist_default(emptyObject.parseObjectTail()).equals("endobj\n");
		dist_default(someObject.parseObjectTail()).equals("endobj\n");
		dist_default(streamObject.parseObjectTail()).equals("\nendstream\nendobj\n");
	});
	dist_default("Stream objects create correct stream-related dictionary keys", function() {
		const streamO1 = new PdfStreamObject(69, new Map([]), new Uint8Array([
			1,
			2,
			3,
			4,
			5
		]), PdfStreamEncoding.FLATE);
		const streamO2 = new PdfStreamObject(420, new Map([]), new Uint8Array([
			1,
			2,
			3
		]), PdfStreamEncoding.NONE);
		dist_default(streamO1.parseObjectHead()).equals("69 0 obj\n<<\n/Filter /FlateDecode/Length 5\n>>\nstream\n");
		dist_default(streamO2.parseObjectHead()).equals("420 0 obj\n<<\n/Length 3\n>>\nstream\n");
	});
});

//#endregion
//#region tests/api/worker/pdf/PdfDocumentTest.ts
dist_default.spec("PdfDocument", function() {
	dist_default("Chars with over one byteLength are detected in StringParts", async function() {
		dist_default(areStringPartsOneByteLength("Hello World".split(""))).equals(true);
		dist_default(areStringPartsOneByteLength("".split(""))).equals(true);
		dist_default(areStringPartsOneByteLength(`"'That's Wrong!'";.,`.split(""))).equals(true);
		dist_default(areStringPartsOneByteLength("Wybieram si w podr do Stambuu".split(""))).equals(false);
		dist_default(areStringPartsOneByteLength("".split(""))).equals(false);
		dist_default(areStringPartsOneByteLength("".split(""))).equals(false);
	});
});

//#endregion
//#region tests/api/worker/invoicegen/invoiceTestUtils.ts
function invoiceItemListMock(amountOfEntries) {
	const data$1 = [];
	for (let i = 0; i < amountOfEntries; i++) data$1.push(createTestEntity(InvoiceDataItemTypeRef, {
		amount: `${i}`,
		startDate: new Date("09.09.1984"),
		endDate: new Date("09.09.1984"),
		singlePrice: "10.00",
		totalPrice: "10.00",
		itemType: "25"
	}));
	return data$1;
}

//#endregion
//#region tests/api/worker/invoicegen/PdfInvoiceGeneratorTest.ts
var import_testdouble$8 = __toESM(require_testdouble(), 1);
dist_default.spec("PdfInvoiceGenerator", function() {
	let pdfWriter;
	dist_default.beforeEach(function() {
		pdfWriter = new PdfWriter(new TextEncoder(), fetchStub);
	});
	dist_default("pdf generation for japanese invoice addVat 3_items", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: " \n, 411,\n501-5627 Shirakawa, Ono-Gun, Gifu, Japan",
			country: "JP",
			subTotal: "28.00",
			grandTotal: "28.00",
			vatType: VatType.ADD_VAT,
			vatIdNumber: "JP999999999",
			paymentMethod: PaymentMethod.INVOICE,
			items: invoiceItemListMock(3)
		});
		const gen = new PdfInvoiceGenerator(pdfWriter, invoiceData, "1978197819801981931", "NiiNii");
		const pdf = await gen.generate();
	});
	dist_default("pdf generation for russian invoice vatReverseCharge 4_items", async function() {
		const renderInvoice = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "CompanyRU\n194352, -\n , . 8, . 2, . .",
			country: "RU",
			items: invoiceItemListMock(2),
			vatType: "4",
			vat: "0",
			vatRate: "0",
			vatIdNumber: "1111_2222_3333_4444"
		});
		const gen = new PdfInvoiceGenerator(pdfWriter, renderInvoice, "1978197819801981931", "NiiNii");
		const pdf = await gen.generate();
	});
	dist_default("pdf rendering with 100 entries", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Marcel Davis",
			country: "DE",
			vatRate: "19",
			vatType: "1",
			vat: "1",
			items: invoiceItemListMock(100)
		});
		const gen = new PdfInvoiceGenerator(pdfWriter, invoiceData, "1978197819801981931", "NiiNii");
		const pdf = await gen.generate();
	});
	dist_default("pdf rendering with max entries to be put on first page", async function() {
		const renderInvoice = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Peter Lustig",
			country: "DE",
			items: invoiceItemListMock(13)
		});
		const gen = new PdfInvoiceGenerator(pdfWriter, renderInvoice, "1978197819801981931", "NiiNii");
		const pdf = await gen.generate();
	});
});
async function fetchStub(input, init$2) {
	if (globalThis.isBrowser) return fetch("./resources/pdf/" + input.toString());
else {
		const [fs, path] = await Promise.all([import("node:fs"), import("node:path")]);
		const resourceFile = path.normalize(process.cwd() + "/../resources" + input.toString());
		const response = (0, import_testdouble$8.object)();
		(0, import_testdouble$8.when)(response.arrayBuffer()).thenResolve(fs.readFileSync(resourceFile));
		return response;
	}
}

//#endregion
//#region tests/api/worker/invoicegen/XRechnungInvoiceGeneratorTest.ts
dist_default.spec("XRechnungInvoiceGenerator", function() {
	dist_default("xrechnung generation for japanese invoice noVat 2_items", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: " \n, 411,\n501-5627 Shirakawa, Ono-Gun, Gifu, Japan",
			country: "JP",
			subTotal: "20.00",
			grandTotal: "20.00",
			vatType: VatType.NO_VAT,
			paymentMethod: PaymentMethod.INVOICE,
			items: [createTestEntity(InvoiceDataItemTypeRef, {
				amount: `1`,
				startDate: new Date("09.09.1984"),
				endDate: new Date("09.09.1984"),
				singlePrice: "10.00",
				totalPrice: "10.00",
				itemType: "25"
			}), createTestEntity(InvoiceDataItemTypeRef, {
				amount: `1`,
				startDate: new Date("09.09.1984"),
				endDate: new Date("09.09.1984"),
				singlePrice: "10.00",
				totalPrice: "10.00",
				itemType: "25"
			})]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for german paypal addVat 3_items", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Bernd Brot\nNeuschauerberg 56\n91488 Emskirchen",
			country: "DE",
			subTotal: "60.00",
			grandTotal: "71.40",
			vatRate: "19",
			vat: "11.40",
			vatIdNumber: "DE12345678912345678912",
			vatType: VatType.ADD_VAT,
			paymentMethod: PaymentMethod.PAYPAL,
			items: [
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "4",
					startDate: new Date("11.11.1999"),
					endDate: new Date("12.31.2000"),
					singlePrice: "10.00",
					totalPrice: "40.00",
					itemType: "21"
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "2",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "5.00",
					totalPrice: "10.00",
					itemType: "9"
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "10.00",
					totalPrice: "10.00",
					itemType: "12"
				})
			]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for german accountBalance vatIncludedHidden 1_items", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Klappriger Klabautermann\nMariendorfer Hof 971\n12107 Berlin",
			country: "DE",
			subTotal: "36.00",
			grandTotal: "36.00",
			vatRate: "19",
			vat: "5.75",
			vatIdNumber: "DE12345678912345678912",
			vatType: VatType.VAT_INCLUDED_HIDDEN,
			paymentMethod: PaymentMethod.ACCOUNT_BALANCE,
			items: [createTestEntity(InvoiceDataItemTypeRef, {
				amount: "1",
				startDate: new Date("11.11.1999"),
				endDate: new Date("12.31.2000"),
				singlePrice: "36.00",
				totalPrice: "36.00",
				itemType: "21"
			})]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for russia noVatReverse creditCard addVat 1_items", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "CompanyRU\n194352, -\n , . 8, . 2, . .",
			country: "RU",
			subTotal: "30.00",
			grandTotal: "30.00",
			vatType: VatType.NO_VAT_CHARGE_TUTAO,
			vatRate: "0",
			vat: "0",
			vatIdNumber: "RU1234567891",
			paymentMethod: PaymentMethod.CREDIT_CARD,
			items: [createTestEntity(InvoiceDataItemTypeRef, {
				amount: "3",
				startDate: new Date("09.09.1984"),
				endDate: new Date("09.09.1984"),
				singlePrice: "10.00",
				totalPrice: "30.00",
				itemType: "12"
			})]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for credit note", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Malte Kieselstein\nLudwigstrae 6\nHanau-Steinheim",
			invoiceType: InvoiceType.CREDIT,
			country: "DE",
			subTotal: "14.40",
			grandTotal: "17.14",
			vatType: VatType.ADD_VAT,
			vatRate: "19",
			vat: "2.74",
			vatIdNumber: "DE12345678912345678912",
			paymentMethod: PaymentMethod.ACCOUNT_BALANCE,
			items: [createTestEntity(InvoiceDataItemTypeRef, {
				amount: "1",
				startDate: new Date("09.09.1984"),
				endDate: new Date("09.09.1984"),
				singlePrice: "14.40",
				totalPrice: "14.40",
				itemType: InvoiceItemType.Credit
			})]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for discount", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "   \n SL4 1DD  ",
			invoiceType: InvoiceType.INVOICE,
			country: "AE",
			subTotal: "30.00",
			grandTotal: "33.00",
			vatType: VatType.ADD_VAT,
			vatRate: "10",
			vat: "3.00",
			vatIdNumber: "AE12345678912345678912",
			paymentMethod: PaymentMethod.ACCOUNT_BALANCE,
			items: [
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "30.00",
					totalPrice: "30.00",
					itemType: InvoiceItemType.LegendAccount
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "3",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "10.00",
					totalPrice: "30.00",
					itemType: InvoiceItemType.WhitelabelChild
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "-30.00",
					totalPrice: "-30.00",
					itemType: InvoiceItemType.Discount
				})
			]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("xrechnung generation for multi discount", async function() {
		const invoiceData = createTestEntity(InvoiceDataGetOutTypeRef, {
			address: "Jarl Balgruuf\nHolywood BT18 0AA",
			invoiceType: InvoiceType.INVOICE,
			country: "DE",
			subTotal: "8.30",
			grandTotal: "8.30",
			vatType: VatType.VAT_INCLUDED_SHOWN,
			vatRate: "19",
			vat: "1.27",
			vatIdNumber: "DE12345678912345678912",
			paymentMethod: PaymentMethod.ACCOUNT_BALANCE,
			items: [
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "20.30",
					totalPrice: "20.30",
					itemType: InvoiceItemType.Credit
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "-10.50",
					totalPrice: "-10.50",
					itemType: InvoiceItemType.Discount
				}),
				createTestEntity(InvoiceDataItemTypeRef, {
					amount: "1",
					startDate: new Date("09.09.1984"),
					endDate: new Date("09.09.1984"),
					singlePrice: "-1.50",
					totalPrice: "-1.50",
					itemType: InvoiceItemType.Discount
				})
			]
		});
		const gen = new XRechnungInvoiceGenerator(invoiceData, "1978197819801981931", "MyCustomerId", "test@tutao.de");
		const xml = gen.generate();
	});
	dist_default("extractPostalCode", function() {
		const line1 = "Berlin, 12107";
		dist_default(extractPostalCode(line1)).equals("12107");
		const line2 = "Neustadt a.d. Aisch 91413";
		dist_default(extractPostalCode(line2)).equals("91413");
		const line3 = "94188 Emskirchen";
		dist_default(extractPostalCode(line3)).equals("94188");
		const line4 = "Holywood BT18 0AA";
		dist_default(extractPostalCode(line4)).equals("Could not extract postal code. Please refer to full address line.");
		const line5 = "501-5627 Shirakawa, Ono-Gun, Gifu, Japan";
		dist_default(extractPostalCode(line5)).equals("Could not extract postal code. Please refer to full address line.");
	});
	dist_default("extractCityName", function() {
		const line1 = "Berlin, 12107";
		dist_default(extractCityName(line1).includes("Berlin")).equals(true);
		const line2 = "Neustadt a.d. Aisch 91413";
		dist_default(extractCityName(line2).includes("Neustadt a.d. Aisch")).equals(true);
		const line3 = "94188 Emskirchen";
		dist_default(extractCityName(line3).includes("Emskirchen")).equals(true);
		const line4 = "Holywood BT18 0AA";
		dist_default(extractCityName(line4).includes("Holywood")).equals(true);
		const line5 = "501-5627 Shirakawa, Ono-Gun, Gifu, Japan";
		dist_default(extractCityName(line5).includes("Shirakawa")).equals(true);
	});
});

//#endregion
//#region tests/subscription/SignupFormTest.ts
dist_default.spec("CaptchaInputParse", function() {
	dist_default("invalid input", function() {
		dist_default(parseCaptchaInput("nonsense")).equals(null);
		dist_default(parseCaptchaInput("2:")).equals(null);
		dist_default(parseCaptchaInput(":::")).equals(null);
		dist_default(parseCaptchaInput("")).equals(null);
		dist_default(parseCaptchaInput("25:01")).equals(null);
		dist_default(parseCaptchaInput("08:84")).equals(null);
		dist_default(parseCaptchaInput("08:60")).equals(null);
	});
	dist_default("single digit hour or minute", function() {
		dist_default(parseCaptchaInput("1:1")).equals("01:01");
		dist_default(parseCaptchaInput("13:1")).equals("01:01");
		dist_default(parseCaptchaInput("01:1")).equals("01:01");
		dist_default(parseCaptchaInput("1:01")).equals("01:01");
		dist_default(parseCaptchaInput("2:00")).equals("02:00");
	});
	dist_default("hour 0", function() {
		dist_default(parseCaptchaInput("24:00")).equals("00:00");
		dist_default(parseCaptchaInput("12:00")).equals("00:00");
		dist_default(parseCaptchaInput("00:00")).equals("00:00");
		dist_default(parseCaptchaInput("24:14")).equals("00:14");
	});
	dist_default("24 hour and 12 hour match", function() {
		dist_default(parseCaptchaInput("13:01")).equals("01:01");
		dist_default(parseCaptchaInput("01:01")).equals("01:01");
	});
});

//#endregion
//#region tests/api/worker/facades/ContactFacadeTest.ts
var import_testdouble$7 = __toESM(require_testdouble(), 1);
dist_default.spec("ContactFacadeTest", function() {
	let entityClient$1;
	dist_default.before(() => {
		entityClient$1 = (0, import_testdouble$7.object)();
	});
	dist_default("the facade can import a list of clients", async function() {
		const facade = new ContactFacade(entityClient$1);
		const contacts$1 = [createFilledContact("Test", "User", "Hello World!", "Tutao", "Mr.", "Jung", "Lange", "Jr.", "It", ["jung@tuta.com"], ["93291381"], [], [], ["tutanota.com"]), createFilledContact("Ant", "Ste", "Hello World!", "Tutao", "Mr.", "Buffalo", "Lange", "Jr.", "IT", ["antste@antste.de", "bentste@bentste.de"], ["123123123", "321321321"], ["diaspora.de"])];
		await facade.importContactList(contacts$1, "testId");
		(0, import_testdouble$7.verify)(entityClient$1.setupMultipleEntities("testId", contacts$1));
	});
});

//#endregion
//#region tests/api/worker/facades/KeyRotationFacadeTest.ts
var import_testdouble$6 = __toESM(require_testdouble(), 1);
const { anything } = import_testdouble$6.matchers;
const PQ_SAFE_BITARRAY_KEY_LENGTH = KEY_LENGTH_BYTES_AES_256 / 4;
const PW_KEY = [0];
PW_KEY.length = PQ_SAFE_BITARRAY_KEY_LENGTH;
const CURRENT_USER_GROUP_KEY = {
	object: [1],
	version: 0
};
CURRENT_USER_GROUP_KEY.object.length = PQ_SAFE_BITARRAY_KEY_LENGTH;
const CURRENT_ADMIN_GROUP_KEY = {
	object: [2],
	version: 0
};
CURRENT_ADMIN_GROUP_KEY.object.length = PQ_SAFE_BITARRAY_KEY_LENGTH;
const NEW_USER_GROUP_KEY = {
	object: [
		3,
		3,
		3,
		3
	],
	version: 1
};
const NEW_ADMIN_GROUP_KEY = {
	object: [4],
	version: 1
};
const RECOVER_CODE = [8];
const RECOVER_CODE_VERIFIER = new Uint8Array([9]);
const AUTH_VERIFIER = createAuthVerifier(PW_KEY);
const DISTRIBUTION_KEY = [10];
const CURRENT_USER_AREA_GROUP_KEY = {
	object: [11],
	version: 0
};
const NEW_GROUP_KEY = {
	object: [12],
	version: 1
};
const MEMBER1_BUCKET_KEY = [13];
const MEMBER1_SESSION_KEY = [14];
const OTHER_MEMBER_USER_GROUP_KEY = {
	object: [15],
	version: 0
};
OTHER_MEMBER_USER_GROUP_KEY.object.length = PQ_SAFE_BITARRAY_KEY_LENGTH;
const MEMBER1_SESSION_KEY_ENC_NEW_USER_AREA_GROUP_KEY = new Uint8Array(MEMBER1_SESSION_KEY.concat(NEW_GROUP_KEY.object));
const MEMBER1_BUCKET_KEY_ENC_MEMBER1_SESSION_KEY = new Uint8Array(MEMBER1_BUCKET_KEY.concat(MEMBER1_SESSION_KEY));
const DISTRIBUTION_KEY_ENC_NEW_USER_GROUP_KEY = new Uint8Array(DISTRIBUTION_KEY.concat(NEW_USER_GROUP_KEY.object));
const CURRENT_ADMIN_GROUP_ENC_CURRENT_USER_GROUP_KEY = {
	key: new Uint8Array(CURRENT_ADMIN_GROUP_KEY.object.concat(CURRENT_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const CURRENT_ADMIN_GROUP_ENC_CURRENT_ADMIN_GROUP_KEY = {
	key: new Uint8Array(CURRENT_ADMIN_GROUP_KEY.object.concat(CURRENT_ADMIN_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const PW_ENC_CURRENT_USER_GROUP_KEY = {
	key: new Uint8Array(PW_KEY.concat(CURRENT_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const NEW_ADMIN_GROUP_ENC_NEW_USER_GROUP_KEY = {
	key: new Uint8Array(NEW_ADMIN_GROUP_KEY.object.concat(NEW_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const NEW_ADMIN_GROUP_ENC_NEW_ADMIN_GROUP_KEY = {
	key: new Uint8Array(NEW_ADMIN_GROUP_KEY.object.concat(NEW_ADMIN_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const NEW_USER_GROUP_ENC_NEW_ADMIN_GROUP_KEY = {
	key: new Uint8Array(NEW_USER_GROUP_KEY.object.concat(NEW_ADMIN_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const NEW_ADMIN_GROUP_ENC_CURRENT_ADMIN_GROUP_KEY = {
	key: new Uint8Array(NEW_ADMIN_GROUP_KEY.object.concat(CURRENT_ADMIN_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const NEW_USER_GROUP_ENC_CURRENT_USER_GROUP_KEY = {
	key: new Uint8Array(NEW_USER_GROUP_KEY.object.concat(CURRENT_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const PW_ENC_NEW_USER_GROUP_KEY = {
	key: new Uint8Array(PW_KEY.concat(NEW_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const NEW_USER_GROUP_ENC_RECOVER_CODE_KEY = {
	key: new Uint8Array(NEW_USER_GROUP_KEY.object.concat(RECOVER_CODE)),
	encryptingKeyVersion: 1
};
const RECOVER_CODE_ENC_NEW_USER_GROUP_KEY = {
	key: new Uint8Array(RECOVER_CODE.concat(NEW_USER_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const NEW_USER_AREA_GROUP_ENC_CURRENT_USER_AREA_GROUP_KEY = {
	key: new Uint8Array(NEW_GROUP_KEY.object.concat(CURRENT_USER_AREA_GROUP_KEY.object)),
	encryptingKeyVersion: 1
};
const CURRENT_ADMIN_GROUP_ENC_NEW_USER_AREA_GROUP_KEY = {
	key: new Uint8Array(CURRENT_ADMIN_GROUP_KEY.object.concat(NEW_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const CURRENT_USER_GROUP_ENC_NEW_USER_AREA_GROUP_KEY = {
	key: new Uint8Array(CURRENT_USER_GROUP_KEY.object.concat(NEW_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const OTHER_USER_GROUP_ENC_NEW_SHARED_GROUP_KEY = {
	key: new Uint8Array(OTHER_MEMBER_USER_GROUP_KEY.object.concat(NEW_GROUP_KEY.object)),
	encryptingKeyVersion: 0
};
const userId = "userId";
const userGroupId = "userGroupId";
const adminGroupId = "adminGroupId";
const someGroupId = "someGroup";
const usersCustomerGroupId = "usersCustomerGroupId";
const groupInfoElementId = "groupInfo";
const recoverCodeId = "recoverCodeId";
const keyRotationsListId = "keyRotationsListId";
const invitationsListId = "invitationsListId";
const groupKeyUpdatesListId = "groupKeyUpdatesListId";
function prepareRecoverData(recoverData, recoverCodeFacade) {
	recoverData = {
		hexCode: "hexCode",
		recoverCodeEncUserGroupKey: NEW_USER_GROUP_ENC_RECOVER_CODE_KEY.key,
		userKeyVersion: NEW_USER_GROUP_ENC_RECOVER_CODE_KEY.encryptingKeyVersion,
		userEncRecoverCode: RECOVER_CODE_ENC_NEW_USER_GROUP_KEY.key,
		recoveryCodeVerifier: RECOVER_CODE_VERIFIER
	};
	(0, import_testdouble$6.when)(recoverCodeFacade.getRawRecoverCode(PW_KEY)).thenResolve(RECOVER_CODE);
	(0, import_testdouble$6.when)(recoverCodeFacade.encryptRecoveryCode(RECOVER_CODE, NEW_USER_GROUP_KEY)).thenReturn(recoverData);
}
function verifyRecoverCodeData(userGroupKeyData) {
	const recoverCodeData = assertNotNull(userGroupKeyData.recoverCodeData);
	dist_default(recoverCodeData.recoveryCodeVerifier).deepEquals(RECOVER_CODE_VERIFIER);
	dist_default(recoverCodeData.userKeyVersion).equals(String(NEW_USER_GROUP_ENC_RECOVER_CODE_KEY.encryptingKeyVersion));
	dist_default(recoverCodeData.userEncRecoveryCode).deepEquals(RECOVER_CODE_ENC_NEW_USER_GROUP_KEY.key);
	dist_default(recoverCodeData.recoveryCodeEncUserGroupKey).deepEquals(NEW_USER_GROUP_ENC_RECOVER_CODE_KEY.key);
}
function prepareUserKeyRotation(mocks, keyRotationFacade, userGroup) {
	const commonHash = new Uint8Array([1, 2]);
	const adminGeneratedHash = new Uint8Array([
		1,
		2,
		3
	]);
	const adminPubEccKey = new Uint8Array([
		0,
		9,
		9
	]);
	const pubEncSymKeyBytes = new Uint8Array([
		7,
		7,
		7
	]);
	const adminPubKyberKey = new Uint8Array([
		8,
		8,
		8
	]);
	keyRotationFacade.setPendingKeyRotations({
		pwKey: PW_KEY,
		adminOrUserGroupKeyRotation: createTestEntity(KeyRotationTypeRef, {
			_id: [keyRotationsListId, userGroupId],
			targetKeyVersion: String(Number(userGroup.groupKeyVersion) + 1),
			groupKeyRotationType: GroupKeyRotationType.User,
			adminGroupKeyAuthenticationData: createTestEntity(AdminGroupKeyAuthenticationDataTypeRef, {
				authKeyEncAdminRotationHash: adminGeneratedHash,
				version: "1",
				userGroup: "userGroup"
			})
		}),
		teamOrCustomerGroupKeyRotations: [],
		userAreaGroupsKeyRotations: []
	});
	(0, import_testdouble$6.when)(mocks.cryptoWrapper.aesDecrypt(import_testdouble$6.matchers.anything(), import_testdouble$6.matchers.anything(), true)).thenReturn(commonHash);
	(0, import_testdouble$6.when)(mocks.cryptoWrapper.sha256Hash(import_testdouble$6.matchers.anything())).thenReturn(commonHash);
	(0, import_testdouble$6.when)(mocks.serviceExecutor.get(PublicKeyService, import_testdouble$6.matchers.anything())).thenResolve({
		pubEccKey: adminPubEccKey,
		pubKyberKey: adminPubKyberKey
	});
	const customer = createTestEntity(CustomerTypeRef, { adminGroup: "adminGroupId" });
	(0, import_testdouble$6.when)(mocks.entityClient.load(CustomerTypeRef, import_testdouble$6.matchers.anything())).thenResolve(customer);
	(0, import_testdouble$6.when)(mocks.asymmetricCryptoFacade.tutaCryptEncryptSymKey(import_testdouble$6.matchers.anything(), import_testdouble$6.matchers.anything(), import_testdouble$6.matchers.anything())).thenResolve({
		pubEncSymKeyBytes,
		cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT,
		senderKeyVersion: 1,
		recipientKeyVersion: 1
	});
}
dist_default.spec("KeyRotationFacadeTest", function() {
	let entityClientMock;
	let keyRotationFacade;
	let keyLoaderFacadeMock;
	let pqFacadeMock;
	let serviceExecutorMock;
	let userFacade;
	let recoverCodeFacade;
	let cryptoFacade;
	let shareFacade;
	let groupManagementFacade;
	let asymmetricCryptoFacade$1;
	let user;
	const pwKey = uint8ArrayToBitArray(new Uint8Array(Array(KEY_LENGTH_BYTES_AES_256).keys()));
	let cryptoWrapperMock;
	let userEncAdminKey;
	const groupId = someGroupId;
	let group;
	let groupInfo;
	let groupKeyVersion0;
	let customer;
	dist_default.beforeEach(async () => {
		entityClientMock = (0, import_testdouble$6.instance)(EntityClient);
		keyLoaderFacadeMock = (0, import_testdouble$6.object)();
		pqFacadeMock = (0, import_testdouble$6.object)();
		serviceExecutorMock = (0, import_testdouble$6.instance)(ServiceExecutor);
		cryptoWrapperMock = (0, import_testdouble$6.object)();
		userEncAdminKey = (0, import_testdouble$6.object)();
		recoverCodeFacade = (0, import_testdouble$6.object)();
		const recoverCodeFacadeAsync = lazyMemoized(async () => recoverCodeFacade);
		userFacade = (0, import_testdouble$6.object)();
		cryptoFacade = (0, import_testdouble$6.object)();
		shareFacade = (0, import_testdouble$6.object)();
		groupManagementFacade = (0, import_testdouble$6.object)();
		asymmetricCryptoFacade$1 = (0, import_testdouble$6.object)();
		keyRotationFacade = new KeyRotationFacade(entityClientMock, keyLoaderFacadeMock, pqFacadeMock, serviceExecutorMock, cryptoWrapperMock, recoverCodeFacadeAsync, userFacade, cryptoFacade, async () => shareFacade, async () => groupManagementFacade, asymmetricCryptoFacade$1);
		user = await makeUser(userId, {
			key: userEncAdminKey,
			encryptingKeyVersion: 0
		});
		const customerId = "customerId";
		customer = createTestEntity(CustomerTypeRef, {
			_id: customerId,
			userGroups: "userGroupsList"
		});
		const groupData = makeGroupWithMembership(groupId, user);
		group = groupData.group;
		groupInfo = groupData.groupInfo;
		(0, import_testdouble$6.when)(userFacade.getUser()).thenReturn(user);
		(0, import_testdouble$6.when)(userFacade.getUserGroupId()).thenReturn(userGroupId);
		(0, import_testdouble$6.when)(entityClientMock.load(GroupTypeRef, groupId)).thenResolve(group);
		(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(groupId)).thenResolve({
			version: 0,
			object: groupKeyVersion0
		});
		(0, import_testdouble$6.when)(entityClientMock.load(UserGroupRootTypeRef, anything())).thenResolve(await makeUserGroupRoot(keyRotationsListId, invitationsListId, groupKeyUpdatesListId));
		(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymUserGroupKey()).thenReturn(CURRENT_USER_GROUP_KEY);
		(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(adminGroupId)).thenResolve(CURRENT_ADMIN_GROUP_KEY);
		(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(groupId)).thenResolve(CURRENT_USER_AREA_GROUP_KEY);
		(0, import_testdouble$6.when)(entityClientMock.load(CustomerTypeRef, customerId)).thenResolve(customer);
		(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupInfoTypeRef, customer.userGroups)).thenResolve([]);
	});
	dist_default.spec("initialize", function() {
		dist_default("When a key rotation for the admin group exists on the server, the password key is saved in the facade", async function() {
			(0, import_testdouble$6.when)(serviceExecutorMock.get(GroupKeyRotationInfoService, anything())).thenResolve(createTestEntity(GroupKeyRotationInfoGetOutTypeRef, {
				userOrAdminGroupKeyRotationScheduled: true,
				groupKeyUpdates: []
			}));
			await keyRotationFacade.initialize(pwKey, true);
			dist_default(keyRotationFacade.pendingKeyRotations.pwKey).deepEquals(pwKey);
		});
		dist_default("When a key rotation for the admin group does not exist on the server, the password key is not saved in the facade", async function() {
			(0, import_testdouble$6.when)(serviceExecutorMock.get(GroupKeyRotationInfoService, anything())).thenResolve(createTestEntity(GroupKeyRotationInfoGetOutTypeRef, {
				userOrAdminGroupKeyRotationScheduled: false,
				groupKeyUpdates: []
			}));
			await keyRotationFacade.initialize(pwKey, true);
			dist_default(keyRotationFacade.pendingKeyRotations.pwKey).equals(null);
		});
	});
	dist_default.spec("loadPendingKeyRotations", function() {
		dist_default("When a key rotation for a user area group exists on the server, the pending key rotation is saved in the facade.", async function() {
			(0, import_testdouble$6.when)(entityClientMock.loadAll(KeyRotationTypeRef, anything())).thenResolve(makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId));
			await keyRotationFacade.loadPendingKeyRotations(user);
			dist_default(keyRotationFacade.pendingKeyRotations.userAreaGroupsKeyRotations.length).equals(1);
			dist_default(keyRotationFacade.pendingKeyRotations.adminOrUserGroupKeyRotation).equals(null);
		});
		dist_default.spec("When a key rotation for a group that is not yet supported exists on the server, nothing is saved in the facade", function() {
			dist_default("Team", async function() {
				(0, import_testdouble$6.when)(entityClientMock.loadAll(KeyRotationTypeRef, anything())).thenResolve(makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Team, groupId));
				await keyRotationFacade.loadPendingKeyRotations(user);
				dist_default(keyRotationFacade.pendingKeyRotations.userAreaGroupsKeyRotations.length).equals(0);
				dist_default(keyRotationFacade.pendingKeyRotations.adminOrUserGroupKeyRotation).equals(null);
			});
			dist_default("Customer", async function() {
				(0, import_testdouble$6.when)(entityClientMock.loadAll(KeyRotationTypeRef, anything())).thenResolve(makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, groupId));
				await keyRotationFacade.loadPendingKeyRotations(user);
				dist_default(keyRotationFacade.pendingKeyRotations.userAreaGroupsKeyRotations.length).equals(0);
				dist_default(keyRotationFacade.pendingKeyRotations.adminOrUserGroupKeyRotation).equals(null);
			});
		});
	});
	dist_default.spec("processPendingKeyRotation", function() {
		dist_default.spec("User area group key rotation", function() {
			dist_default("Rotated group does not have a key pair", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
				});
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.keyPair).equals(null);
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(null);
				dist_default(update.adminGroupKeyVersion).equals(null);
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(1);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
			});
			dist_default("Rotated group does not have adminEncKey", async function() {
				group.adminGroupEncGKey = null;
				(0, import_testdouble$6.when)(groupManagementFacade.hasAdminEncGKey(group)).thenReturn(false);
				group.adminGroupKeyVersion = null;
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
				});
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.keyPair).equals(null);
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).equals(null);
				dist_default(update.adminGroupKeyVersion).equals(null);
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(1);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
			});
			dist_default("Rotated group has key pair and adminEncGroupKey", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
				});
				group.currentKeys = createTestEntity(KeyPairTypeRef);
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey, newKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				const generated = mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, newKey.object);
				const { newKeyPairs, encryptedEccPrivKey, encryptedKyberPrivKey, kyberPublicKeyBytes } = generated.get(newKey.object);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				const sentKeyPairs = createTestEntity(KeyPairTypeRef, {
					pubEccKey: newKeyPairs.eccKeyPair.publicKey,
					symEncPrivEccKey: encryptedEccPrivKey,
					pubKyberKey: kyberPublicKeyBytes,
					symEncPrivKyberKey: encryptedKyberPrivKey
				});
				dist_default(update.keyPair).deepEquals(sentKeyPairs);
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(null);
				dist_default(update.adminGroupKeyVersion).equals(null);
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(1);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
			});
			dist_default.spec("Rotated group is a shared group", function() {
				dist_default("Rotated group has pending invitations", async function() {
					keyRotationFacade.setPendingKeyRotations({
						pwKey: null,
						adminOrUserGroupKeyRotation: null,
						teamOrCustomerGroupKeyRotations: [],
						userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
					});
					prepareKeyMocks(cryptoWrapperMock);
					const invitationId = [invitationsListId, "invitationElementId"];
					const inviteeMailAddress = "inviteeMailAddress";
					const capability = ShareCapability.Invite;
					(0, import_testdouble$6.when)(entityClientMock.loadAll(SentGroupInvitationTypeRef, group.invitations)).thenResolve([createTestEntity(SentGroupInvitationTypeRef, {
						receivedInvitation: invitationId,
						inviteeMailAddress,
						capability
					})]);
					const groupInvitationPostDataMock = (0, import_testdouble$6.object)();
					(0, import_testdouble$6.when)(shareFacade.prepareGroupInvitation(anything(), groupInfo, [inviteeMailAddress], capability)).thenResolve(groupInvitationPostDataMock);
					await keyRotationFacade.processPendingKeyRotation(user);
					const captor$4 = import_testdouble$6.matchers.captor();
					(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
					(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(groupInvitationPostDataMock));
					const sentData = captor$4.value;
					dist_default(sentData.groupKeyUpdates.length).equals(1);
					const update = sentData.groupKeyUpdates[0];
					dist_default(update.group).equals(groupId);
					dist_default(update.groupKeyVersion).equals("1");
					dist_default(update.groupKeyUpdatesForMembers).deepEquals([]);
				});
				dist_default("Rotated group has pending invitations, where no re-invite is possible", async function() {
					keyRotationFacade.setPendingKeyRotations({
						pwKey: null,
						adminOrUserGroupKeyRotation: null,
						teamOrCustomerGroupKeyRotations: [],
						userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
					});
					prepareKeyMocks(cryptoWrapperMock);
					const invitationId = [invitationsListId, "invitationElementId"];
					const inviteeMailAddress = "inviteeMailAddress";
					const capability = ShareCapability.Invite;
					(0, import_testdouble$6.when)(entityClientMock.loadAll(SentGroupInvitationTypeRef, group.invitations)).thenResolve([createTestEntity(SentGroupInvitationTypeRef, {
						receivedInvitation: invitationId,
						inviteeMailAddress,
						capability
					})]);
					(0, import_testdouble$6.when)(shareFacade.prepareGroupInvitation(anything(), groupInfo, [inviteeMailAddress], capability)).thenReject(new RecipientsNotFoundError([inviteeMailAddress].join("\n")));
					await keyRotationFacade.processPendingKeyRotation(user);
					const captor$4 = import_testdouble$6.matchers.captor();
					(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
					(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
					const sentData = captor$4.value;
					dist_default(sentData.groupKeyUpdates.length).equals(1);
					const update = sentData.groupKeyUpdates[0];
					dist_default(update.group).equals(groupId);
					dist_default(update.groupKeyVersion).equals("1");
					dist_default(update.groupKeyUpdatesForMembers).deepEquals([]);
				});
				dist_default("Rotated group has other members", async function() {
					keyRotationFacade.setPendingKeyRotations({
						pwKey: null,
						adminOrUserGroupKeyRotation: null,
						teamOrCustomerGroupKeyRotations: [],
						userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
					});
					prepareKeyMocks(cryptoWrapperMock);
					const memberUserId = "memberUserId";
					const memberUserGroupInfoId = ["memberUGIListId", "memberUGIElementId"];
					const memberMailAddress = "member@tuta.com";
					(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group.members)).thenResolve([createTestEntity(GroupMemberTypeRef, {
						group: groupId,
						user: userId
					}), createTestEntity(GroupMemberTypeRef, {
						group: groupId,
						user: memberUserId,
						userGroupInfo: memberUserGroupInfoId
					})]);
					(0, import_testdouble$6.when)(entityClientMock.loadMultiple(GroupInfoTypeRef, memberUserGroupInfoId[0], [memberUserGroupInfoId[1]])).thenResolve([createTestEntity(GroupInfoTypeRef, {
						_id: memberUserGroupInfoId,
						mailAddress: memberMailAddress
					})]);
					const recipientKeyVersion = "0";
					const pubEncBucketKeyMock = (0, import_testdouble$6.object)();
					const protocolVersion = CryptoProtocolVersion.TUTA_CRYPT;
					(0, import_testdouble$6.when)(cryptoFacade.encryptBucketKeyForInternalRecipient(userGroupId, anything(), memberMailAddress, [])).thenResolve(createTestEntity(InternalRecipientKeyDataTypeRef, {
						protocolVersion,
						senderKeyVersion: user.userGroup.groupKeyVersion,
						mailAddress: memberMailAddress,
						recipientKeyVersion,
						pubEncBucketKey: pubEncBucketKeyMock
					}));
					(0, import_testdouble$6.when)(cryptoWrapperMock.aes256RandomKey()).thenReturn(NEW_GROUP_KEY.object, MEMBER1_BUCKET_KEY, MEMBER1_SESSION_KEY);
					(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKey(MEMBER1_BUCKET_KEY, MEMBER1_SESSION_KEY)).thenReturn(MEMBER1_BUCKET_KEY_ENC_MEMBER1_SESSION_KEY);
					(0, import_testdouble$6.when)(cryptoWrapperMock.encryptBytes(MEMBER1_SESSION_KEY, bitArrayToUint8Array(NEW_GROUP_KEY.object))).thenReturn(MEMBER1_SESSION_KEY_ENC_NEW_USER_AREA_GROUP_KEY);
					await keyRotationFacade.processPendingKeyRotation(user);
					const captor$4 = import_testdouble$6.matchers.captor();
					(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
					(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
					const sentData = captor$4.value;
					dist_default(sentData.groupKeyUpdates.length).equals(1);
					const update = sentData.groupKeyUpdates[0];
					dist_default(update.group).equals(groupId);
					dist_default(update.groupKeyVersion).equals("1");
					dist_default(update.groupKeyUpdatesForMembers.length).deepEquals(1);
					const groupKeyUpdateData = update.groupKeyUpdatesForMembers[0];
					dist_default(groupKeyUpdateData.sessionKeyEncGroupKeyVersion).equals("1");
					dist_default(groupKeyUpdateData.sessionKeyEncGroupKey).deepEquals(MEMBER1_SESSION_KEY_ENC_NEW_USER_AREA_GROUP_KEY);
					dist_default(groupKeyUpdateData.bucketKeyEncSessionKey).deepEquals(MEMBER1_BUCKET_KEY_ENC_MEMBER1_SESSION_KEY);
					const pubEncBucketKeyData = groupKeyUpdateData.pubEncBucketKeyData;
					dist_default(pubEncBucketKeyData.pubEncSymKey).deepEquals(pubEncBucketKeyMock);
					dist_default(pubEncBucketKeyData.protocolVersion).deepEquals(protocolVersion);
					dist_default(pubEncBucketKeyData.senderKeyVersion).deepEquals(user.userGroup.groupKeyVersion);
					dist_default(pubEncBucketKeyData.recipientKeyVersion).deepEquals(recipientKeyVersion);
					dist_default(pubEncBucketKeyData.recipientIdentifier).deepEquals(memberMailAddress);
					dist_default(pubEncBucketKeyData.recipientIdentifierType).deepEquals(PublicKeyIdentifierType.MAIL_ADDRESS);
				});
				dist_default("Rotated group has deactivated members", async function() {
					keyRotationFacade.setPendingKeyRotations({
						pwKey: null,
						adminOrUserGroupKeyRotation: null,
						teamOrCustomerGroupKeyRotations: [],
						userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
					});
					prepareKeyMocks(cryptoWrapperMock);
					const memberUserId = "memberUserId";
					const memberUserGroupInfoId = ["memberUGIListId", "memberUGIElementId"];
					const memberMailAddress = "member@tuta.com";
					const sameUserMember = createTestEntity(GroupMemberTypeRef, {
						group: groupId,
						user: userId
					});
					(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group.members)).thenResolve([sameUserMember, createTestEntity(GroupMemberTypeRef, {
						group: groupId,
						user: memberUserId,
						userGroupInfo: memberUserGroupInfoId
					})], [sameUserMember]);
					(0, import_testdouble$6.when)(entityClientMock.loadMultiple(GroupInfoTypeRef, memberUserGroupInfoId[0], [memberUserGroupInfoId[1]])).thenResolve([createTestEntity(GroupInfoTypeRef, {
						_id: memberUserGroupInfoId,
						mailAddress: memberMailAddress
					})]);
					(0, import_testdouble$6.when)(cryptoFacade.encryptBucketKeyForInternalRecipient(userGroupId, anything(), memberMailAddress, [])).thenDo((senderUserGroupId, bucketKey, recipientMailAddress, notFoundRecipients) => {
						notFoundRecipients.push(memberMailAddress);
						return null;
					});
					(0, import_testdouble$6.when)(cryptoWrapperMock.aes256RandomKey()).thenReturn(NEW_GROUP_KEY.object, MEMBER1_BUCKET_KEY, MEMBER1_SESSION_KEY);
					(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKey(MEMBER1_BUCKET_KEY, MEMBER1_SESSION_KEY)).thenReturn(MEMBER1_BUCKET_KEY_ENC_MEMBER1_SESSION_KEY);
					(0, import_testdouble$6.when)(cryptoWrapperMock.encryptBytes(MEMBER1_SESSION_KEY, bitArrayToUint8Array(NEW_GROUP_KEY.object))).thenReturn(MEMBER1_SESSION_KEY_ENC_NEW_USER_AREA_GROUP_KEY);
					await keyRotationFacade.processPendingKeyRotation(user);
					const captor$4 = import_testdouble$6.matchers.captor();
					(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
					(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
					const sentData = captor$4.value;
					dist_default(sentData.groupKeyUpdates.length).equals(1);
					const update = sentData.groupKeyUpdates[0];
					dist_default(update.group).equals(groupId);
					dist_default(update.groupKeyVersion).equals("1");
					dist_default(update.groupKeyUpdatesForMembers).deepEquals([]);
				});
			});
			dist_default("Key rotation for multiple groups are executed in one request", async function() {
				const secondGroupId = "groupId-2";
				makeGroupWithMembership(secondGroupId, user);
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(secondGroupId)).thenResolve(CURRENT_USER_AREA_GROUP_KEY);
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: [createTestEntity(KeyRotationTypeRef, {
						groupKeyRotationType: GroupKeyRotationType.UserArea,
						_id: [keyRotationsListId, groupId],
						targetKeyVersion: "1"
					}), createTestEntity(KeyRotationTypeRef, {
						groupKeyRotationType: GroupKeyRotationType.UserArea,
						_id: [keyRotationsListId, secondGroupId],
						targetKeyVersion: "1"
					})]
				});
				prepareKeyMocks(cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(2);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				const secondUpdate = sentData.groupKeyUpdates[1];
				dist_default(secondUpdate.group).equals(secondGroupId);
				dist_default(secondUpdate.groupKeyVersion).equals("1");
			});
			dist_default("Rotate group user area group of non admin", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
				});
				findAllAndRemove(user.memberships, (m) => m.groupType === GroupType.Admin);
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.keyPair).equals(null);
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(null);
				dist_default(update.adminGroupKeyVersion).equals(null);
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(1);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
			});
		});
		dist_default.spec("Admin group key rotation", function() {
			let userGroup;
			let adminGroup;
			let recoverData;
			let generatedKeyPairs;
			dist_default.beforeEach(function() {
				userGroup = makeGroupWithMembership(userGroupId, user).group;
				userGroup.adminGroupEncGKey = CURRENT_ADMIN_GROUP_ENC_CURRENT_USER_GROUP_KEY.key;
				userGroup.adminGroupKeyVersion = String(CURRENT_ADMIN_GROUP_ENC_CURRENT_USER_GROUP_KEY.encryptingKeyVersion);
				userGroup.type = GroupType.User;
				userGroup.currentKeys = (0, import_testdouble$6.object)();
				adminGroup = makeGroupWithMembership(adminGroupId, user).group;
				adminGroup.adminGroupEncGKey = CURRENT_ADMIN_GROUP_ENC_CURRENT_ADMIN_GROUP_KEY.key;
				adminGroup.adminGroupKeyVersion = String(CURRENT_ADMIN_GROUP_ENC_CURRENT_ADMIN_GROUP_KEY.encryptingKeyVersion);
				adminGroup.type = GroupType.Admin;
				adminGroup.currentKeys = (0, import_testdouble$6.object)();
				prepareRecoverData(recoverData, recoverCodeFacade);
				(0, import_testdouble$6.when)(groupManagementFacade.hasAdminEncGKey(userGroup)).thenReturn(true);
				(0, import_testdouble$6.when)(groupManagementFacade.hasAdminEncGKey(adminGroup)).thenReturn(true);
				(0, import_testdouble$6.when)(userFacade.deriveUserGroupKeyDistributionKey(userGroupId, PW_KEY)).thenReturn(DISTRIBUTION_KEY);
				const encryptingKeyCaptor = import_testdouble$6.matchers.captor();
				const keyCaptor = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKey(DISTRIBUTION_KEY, NEW_USER_GROUP_KEY.object)).thenReturn(DISTRIBUTION_KEY_ENC_NEW_USER_GROUP_KEY);
				(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKeyWithVersionedKey(encryptingKeyCaptor.capture(), keyCaptor.capture())).thenDo((arg) => ({
					encryptingKeyVersion: encryptingKeyCaptor.value.version,
					key: new Uint8Array(encryptingKeyCaptor.value.object.concat(keyCaptor.value))
				}));
				(0, import_testdouble$6.when)(cryptoWrapperMock.aes256RandomKey()).thenReturn(NEW_ADMIN_GROUP_KEY.object, NEW_USER_GROUP_KEY.object);
				generatedKeyPairs = mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, NEW_ADMIN_GROUP_KEY.object, NEW_USER_GROUP_KEY.object);
			});
			dist_default("Successful rotation", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: PW_KEY,
					adminOrUserGroupKeyRotation: createTestEntity(KeyRotationTypeRef, {
						_id: [keyRotationsListId, adminGroupId],
						targetKeyVersion: String(Number(adminGroup.groupKeyVersion) + 1),
						groupKeyRotationType: GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount
					}),
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: []
				});
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(AdminGroupKeyRotationService, import_testdouble$6.matchers.argThat((arg) => {
					const userGroupKeyData = arg.userGroupKeyData;
					const adminGroupKeyData = arg.adminGroupKeyData;
					verifyRecoverCodeData(userGroupKeyData);
					dist_default(userGroupKeyData.adminGroupKeyVersion).deepEquals(String(NEW_ADMIN_GROUP_ENC_NEW_USER_GROUP_KEY.encryptingKeyVersion));
					verifyUserGroupKeyDataExceptAdminKey(userGroupKeyData, generatedKeyPairs);
					dist_default(adminGroupKeyData.groupMembershipUpdateData.length).equals(1);
					dist_default(adminGroupKeyData.groupMembershipUpdateData[0].userId).deepEquals(userId);
					dist_default(adminGroupKeyData.groupMembershipUpdateData[0].userKeyVersion).deepEquals(String(NEW_USER_GROUP_ENC_NEW_ADMIN_GROUP_KEY.encryptingKeyVersion));
					dist_default(adminGroupKeyData.adminGroupKeyVersion).deepEquals(String(NEW_ADMIN_GROUP_KEY.version));
					dist_default(adminGroupKeyData.groupKeyVersion).deepEquals(assertNotNull(adminGroupKeyData.adminGroupKeyVersion));
					dist_default(adminGroupKeyData.group).deepEquals(adminGroupId);
					dist_default(adminGroupKeyData.adminGroupEncGroupKey).deepEquals(NEW_ADMIN_GROUP_ENC_NEW_ADMIN_GROUP_KEY.key);
					dist_default(adminGroupKeyData.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(NEW_USER_GROUP_ENC_NEW_ADMIN_GROUP_KEY.key);
					dist_default(adminGroupKeyData.groupEncPreviousGroupKey).deepEquals(NEW_ADMIN_GROUP_ENC_CURRENT_ADMIN_GROUP_KEY.key);
					const mockedAdminKeyPairs = generatedKeyPairs.get(NEW_ADMIN_GROUP_KEY.object);
					verifyKeyPair(adminGroupKeyData.keyPair, mockedAdminKeyPairs);
					return true;
				})));
				dist_default(keyRotationFacade.pendingKeyRotations.adminOrUserGroupKeyRotation).equals(null);
				dist_default(keyRotationFacade.pendingKeyRotations.pwKey).equals(null);
			});
			dist_default("Successful rotation - no recover code", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: PW_KEY,
					adminOrUserGroupKeyRotation: createTestEntity(KeyRotationTypeRef, {
						_id: [keyRotationsListId, adminGroupId],
						targetKeyVersion: String(Number(adminGroup.groupKeyVersion) + 1),
						groupKeyRotationType: GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount
					}),
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: []
				});
				assertNotNull(user.auth).recoverCode = null;
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(AdminGroupKeyRotationService, import_testdouble$6.matchers.argThat((arg) => {
					const userGroupKeyData = arg.userGroupKeyData;
					const adminGroupKeyData = arg.adminGroupKeyData;
					dist_default(userGroupKeyData.recoverCodeData).equals(null);
					dist_default(userGroupKeyData.userGroupKeyVersion).deepEquals(String(NEW_USER_GROUP_KEY.version));
					dist_default(adminGroupKeyData.groupKeyVersion).deepEquals(assertNotNull(adminGroupKeyData.adminGroupKeyVersion));
					return true;
				})));
				(0, import_testdouble$6.verify)(recoverCodeFacade.getRawRecoverCode(import_testdouble$6.matchers.anything()), { times: 0 });
				(0, import_testdouble$6.verify)(recoverCodeFacade.encryptRecoveryCode(anything(), anything()), { times: 0 });
			});
			dist_default("Successful rotation with multiple users - sends encrypted new key hash", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: PW_KEY,
					adminOrUserGroupKeyRotation: createTestEntity(KeyRotationTypeRef, {
						_id: [keyRotationsListId, adminGroupId],
						targetKeyVersion: String(Number(adminGroup.groupKeyVersion) + 1),
						groupKeyRotationType: GroupKeyRotationType.AdminGroupKeyRotationSingleUserAccount
					}),
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: []
				});
				const adminUserGroupInfo = createTestEntity(GroupInfoTypeRef, { group: userGroupId });
				const additionalUserGroupId = "additionalUserGroupId";
				const additionalUserGroupInfo = createTestEntity(GroupInfoTypeRef, { group: additionalUserGroupId });
				(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupInfoTypeRef, customer.userGroups)).thenResolve([adminUserGroupInfo, additionalUserGroupInfo]);
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(groupId)).thenResolve({
					version: 0,
					object: groupKeyVersion0
				});
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(additionalUserGroupId)).thenResolve({
					version: 0,
					object: groupKeyVersion0
				});
				const cleartextHash = (0, import_testdouble$6.object)();
				(0, import_testdouble$6.when)(cryptoWrapperMock.sha256Hash(anything())).thenReturn(cleartextHash);
				const encHash = (0, import_testdouble$6.object)();
				(0, import_testdouble$6.when)(cryptoWrapperMock.aesEncrypt(anything(), cleartextHash)).thenReturn(encHash);
				(0, import_testdouble$6.when)(groupManagementFacade.getCurrentGroupKeyViaAdminEncGKey(additionalUserGroupInfo.group)).thenResolve((0, import_testdouble$6.object)());
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(AdminGroupKeyRotationService, import_testdouble$6.matchers.argThat((arg) => {
					dist_default(arg.adminGroupKeyAuthenticationDataList).notEquals(null);
					dist_default(arg.adminGroupKeyAuthenticationDataList.length).equals(1);
					const adminGroupKeyAuthenticationData = arg.adminGroupKeyAuthenticationDataList[0];
					dist_default(adminGroupKeyAuthenticationData.userGroup).equals(additionalUserGroupId);
					dist_default(adminGroupKeyAuthenticationData.version).equals("1");
					dist_default(adminGroupKeyAuthenticationData.authKeyEncAdminRotationHash).equals(encHash);
					return true;
				})));
				(0, import_testdouble$6.verify)(cryptoWrapperMock.deriveKeyWithHkdf(import_testdouble$6.matchers.argThat((arg) => {
					dist_default(arg.context).equals("adminGroupKeyRotationHash");
					dist_default(arg.salt).equals(additionalUserGroupId);
					return true;
				})));
			});
		});
		dist_default.spec("User group key rotation", function() {
			let userGroup;
			let generatedKeyPairs;
			let recoverData;
			dist_default.beforeEach(function() {
				userGroup = makeGroupWithMembership(userGroupId, user).group;
				userGroup.pubAdminGroupEncGKey = null;
				userGroup.adminGroupEncGKey = CURRENT_ADMIN_GROUP_ENC_CURRENT_USER_GROUP_KEY.key;
				userGroup.adminGroupKeyVersion = String(CURRENT_ADMIN_GROUP_ENC_CURRENT_USER_GROUP_KEY.encryptingKeyVersion);
				userGroup.type = GroupType.User;
				userGroup.currentKeys = (0, import_testdouble$6.object)();
				prepareRecoverData(recoverData, recoverCodeFacade);
				(0, import_testdouble$6.when)(groupManagementFacade.hasAdminEncGKey(userGroup)).thenReturn(true);
				(0, import_testdouble$6.when)(userFacade.deriveUserGroupKeyDistributionKey(userGroupId, PW_KEY)).thenReturn(DISTRIBUTION_KEY);
				const encryptingKeyCaptor = import_testdouble$6.matchers.captor();
				const keyCaptor = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.when)(cryptoWrapperMock.aes256RandomKey()).thenReturn(NEW_USER_GROUP_KEY.object);
				(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKeyWithVersionedKey(encryptingKeyCaptor.capture(), keyCaptor.capture())).thenDo((arg) => ({
					encryptingKeyVersion: encryptingKeyCaptor.value.version,
					key: new Uint8Array(encryptingKeyCaptor.value.object.concat(keyCaptor.value))
				}));
				(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKey(DISTRIBUTION_KEY, NEW_USER_GROUP_KEY.object)).thenReturn(DISTRIBUTION_KEY_ENC_NEW_USER_GROUP_KEY);
				generatedKeyPairs = mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, NEW_USER_GROUP_KEY.object);
				const newUserPqKeyPair = generatedKeyPairs.get(NEW_USER_GROUP_KEY.object).newKeyPairs;
				const latestAdminKeyVersion = 1;
				const publicKeyGetOut = createPublicKeyGetOut({
					pubKeyVersion: latestAdminKeyVersion.toString(),
					pubRsaKey: null,
					pubEccKey: (0, import_testdouble$6.object)(),
					pubKyberKey: (0, import_testdouble$6.object)()
				});
				const adminPubKeys = convertToVersionedPublicKeys(publicKeyGetOut);
				(0, import_testdouble$6.when)(serviceExecutorMock.get(PublicKeyService, import_testdouble$6.matchers.argThat((arg) => {
					return arg.version == null && arg.identifierType === PublicKeyIdentifierType.GROUP_ID && arg.identifier === adminGroupId;
				}))).thenResolve(publicKeyGetOut);
				(0, import_testdouble$6.when)(asymmetricCryptoFacade$1.tutaCryptEncryptSymKey(NEW_USER_GROUP_KEY.object, adminPubKeys, {
					version: NEW_USER_GROUP_KEY.version,
					object: newUserPqKeyPair.eccKeyPair
				})).thenResolve({
					pubEncSymKeyBytes: (0, import_testdouble$6.object)(),
					senderKeyVersion: NEW_USER_GROUP_KEY.version,
					recipientKeyVersion: latestAdminKeyVersion,
					cryptoProtocolVersion: CryptoProtocolVersion.TUTA_CRYPT
				});
			});
			dist_default("Successful rotation", async function() {
				prepareUserKeyRotation({
					serviceExecutor: serviceExecutorMock,
					cryptoWrapper: cryptoWrapperMock,
					entityClient: entityClientMock,
					asymmetricCryptoFacade: asymmetricCryptoFacade$1
				}, keyRotationFacade, userGroup);
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(UserGroupKeyRotationService, import_testdouble$6.matchers.argThat((arg) => {
					const userGroupKeyData = arg.userGroupKeyData;
					verifyRecoverCodeData(userGroupKeyData);
					dist_default(userGroupKeyData.adminGroupEncUserGroupKey).equals(null);
					dist_default(userGroupKeyData.adminGroupKeyVersion).deepEquals(String(NEW_ADMIN_GROUP_ENC_NEW_USER_GROUP_KEY.encryptingKeyVersion));
					const pubAdminGroupEncUserGroupKey = userGroupKeyData.pubAdminGroupEncUserGroupKey;
					dist_default(pubAdminGroupEncUserGroupKey).notEquals(null);
					dist_default(pubAdminGroupEncUserGroupKey?.pubEncSymKey);
					verifyUserGroupKeyDataExceptAdminKey(userGroupKeyData, generatedKeyPairs);
					return true;
				})));
				(0, import_testdouble$6.verify)(cryptoWrapperMock.deriveKeyWithHkdf(import_testdouble$6.matchers.argThat((arg) => {
					dist_default(arg.context).equals("adminGroupKeyRotationHash");
					dist_default(arg.salt).equals(userGroupId);
					return true;
				})));
				dist_default(keyRotationFacade.pendingKeyRotations.adminOrUserGroupKeyRotation).equals(null);
				dist_default(keyRotationFacade.pendingKeyRotations.pwKey).equals(null);
			});
			dist_default("Successful rotation - no recover code", async function() {
				prepareUserKeyRotation({
					serviceExecutor: serviceExecutorMock,
					cryptoWrapper: cryptoWrapperMock,
					entityClient: entityClientMock,
					asymmetricCryptoFacade: asymmetricCryptoFacade$1
				}, keyRotationFacade, userGroup);
				assertNotNull(user.auth).recoverCode = null;
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(UserGroupKeyRotationService, import_testdouble$6.matchers.argThat((arg) => {
					const userGroupKeyData = arg.userGroupKeyData;
					dist_default(userGroupKeyData.recoverCodeData).equals(null);
					dist_default(userGroupKeyData.userGroupKeyVersion).deepEquals(String(NEW_USER_GROUP_KEY.version));
					return true;
				})));
				(0, import_testdouble$6.verify)(recoverCodeFacade.getRawRecoverCode(import_testdouble$6.matchers.anything()), { times: 0 });
				(0, import_testdouble$6.verify)(recoverCodeFacade.encryptRecoveryCode(anything(), anything()), { times: 0 });
			});
			dist_default("Fails if admin public key hashes do not match", async function() {
				prepareUserKeyRotation({
					serviceExecutor: serviceExecutorMock,
					cryptoWrapper: cryptoWrapperMock,
					entityClient: entityClientMock,
					asymmetricCryptoFacade: asymmetricCryptoFacade$1
				}, keyRotationFacade, userGroup);
				(0, import_testdouble$6.when)(cryptoWrapperMock.sha256Hash(import_testdouble$6.matchers.anything())).thenReturn(new Uint8Array([
					9,
					8,
					7
				]));
				await assertThrows(Error, async () => keyRotationFacade.processPendingKeyRotation(user));
			});
			dist_default("Fails if there is no key hash", async function() {
				prepareUserKeyRotation({
					serviceExecutor: serviceExecutorMock,
					cryptoWrapper: cryptoWrapperMock,
					entityClient: entityClientMock,
					asymmetricCryptoFacade: asymmetricCryptoFacade$1
				}, keyRotationFacade, userGroup);
				keyRotationFacade.setPendingKeyRotations({
					pwKey: PW_KEY,
					adminOrUserGroupKeyRotation: createTestEntity(KeyRotationTypeRef, {
						_id: [keyRotationsListId, userGroupId],
						targetKeyVersion: String(Number(userGroup.groupKeyVersion) + 1),
						groupKeyRotationType: GroupKeyRotationType.User,
						adminGroupKeyAuthenticationData: null
					}),
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: []
				});
				await assertThrows(Error, async function() {
					await keyRotationFacade.processPendingKeyRotation(user);
				});
			});
			dist_default("Fails if admin is not quantum safe", async function() {
				prepareUserKeyRotation({
					serviceExecutor: serviceExecutorMock,
					cryptoWrapper: cryptoWrapperMock,
					entityClient: entityClientMock,
					asymmetricCryptoFacade: asymmetricCryptoFacade$1
				}, keyRotationFacade, userGroup);
				(0, import_testdouble$6.when)(serviceExecutorMock.get(PublicKeyService, import_testdouble$6.matchers.anything())).thenResolve({});
				await assertThrows(Error, async function() {
					await keyRotationFacade.processPendingKeyRotation(user);
				});
			});
		});
		dist_default.spec("Ignore currently unsupported cases", function() {
			dist_default("If the user group key is not quantum-safe yet, the user area group key rotations are ignored", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: [],
					userAreaGroupsKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, groupId)
				});
				prepareKeyMocks(cryptoWrapperMock);
				const insecureUserGroupKey = {
					object: [666],
					version: 0
				};
				insecureUserGroupKey.object.length = 4;
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymUserGroupKey()).thenReturn(insecureUserGroupKey);
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(anything(), anything()), { times: 0 });
			});
		});
		dist_default.spec("Key rotation for customer or team group", function() {
			dist_default("Successful rotation, single member group", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, groupId),
					userAreaGroupsKeyRotations: []
				});
				group.currentKeys = createTestEntity(KeyPairTypeRef);
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey, newKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				const generated = mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, newKey.object);
				const { newKeyPairs, encryptedEccPrivKey, encryptedKyberPrivKey, kyberPublicKeyBytes } = generated.get(newKey.object);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				const sentKeyPairs = createTestEntity(KeyPairTypeRef, {
					pubEccKey: newKeyPairs.eccKeyPair.publicKey,
					symEncPrivEccKey: encryptedEccPrivKey,
					pubKyberKey: kyberPublicKeyBytes,
					symEncPrivKyberKey: encryptedKyberPrivKey
				});
				dist_default(update.keyPair).deepEquals(sentKeyPairs);
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(adminEncNewGroupKey.key);
				dist_default(update.adminGroupKeyVersion).equals("0");
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(1);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
			});
			dist_default("Successful rotation, multiple member group", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, groupId),
					userAreaGroupsKeyRotations: []
				});
				const memberUserId = "memberUserId";
				const memberUser = createTestEntity(UserTypeRef, {
					_id: memberUserId,
					userGroup: createTestEntity(GroupMembershipTypeRef, {
						group: groupId,
						groupKeyVersion: "0"
					})
				});
				(0, import_testdouble$6.when)(entityClientMock.load(UserTypeRef, memberUserId)).thenResolve(memberUser);
				(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group.members)).thenResolve([createTestEntity(GroupMemberTypeRef, {
					group: groupId,
					user: userId
				}), createTestEntity(GroupMemberTypeRef, {
					group: groupId,
					user: memberUserId
				})]);
				const { userEncNewGroupKey, newGroupKeyEncPreviousGroupKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				const otherMemberEncNewGroupKey = mockPrepareKeyForOtherMembers(memberUser, groupManagementFacade, cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(adminEncNewGroupKey.key);
				dist_default(update.adminGroupKeyVersion).equals("0");
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(2);
				dist_default(update.groupMembershipUpdateData[0].userId).equals(userId);
				dist_default(update.groupMembershipUpdateData[0].userEncGroupKey).deepEquals(userEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[0].userKeyVersion).equals("0");
				dist_default(update.groupMembershipUpdateData[1].userId).equals(memberUserId);
				dist_default(update.groupMembershipUpdateData[1].userEncGroupKey).deepEquals(otherMemberEncNewGroupKey.key);
				dist_default(update.groupMembershipUpdateData[1].userKeyVersion).equals("0");
			});
			dist_default("If the user is not an admin, the group key rotations are ignored", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, groupId),
					userAreaGroupsKeyRotations: []
				});
				findAllAndRemove(user.memberships, (m) => m.groupType === GroupType.Admin);
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(anything(), anything()), { times: 0 });
			});
			dist_default("If the admin group key is not quantum-safe yet, the group key rotations are ignored", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, groupId),
					userAreaGroupsKeyRotations: []
				});
				prepareKeyMocks(cryptoWrapperMock);
				const insecureAdminGroupKey = {
					object: [666],
					version: 0
				};
				insecureAdminGroupKey.object.length = 4;
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(adminGroupId)).thenResolve(insecureAdminGroupKey);
				await keyRotationFacade.processPendingKeyRotation(user);
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(anything(), anything()), { times: 0 });
			});
			dist_default("When the group has no members, the rotation is still handled but no membership update is created", async function() {
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Team, groupId),
					userAreaGroupsKeyRotations: []
				});
				(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group.members)).thenResolve([]);
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(groupId)).thenReject(Error(`No group with groupId ${groupId} found!`));
				(0, import_testdouble$6.when)(groupManagementFacade.getGroupKeyViaAdminEncGKey(groupId, 0)).thenResolve(CURRENT_USER_AREA_GROUP_KEY.object);
				const { newGroupKeyEncPreviousGroupKey, adminEncNewGroupKey } = prepareKeyMocks(cryptoWrapperMock);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(1);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				dist_default(update.adminGroupEncGroupKey).deepEquals(adminEncNewGroupKey.key);
				dist_default(update.adminGroupKeyVersion).equals("0");
				dist_default(update.groupEncPreviousGroupKey).deepEquals(newGroupKeyEncPreviousGroupKey.key);
				dist_default(update.groupMembershipUpdateData.length).equals(0);
			});
			dist_default("Updates for multiple groups are executed in one request", async function() {
				const secondGroupId = "groupId-2";
				const thirdGroupId = "groupId-3";
				makeGroupWithMembership(secondGroupId, user);
				makeGroupWithMembership(thirdGroupId, user);
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(secondGroupId)).thenResolve(CURRENT_USER_AREA_GROUP_KEY);
				(0, import_testdouble$6.when)(keyLoaderFacadeMock.getCurrentSymGroupKey(thirdGroupId)).thenResolve(CURRENT_USER_AREA_GROUP_KEY);
				keyRotationFacade.setPendingKeyRotations({
					pwKey: null,
					adminOrUserGroupKeyRotation: null,
					teamOrCustomerGroupKeyRotations: makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Team, groupId).concat(makeKeyRotation(keyRotationsListId, GroupKeyRotationType.Customer, secondGroupId).concat(makeKeyRotation(keyRotationsListId, GroupKeyRotationType.UserArea, thirdGroupId))),
					userAreaGroupsKeyRotations: []
				});
				group.currentKeys = createTestEntity(KeyPairTypeRef);
				(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group.members)).thenResolve([]);
				const { newKey } = prepareKeyMocks(cryptoWrapperMock);
				mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, newKey.object);
				await keyRotationFacade.processPendingKeyRotation(user);
				const captor$4 = import_testdouble$6.matchers.captor();
				(0, import_testdouble$6.verify)(serviceExecutorMock.post(GroupKeyRotationService, captor$4.capture()));
				(0, import_testdouble$6.verify)(shareFacade.sendGroupInvitationRequest(anything()), { times: 0 });
				const sentData = captor$4.value;
				dist_default(sentData.groupKeyUpdates.length).equals(3);
				const update = sentData.groupKeyUpdates[0];
				dist_default(update.group).equals(groupId);
				dist_default(update.groupKeyVersion).equals("1");
				const secondUpdate = sentData.groupKeyUpdates[1];
				dist_default(secondUpdate.group).equals(secondGroupId);
				dist_default(secondUpdate.groupKeyVersion).equals("1");
				const thirdUpdate = sentData.groupKeyUpdates[2];
				dist_default(thirdUpdate.group).equals(thirdGroupId);
				dist_default(thirdUpdate.groupKeyVersion).equals("1");
			});
		});
		dist_default.spec("processPendingKeyRotationsAndUpdates error handling", function() {
			dist_default("loadPendingKeyRotations LockedError is caught", async function() {
				const terror = new LockedError("test error");
				(0, import_testdouble$6.when)(entityClientMock.load(UserGroupRootTypeRef, anything())).thenReject(terror);
				const log = console.log = spy(console.log);
				await keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)());
				dist_default(log.callCount).equals(1);
				dist_default(log.args[1]).equals(terror);
			});
			dist_default("loadPendingKeyRotations other Errors are thrown", async function() {
				const terror = new Error("test error");
				(0, import_testdouble$6.when)(entityClientMock.load(UserGroupRootTypeRef, anything())).thenReject(terror);
				const log = console.log = spy(console.log);
				await assertThrows(Error, async () => keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)()));
			});
			dist_default("processPendingKeyRotation LockedError is caught", async function() {
				mockAttribute(keyRotationFacade, keyRotationFacade.loadPendingKeyRotations, () => {});
				const terror = new LockedError("test error");
				mockAttribute(keyRotationFacade, keyRotationFacade.processPendingKeyRotation, () => {
					throw terror;
				});
				const log = console.log = spy(console.log);
				await keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)());
				dist_default(log.callCount).equals(1);
				dist_default(log.args[1]).equals(terror);
			});
			dist_default("processPendingKeyRotation other errors are thrown", async function() {
				mockAttribute(keyRotationFacade, keyRotationFacade.loadPendingKeyRotations, () => {});
				const terror = new Error("test error");
				mockAttribute(keyRotationFacade, keyRotationFacade.processPendingKeyRotation, () => {
					throw terror;
				});
				const log = console.log = spy(console.log);
				await assertThrows(Error, async () => keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)()));
			});
			dist_default("updateGroupMemberships LockedError is caught", async function() {
				mockAttribute(keyRotationFacade, keyRotationFacade.loadPendingKeyRotations, () => {});
				mockAttribute(keyRotationFacade, keyRotationFacade.processPendingKeyRotation, () => {});
				const terror = new LockedError("test error");
				mockAttribute(keyRotationFacade, keyRotationFacade.updateGroupMemberships, () => {
					throw terror;
				});
				const log = console.log = spy(console.log);
				await keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)());
				dist_default(log.callCount).equals(1);
				dist_default(log.args[1]).equals(terror);
			});
			dist_default("updateGroupMemberships other errors are thrown", async function() {
				mockAttribute(keyRotationFacade, keyRotationFacade.loadPendingKeyRotations, () => {});
				mockAttribute(keyRotationFacade, keyRotationFacade.processPendingKeyRotation, () => {});
				const terror = new Error("test error");
				mockAttribute(keyRotationFacade, keyRotationFacade.updateGroupMemberships, () => {
					throw terror;
				});
				const log = console.log = spy(console.log);
				await assertThrows(Error, async () => keyRotationFacade.processPendingKeyRotationsAndUpdates((0, import_testdouble$6.object)()));
			});
		});
	});
	function makeGroupWithMembership(groupId$1, user$1) {
		const group$1 = createTestEntity(GroupTypeRef, {
			_id: groupId$1,
			adminGroupKeyVersion: "0",
			groupInfo: ["listId", groupInfoElementId],
			adminGroupEncGKey: new Uint8Array(1),
			pubAdminGroupEncGKey: null,
			groupKeyVersion: "0",
			invitations: invitationsListId,
			admin: adminGroupId,
			members: "membersListId"
		});
		const groupInfo$1 = createTestEntity(GroupInfoTypeRef, {
			_id: group$1.groupInfo,
			group: groupId$1
		});
		(0, import_testdouble$6.when)(groupManagementFacade.hasAdminEncGKey(group$1)).thenReturn(true);
		(0, import_testdouble$6.when)(entityClientMock.load(GroupInfoTypeRef, group$1.groupInfo)).thenResolve(groupInfo$1);
		(0, import_testdouble$6.when)(entityClientMock.load(GroupTypeRef, groupId$1)).thenResolve(group$1);
		(0, import_testdouble$6.when)(entityClientMock.loadAll(SentGroupInvitationTypeRef, group$1.invitations)).thenResolve([]);
		const member = createTestEntity(GroupMemberTypeRef, {
			group: groupId$1,
			user: user$1._id
		});
		user$1.memberships.push(createTestEntity(GroupMembershipTypeRef, {
			group: groupId$1,
			groupKeyVersion: "0"
		}));
		(0, import_testdouble$6.when)(entityClientMock.loadAll(GroupMemberTypeRef, group$1.members)).thenResolve([member]);
		return {
			group: group$1,
			groupInfo: groupInfo$1
		};
	}
});
async function makeUser(userId$1, userEncAdminKey) {
	return createTestEntity(UserTypeRef, {
		_id: userId$1,
		userGroup: createTestEntity(GroupMembershipTypeRef, {
			groupKeyVersion: "0",
			symKeyVersion: String(PW_ENC_CURRENT_USER_GROUP_KEY.encryptingKeyVersion),
			symEncGKey: PW_ENC_CURRENT_USER_GROUP_KEY.key,
			groupType: GroupType.User,
			group: userGroupId
		}),
		auth: createTestEntity(UserAuthenticationTypeRef, { recoverCode: recoverCodeId }),
		memberships: [
			createTestEntity(GroupMembershipTypeRef, {
				groupType: GroupType.Admin,
				groupKeyVersion: "0",
				symKeyVersion: String(userEncAdminKey.encryptingKeyVersion),
				symEncGKey: userEncAdminKey.key,
				group: adminGroupId
			}),
			createTestEntity(GroupMembershipTypeRef, { group: someGroupId }),
			createTestEntity(GroupMembershipTypeRef, {
				groupType: GroupType.Customer,
				group: usersCustomerGroupId
			})
		],
		customer: "customerId"
	});
}
function makeKeyRotation(keyRotationsList, groupType, groupId) {
	return [createTestEntity(KeyRotationTypeRef, {
		_id: [keyRotationsList, groupId],
		groupKeyRotationType: groupType,
		targetKeyVersion: "1"
	})];
}
async function makeUserGroupRoot(keyRotationsList, invitations, groupKeyUpdatesList) {
	return createTestEntity(UserGroupRootTypeRef, {
		keyRotations: createTestEntity(KeyRotationsRefTypeRef, { list: keyRotationsList }),
		invitations,
		groupKeyUpdates: createTestEntity(GroupKeyUpdatesRefTypeRef, { list: groupKeyUpdatesList })
	});
}
function prepareKeyMocks(cryptoWrapperMock) {
	(0, import_testdouble$6.when)(cryptoWrapperMock.aes256RandomKey()).thenReturn(NEW_GROUP_KEY.object);
	const encryptingKeyCaptor = import_testdouble$6.matchers.captor();
	const keyCaptor = import_testdouble$6.matchers.captor();
	(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKeyWithVersionedKey(encryptingKeyCaptor.capture(), keyCaptor.capture())).thenDo((arg) => ({
		encryptingKeyVersion: encryptingKeyCaptor.value.version,
		key: new Uint8Array(encryptingKeyCaptor.value.object.concat(keyCaptor.value))
	}));
	return {
		userEncNewGroupKey: CURRENT_USER_GROUP_ENC_NEW_USER_AREA_GROUP_KEY,
		newGroupKeyEncPreviousGroupKey: NEW_USER_AREA_GROUP_ENC_CURRENT_USER_AREA_GROUP_KEY,
		newKey: NEW_GROUP_KEY,
		adminEncNewGroupKey: CURRENT_ADMIN_GROUP_ENC_NEW_USER_AREA_GROUP_KEY,
		currentAdminGroupKey: CURRENT_ADMIN_GROUP_KEY
	};
}
function mockPrepareKeyForOtherMembers(user, groupManagementFacadeMock, cryptoWrapperMock) {
	(0, import_testdouble$6.when)(groupManagementFacadeMock.getGroupKeyViaAdminEncGKey(user.userGroup.group, Number(user.userGroup.groupKeyVersion))).thenResolve(OTHER_MEMBER_USER_GROUP_KEY.object);
	const encryptingKeyCaptor = import_testdouble$6.matchers.captor();
	const keyCaptor = import_testdouble$6.matchers.captor();
	(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKey(encryptingKeyCaptor.capture(), keyCaptor.capture())).thenDo((arg) => new Uint8Array(encryptingKeyCaptor.value.concat(keyCaptor.value)));
	return OTHER_USER_GROUP_ENC_NEW_SHARED_GROUP_KEY;
}
function mockGenerateKeyPairs(pqFacadeMock, cryptoWrapperMock, ...newKeys) {
	const results = new Map();
	for (const newKey of newKeys) {
		const newKeyPairs = (0, import_testdouble$6.object)();
		newKeyPairs.eccKeyPair = {
			publicKey: Uint8Array.from([1]),
			privateKey: (0, import_testdouble$6.object)()
		};
		newKeyPairs.kyberKeyPair = {
			publicKey: (0, import_testdouble$6.object)(),
			privateKey: (0, import_testdouble$6.object)()
		};
		const encryptedEccPrivKey = (0, import_testdouble$6.object)();
		(0, import_testdouble$6.when)(cryptoWrapperMock.encryptEccKey(newKey, newKeyPairs.eccKeyPair.privateKey)).thenReturn(encryptedEccPrivKey);
		const encryptedKyberPrivKey = (0, import_testdouble$6.object)();
		(0, import_testdouble$6.when)(cryptoWrapperMock.encryptKyberKey(newKey, newKeyPairs.kyberKeyPair.privateKey)).thenReturn(encryptedKyberPrivKey);
		const kyberPublicKeyBytes = Uint8Array.from([3]);
		(0, import_testdouble$6.when)(cryptoWrapperMock.kyberPublicKeyToBytes(newKeyPairs.kyberKeyPair.publicKey)).thenReturn(kyberPublicKeyBytes);
		results.set(newKey, {
			newKeyPairs,
			encryptedEccPrivKey,
			encryptedKyberPrivKey,
			kyberPublicKeyBytes
		});
		(0, import_testdouble$6.when)(cryptoWrapperMock.decryptKeyPair(newKey, import_testdouble$6.matchers.argThat((arg) => {
			return arg.symEncPrivEccKey === encryptedEccPrivKey && arg.symEncPrivKyberKey === encryptedKyberPrivKey && arg.symEncPrivRsaKey == null && arg.pubKyberKey === kyberPublicKeyBytes;
		}))).thenReturn(newKeyPairs);
	}
	const [first, ...rest] = Array.from(results.values());
	(0, import_testdouble$6.when)(pqFacadeMock.generateKeyPairs()).thenResolve(first.newKeyPairs, ...rest.map((result) => result.newKeyPairs));
	return results;
}
function verifyKeyPair(keyPair, mockedKeyPairs) {
	dist_default(keyPair).notEquals(null);
	dist_default(keyPair?.symEncPrivEccKey).deepEquals(mockedKeyPairs.encryptedEccPrivKey);
	dist_default(keyPair?.pubEccKey).deepEquals(mockedKeyPairs.newKeyPairs.eccKeyPair.publicKey);
	dist_default(keyPair?.symEncPrivKyberKey).deepEquals(mockedKeyPairs.encryptedKyberPrivKey);
	dist_default(keyPair?.pubKyberKey).deepEquals(mockedKeyPairs.kyberPublicKeyBytes);
	dist_default(keyPair?.symEncPrivRsaKey).equals(null);
	dist_default(keyPair?.pubRsaKey).equals(null);
}
function verifyUserGroupKeyDataExceptAdminKey(userGroupKeyData, generatedKeyPairs) {
	dist_default(userGroupKeyData.userGroupKeyVersion).deepEquals(String(NEW_USER_GROUP_KEY.version));
	dist_default(userGroupKeyData.group).deepEquals(userGroupId);
	dist_default(userGroupKeyData.authVerifier).deepEquals(AUTH_VERIFIER);
	dist_default(userGroupKeyData.distributionKeyEncUserGroupKey).deepEquals(DISTRIBUTION_KEY_ENC_NEW_USER_GROUP_KEY);
	verifyKeyPair(userGroupKeyData.keyPair, generatedKeyPairs.get(NEW_USER_GROUP_KEY.object));
	dist_default(userGroupKeyData.passphraseEncUserGroupKey).deepEquals(PW_ENC_NEW_USER_GROUP_KEY.key);
	dist_default(userGroupKeyData.userGroupEncPreviousGroupKey).deepEquals(NEW_USER_GROUP_ENC_CURRENT_USER_GROUP_KEY.key);
}

//#endregion
//#region tests/mail/view/ConversationViewModelTest.ts
var import_testdouble$5 = __toESM(require_testdouble(), 1);
dist_default.spec("ConversationViewModel", function() {
	let conversation;
	let primaryMail;
	let anotherMail;
	let viewModel;
	let mailModel;
	let mailboxModel;
	let mailboxDetail;
	let entityRestClientMock;
	let prefProvider;
	let redraw;
	let loadingDefer;
	let eventCallback;
	const listId = "listId";
	const viewModelFactory = async () => {
		return ({ mail, showFolder }) => {
			const viewModelObject = (0, import_testdouble$5.object)();
			viewModelObject.mail = mail;
			return viewModelObject;
		};
	};
	async function makeViewModel(pMail) {
		const factory = await viewModelFactory();
		const mailboxProperties = createTestEntity(MailboxPropertiesTypeRef);
		const entityClient$1 = new EntityClient(entityRestClientMock);
		const eventController = {
			addEntityListener: (listener) => {
				eventCallback = listener;
			},
			removeEntityListener: noOp
		};
		const viewModelParams = {
			mail: pMail,
			showFolder: false,
			delayBodyRenderingUntil: Promise.resolve()
		};
		viewModel = new ConversationViewModel(viewModelParams, (options) => factory(options, mailboxDetail, mailboxProperties), entityClient$1, eventController, prefProvider, mailModel, redraw);
	}
	const addMail = (mailId$1) => {
		const conversationId = "conversation" + mailId$1;
		const newMail = createTestEntity(MailTypeRef, {
			_id: [listId, mailId$1],
			conversationEntry: [listId, conversationId],
			state: MailState.RECEIVED
		});
		const mailConversationEntry = createTestEntity(ConversationEntryTypeRef, {
			_id: [listId, conversationId],
			mail: newMail._id,
			previous: primaryMail?._id
		});
		entityRestClientMock.addListInstances(newMail);
		entityRestClientMock.addListInstances(mailConversationEntry);
		conversation.push(mailConversationEntry);
		return newMail;
	};
	const sameAsConversation = (mailsDisplayed) => {
		for (let i = 0; i < mailsDisplayed.length; i++) if (!isSameId(mailsDisplayed[i].entryId, conversation[i]._id)) return false;
		return true;
	};
	dist_default.beforeEach(async function() {
		conversation = [];
		mailboxDetail = (0, import_testdouble$5.object)();
		mailModel = (0, import_testdouble$5.object)();
		entityRestClientMock = new EntityRestClientMock();
		prefProvider = (0, import_testdouble$5.object)();
		loadingDefer = defer();
		redraw = async () => {
			await delay(1);
			if (viewModel.isFinished()) loadingDefer.resolve();
		};
		primaryMail = addMail("mailId");
		anotherMail = addMail("anotherMail");
		await makeViewModel(primaryMail);
	});
	dist_default.spec("Correct amount of mails are shown", function() {
		dist_default("shows all mails in conversation by default", async function() {
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const numMailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail").length;
			dist_default(numMailsDisplayed).equals(conversation.length)(`Wrong number of mails in conversationItems, got ${numMailsDisplayed} should be ${conversation.length}`);
		});
		dist_default("when the option is off it only shows selected mail", async function() {
			(0, import_testdouble$5.when)(prefProvider.getConversationViewShowOnlySelectedMail()).thenReturn(true);
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const numMailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail").length;
			dist_default(numMailsDisplayed).equals(1)(`Wrong number of mails in conversationItems, got ${numMailsDisplayed} should be 1`);
		});
	});
	dist_default.spec("Drafts in Conversation View", function() {
		dist_default("Should be in conversation", async function() {
			const draftMail = addMail("draftMail");
			draftMail.state = MailState.DRAFT;
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const numMailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail").length;
			dist_default(numMailsDisplayed).equals(conversation.length)(`Wrong number of mails in conversationItems, got ${numMailsDisplayed} should be ${conversation.length}`);
		});
		dist_default("when draft is in trash folder, it should not be included in the conversation", async function() {
			const trashDraftMail = addMail("trashDraftMail");
			trashDraftMail.state = MailState.DRAFT;
			const trash = createTestEntity(MailFolderTypeRef, {
				_id: [listId, "trashFolder"],
				folderType: MailSetKind.TRASH
			});
			entityRestClientMock.addListInstances(trash);
			(0, import_testdouble$5.when)(mailModel.getMailboxDetailsForMail(import_testdouble$5.matchers.anything())).thenResolve(mailboxDetail);
			(0, import_testdouble$5.when)(mailModel.getMailFolderForMail(trashDraftMail)).thenReturn(trash);
			conversation.pop();
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const mailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail");
			dist_default(sameAsConversation(mailsDisplayed)).equals(true)(`Wrong mails in conversation, got ${mailsDisplayed.map((ci) => ci.entryId)}, should be ${conversation.map((ce) => ce._id)}`);
		});
		dist_default("when draft is in trash folder but is the primary mail, it should be included in the conversation", async function() {
			const trashDraftMail = addMail("trashDraftMail");
			trashDraftMail.state = MailState.DRAFT;
			const trash = createTestEntity(MailFolderTypeRef, {
				_id: [listId, "trashFolder"],
				folderType: MailSetKind.TRASH
			});
			entityRestClientMock.addListInstances(trash);
			(0, import_testdouble$5.when)(mailModel.getMailboxDetailsForMail(trashDraftMail)).thenResolve(mailboxDetail);
			(0, import_testdouble$5.when)(mailModel.getMailFolderForMail(trashDraftMail)).thenReturn(trash);
			await makeViewModel(trashDraftMail);
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const mailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail");
			dist_default(sameAsConversation(mailsDisplayed)).equals(true)(`Wrong mails in conversation, got ${mailsDisplayed.map((ci) => ci.entryId)}, should be ${conversation.map((ce) => ce._id)}`);
		});
	});
	dist_default.spec("Entity Updates", function() {
		dist_default("when a new mail comes in, it is added to conversation", async function() {
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const yetAnotherMail = addMail("yetAnotherMailId");
			await eventCallback([{
				application: "tutanota",
				type: "ConversationEntry",
				operation: OperationType.CREATE,
				instanceListId: listId,
				instanceId: yetAnotherMail.conversationEntry[1]
			}], "mailGroupId");
			const mailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail");
			dist_default(sameAsConversation(mailsDisplayed)).equals(true)(`Wrong mails in conversation, got ${mailsDisplayed.map((ci) => `[${ci.entryId[0]}, ${ci.entryId[1]}]`).join(", ")}, should be ${conversation.map((ce) => `[${ce._id[0]}, ${ce._id[1]}]`).join(", ")}`);
		});
		dist_default("when a mail gets deleted, it is removed from conversation", async function() {
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			conversation.pop();
			const mailConversationEntry = createTestEntity(ConversationEntryTypeRef, {
				_id: anotherMail.conversationEntry,
				mail: anotherMail._id,
				previous: primaryMail?._id
			});
			await entityRestClientMock.erase(mailConversationEntry);
			const deletedmailConversationEntry = createTestEntity(ConversationEntryTypeRef, {
				_id: anotherMail.conversationEntry,
				previous: primaryMail?._id
			});
			entityRestClientMock.addListInstances(deletedmailConversationEntry);
			await eventCallback([{
				application: "tutanota",
				type: "ConversationEntry",
				operation: OperationType.UPDATE,
				instanceListId: listId,
				instanceId: anotherMail.conversationEntry[1]
			}], "mailGroupId");
			const mailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail");
			dist_default(sameAsConversation(mailsDisplayed)).equals(true)(`Wrong mails in conversation, got ${mailsDisplayed.map((ci) => ci.entryId)}, should be ${conversation.map((ce) => ce._id)}`);
		});
		dist_default("when conversation mode is turned off and a new mail comes in, nothing added to conversation", async function() {
			(0, import_testdouble$5.when)(prefProvider.getConversationViewShowOnlySelectedMail()).thenReturn(true);
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			const yetAnotherMail = addMail("yetAnotherMailId");
			await eventCallback([{
				application: "tutanota",
				type: "ConversationEntry",
				operation: OperationType.CREATE,
				instanceListId: listId,
				instanceId: yetAnotherMail.conversationEntry[1]
			}], "mailGroupId");
			const numMailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail").length;
			dist_default(numMailsDisplayed).equals(1)(`Wrong number of mails in conversationItems, got ${numMailsDisplayed} should be 1`);
		});
		dist_default("when a draft in trash, it is removed from the conversation on update", async function() {
			const trashDraftMail = addMail("trashDraftMail");
			trashDraftMail.state = MailState.DRAFT;
			viewModel.init(Promise.resolve());
			await loadingDefer.promise;
			conversation.pop();
			const trash = createTestEntity(MailFolderTypeRef, {
				_id: ["folderListId", "trashFolder"],
				folderType: MailSetKind.TRASH
			});
			entityRestClientMock.addListInstances(trash);
			const newTrashDraftMail = addMail("trashDraftMail");
			newTrashDraftMail.state = MailState.DRAFT;
			newTrashDraftMail._id = ["newListId", trashDraftMail._id[1]];
			conversation.pop();
			(0, import_testdouble$5.when)(mailModel.getMailboxDetailsForMail(import_testdouble$5.matchers.anything())).thenResolve(mailboxDetail);
			(0, import_testdouble$5.when)(mailModel.getMailFolderForMail(newTrashDraftMail)).thenReturn(trash);
			await eventCallback([{
				application: "tutanota",
				type: "ConversationEntry",
				operation: OperationType.UPDATE,
				instanceListId: listId,
				instanceId: trashDraftMail.conversationEntry[1]
			}], "mailGroupId");
			const mailsDisplayed = viewModel.conversationItems().filter((i) => i.type === "mail");
			dist_default(sameAsConversation(mailsDisplayed)).equals(true)(`Wrong mails in conversation, got ${mailsDisplayed.map((ci) => ci.entryId)}, should be ${conversation.map((ce) => ce._id)}`);
		});
	});
});

//#endregion
//#region tests/mail/view/MailViewerViewModelTest.ts
var import_testdouble$4 = __toESM(require_testdouble(), 1);
dist_default.spec("MailViewerViewModel", function() {
	let mail;
	let showFolder = false;
	let entityClient$1;
	let mailModel;
	let mailboxModel;
	let contactModel;
	let configFacade;
	let fileController;
	let logins;
	let eventController;
	let workerFacade;
	let searchModel;
	let mailFacade;
	let sendMailModel;
	let sendMailModelFactory = () => Promise.resolve(sendMailModel);
	let cryptoFacade;
	let contactImporter;
	function makeViewModelWithHeaders(headers) {
		entityClient$1 = (0, import_testdouble$4.object)();
		mailModel = (0, import_testdouble$4.object)();
		mailboxModel = (0, import_testdouble$4.object)();
		contactModel = (0, import_testdouble$4.object)();
		configFacade = (0, import_testdouble$4.object)();
		fileController = (0, import_testdouble$4.object)();
		logins = (0, import_testdouble$4.object)();
		sendMailModel = (0, import_testdouble$4.object)();
		eventController = (0, import_testdouble$4.object)();
		workerFacade = (0, import_testdouble$4.object)();
		searchModel = (0, import_testdouble$4.object)();
		mailFacade = (0, import_testdouble$4.object)();
		cryptoFacade = (0, import_testdouble$4.object)();
		contactImporter = (0, import_testdouble$4.object)();
		mail = prepareMailWithHeaders(mailFacade, headers);
		return new MailViewerViewModel(mail, showFolder, entityClient$1, mailboxModel, mailModel, contactModel, configFacade, fileController, logins, sendMailModelFactory, eventController, workerFacade, searchModel, mailFacade, cryptoFacade, async () => contactImporter);
	}
	function prepareMailWithHeaders(mailFacade$1, headers) {
		const toRecipients = [createTestEntity(MailAddressTypeRef, {
			name: "Ma",
			address: "ma@tuta.com"
		})];
		const mail$1 = createTestEntity(MailTypeRef, {
			_id: ["mailListId", "mailId"],
			listUnsubscribe: true,
			mailDetails: ["mailDetailsListId", "mailDetailsId"],
			state: MailState.RECEIVED,
			sender: createTestEntity(MailAddressTypeRef, {
				name: "ListSender",
				address: "sender@list.com"
			})
		});
		const mailDetails = createTestEntity(MailDetailsTypeRef, {
			headers: createTestEntity(HeaderTypeRef, { headers }),
			recipients: createTestEntity(RecipientsTypeRef, { toRecipients })
		});
		(0, import_testdouble$4.when)(mailFacade$1.loadMailDetailsBlob(mail$1)).thenResolve(mailDetails);
		return mail$1;
	}
	dist_default.spec("unsubscribe", function() {
		function initUnsubscribeHeaders(headers) {
			const viewModel = makeViewModelWithHeaders(headers);
			const mailGroupInfo = createTestEntity(GroupInfoTypeRef, {
				mailAddressAliases: [],
				mailAddress: "ma@tuta.com"
			});
			const mailboxDetail = { mailGroupInfo };
			(0, import_testdouble$4.when)(mailModel.getMailboxDetailsForMail(import_testdouble$4.matchers.anything())).thenResolve(mailboxDetail);
			(0, import_testdouble$4.when)(logins.getUserController()).thenReturn({ userGroupInfo: mailGroupInfo });
			return viewModel;
		}
		async function testHeaderUnsubscribe(headers, expected) {
			const viewModel = initUnsubscribeHeaders(headers);
			const result = await viewModel.unsubscribe();
			(0, import_testdouble$4.verify)(mailModel.unsubscribe(mail, "ma@tuta.com", expected), { times: 1 });
			dist_default(result).equals(true);
		}
		dist_default.spec("url", function() {
			dist_default("easy case", async function() {
				const headers = "List-Unsubscribe: <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>";
				await testHeaderUnsubscribe(headers, [headers]);
			});
			dist_default("with POST", async function() {
				const headers = ["List-Unsubscribe: <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>", "List-Unsubscribe-Post: List-Unsubscribe=One-Click"];
				await testHeaderUnsubscribe(headers.join("\r\n"), headers);
			});
			dist_default("with whitespace", async function() {
				const headers = ["List-Unsubscribe:      <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				const expected = ["List-Unsubscribe:      <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				await testHeaderUnsubscribe(headers.join("\r\n"), expected);
			});
			dist_default("with tab", async function() {
				const headers = ["List-Unsubscribe:	 <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				const expected = ["List-Unsubscribe:	 <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				await testHeaderUnsubscribe(headers.join("\r\n"), expected);
			});
			dist_default("with newline whitespace", async function() {
				const headers = ["List-Unsubscribe: \r\n <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				const expected = ["List-Unsubscribe: <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				await testHeaderUnsubscribe(headers.join("\r\n"), expected);
			});
			dist_default("with newline tab", async function() {
				const headers = ["List-Unsubscribe: \r\n	<http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				const expected = ["List-Unsubscribe: <http://unsub.me?id=2134>, <mailto:unsubscribe@newsletter.de>"];
				await testHeaderUnsubscribe(headers.join("\r\n"), expected);
			});
			dist_default("no list unsubscribe header", async function() {
				const headers = "To: InvalidHeader";
				const viewModel = initUnsubscribeHeaders(headers);
				const result = await viewModel.unsubscribe();
				(0, import_testdouble$4.verify)(mailModel.unsubscribe(import_testdouble$4.matchers.anything(), import_testdouble$4.matchers.anything(), import_testdouble$4.matchers.anything()), { times: 0 });
				dist_default(result).equals(false);
			});
		});
	});
});

//#endregion
//#region tests/api/worker/facades/KeyCacheTest.ts
dist_default.spec("KeyCacheTest", function() {
	let keyCache;
	dist_default.beforeEach(function() {
		keyCache = new KeyCache();
		keyCache.setCurrentUserGroupKey({
			version: 0,
			object: aes256RandomKey()
		});
	});
	dist_default("removeOutdatedGroupKeys - new group key version for cached key", async function() {
		let groupId = "groupId";
		const user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef),
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				group: groupId,
				groupKeyVersion: "1"
			})]
		});
		await keyCache.getCurrentGroupKey(groupId, () => Promise.resolve({
			version: 0,
			object: aes256RandomKey()
		}));
		await keyCache.removeOutdatedGroupKeys(user);
		const cachedKey = await keyCache.getCurrentGroupKey(groupId, async () => {
			return {
				version: 1,
				object: aes256RandomKey()
			};
		});
		dist_default(cachedKey.version).equals(1);
	});
	dist_default("removeOutdatedGroupKeys - no version update for cached key", async function() {
		let groupId = "groupId";
		const user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef),
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				group: groupId,
				groupKeyVersion: "0"
			})]
		});
		await keyCache.getCurrentGroupKey(groupId, () => Promise.resolve({
			version: 0,
			object: aes256RandomKey()
		}));
		await keyCache.removeOutdatedGroupKeys(user);
		const cachedKey = await keyCache.getCurrentGroupKey(groupId, async () => {
			throw new Error("unexpected call to key loader");
		});
		dist_default(cachedKey.version).equals(0);
	});
	dist_default("removeOutdatedGroupKeys - removed membership for cached key", async function() {
		let groupId = "groupId";
		const user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef),
			memberships: []
		});
		await keyCache.getCurrentGroupKey(groupId, () => Promise.resolve({
			version: 0,
			object: aes256RandomKey()
		}));
		await keyCache.removeOutdatedGroupKeys(user);
		dist_default(async () => keyCache.getCurrentGroupKey(groupId, async () => {
			throw new NotAuthorizedError("unexpected call to key loader");
		})).asyncThrows(NotAuthorizedError);
	});
	dist_default("removeOutdatedGroupKeys - ignore user group key update", async function() {
		let groupId = "groupId";
		const user = createTestEntity(UserTypeRef, {
			userGroup: createTestEntity(GroupMembershipTypeRef, {
				group: "userGroupId",
				groupKeyVersion: "1"
			}),
			memberships: [createTestEntity(GroupMembershipTypeRef, {
				group: groupId,
				groupKeyVersion: "0"
			})]
		});
		await keyCache.removeOutdatedGroupKeys(user);
		const cachedUserGroupKey = keyCache.getCurrentUserGroupKey();
		dist_default(cachedUserGroupKey.version).equals(0);
	});
});

//#endregion
//#region tests/misc/InAppRatingUtilsTest.ts
var import_testdouble$3 = __toESM(require_testdouble(), 1);
dist_default.spec("InAppRatingUtilsTest", () => {
	let deviceConfigMock = (0, import_testdouble$3.object)();
	let locatorMock = (0, import_testdouble$3.object)();
	dist_default.beforeEach(() => {
		deviceConfigMock = (0, import_testdouble$3.object)();
		locatorMock = (0, import_testdouble$3.object)();
		initCommonLocator(locatorMock);
	});
	const now$1 = new Date("2024-10-27T12:34:00Z");
	const userControllerMock = (0, import_testdouble$3.object)({ async loadCustomerInfo() {} });
	dist_default.spec("getRatingAllowed", () => {
		dist_default("Should not trigger if the app is not on iOS", async () => {
			const appInstallationDate = new Date("2024-10-11T11:12:04Z");
			(0, import_testdouble$3.when)(deviceConfigMock.getRetryRatingPromptAfter()).thenReturn(null);
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(locatorMock.systemFacade.getInstallationDate()).thenResolve(String(appInstallationDate.getTime()));
			const res = await getRatingAllowed(now$1, deviceConfigMock, false);
			dist_default(res).equals(RatingCheckResult.UNSUPPORTED_PLATFORM);
		});
		dist_default("Should not trigger if the rating dialog was shown less than a year ago", async () => {
			const appInstallationDate = new Date("2024-10-11T11:12:04Z");
			(0, import_testdouble$3.when)(deviceConfigMock.getRetryRatingPromptAfter()).thenReturn(null);
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(new Date("2024-06-06T06:06:06Z"));
			(0, import_testdouble$3.when)(locatorMock.systemFacade.getInstallationDate()).thenResolve(String(appInstallationDate.getTime()));
			const res = await getRatingAllowed(now$1, deviceConfigMock, true);
			dist_default(res).equals(RatingCheckResult.LAST_RATING_TOO_YOUNG);
		});
		dist_default("Should not trigger if the app was installed less than 7 days ago", async () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(locatorMock.systemFacade.getInstallationDate()).thenResolve(String(new Date("2024-10-23T11:12:04Z").getTime()));
			const res = await getRatingAllowed(now$1, deviceConfigMock, true);
			dist_default(res).equals(RatingCheckResult.APP_INSTALLATION_TOO_YOUNG);
		});
		dist_default("Should not trigger if the customer account was created less than 7 days ago", async () => {
			const appInstallationDate = new Date("2024-10-11T11:12:04Z");
			const customerCreationDate = new Date("2024-10-23T11:12:04Z");
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(locatorMock.systemFacade.getInstallationDate()).thenResolve(String(appInstallationDate.getTime()));
			(0, import_testdouble$3.when)(locatorMock.logins.getUserController()).thenReturn(userControllerMock);
			(0, import_testdouble$3.when)(locatorMock.logins.getUserController().loadCustomerInfo()).thenResolve({ creationTime: customerCreationDate });
			const res = await getRatingAllowed(now$1, deviceConfigMock, true);
			dist_default(res).equals(RatingCheckResult.ACCOUNT_TOO_YOUNG);
		});
		dist_default("Should not trigger if the retry prompt timer has not elapsed", async () => {
			const appInstallationDate = new Date("2024-10-11T11:12:04Z");
			const customerCreationDate = new Date("2024-10-11T11:12:04Z");
			(0, import_testdouble$3.when)(deviceConfigMock.getRetryRatingPromptAfter()).thenReturn(new Date("2024-11-27T14:34:00Z"));
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(locatorMock.systemFacade.getInstallationDate()).thenResolve(String(appInstallationDate.getTime()));
			(0, import_testdouble$3.when)(locatorMock.logins.getUserController()).thenReturn(userControllerMock);
			(0, import_testdouble$3.when)(locatorMock.logins.getUserController().loadCustomerInfo()).thenResolve({ creationTime: customerCreationDate });
			const res = await getRatingAllowed(now$1, deviceConfigMock, true);
			(0, import_testdouble$3.verify)(locatorMock.logins.getUserController().loadCustomerInfo(), { times: 1 });
			dist_default(res).equals(RatingCheckResult.RATING_DISMISSED);
		});
	});
	dist_default.spec("isEventHappyMoment", () => {
		dist_default("Should trigger when three activities reached and retry timer has elapsed", () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn([
				new Date("2024-10-11T11:12:04Z"),
				new Date("2024-10-10T11:12:04Z"),
				new Date("2024-10-09T11:12:04Z")
			]);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			dist_default(res).equals(true);
		});
		dist_default("Should trigger if there are at least 3 events/emails created and no previous prompt", () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn([
				new Date("2024-10-11T11:12:04Z"),
				new Date("2024-10-10T11:12:04Z"),
				new Date("2024-10-09T11:12:04Z")
			]);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			(0, import_testdouble$3.verify)(deviceConfigMock.getEvents(), { times: 1 });
			dist_default(res).equals(true);
		});
		dist_default("Should not trigger if there are at least 3 events/emails created and no previous prompt", () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(new Date("2024-02-11T11:12:04Z"));
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn([
				new Date("2024-10-11T11:12:04Z"),
				new Date("2024-10-10T11:12:04Z"),
				new Date("2024-10-09T11:12:04Z")
			]);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			(0, import_testdouble$3.verify)(deviceConfigMock.getEvents(), { times: 1 });
			dist_default(res).equals(false);
		});
		dist_default("Should trigger if there are at least 10 recent activities in the last 28 days", () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(new Date("2022-10-11T11:12:04Z"));
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn([
				new Date("2024-10-11T11:12:04Z"),
				new Date("2024-10-10T11:12:04Z"),
				new Date("2024-10-09T11:12:04Z"),
				new Date("2024-10-08T11:12:04Z"),
				new Date("2024-10-07T11:12:04Z"),
				new Date("2024-10-06T11:12:04Z"),
				new Date("2024-10-05T11:12:04Z"),
				new Date("2024-10-04T11:12:04Z"),
				new Date("2024-10-03T11:12:04Z"),
				new Date("2024-10-02T11:12:04Z")
			]);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			dist_default(res).equals(true);
		});
		dist_default("Should not trigger if there are less than 10 recent activities in the last 28 days", () => {
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(new Date("2022-10-11T11:12:04Z"));
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn([
				new Date("2024-10-11T11:12:04Z"),
				new Date("2024-10-10T11:12:04Z"),
				new Date("2024-10-09T11:12:04Z"),
				new Date("2024-10-08T11:12:04Z"),
				new Date("2024-10-07T11:12:04Z"),
				new Date("2024-10-06T11:12:04Z"),
				new Date("2024-10-05T11:12:04Z"),
				new Date("2024-10-04T11:12:04Z"),
				new Date("2024-10-03T11:12:04Z"),
				new Date("2024-09-28T11:12:04Z")
			]);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			dist_default(res).equals(false);
		});
		dist_default("Should not trigger if less than 3 events/emails created", () => {
			const events = [new Date("2024-10-11T11:12:04Z"), new Date("2024-10-10T11:12:04Z")];
			(0, import_testdouble$3.when)(deviceConfigMock.getLastRatingPromptedDate()).thenReturn(null);
			(0, import_testdouble$3.when)(deviceConfigMock.getEvents()).thenReturn(events);
			const res = isEventHappyMoment(now$1, deviceConfigMock);
			dist_default(res).equals(false);
		});
	});
});

//#endregion
//#region tests/native/main/MailExportControllerTest.ts
var import_testdouble$2 = __toESM(require_testdouble(), 1);
dist_default.spec("MailExportController", function() {
	const userId$1 = "userId";
	let controller;
	let mailExportFacade;
	let exportFacade;
	let logins;
	let mailboxModel;
	let mailboxDetail;
	let userController;
	let scheduler;
	const sanitizer = { sanitizeHTML: (text, _) => ({
		html: text,
		blockedExternalContent: 0,
		inlineImageCids: [],
		links: []
	}) };
	dist_default.beforeEach(function() {
		userController = { userId: userId$1 };
		mailboxDetail = {
			mailbox: createTestEntity(MailBoxTypeRef, {
				_id: "mailboxId",
				currentMailBag: createTestEntity(MailBagTypeRef, {
					_id: "currentMailBagId",
					mails: "currentMailList"
				}),
				archivedMailBags: [createTestEntity(MailBagTypeRef, {
					_id: "archivedMailBagId1",
					mails: "archivedMailList1"
				}), createTestEntity(MailBagTypeRef, {
					_id: "archivedMailBagId2",
					mails: "archivedMailList2"
				})]
			}),
			mailGroup: createTestEntity(GroupTypeRef, { _id: "mailGroupId" }),
			mailGroupInfo: createTestEntity(GroupInfoTypeRef),
			mailboxGroupRoot: createTestEntity(MailboxGroupRootTypeRef)
		};
		mailExportFacade = (0, import_testdouble$2.object)();
		exportFacade = (0, import_testdouble$2.object)();
		logins = (0, import_testdouble$2.object)();
		(0, import_testdouble$2.when)(logins.getUserController()).thenReturn(userController);
		mailboxModel = (0, import_testdouble$2.object)();
		(0, import_testdouble$2.when)(mailboxModel.getMailboxDetailByMailboxId(mailboxDetail.mailbox._id)).thenResolve(mailboxDetail);
		scheduler = new SchedulerMock();
		controller = new MailExportController(mailExportFacade, sanitizer, exportFacade, logins, mailboxModel, scheduler);
	});
	function prepareMailData(mailBag, startId, num) {
		const mailDetails = createTestEntity(MailDetailsTypeRef, {
			sentDate: new Date(42),
			body: createTestEntity(BodyTypeRef, { compressedText: "body! compressed" }),
			recipients: createTestEntity(RecipientsTypeRef)
		});
		const attachmentInfo = createTestEntity(FileTypeRef, { _id: ["fileListId", "fileId"] });
		const mail = createTestEntity(MailTypeRef, {
			_id: ["mailListId", startId + `_${num}`],
			attachments: [attachmentInfo._id],
			receivedDate: new Date(43),
			sender: createTestEntity(MailAddressTypeRef, {
				name: "MailSender",
				address: "sender@list.com"
			})
		});
		const attachmentData = new Uint8Array([
			1,
			2,
			3
		]);
		const dataFile = createDataFile("test", "application/octet-stream", attachmentData);
		(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(mailBag.mails, startId, import_testdouble$2.matchers.anything())).thenResolve([mail]);
		(0, import_testdouble$2.when)(mailExportFacade.loadMailDetails([mail])).thenResolve([{
			mail,
			mailDetails
		}]);
		(0, import_testdouble$2.when)(mailExportFacade.loadAttachments([mail], import_testdouble$2.matchers.anything())).thenResolve([attachmentInfo]);
		(0, import_testdouble$2.when)(mailExportFacade.loadAttachmentData(mail, [attachmentInfo])).thenResolve([dataFile]);
		const mailBundle = makeMailBundle(sanitizer, mail, mailDetails, [dataFile]);
		return {
			mail,
			mailBundle,
			mailDetails
		};
	}
	dist_default.spec("startExport", function() {
		dist_default.test("it updates the initial state", async function() {
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([createTestEntity(BlobServerUrlTypeRef, { url: "baseUrl" })]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenResolve([]);
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(exportFacade.startMailboxExport(userId$1, mailboxDetail.mailbox._id, assertNotNull(mailboxDetail.mailbox.currentMailBag)._id, GENERATED_MAX_ID));
		});
		dist_default.test("it runs the export", async function() {
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([createTestEntity(BlobServerUrlTypeRef, { url: "baseUrl" })]);
			const mailBag = assertNotNull(mailboxDetail.mailbox.currentMailBag);
			const { mail, mailBundle } = prepareMailData(mailBag, GENERATED_MAX_ID, 1);
			prepareMailData(assertNotNull(mailboxDetail.mailbox.archivedMailBags[0]), GENERATED_MAX_ID, 2);
			prepareMailData(assertNotNull(mailboxDetail.mailbox.archivedMailBags[1]), GENERATED_MAX_ID, 3);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.not(GENERATED_MAX_ID), import_testdouble$2.matchers.anything())).thenResolve([]);
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle, userId$1, mailBag._id, getElementId(mail)));
		});
		dist_default.test("it sets state to locked when a LockedForUser ExportError is thrown", async function() {
			(0, import_testdouble$2.when)(exportFacade.startMailboxExport(userId$1, mailboxDetail.mailbox._id, assertNotNull(mailboxDetail.mailbox.currentMailBag)._id, GENERATED_MAX_ID)).thenReject(new ExportError("message", ExportErrorReason.LockedForUser));
			await controller.startExport(mailboxDetail);
			dist_default(controller.state().type).equals("locked");
		});
	});
	dist_default.spec("resumeIfNeeded", function() {
		dist_default.test("when the persisted state is finished it does not continue with export", function() {
			(0, import_testdouble$2.when)(exportFacade.getMailboxExportState(userId$1)).thenResolve({ type: "finished" });
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything()), { times: 0 });
			dist_default(controller.state().type).equals("idle");
		});
		dist_default.test("when persisted state is running it runs the export", async function() {
			const initialMailId = "initialMailId";
			const mailBag = assertNotNull(mailboxDetail.mailbox.currentMailBag);
			const { mail, mailBundle } = prepareMailData(mailBag, initialMailId, 1);
			const persistedState = {
				type: "running",
				mailboxId: mailboxDetail.mailbox._id,
				userId: userId$1,
				mailId: initialMailId,
				mailBagId: mailBag._id,
				exportedMails: 0,
				exportDirectoryPath: "directory"
			};
			(0, import_testdouble$2.when)(exportFacade.getMailboxExportState(userId$1)).thenResolve(persistedState);
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([createTestEntity(BlobServerUrlTypeRef, { url: "baseUrl" })]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(mailBag.mails, import_testdouble$2.matchers.not(initialMailId), import_testdouble$2.matchers.anything())).thenResolve([]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.not(mailBag.mails), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenResolve([]);
			await controller.resumeIfNeeded();
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle, userId$1, mailBag._id, getElementId(mail)));
		});
		dist_default.test("when the exportFacade returns a locked state, the state is set to locked and retry is scheduled", async function() {
			(0, import_testdouble$2.when)(exportFacade.getMailboxExportState(userId$1)).thenResolve({
				type: "locked",
				userId: userId$1
			});
			scheduler.scheduleAfter = spy();
			await controller.resumeIfNeeded();
			dist_default(scheduler.scheduleAfter.callCount).equals(1);
			dist_default(scheduler.scheduleAfter.args[1]).equals(3e5);
			dist_default(controller.state().type).equals("locked");
		});
	});
	dist_default.spec("cancelExport", function() {
		dist_default.test("canceling resets the state", async function() {
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([createTestEntity(BlobServerUrlTypeRef, { url: "baseUrl" })]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenResolve([]);
			const startPromise = controller.startExport(mailboxDetail);
			const cancelPromise = controller.cancelExport();
			dist_default(controller.state().type).equals("idle");
			await Promise.all([startPromise, cancelPromise]);
		});
	});
	dist_default.spec("export loop", function() {
		dist_default.test("it continues to load mail list", async function() {
			const mailBag = assertNotNull(mailboxDetail.mailbox.currentMailBag);
			const { mail: mail1 } = prepareMailData(mailBag, GENERATED_MAX_ID, 1);
			const { mail: mail2, mailBundle: mailBundle2 } = prepareMailData(mailBag, getElementId(mail1), 2);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(mailBag.mails, getElementId(mail2), import_testdouble$2.matchers.anything())).thenResolve([]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.not(mailBag.mails), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenResolve([]);
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([createTestEntity(BlobServerUrlTypeRef, { url: "baseUrl" })]);
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle2, userId$1, mailBag._id, getElementId(mail2)));
			(0, import_testdouble$2.verify)(exportFacade.endMailboxExport(userId$1));
		});
		dist_default.test("it loops over mail bags", async function() {
			const currentMailBag = assertNotNull(mailboxDetail.mailbox.currentMailBag);
			const { mail: mail1, mailBundle: mailBundle1 } = prepareMailData(currentMailBag, GENERATED_MAX_ID, 1);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(currentMailBag.mails, getElementId(mail1), "baseUrl")).thenResolve([]);
			const archivedMailBag1 = mailboxDetail.mailbox.archivedMailBags[0];
			const { mail: mail2, mailBundle: mailBundle2 } = prepareMailData(archivedMailBag1, GENERATED_MAX_ID, 2);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(archivedMailBag1.mails, getElementId(mail2), "baseUrl")).thenResolve([]);
			const archivedMailBag2 = mailboxDetail.mailbox.archivedMailBags[1];
			const { mail: mail3, mailBundle: mailBundle3 } = prepareMailData(archivedMailBag2, GENERATED_MAX_ID, 3);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(archivedMailBag2.mails, getElementId(mail3), "baseUrl")).thenResolve([]);
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([{
				_id: "id",
				url: "baseUrl",
				_type: BlobServerUrlTypeRef
			}]);
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle1, userId$1, currentMailBag._id, getElementId(mail1)));
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle2, userId$1, archivedMailBag1._id, getElementId(mail2)));
			(0, import_testdouble$2.verify)(exportFacade.saveMailboxExport(mailBundle3, userId$1, archivedMailBag2._id, getElementId(mail3)));
			(0, import_testdouble$2.verify)(exportFacade.endMailboxExport(userId$1));
		});
		dist_default.test("it loops over servers", async function() {
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([
				{
					_id: "id",
					url: "baseUrl1",
					_type: BlobServerUrlTypeRef
				},
				{
					_id: "id",
					url: "baseUrl2",
					_type: BlobServerUrlTypeRef
				},
				{
					_id: "id",
					url: "baseUrl3",
					_type: BlobServerUrlTypeRef
				}
			]);
			const currentMailBag = assertNotNull(mailboxDetail.mailbox.currentMailBag);
			const { mail: mail1, mailBundle: mailBundle1, mailDetails: mailDetails1 } = prepareMailData(currentMailBag, GENERATED_MAX_ID, 1);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(currentMailBag.mails, getElementId(mail1), import_testdouble$2.matchers.anything())).thenResolve([]);
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.not(currentMailBag.mails), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenResolve([]);
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(mailExportFacade.loadFixedNumberOfMailsWithCache(currentMailBag.mails, GENERATED_MAX_ID, "baseUrl2"));
			(0, import_testdouble$2.verify)(mailExportFacade.loadAttachments([mail1], "baseUrl3"));
			(0, import_testdouble$2.verify)(mailExportFacade.loadAttachmentData(mail1, import_testdouble$2.matchers.anything()));
		});
	});
	dist_default.spec("handle errors", function() {
		dist_default.test("SuspensionError", async () => {
			(0, import_testdouble$2.when)(mailExportFacade.getExportServers(mailboxDetail.mailGroup)).thenResolve([{
				_id: "id",
				url: "baseUrl",
				_type: BlobServerUrlTypeRef
			}]);
			let wasThrown = false;
			(0, import_testdouble$2.when)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything())).thenDo(() => {
				if (wasThrown) return Promise.resolve([]);
else {
					wasThrown = true;
					return Promise.reject(new SuspensionError(":(", "10"));
				}
			});
			await controller.startExport(mailboxDetail);
			(0, import_testdouble$2.verify)(mailExportFacade.loadFixedNumberOfMailsWithCache(import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything(), import_testdouble$2.matchers.anything()), { times: 4 });
			dist_default(wasThrown).equals(true);
		});
	});
});

//#endregion
//#region tests/api/worker/facades/MailExportFacadeTest.ts
var import_testdouble$1 = __toESM(require_testdouble(), 1);
dist_default.spec("MailExportFacade", () => {
	const token = "my token";
	const tokenHeaders = { [MAIL_EXPORT_TOKEN_HEADER]: token };
	const mail1 = createTestEntity(MailTypeRef);
	const mail2 = createTestEntity(MailTypeRef);
	const details1 = createTestEntity(MailDetailsTypeRef);
	const details2 = createTestEntity(MailDetailsTypeRef);
	let facade;
	let tokenFacade;
	let bulkMailLoader;
	let blobFacade;
	let cryptoFacade;
	let blobAccessTokenFacade;
	dist_default.beforeEach(() => {
		tokenFacade = { loadWithToken: (req) => req(token) };
		bulkMailLoader = (0, import_testdouble$1.object)();
		blobFacade = (0, import_testdouble$1.object)();
		cryptoFacade = (0, import_testdouble$1.object)();
		blobAccessTokenFacade = (0, import_testdouble$1.instance)(BlobAccessTokenFacade);
		facade = new MailExportFacade(tokenFacade, bulkMailLoader, blobFacade, cryptoFacade, blobAccessTokenFacade);
	});
	dist_default.test("loadFixedNumberOfMailsWithCache", async () => {
		(0, import_testdouble$1.when)(bulkMailLoader.loadFixedNumberOfMailsWithCache("mailListId", "startId", {
			baseUrl: "baseUrl",
			extraHeaders: tokenHeaders,
			suspensionBehavior: SuspensionBehavior.Throw
		})).thenResolve([mail1, mail2]);
		const result = await facade.loadFixedNumberOfMailsWithCache("mailListId", "startId", "baseUrl");
		dist_default(result).deepEquals([mail1, mail2]);
	});
	dist_default.test("loadMailDetails", async () => {
		const expected = [{
			mail: mail1,
			mailDetails: details1
		}, {
			mail: mail2,
			mailDetails: details2
		}];
		(0, import_testdouble$1.when)(bulkMailLoader.loadMailDetails([mail1, mail2], {
			extraHeaders: tokenHeaders,
			suspensionBehavior: SuspensionBehavior.Throw
		})).thenResolve(expected);
		const result = await facade.loadMailDetails([mail1, mail2]);
		dist_default(result).deepEquals(expected);
	});
	dist_default.test("loadAttachments", async () => {
		const expected = [createTestEntity(FileTypeRef), createTestEntity(FileTypeRef)];
		(0, import_testdouble$1.when)(bulkMailLoader.loadAttachments([mail1, mail2], {
			baseUrl: "baseUrl",
			extraHeaders: tokenHeaders,
			suspensionBehavior: SuspensionBehavior.Throw
		})).thenResolve(expected);
		const result = await facade.loadAttachments([mail1, mail2], "baseUrl");
		dist_default(result).deepEquals(expected);
	});
	dist_default.test("loadAttachmentData", async () => {
		const dataByteMail1 = new Uint8Array([
			1,
			2,
			3
		]);
		const dataByteMail2 = new Uint8Array([
			4,
			5,
			6
		]);
		const mailAttachments = [createTestEntity(FileTypeRef, {
			name: "mail1",
			mimeType: "img/png",
			cid: "12345",
			_id: ["attachment", "id1"]
		}), createTestEntity(FileTypeRef, {
			name: "mail2",
			mimeType: "pdf",
			cid: "12345",
			_id: ["attachment", "id2"]
		})];
		(0, import_testdouble$1.when)(cryptoFacade.enforceSessionKeyUpdateIfNeeded(mail1, mailAttachments)).thenResolve(mailAttachments);
		(0, import_testdouble$1.when)(blobFacade.downloadAndDecryptBlobsOfMultipleInstances(ArchiveDataType.Attachments, [createReferencingInstance(mailAttachments[0]), createReferencingInstance(mailAttachments[1])], {
			extraHeaders: tokenHeaders,
			suspensionBehavior: SuspensionBehavior.Throw
		})).thenResolve(new Map([["id1", dataByteMail1], ["id2", dataByteMail2]]));
		const result = await facade.loadAttachmentData(mail1, mailAttachments);
		dist_default(result).deepEquals([{
			_type: "DataFile",
			name: "mail1",
			mimeType: "img/png",
			data: dataByteMail1,
			cid: "12345",
			size: 3,
			id: ["attachment", "id1"]
		}, {
			_type: "DataFile",
			name: "mail2",
			mimeType: "pdf",
			data: dataByteMail2,
			cid: "12345",
			size: 3,
			id: ["attachment", "id2"]
		}]);
	});
});

//#endregion
//#region tests/Suite.ts
var import_testdouble = __toESM(require_testdouble(), 1);
async function run({ integration, filter } = {}) {
	await setupSuite({ integration });
	const result = await dist_default.run({ filter });
	dist_default.printReport(result);
	return result;
}
async function setupSuite({ integration }) {
	const { WorkerImpl: WorkerImpl$1 } = await import("./WorkerImpl-Ulv00s7j.js");
	globalThis.testWorker = WorkerImpl$1;
	if (typeof process != "undefined") if (integration) {
		console.log("\nRunning with integration tests because was run with -i\n");
		await import("./WorkerTest-net_Za8r.js");
		await import("./IntegrationTest-BY8wHIXc.js");
	} else console.log("\nRunning without integration tests because run without -i\n");
	if (typeof process != "undefined") {
		await random.addEntropy([{
			data: 36,
			entropy: 256,
			source: "key"
		}]);
		await import("./PathUtilsTest-Dh7_jHT_.js");
		await import("./TempFsTest-DYtFwBq6.js");
		await import("./DesktopConfigMigratorTest-1UrCdkY-.js");
		await import("./ElectronUpdaterTest-nL6QEJ0k.js");
		await import("./DesktopNotifierTest-BzmFx6hV.js");
		await import("./ApplicationWindowTest-BefKG9JY.js");
		await import("./SecretStorageTest-BBj-FLCX.js");
		await import("./DesktopAlarmStorageTest-BoAvBqb4.js");
		await import("./DesktopAlarmSchedulerTest-CJYUpgHB.js");
		await import("./DesktopFileFacadeTest-C-8eR8kB.js");
		await import("./ProtocolProxyTest-BTpS7Acq.js");
		await import("./SocketeerTest-Caj2tpg7.js");
		await import("./DesktopIntegratorTest-Cx6s6-Er.js");
		await import("./RegistryScriptGeneratorTest-bO6_RAJH.js");
		await import("./DesktopCryptoFacadeTest-AI994OPI.js");
		await import("./DesktopContextMenuTest-BNC5ekpO.js");
		await import("./DesktopKeyStoreFacadeTest-WEJhc16R.js");
		await import("./ConfigFileTest-bV1VPTKU.js");
		await import("./OfflineDbFacadeTest-D3DaePz6.js");
		await import("./DesktopNativeCredentialsFacadeTest-CV9nQp4l.js");
		await import("./AppPassHandlerTest-c0bEB59T.js");
		await import("./OfflineStorageMigratorTest-pSLHsQnf.js");
		await import("./OfflineStorageMigrationsTest-BGiq-A-6.js");
		await import("./OfflineStorageTest-BgaCSfok.js");
		await import("./DesktopConfigTest-vOcN7I0i.js");
		await import("./RestClientTest-CxYRvl-k.js");
		await import("./TempFsTest-DYtFwBq6.js");
		await import("./SseClientTest-BP4T15qN.js");
		await import("./TutaSseFacadeTest-DdOMHyC8.js");
		await import("./TutaNotificationHandlerTest-B5iQmXAR.js");
		await import("./KeychainEncryptionTest-BKGX2Eet.js");
		await import("./DesktopCredentialsStorageTest-C8qZJYdF.js");
		await import("./DesktopExportFacadeTest-CEtrIUBl.js");
	}
	import_testdouble.config({ ignoreWarnings: true });
	dist_default.before(async function() {
		await random.addEntropy([{
			data: 36,
			entropy: 256,
			source: "key"
		}]);
	});
	dist_default.afterEach(function() {
		import_testdouble.reset();
		env.mode = Mode.Test;
	});
}

//#endregion
export { run };
//# sourceMappingURL=Suite-DQ7Aq7rC.js.map