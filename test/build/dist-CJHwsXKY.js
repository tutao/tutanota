
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`

//#region ../packages/tutanota-utils/dist/TypeRef.js
var TypeRef = class {
	app;
	type;
	/**
	* Field that is never set. Used to make two TypeRefs incompatible (they are structurally compared otherwise).
	* Cannot be private.
	*/
	phantom = null;
	constructor(app, type) {
		this.app = app;
		this.type = type;
		Object.freeze(this);
	}
	/**
	* breaks when the object passes worker barrier
	*/
	toString() {
		return `[TypeRef ${this.app} ${this.type}]`;
	}
};
function getTypeId(typeRef) {
	return typeRef.app + "/" + typeRef.type;
}
function isSameTypeRefByAttr(typeRef, app, typeName) {
	return typeRef.app === app && typeRef.type === typeName;
}
function isSameTypeRef(typeRef1, typeRef2) {
	return isSameTypeRefByAttr(typeRef1, typeRef2.app, typeRef2.type);
}

//#endregion
//#region ../packages/tutanota-utils/dist/Utils.js
function freshVersioned(object) {
	return {
		object,
		version: 0
	};
}
function defer() {
	let ret = {};
	ret.promise = new Promise((resolve, reject) => {
		ret.resolve = resolve;
		ret.reject = reject;
	});
	return ret;
}
function deferWithHandler(handler) {
	const deferred = {};
	deferred.promise = new Promise((resolve, reject) => {
		deferred.resolve = resolve;
		deferred.reject = reject;
	}).then(handler);
	return deferred;
}
async function asyncFind(array, finder) {
	for (let i = 0; i < array.length; i++) {
		const item = array[i];
		if (await finder(item, i, array.length)) return item;
	}
	return null;
}
function neverNull(object) {
	return object;
}
function assertNotNull(value, message = "null") {
	if (value == null) throw new Error("AssertNotNull failed : " + message);
	return value;
}
function assertNonNull(value, message = "null") {
	if (value == null) throw new Error("AssertNonNull failed: " + message);
}
function isNotNull(t) {
	return t != null;
}
function assert(assertion, message) {
	if (!resolveMaybeLazy(assertion)) throw new Error(`Assertion failed: ${message}`);
}
function downcast(object) {
	return object;
}
function clone(instance) {
	if (instance instanceof Uint8Array) return downcast(instance.slice());
else if (instance instanceof Array) return downcast(instance.map((i) => clone(i)));
else if (instance instanceof Date) return new Date(instance.getTime());
else if (instance instanceof TypeRef) return instance;
else if (instance instanceof Object) {
		const copy = Object.create(Object.getPrototypeOf(instance) || null);
		Object.assign(copy, instance);
		for (let key of Object.keys(copy)) copy[key] = clone(copy[key]);
		return copy;
	} else return instance;
}
function lazyMemoized(source) {
	let cached = false;
	let value;
	return () => {
		if (cached) return value;
else {
			cached = true;
			return value = source();
		}
	};
}
function makeSingleUse(fn) {
	let called = false;
	return (arg) => {
		if (!called) {
			called = true;
			fn(arg);
		}
	};
}
function memoized(fn) {
	let lastArg;
	let lastResult;
	let didCache = false;
	return (arg) => {
		if (!didCache || arg !== lastArg) {
			lastArg = arg;
			didCache = true;
			lastResult = fn(arg);
		}
		return lastResult;
	};
}
function memoizedWithHiddenArgument(argumentProvider, computationFunction) {
	const memoizedComputation = memoized(computationFunction);
	return () => memoizedComputation(argumentProvider());
}
function identity(t) {
	return t;
}
function noOp() {}
function debounce(timeout, toThrottle) {
	let timeoutId;
	let toInvoke;
	return downcast((...args) => {
		if (timeoutId) clearTimeout(timeoutId);
		toInvoke = toThrottle.bind(null, ...args);
		timeoutId = setTimeout(toInvoke, timeout);
	});
}
function debounceStart(timeout, toThrottle) {
	let timeoutId;
	let lastInvoked = 0;
	return downcast((...args) => {
		if (Date.now() - lastInvoked < timeout) {
			if (timeoutId) clearTimeout(timeoutId);
			timeoutId = setTimeout(() => {
				timeoutId = null;
				toThrottle.apply(null, args);
			}, timeout);
		} else toThrottle.apply(null, args);
		lastInvoked = Date.now();
	});
}
function throttle(periodMs, toThrottle) {
	let lastArgs = null;
	return (...args) => {
		if (lastArgs) return;
else setTimeout(() => {
			try {
				toThrottle.apply(null, args);
			} finally {
				lastArgs = null;
			}
		}, periodMs);
	};
}
function randomIntFromInterval(min$1, max$1) {
	return Math.floor(Math.random() * (max$1 - min$1 + 1) + min$1);
}
function errorToString(error) {
	let errorString = error.name ? error.name : "?";
	if (error.message) errorString += `\n Error message: ${error.message}`;
	if (error.stack) errorString += `\nStacktrace: \n${error.stack}`;
	return errorString;
}
function deepEqual(a, b) {
	if (a === b) return true;
	if (xor(a === null, b === null) || xor(a === undefined, b === undefined)) return false;
	if (typeof a === "object" && typeof b === "object") {
		const aIsArgs = isArguments(a), bIsArgs = isArguments(b);
		if (a.length === b.length && (a instanceof Array && b instanceof Array || aIsArgs && bIsArgs)) {
			const aKeys = Object.getOwnPropertyNames(a), bKeys = Object.getOwnPropertyNames(b);
			if (aKeys.length !== bKeys.length) return false;
			for (let i = 0; i < aKeys.length; i++) if (!hasOwn.call(b, aKeys[i]) || !deepEqual(a[aKeys[i]], b[aKeys[i]])) return false;
			return true;
		}
		if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
		if (a instanceof Map && b instanceof Map) {
			for (const key of a.keys()) if (!b.has(key) || !deepEqual(a.get(key), b.get(key))) return false;
			for (const key of b.keys()) if (!a.has(key)) return false;
			return true;
		}
		if (a instanceof Object && b instanceof Object && !aIsArgs && !bIsArgs) {
			for (let i in a) if (!(i in b) || !deepEqual(a[i], b[i])) return false;
			for (let i in b) if (!(i in a)) return false;
			return true;
		}
		if (typeof Buffer === "function" && a instanceof Buffer && b instanceof Buffer) {
			for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
			return true;
		}
		if (a.valueOf() === b.valueOf()) return true;
	}
	return false;
}
function xor(a, b) {
	const aBool = !!a;
	const bBool = !!b;
	return aBool && !bBool || bBool && !aBool;
}
function isArguments(a) {
	if ("callee" in a) {
		for (let i in a) if (i === "callee") return false;
		return true;
	}
}
const hasOwn = {}.hasOwnProperty;
function freezeMap(myMap) {
	function mapSet(key, value) {
		throw new Error("Can't add property " + key + ", map is not extensible");
	}
	function mapDelete(key) {
		throw new Error("Can't delete property " + key + ", map is frozen");
	}
	function mapClear() {
		throw new Error("Can't clear map, map is frozen");
	}
	const anyMap = downcast(myMap);
	anyMap.set = mapSet;
	anyMap.delete = mapDelete;
	anyMap.clear = mapClear;
	Object.freeze(anyMap);
	return anyMap;
}
function addressDomain(senderAddress) {
	return senderAddress.slice(senderAddress.lastIndexOf("@") + 1);
}
function typedKeys(obj) {
	return downcast(Object.keys(obj));
}
function typedEntries(obj) {
	return downcast(Object.entries(obj));
}
function typedValues(obj) {
	return downcast(Object.values(obj));
}
function resolveMaybeLazy(maybe) {
	return typeof maybe === "function" ? maybe() : maybe;
}
function getAsLazy(maybe) {
	return typeof maybe === "function" ? downcast(maybe) : () => maybe;
}
function mapLazily(maybe, mapping) {
	return () => mapping(resolveMaybeLazy(maybe));
}
function filterInt(value) {
	if (/^\d+$/.test(value)) return parseInt(value, 10);
else return NaN;
}
function insideRect(point, rect) {
	return point.x >= rect.left && point.x < rect.right && point.y >= rect.top && point.y < rect.bottom;
}
function mapNullable(val, action) {
	if (val != null) {
		const result = action(val);
		if (result != null) return result;
	}
	return null;
}
function mapObject(mapper, obj) {
	const newObj = {};
	for (const key of Object.keys(obj)) {
		const typedKey = key;
		newObj[typedKey] = mapper(obj[typedKey]);
	}
	return newObj;
}
var BoundedExecutor = class {
	maxParallelJobs;
	runningJobsCount = 0;
	currentJob = Promise.resolve();
	constructor(maxParallelJobs) {
		this.maxParallelJobs = maxParallelJobs;
	}
	async run(job) {
		while (this.runningJobsCount === this.maxParallelJobs) await this.currentJob;
		this.runningJobsCount++;
		try {
			const jobResult = job();
			this.currentJob = jobResult.catch(noOp);
			return await jobResult;
		} finally {
			this.runningJobsCount--;
		}
	}
};

//#endregion
//#region ../packages/tutanota-utils/dist/MapUtils.js
function mergeMaps(maps) {
	return maps.reduce((mergedMap, map) => {
		for (const [key, value] of map.entries()) if (mergedMap.has(key)) neverNull(mergedMap.get(key)).push(value);
else mergedMap.set(key, [value]);
		return mergedMap;
	}, new Map());
}
function getFromMap(map, key, byDefault) {
	let value = map.get(key);
	if (!value) {
		value = byDefault();
		map.set(key, value);
	}
	return value;
}
function mapMap(map, mapper) {
	const resultMap = new Map();
	for (const [key, oldValue] of map) {
		const newValue = mapper(oldValue);
		resultMap.set(key, newValue);
	}
	return resultMap;
}

//#endregion
//#region ../packages/tutanota-utils/dist/ArrayUtils.js
function concat(...arrays) {
	let length = arrays.reduce((previous, current) => previous + current.length, 0);
	let result = new Uint8Array(length);
	let index = 0;
	for (const array of arrays) {
		result.set(array, index);
		index += array.length;
	}
	return result;
}
function numberRange(min$1, max$1) {
	return [...Array(max$1 + 1).keys()].slice(min$1);
}
function arrayEquals(a1, a2) {
	if (a1 === a2) return true;
	if (a1.length === a2.length) {
		for (let i = 0; i < a1.length; i++) if (a1[i] !== a2[i]) return false;
		return true;
	}
	return false;
}
function arrayEqualsWithPredicate(a1, a2, predicate) {
	if (a1.length === a2.length) {
		for (let i = 0; i < a1.length; i++) if (!predicate(a1[i], a2[i])) return false;
		return true;
	}
	return false;
}
function arrayHash(array) {
	let hash = 0;
	hash |= 0;
	for (let i = 0; i < array.length; i++) {
		hash = (hash << 5) - hash + array[i];
		hash |= 0;
	}
	return hash;
}
function remove(theArray, elementToRemove) {
	let i = theArray.indexOf(elementToRemove);
	if (i !== -1) {
		theArray.splice(i, 1);
		return true;
	} else return false;
}
function clear(theArray) {
	theArray.length = 0;
}
function findAll(theArray, finder) {
	const found = [];
	for (let element of theArray) if (finder(element)) found.push(element);
	return found;
}
function findAndRemove(theArray, finder) {
	const index = theArray.findIndex(finder);
	if (index !== -1) {
		theArray.splice(index, 1);
		return true;
	} else return false;
}
function findAllAndRemove(theArray, finder, startIndex = 0) {
	let removedElement = false;
	for (let i = theArray.length - 1; i >= startIndex; i--) if (finder(theArray[i])) {
		theArray.splice(i, 1);
		removedElement = true;
	}
	return removedElement;
}
function mapAndFilterNull(array, mapper) {
	const resultList = [];
	for (const item of array) {
		const resultItem = mapper(item);
		if (resultItem != null) resultList.push(resultItem);
	}
	return resultList;
}
function filterNull(array) {
	return downcast(array.filter((item) => item != null));
}
function last(theArray) {
	return theArray[theArray.length - 1];
}
function isEmpty(array) {
	return array.length === 0;
}
function isNotEmpty(array) {
	return array.length != 0;
}
function lastThrow(array) {
	if (isEmpty(array)) throw new RangeError("Array is empty");
	return neverNull(last(array));
}
function getFirstOrThrow(array) {
	if (isEmpty(array)) throw new RangeError("Array is empty");
	return array[0];
}
function first(array) {
	return array[0] || null;
}
function findLast(array, predicate) {
	const index = findLastIndex(array, predicate);
	if (index !== -1) return array[index];
	return null;
}
function findLastIndex(array, predicate) {
	for (let i = array.length - 1; i >= 0; i--) if (predicate(array[i])) return i;
	return -1;
}
function contains(theArray, elementToCheck) {
	return theArray.indexOf(elementToCheck) !== -1;
}
function count(theArray, pred) {
	return theArray.reduce((acc, next) => pred(next) ? ++acc : acc, 0);
}
function addAll(array, elements) {
	array.push(...elements);
}
function groupByAndMapUniquely(iterable, discriminator, mapper) {
	const map = new Map();
	for (let el of iterable) {
		const key = discriminator(el);
		getFromMap(map, key, () => new Set()).add(mapper(el));
	}
	return map;
}
function groupByAndMap(iterable, discriminator, mapper) {
	const map = new Map();
	for (const el of iterable) {
		const key = discriminator(el);
		getFromMap(map, key, () => []).push(mapper(el));
	}
	return map;
}
function groupBy(iterable, discriminator) {
	return groupByAndMap(iterable, discriminator, identity);
}
function collectToMap(iterable, keyExtractor) {
	const map = new Map();
	for (const el of iterable) {
		const key = keyExtractor(el);
		if (map.has(key)) throw new Error(`The elements of iterable are not unique, duplicated key: ${key}`);
		map.set(key, el);
	}
	return map;
}
function splitInChunks(chunkSize, array) {
	return downcast(_chunk(chunkSize, array));
}
function splitUint8ArrayInChunks(chunkSize, array) {
	return downcast(_chunk(chunkSize, array));
}
function _chunk(chunkSize, array) {
	if (chunkSize < 1) return [];
	let chunkNum = 0;
	const chunks = [];
	let end;
	do {
		let start = chunkNum * chunkSize;
		end = start + chunkSize;
		chunks[chunkNum] = array.slice(start, end);
		chunkNum++;
	} while (end < array.length);
	return chunks;
}
function flatMap(array, mapper) {
	const result = [];
	for (const item of array) {
		const mapped = mapper(item);
		result.push(...mapped);
	}
	return result;
}
function insertIntoSortedArray(element, array, comparator, replaceIf = () => false) {
	let i = 0;
	while (i < array.length) {
		const compareResult = comparator(array[i], element);
		if (compareResult === 0 && replaceIf(element, array[i])) {
			array.splice(i, 1, element);
			return;
		} else if (compareResult <= 0) i++;
else break;
	}
	array.splice(i, 0, element);
}
function deduplicate(arr, comp = (a, b) => a === b) {
	const deduplicated = [];
	for (const a of arr) {
		const isDuplicate = deduplicated.some((b) => comp(a, b));
		if (!isDuplicate) deduplicated.push(a);
	}
	return deduplicated;
}
function binarySearch(array, element, compareFn) {
	let m = 0;
	let n = array.length - 1;
	while (m <= n) {
		const k = n + m >> 1;
		const cmp = compareFn(element, array[k]);
		if (cmp > 0) m = k + 1;
else if (cmp < 0) n = k - 1;
else return k;
	}
	return -m - 1;
}
function lastIndex(array) {
	if (array.length === 0) return 0;
else return array.length - 1;
}
function difference(array1, array2, compare$1 = (a, b) => a === b) {
	return array1.filter((element1) => !array2.some((element2) => compare$1(element1, element2)));
}
function symmetricDifference(set1, set2) {
	const diff = new Set();
	for (const el of set1) if (!set2.has(el)) diff.add(el);
	for (const el of set2) if (!set1.has(el)) diff.add(el);
	return diff;
}
function partition(array, predicate) {
	const left = [];
	const right = [];
	for (let item of array) if (predicate(item)) left.push(item);
else right.push(item);
	return [left, right];
}
async function partitionAsync(array, predicate) {
	const left = [];
	const right = [];
	for (let item of array) if (await predicate(item)) left.push(item);
else right.push(item);
	return [left, right];
}
function arrayOf(n, factory) {
	return numberRange(0, n - 1).map(factory);
}
function compare(first$1, second) {
	if (first$1.length > second.length) return 1;
else if (first$1.length < second.length) return -1;
	for (let i = 0; i < first$1.length; i++) {
		const a = first$1[i];
		const b = second[i];
		if (a > b) return 1;
else if (a < b) return -1;
	}
	return 0;
}

//#endregion
//#region ../packages/tutanota-utils/dist/CollectionUtils.js
function intersection(set1, set2) {
	return new Set(Array.from(set1).filter((item) => set2.has(item)));
}
function setEquals(set1, set2) {
	if (set1.size !== set2.size) return false;
	for (let item of set1) if (!set2.has(item)) return false;
	return true;
}
function setMap(set, mapper) {
	const result = new Set();
	for (const item of set) result.add(mapper(item));
	return result;
}
function setAddAll(set, toAdd) {
	for (const item of toAdd) set.add(item);
}
function findBy(collection, selector) {
	for (const item of collection) if (selector(item)) return item;
	return null;
}
function mapWith(map, key, value) {
	const newMap = new Map(map);
	newMap.set(key, value);
	return newMap;
}
function mapWithout(map, key) {
	const newMap = new Map(map);
	newMap.delete(key);
	return newMap;
}
function trisectingDiff(before, after) {
	const kept = [];
	const added = [];
	const deleted = [];
	const beforeScratch = new Map(before);
	const afterScratch = new Map(after);
	for (const [k, v] of beforeScratch.entries()) {
		beforeScratch.delete(k);
		if (afterScratch.has(k)) {
			afterScratch.delete(k);
			kept.push(v);
		} else deleted.push(v);
	}
	for (const v of afterScratch.values()) added.push(v);
	return {
		kept,
		added,
		deleted
	};
}

//#endregion
//#region ../packages/tutanota-utils/dist/DateUtils.js
const DAY_IN_MILLIS = 864e5;
const YEAR_IN_MILLIS = DAY_IN_MILLIS * 365;
const TIMESTAMP_ZERO_YEAR = 0;
function getStartOfNextDay(date) {
	let d = new Date(date.getTime());
	d.setDate(date.getDate() + 1);
	d.setHours(0, 0, 0, 0);
	return d;
}
function getEndOfDay(date) {
	let d = new Date(date.getTime());
	d.setHours(23, 59, 59, 999);
	return d;
}
function getStartOfDay(date) {
	return getHourOfDay(date, 0);
}
function getHourOfDay(date, hour) {
	let d = new Date(date.getTime());
	d.setHours(hour, 0, 0, 0);
	return d;
}
function isSameDay(date1, date2) {
	return date1.toDateString() === date2.toDateString();
}
function getDayShifted(date, days) {
	return new Date(date.getTime() + days * DAY_IN_MILLIS);
}
function incrementDate(date, byValue) {
	date.setDate(date.getDate() + byValue);
	return date;
}
function incrementMonth(d, byValue) {
	const date = new Date(d);
	date.setMonth(date.getMonth() + byValue);
	return date;
}
function isSameDayOfDate(date1, date2) {
	return !date1 && !date2 || date1 != null && date2 != null && date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
}
function formatSortableDate(date) {
	const month = ("0" + (date.getMonth() + 1)).slice(-2);
	const day = ("0" + date.getDate()).slice(-2);
	return `${date.getFullYear()}-${month}-${day}`;
}
function formatSortableDateTime(date) {
	const hours = ("0" + date.getHours()).slice(-2);
	const minutes = ("0" + date.getMinutes()).slice(-2);
	const seconds = ("0" + date.getSeconds()).slice(-2);
	return `${formatSortableDate(date)}-${hours}h${minutes}m${seconds}s`;
}
function sortableTimestamp() {
	return formatSortableDateTime(new Date());
}
function isValidDate(date) {
	return !isNaN(date.getTime());
}
function millisToDays(millis) {
	return millis / DAY_IN_MILLIS;
}
function daysToMillis(days) {
	return days * DAY_IN_MILLIS;
}

//#endregion
//#region ../packages/tutanota-utils/dist/Encoding.js
function uint8ArrayToArrayBuffer(uint8Array) {
	if (uint8Array.byteLength === uint8Array.buffer.byteLength) return uint8Array.buffer;
else return new Uint8Array(uint8Array).buffer;
}
function hexToBase64(hex) {
	return uint8ArrayToBase64(hexToUint8Array(hex));
}
function base64ToHex(base64) {
	return uint8ArrayToHex(base64ToUint8Array(base64));
}
function base64ToBase64Url(base64) {
	let base64url = base64.replace(/\+/g, "-");
	base64url = base64url.replace(/\//g, "_");
	base64url = base64url.replace(/=/g, "");
	return base64url;
}
function makeLookup(str) {
	const lookup = {};
	for (let i = 0; i < str.length; i++) lookup[str.charAt(i)] = i;
	return lookup;
}
const base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const base64Lookup = makeLookup(base64Alphabet);
const base64extAlphabet = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
const base64ExtLookup = makeLookup(base64extAlphabet);
function base64ToBase64Ext(base64) {
	base64 = base64.replace(/=/g, "");
	let base64ext = "";
	for (let i = 0; i < base64.length; i++) {
		const index = base64Lookup[base64.charAt(i)];
		base64ext += base64extAlphabet[index];
	}
	return base64ext;
}
function base64ExtToBase64(base64ext) {
	let base64 = "";
	for (let i = 0; i < base64ext.length; i++) {
		const index = base64ExtLookup[base64ext.charAt(i)];
		base64 += base64Alphabet[index];
	}
	let padding;
	if (base64.length % 4 === 2) padding = "==";
else if (base64.length % 4 === 3) padding = "=";
else padding = "";
	return base64 + padding;
}
function base64UrlToBase64(base64url) {
	let base64 = base64url.replace(/-/g, "+");
	base64 = base64.replace(/_/g, "/");
	let nbrOfRemainingChars = base64.length % 4;
	if (nbrOfRemainingChars === 0) return base64;
else if (nbrOfRemainingChars === 2) return base64 + "==";
else if (nbrOfRemainingChars === 3) return base64 + "=";
	throw new Error("Illegal base64 string.");
}
function _stringToUtf8Uint8ArrayLegacy(string) {
	let fixedString;
	try {
		fixedString = encodeURIComponent(string);
	} catch (e) {
		fixedString = encodeURIComponent(_replaceLoneSurrogates(string));
	}
	let utf8 = unescape(fixedString);
	let uint8Array = new Uint8Array(utf8.length);
	for (let i = 0; i < utf8.length; i++) uint8Array[i] = utf8.charCodeAt(i);
	return uint8Array;
}
const REPLACEMENT_CHAR = "ï¿½";
function _replaceLoneSurrogates(s) {
	if (s == null) return "";
	let result = [];
	for (let i = 0; i < s.length; i++) {
		let code = s.charCodeAt(i);
		let char = s.charAt(i);
		if (55296 <= code && code <= 56319) if (s.length === i) result.push(REPLACEMENT_CHAR);
else {
			let next = s.charCodeAt(i + 1);
			if (56320 <= next && next <= 57343) {
				result.push(char);
				result.push(s.charAt(i + 1));
				i++;
			} else result.push(REPLACEMENT_CHAR);
		}
else if (56320 <= code && code <= 57343) result.push(REPLACEMENT_CHAR);
else result.push(char);
	}
	return result.join("");
}
const encoder = typeof TextEncoder == "function" ? new TextEncoder() : { encode: _stringToUtf8Uint8ArrayLegacy };
const decoder = typeof TextDecoder == "function" ? new TextDecoder() : { decode: _utf8Uint8ArrayToStringLegacy };
function stringToUtf8Uint8Array(string) {
	return encoder.encode(string);
}
function _utf8Uint8ArrayToStringLegacy(uint8Array) {
	let stringArray = [];
	stringArray.length = uint8Array.length;
	for (let i = 0; i < uint8Array.length; i++) stringArray[i] = String.fromCharCode(uint8Array[i]);
	return decodeURIComponent(escape(stringArray.join("")));
}
function utf8Uint8ArrayToString(uint8Array) {
	return decoder.decode(uint8Array);
}
function hexToUint8Array(hex) {
	let bufView = new Uint8Array(hex.length / 2);
	for (let i = 0; i < bufView.byteLength; i++) bufView[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
	return bufView;
}
const hexDigits = "0123456789abcdef";
function uint8ArrayToHex(uint8Array) {
	let hex = "";
	for (let i = 0; i < uint8Array.byteLength; i++) {
		let value = uint8Array[i];
		hex += hexDigits[value >> 4] + hexDigits[value & 15];
	}
	return hex;
}
function uint8ArrayToBase64(bytes) {
	if (bytes.length < 512) return btoa(String.fromCharCode(...bytes));
	let binary = "";
	const len = bytes.byteLength;
	for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
	return btoa(binary);
}
function int8ArrayToBase64(bytes) {
	let converted = new Uint8Array(bytes);
	return uint8ArrayToBase64(converted);
}
function base64ToUint8Array(base64) {
	if (base64.length % 4 !== 0) throw new Error(`invalid base64 length: ${base64} (${base64.length})`);
	const binaryString = atob(base64);
	const result = new Uint8Array(binaryString.length);
	for (let i = 0; i < binaryString.length; i++) result[i] = binaryString.charCodeAt(i);
	return result;
}
function uint8ArrayToString(charset, bytes) {
	const decoder$1 = new TextDecoder(charset);
	return decoder$1.decode(bytes);
}
function decodeQuotedPrintable(charset, input) {
	return input.replace(/[\t\x20]$/gm, "").replace(/=(?:\r\n?|\n|$)/g, "").replace(/(=([a-fA-F0-9]{2}))+/g, (match) => {
		const hexValues = match.split(/=/);
		hexValues.shift();
		const intArray = hexValues.map((char) => parseInt(char, 16));
		const bytes = Uint8Array.from(intArray);
		return uint8ArrayToString(charset, bytes);
	});
}
function decodeBase64(charset, input) {
	return uint8ArrayToString(charset, base64ToUint8Array(input));
}
function stringToBase64(str) {
	return uint8ArrayToBase64(stringToUtf8Uint8Array(str));
}
function byteArraysToBytes(byteArrays) {
	const totalBytesLength = byteArrays.reduce((acc, element) => acc + element.length, 0);
	const encodingOverhead = byteArrays.length * 2;
	const encodedByteArrays = new Uint8Array(encodingOverhead + totalBytesLength);
	let index = 0;
	for (const byteArray of byteArrays) {
		if (byteArray.length > MAX_ENCODED_BYTES_LENGTH) throw new Error("byte array is to long for encoding");
		index = writeByteArray(encodedByteArrays, byteArray, index);
	}
	return encodedByteArrays;
}
function bytesToByteArrays(encodedByteArrays, expectedByteArrays) {
	const byteArrays = new Array();
	let index = 0;
	while (index < encodedByteArrays.length) {
		const readResult = readByteArray(encodedByteArrays, index);
		byteArrays.push(readResult.byteArray);
		index = readResult.index;
	}
	if (byteArrays.length != expectedByteArrays) throw new Error("invalid amount of key parameters. Expected: " + expectedByteArrays + " actual:" + byteArrays.length);
	return byteArrays;
}
const BYTE_ARRAY_LENGTH_FIELD_SIZE = 2;
const MAX_ENCODED_BYTES_LENGTH = 65535;
function writeByteArray(result, byteArray, index) {
	writeShort(result, byteArray.length, index);
	index += BYTE_ARRAY_LENGTH_FIELD_SIZE;
	result.set(byteArray, index);
	index += byteArray.length;
	return index;
}
function readByteArray(encoded, index) {
	const length = readShort(encoded, index);
	index += BYTE_ARRAY_LENGTH_FIELD_SIZE;
	const byteArray = encoded.slice(index, length + index);
	index += length;
	if (byteArray.length != length) throw new Error("cannot read encoded byte array at pos:" + index + " expected bytes:" + length + " read bytes:" + byteArray.length);
	return {
		index,
		byteArray
	};
}
function writeShort(array, value, index) {
	array[index] = (value & 65280) >> 8;
	array[index + 1] = (value & 255) >> 0;
}
function readShort(array, index) {
	const bytes = array.subarray(index, index + BYTE_ARRAY_LENGTH_FIELD_SIZE);
	let n = 0;
	for (const byte of bytes.values()) n = n << 8 | byte;
	return n;
}

//#endregion
//#region ../packages/tutanota-utils/dist/LazyLoaded.js
var LazyLoaded = class {
	loadFunction;
	defaultValue;
	state = { state: "not_loaded" };
	/**
	* @param loadFunction The function that actually loads the object as soon as getAsync() is called the first time.
	* @param defaultValue The value that shall be returned by getSync() or getLoaded() as long as the object is not loaded yet.
	*/
	constructor(loadFunction, defaultValue = null) {
		this.loadFunction = loadFunction;
		this.defaultValue = defaultValue;
	}
	load() {
		this.getAsync();
		return this;
	}
	isLoaded() {
		return this.state.state === "loaded";
	}
	isLoadedOrLoading() {
		return this.state.state === "loaded" || this.state.state === "loading";
	}
	/**
	* Loads the object if it is not loaded yet. May be called in parallel and takes care that the load function is only called once.
	*/
	getAsync() {
		switch (this.state.state) {
			case "not_loaded": {
				const loadingPromise = this.loadFunction().then((value) => {
					this.state = {
						state: "loaded",
						value
					};
					return value;
				}, (e) => {
					this.state = { state: "not_loaded" };
					throw e;
				});
				this.state = {
					state: "loading",
					promise: loadingPromise
				};
				return loadingPromise;
			}
			case "loading": return this.state.promise;
			case "loaded": return Promise.resolve(this.state.value);
		}
	}
	/**
	* Returns null if the object is not loaded yet.
	*/
	getSync() {
		return this.state.state === "loaded" ? this.state.value : this.defaultValue;
	}
	/**
	* Only call this function if you know that the object is already loaded.
	*/
	getLoaded() {
		if (this.state.state === "loaded") return this.state.value;
else throw new Error("Not loaded!");
	}
	/**
	* Removes the currently loaded object, so it will be loaded again with the next getAsync() call. Does not set any default value.
	*/
	reset() {
		this.state = { state: "not_loaded" };
		this.defaultValue = null;
	}
	/**
	* Loads the object again and replaces the current one
	*/
	async reload() {
		this.state = { state: "not_loaded" };
		return this.getAsync();
	}
};

//#endregion
//#region ../packages/tutanota-utils/dist/PromiseMap.js
async function pMap(iterable, mapper, options = {}) {
	const { concurrency = 1 } = options;
	return new Promise((resolve, reject) => {
		if (typeof mapper !== "function") throw new TypeError("Mapper function is required");
		if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
		const result = [];
		const errors = [];
		const iterator = iterable[Symbol.iterator]();
		let isRejected = false;
		let isIterableDone = false;
		let resolvingCount = 0;
		let currentIndex = 0;
		const next = () => {
			if (isRejected) return;
			const nextItem = iterator.next();
			const index = currentIndex;
			currentIndex++;
			if (nextItem.done) {
				isIterableDone = true;
				if (resolvingCount === 0) resolve(result);
				return;
			}
			resolvingCount++;
			(async () => {
				try {
					const element = await nextItem.value;
					result[index] = await mapper(element, index);
					resolvingCount--;
					next();
				} catch (error) {
					isRejected = true;
					reject(error);
				}
			})();
		};
		for (let index = 0; index < concurrency; index++) {
			next();
			if (isIterableDone) break;
		}
	});
}

//#endregion
//#region ../packages/tutanota-utils/dist/PromiseUtils.js
function mapInCallContext(values, callback) {
	return new PromisableWrapper(_mapInCallContext(values, callback, 0, []));
}
function _mapInCallContext(values, callback, index, acc) {
	if (index >= values.length) return acc;
	let mappedValue = callback(values[index], index);
	if (mappedValue instanceof Promise) return mappedValue.then((v) => {
		acc.push(v);
		return _mapInCallContext(values, callback, index + 1, acc);
	});
else {
		acc.push(mappedValue);
		return _mapInCallContext(values, callback, index + 1, acc);
	}
}
function mapNoFallback(values, callback, options) {
	return PromisableWrapper.from(pMap(values, callback, options));
}
function promiseMapCompat(useMapInCallContext) {
	return useMapInCallContext ? mapInCallContext : mapNoFallback;
}
function flatWrapper(value) {
	return value instanceof PromisableWrapper ? value.value : value;
}
var PromisableWrapper = class PromisableWrapper {
	static from(value) {
		return new PromisableWrapper(value);
	}
	value;
	constructor(value) {
		this.value = value instanceof Promise ? value.then(flatWrapper) : flatWrapper(value);
	}
	thenOrApply(onFulfill, onReject) {
		if (this.value instanceof Promise) {
			const v = this.value.then(onFulfill, onReject);
			return new PromisableWrapper(v);
		} else try {
			return new PromisableWrapper(onFulfill(this.value));
		} catch (e) {
			if (onReject) return new PromisableWrapper(onReject(e));
			throw e;
		}
	}
	toPromise() {
		return Promise.resolve(this.value);
	}
};
function delay(ms) {
	if (Number.isNaN(ms) || ms < 0) throw new Error(`Invalid delay: ${ms}`);
	return new Promise((resolve) => {
		setTimeout(resolve, ms);
	});
}
function ofClass(cls, catcher) {
	return async (e) => {
		if (e instanceof cls) return catcher(e);
else throw e;
	};
}
async function promiseFilter(iterable, filter) {
	let index = 0;
	const result = [];
	for (let item of iterable) {
		if (await filter(item, index)) result.push(item);
		index++;
	}
	return result;
}
function settledThen(promise, handler) {
	return promise.then(handler, handler);
}

//#endregion
//#region ../packages/tutanota-utils/dist/SortedArray.js
/**
* Compared based on the type's natural ordering
*/
function numberCompare(a, b) {
	return a < b ? -1 : a > b ? 1 : 0;
}
var SortedArray = class SortedArray {
	contents;
	compareFn;
	constructor(contents, compareFn) {
		this.contents = contents;
		this.compareFn = compareFn;
	}
	static fromNumbers(array) {
		return SortedArray.from(array, numberCompare);
	}
	static empty(compareFn) {
		return new SortedArray([], compareFn);
	}
	static from(array, compareFn) {
		const list = new SortedArray([], compareFn);
		list.insertAll(array);
		return list;
	}
	get length() {
		return this.contents.length;
	}
	get array() {
		return this.contents;
	}
	get(index) {
		return this.contents[index];
	}
	insertAll(array) {
		this.contents.push(...array);
		this.contents.sort(this.compareFn);
	}
	insert(item) {
		insertIntoSortedArray(item, this.contents, this.compareFn);
	}
	removeFirst(finder) {
		return findAndRemove(this.contents, finder);
	}
};

//#endregion
//#region ../packages/tutanota-utils/dist/StringUtils.js
function pad(num, size) {
	let s = num + "";
	while (s.length < size) s = "0" + s;
	return s;
}
function startsWith(string, substring) {
	return string.startsWith(substring);
}
function capitalizeFirstLetter(str) {
	return str[0].toUpperCase() + str.toLowerCase().slice(1);
}
function endsWith(string, substring) {
	return string.endsWith(substring);
}
function lazyStringValue(valueOrLazy) {
	return typeof valueOrLazy === "function" ? valueOrLazy() : valueOrLazy;
}
function repeat(value, length) {
	let result = "";
	for (let i = 0; i < length; i++) result += value;
	return result;
}
function cleanMatch(s1, s2) {
	return s1.toLowerCase().trim() === s2.toLowerCase().trim();
}
const NBSP = "\xA0";
function toLowerCase(str) {
	return str.toLowerCase();
}
function localeCompare(a, b) {
	return a.localeCompare(b);
}
function byteLength(str) {
	if (str == null) return 0;
	let s = str.length;
	for (let i = str.length - 1; i >= 0; i--) {
		const code = str.charCodeAt(i);
		if (code > 127 && code <= 2047) s++;
else if (code > 2047 && code <= 65535) s += 2;
		if (code >= 56320 && code <= 57343) i--;
	}
	return s;
}

//#endregion
//#region ../packages/tutanota-utils/dist/WebAssembly.js
function callWebAssemblyFunctionWithArguments(func, exports, ...args) {
	const argsToPass = [];
	const toFree = [];
	const toClear = [];
	const toOverwrite = [];
	try {
		for (const arg of args) if (arg === null) argsToPass.push(0);
else if (typeof arg === "number") argsToPass.push(arg);
else if (typeof arg === "boolean") argsToPass.push(arg ? 1 : 0);
else if (typeof arg === "string") {
			const s = allocateStringCopy(arg, exports, toFree);
			try {
				toClear.push(s);
				argsToPass.push(s.byteOffset);
				toFree.push(s.byteOffset);
			} catch (e) {
				exports.free(s.byteOffset);
				throw e;
			}
		} else if (arg instanceof MutableUint8Array) {
			const inputOutput = arg.uint8ArrayInputOutput;
			let arrayInWASM;
			if (inputOutput instanceof SecureFreeUint8Array) arrayInWASM = allocateSecureArrayCopy(inputOutput.uint8ArrayInput, exports, toFree, toClear);
else arrayInWASM = allocateArrayCopy(inputOutput, exports, toFree);
			toOverwrite.push({
				arrayInWASM,
				originalBufferYouPassedIn: arg
			});
			argsToPass.push(arrayInWASM.byteOffset);
		} else if (arg instanceof SecureFreeUint8Array) {
			const arrayInWASM = allocateSecureArrayCopy(arg.uint8ArrayInput, exports, toFree, toClear);
			argsToPass.push(arrayInWASM.byteOffset);
		} else if (arg instanceof Uint8Array || arg instanceof Int8Array) {
			const arrayInWASM = allocateArrayCopy(arg, exports, toFree);
			argsToPass.push(arrayInWASM.byteOffset);
		} else throw new Error(`passed an unhandled argument type ${typeof arg}`);
		return func(...argsToPass);
	} finally {
		for (const f of toOverwrite) {
			const inputOutput = f.originalBufferYouPassedIn.uint8ArrayInputOutput;
			if (inputOutput instanceof SecureFreeUint8Array) inputOutput.uint8ArrayInput.set(f.arrayInWASM);
else inputOutput.set(f.arrayInWASM);
		}
		for (const f of toClear) f.fill(0);
		for (const f of toFree) exports.free(f);
	}
}
function allocateBuffer(length, exports) {
	const memory = exports.memory;
	const ptr = exports.malloc(length);
	if (ptr === 0) throw new Error("malloc failed to allocate memory for string");
	try {
		return new Uint8Array(memory.buffer, ptr, length);
	} catch (e) {
		exports.free(ptr);
		throw e;
	}
}
var MutableUint8Array = class {
	uint8ArrayInputOutput;
	constructor(uint8ArrayInputOutput) {
		this.uint8ArrayInputOutput = uint8ArrayInputOutput;
	}
};
var SecureFreeUint8Array = class {
	uint8ArrayInput;
	constructor(uint8ArrayInput) {
		this.uint8ArrayInput = uint8ArrayInput;
	}
};
function mutableSecureFree(array) {
	return new MutableUint8Array(new SecureFreeUint8Array(array));
}
function secureFree(array) {
	return new SecureFreeUint8Array(array);
}
function allocateStringCopy(str, exports, toFree) {
	const strBytes = stringToUtf8Uint8Array(str);
	const allocationAmount = strBytes.length + 1;
	let buf = allocateBuffer(allocationAmount, exports);
	try {
		buf.set(strBytes);
		buf[buf.length - 1] = 0;
		toFree.push(buf.byteOffset);
		return buf;
	} catch (e) {
		exports.free(buf.byteOffset);
		throw e;
	}
}
function allocateArrayCopy(arr, exports, toFree) {
	const allocationAmount = arr.length;
	let buf = allocateBuffer(allocationAmount, exports);
	try {
		buf.set(arr);
		toFree.push(buf.byteOffset);
		return buf;
	} catch (e) {
		exports.free(buf.byteOffset);
		throw e;
	}
}
function allocateSecureArrayCopy(arr, exports, toFree, toClear) {
	const arrayInWASM = allocateArrayCopy(arr, exports, toFree);
	try {
		toClear.push(arrayInWASM);
	} catch (e) {
		arrayInWASM.fill(0);
		throw e;
	}
	return arrayInWASM;
}

//#endregion
//#region ../packages/tutanota-utils/dist/MathUtils.js
function mod(n, m) {
	return (n % m + m) % m;
}
function clamp(value, min$1, max$1) {
	return Math.max(min$1, Math.min(value, max$1));
}

//#endregion
//#region ../packages/tutanota-utils/dist/Tokenizer.js
function tokenize(text) {
	if (text == null) return [];
	let currentWord = [];
	let words = [];
	for (let i = 0; i < text.length; i++) {
		let currentChar = text.charAt(i);
		if (isEndOfWord(currentChar)) {
			addCurrentWord(currentWord, words);
			currentWord = [];
		} else currentWord.push(currentChar);
	}
	addCurrentWord(currentWord, words);
	return words;
}
function addCurrentWord(currentWord, words) {
	while (currentWord.length > 0 && currentWord[0] === "'") currentWord.shift();
	while (currentWord.length > 0 && currentWord[currentWord.length - 1] === "'") currentWord.pop();
	if (currentWord.length > 0) words.push(currentWord.join("").toLowerCase());
}
function isEndOfWord(char) {
	switch (char) {
		case " ":
		case "\n":
		case "\r":
		case "	":
		case "\v":
		case "\f":
		case ".":
		case ",":
		case ":":
		case ";":
		case "!":
		case "?":
		case "&":
		case "\"":
		case "<":
		case ">":
		case "-":
		case "+":
		case "=":
		case "(":
		case ")":
		case "[":
		case "]":
		case "{":
		case "}":
		case "/":
		case "\\":
		case "^":
		case "_":
		case "`":
		case "~":
		case "|":
		case "@": return true;
		default: return false;
	}
}

//#endregion
export { BoundedExecutor, DAY_IN_MILLIS, LazyLoaded, NBSP, PromisableWrapper, SortedArray, TIMESTAMP_ZERO_YEAR, TypeRef, YEAR_IN_MILLIS, addAll, addressDomain, arrayEquals, arrayEqualsWithPredicate, arrayHash, arrayOf, assert, assertNonNull, assertNotNull, asyncFind, base64ExtToBase64, base64ToBase64Ext, base64ToBase64Url, base64ToHex, base64ToUint8Array, base64UrlToBase64, binarySearch, byteArraysToBytes, byteLength, bytesToByteArrays, callWebAssemblyFunctionWithArguments, capitalizeFirstLetter, clamp, cleanMatch, clear, clone, collectToMap, compare, concat, contains, count, daysToMillis, debounce, debounceStart, decodeBase64, decodeQuotedPrintable, deduplicate, deepEqual, defer, deferWithHandler, delay, difference, downcast, endsWith, errorToString, filterInt, filterNull, findAll, findAllAndRemove, findAndRemove, findBy, findLast, findLastIndex, first, flatMap, formatSortableDate, formatSortableDateTime, freezeMap, freshVersioned, getAsLazy, getDayShifted, getEndOfDay, getFirstOrThrow, getFromMap, getStartOfDay, getStartOfNextDay, getTypeId, groupBy, groupByAndMap, groupByAndMapUniquely, hexToBase64, hexToUint8Array, identity, incrementDate, incrementMonth, insertIntoSortedArray, insideRect, int8ArrayToBase64, intersection, isEmpty, isNotEmpty, isNotNull, isSameDay, isSameDayOfDate, isSameTypeRef, isSameTypeRefByAttr, isValidDate, last, lastIndex, lastThrow, lazyMemoized, lazyStringValue, localeCompare, makeSingleUse, mapAndFilterNull, mapLazily, mapMap, mapNullable, mapObject, mapWith, mapWithout, memoized, memoizedWithHiddenArgument, mergeMaps, millisToDays, mod, mutableSecureFree, neverNull, noOp, numberRange, ofClass, pMap, pad, partition, partitionAsync, promiseFilter, promiseMapCompat, randomIntFromInterval, remove, repeat, resolveMaybeLazy, secureFree, setAddAll, setEquals, setMap, settledThen, sortableTimestamp, splitInChunks, splitUint8ArrayInChunks, startsWith, stringToBase64, stringToUtf8Uint8Array, symmetricDifference, throttle, toLowerCase, tokenize, trisectingDiff, typedEntries, typedKeys, typedValues, uint8ArrayToArrayBuffer, uint8ArrayToBase64, uint8ArrayToHex, uint8ArrayToString, utf8Uint8ArrayToString };
//# sourceMappingURL=dist-CJHwsXKY.js.map