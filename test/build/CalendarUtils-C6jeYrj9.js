
globalThis.env = {
  "staticUrl": "http://localhost:9000",
  "versionNumber": "264.250130.1",
  "dist": false,
  "mode": "Test",
  "timeout": 20000,
  "domainConfigs": {
    "mail.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.tuta.com",
      "apiUrl": "https://mail.tutanota.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "test.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.test.tuta.com",
      "apiUrl": "https://test.tutanota.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://test.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://tutanota.com"
    },
    "app.local.tutanota.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tuta.com:9000",
      "apiUrl": "https://app.local.tutanota.com:9000",
      "paymentUrl": "https://local.tutanota.com:9000/client/build/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/client/build/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/client/build/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/client/build/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/client/build/webauthnmobile",
      "webauthnRpId": "tutanota.com",
      "u2fAppId": "https://local.tutanota.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tutanota.com:9000"
    },
    "app.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://mail.tutanota.com",
      "apiUrl": "https://app.tuta.com",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://mail.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://mail.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "app.test.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://test.tutanota.com",
      "apiUrl": "https://app.test.tuta.com",
      "paymentUrl": "https://pay.test.tutanota.com/braintree.html",
      "webauthnUrl": "https://app.test.tuta.com/webauthn",
      "legacyWebauthnUrl": "https://test.tutanota.com/webauthn",
      "webauthnMobileUrl": "https://app.test.tuta.com/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://test.tutanota.com/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.test.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.test.tuta.com/giftcard",
      "referralBaseUrl": "https://app.test.tuta.com/signup",
      "websiteBaseUrl": "https://test.tuta.com"
    },
    "app.local.tuta.com": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "https://app.local.tutanota.com:9000",
      "apiUrl": "https://app.local.tuta.com:9000",
      "paymentUrl": "https://app.local.tuta.com:9000/braintree.html",
      "webauthnUrl": "https://app.local.tuta.com:9000/webauthn",
      "legacyWebauthnUrl": "https://local.tutanota.com:9000/webauthn",
      "webauthnMobileUrl": "https://app.local.tuta.com:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "https://local.tutanota.com:9000/webauthnmobile",
      "webauthnRpId": "tuta.com",
      "u2fAppId": "https://app.local.tuta.com/u2f-appid.json",
      "giftCardBaseUrl": "https://app.local.tuta.com:9000/giftcard",
      "referralBaseUrl": "https://app.local.tuta.com:9000/signup",
      "websiteBaseUrl": "https://local.tuta.com:9000"
    },
    "localhost": {
      "firstPartyDomain": true,
      "partneredDomainTransitionUrl": "http://localhost:9000",
      "apiUrl": "http://localhost:9000",
      "paymentUrl": "http://localhost:9000/braintree.html",
      "webauthnUrl": "http://localhost:9000/webauthn",
      "legacyWebauthnUrl": "http://localhost:9000/webauthn",
      "webauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "legacyWebauthnMobileUrl": "http://localhost:9000/webauthnmobile",
      "webauthnRpId": "localhost",
      "u2fAppId": "http://localhost:9000/u2f-appid.json",
      "giftCardBaseUrl": "http://localhost:9000/giftcard",
      "referralBaseUrl": "http://localhost:9000/signup",
      "websiteBaseUrl": "https://tuta.com"
    },
    "{hostname}": {
      "firstPartyDomain": false,
      "partneredDomainTransitionUrl": "{protocol}//{hostname}",
      "apiUrl": "{protocol}//{hostname}",
      "paymentUrl": "https://pay.tutanota.com/braintree.html",
      "webauthnUrl": "{protocol}//{hostname}/webauthn",
      "legacyWebauthnUrl": "{protocol}//{hostname}/webauthn",
      "webauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "legacyWebauthnMobileUrl": "{protocol}//{hostname}/webauthnmobile",
      "webauthnRpId": "{hostname}",
      "u2fAppId": "{protocol}//{hostname}/u2f-appid.json",
      "giftCardBaseUrl": "https://app.tuta.com/giftcard",
      "referralBaseUrl": "https://app.tuta.com/signup",
      "websiteBaseUrl": "https://tuta.com"
    }
  },
  "platformId": null
};
const __NODE_GYP_better_sqlite3 = `./better-sqlite3.darwin-${typeof process !== 'undefined' ? process.arch : "unknown"}.node`
import { TIMESTAMP_ZERO_YEAR, assert, clone, decodeBase64, deepEqual, downcast, filterInt, findAllAndRemove, getFirstOrThrow, getFromMap, getStartOfDay, incrementDate, insertIntoSortedArray, isNotNull, isSameDayOfDate, isValidDate, neverNull } from "./dist-CJHwsXKY.js";
import { CLIENT_ONLY_CALENDARS, CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID, EndType, EventTextTimeOption, RepeatPeriod, WeekStart, getWeekStart } from "./TutanotaConstants-3bwAESYA.js";
import { ParserError } from "./ParserCombinator-D38ofgFx.js";
import { DateTime, FixedOffsetZone, IANAZone } from "./luxon-D6cgmg6Q.js";
import { isSameId } from "./EntityUtils-RQxXZlcV.js";
import { DAYS_SHIFTED_MS, generateEventElementId, isAllDayEvent, isAllDayEventByTimes } from "./CommonCalendarUtils-DKaO7v1K.js";
import { CalendarEventTypeRef, createCalendarRepeatRule } from "./TypeRefs-CR3TLWn0.js";
import { createDateWrapper } from "./TypeRefs-BP1jvX9p.js";

//#region ../src/common/calendar/date/CalendarUtils.ts
function eventStartsBefore(currentDate, zone, event) {
	return getEventStart(event, zone).getTime() < currentDate.getTime();
}
function eventEndsBefore(date, zone, event) {
	return getEventEnd(event, zone).getTime() < date.getTime();
}
function eventStartsAfter(date, zone, event) {
	return getEventStart(event, zone).getTime() > date.getTime();
}
function eventEndsAfterDay(currentDate, zone, event) {
	return getEventEnd(event, zone).getTime() > getStartOfNextDayWithZone(currentDate, zone).getTime();
}
function eventEndsAfterOrOn(currentDate, zone, event) {
	return getEventEnd(event, zone).getTime() >= getStartOfNextDayWithZone(currentDate, zone).getTime();
}
function generateUid(groupId, timestamp) {
	return `${groupId}${timestamp}@tuta.com`;
}
function isBirthdayEvent(uid) {
	return uid?.includes(CLIENT_ONLY_CALENDAR_BIRTHDAYS_BASE_ID) ?? false;
}
function getMonthRange(date, zone) {
	const startDateTime = DateTime.fromJSDate(date, { zone }).set({
		day: 1,
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	});
	const start = startDateTime.toJSDate().getTime();
	const end = startDateTime.plus({ month: 1 }).toJSDate().getTime();
	return {
		start,
		end
	};
}
function getDayRange(date, zone) {
	const startDateTime = DateTime.fromJSDate(date, { zone }).set({
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	});
	const start = startDateTime.toJSDate().getTime();
	const end = startDateTime.plus({ day: 1 }).toJSDate().getTime();
	return {
		start,
		end
	};
}
function getStartOfDayWithZone(date, zone) {
	return DateTime.fromJSDate(date, { zone }).set({
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	}).toJSDate();
}
function getStartOfNextDayWithZone(date, zone) {
	return DateTime.fromJSDate(date, { zone }).set({
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	}).plus({ day: 1 }).toJSDate();
}
function getEndOfDayWithZone(date, zone) {
	return DateTime.fromJSDate(date, { zone }).set({
		hour: 23,
		minute: 59,
		second: 59,
		millisecond: 0
	}).toJSDate();
}
function calculateAlarmTime(date, interval, ianaTimeZone) {
	const diff = alarmIntervalToLuxonDurationLikeObject(interval);
	return DateTime.fromJSDate(date, { zone: ianaTimeZone }).minus(diff).toJSDate();
}
function getAllDayDateForTimezone(utcDate, zone) {
	return DateTime.fromJSDate(utcDate, { zone: "utc" }).setZone(zone, { keepLocalTime: true }).set({
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	}).toJSDate();
}
function incrementByRepeatPeriod(date, repeatPeriod, interval, ianaTimeZone) {
	switch (repeatPeriod) {
		case RepeatPeriod.DAILY: return DateTime.fromJSDate(date, { zone: ianaTimeZone }).plus({ days: interval }).toJSDate();
		case RepeatPeriod.WEEKLY: return DateTime.fromJSDate(date, { zone: ianaTimeZone }).plus({ weeks: interval }).toJSDate();
		case RepeatPeriod.MONTHLY: return DateTime.fromJSDate(date, { zone: ianaTimeZone }).plus({ months: interval }).toJSDate();
		case RepeatPeriod.ANNUALLY: return DateTime.fromJSDate(date, { zone: ianaTimeZone }).plus({ years: interval }).toJSDate();
		default: throw new Error("Unknown repeat period");
	}
}
function getValidTimeZone(zone, fallback) {
	if (IANAZone.isValidZone(zone)) return zone;
else if (fallback && IANAZone.isValidZone(fallback)) {
		console.warn(`Time zone ${zone} is not valid, falling back to ${fallback}`);
		return fallback;
	} else {
		const actualFallback = FixedOffsetZone.instance(new Date().getTimezoneOffset()).name;
		console.warn(`Fallback time zone ${zone} is not valid, falling back to ${actualFallback}`);
		return actualFallback;
	}
}
function getTimeZone() {
	return DateTime.local().zoneName;
}
var DefaultDateProvider = class {
	now() {
		return Date.now();
	}
	timeZone() {
		return getTimeZone();
	}
};
function createRepeatRuleWithValues(frequency, interval, timeZone = getTimeZone()) {
	return createCalendarRepeatRule({
		timeZone,
		frequency,
		interval: String(interval),
		endValue: null,
		endType: "0",
		excludedDates: [],
		advancedRules: []
	});
}
function getDiffIn24hIntervals(a, b, zone) {
	return Math.floor(DateTime.fromJSDate(b, { zone }).diff(DateTime.fromJSDate(a, { zone }), "day").days);
}
function getDiffIn60mIntervals(a, b) {
	return Math.floor(DateTime.fromJSDate(b).diff(DateTime.fromJSDate(a), "hours").hours);
}
function getStartOfWeek(date, firstDayOfWeekFromOffset) {
	let firstDay;
	if (firstDayOfWeekFromOffset > date.getDay()) firstDay = date.getDay() + 7 - firstDayOfWeekFromOffset;
else firstDay = date.getDay() - firstDayOfWeekFromOffset;
	return incrementDate(getStartOfDay(date), -firstDay);
}
function getRangeOfDays(startDay, numDays) {
	let calculationDate = startDay;
	const days = [];
	for (let i = 0; i < numDays; i++) {
		days.push(calculationDate);
		calculationDate = incrementDate(new Date(calculationDate), 1);
	}
	return days;
}
function getStartOfTheWeekOffset(weekStart) {
	switch (weekStart) {
		case WeekStart.SUNDAY: return 0;
		case WeekStart.SATURDAY: return 6;
		case WeekStart.MONDAY:
		default: return 1;
	}
}
function getStartOfTheWeekOffsetForUser(userSettingsGroupRoot) {
	return getStartOfTheWeekOffset(getWeekStart(userSettingsGroupRoot));
}
function getTimeFormatForUser(userSettingsGroupRoot) {
	return userSettingsGroupRoot.timeFormat;
}
function getWeekNumber(startOfTheWeek) {
	return DateTime.fromJSDate(startOfTheWeek).weekNumber;
}
function getEventEnd(event, timeZone) {
	if (isAllDayEvent(event)) return getAllDayDateForTimezone(event.endTime, timeZone);
else return event.endTime;
}
function getEventStart({ startTime, endTime }, timeZone) {
	return getEventStartByTimes(startTime, endTime, timeZone);
}
function getEventStartByTimes(startTime, endTime, timeZone) {
	if (isAllDayEventByTimes(startTime, endTime)) return getAllDayDateForTimezone(startTime, timeZone);
else return startTime;
}
function getAllDayDateUTCFromZone(date, zone) {
	return DateTime.fromJSDate(date, { zone }).setZone("utc", { keepLocalTime: true }).set({
		hour: 0,
		minute: 0,
		second: 0,
		millisecond: 0
	}).toJSDate();
}
function isLongEvent(event, zone) {
	return event.repeatRule != null || getEventEnd(event, zone).getTime() - getEventStart(event, zone).getTime() > DAYS_SHIFTED_MS;
}
function assignEventId(event, zone, groupRoot) {
	const listId = isLongEvent(event, zone) ? groupRoot.longEvents : groupRoot.shortEvents;
	event._id = [listId, generateEventElementId(event.startTime.getTime())];
}
function isSameEventInstance(left, right) {
	return isSameId(left._id, right._id) && left.startTime.getTime() === right.startTime.getTime();
}
function hasAlarmsForTheUser(user, event) {
	const useAlarmList = neverNull(user.alarmInfoList).alarms;
	return event.alarmInfos.some(([listId]) => isSameId(listId, useAlarmList));
}
function eventComparator(l, r) {
	return l.startTime.getTime() - r.startTime.getTime();
}
function assertDateIsValid(date) {
	if (!isValidDate(date)) throw new Error("Date is invalid!");
}
let CalendarEventValidity = function(CalendarEventValidity$1) {
	CalendarEventValidity$1[CalendarEventValidity$1["InvalidContainsInvalidDate"] = 0] = "InvalidContainsInvalidDate";
	CalendarEventValidity$1[CalendarEventValidity$1["InvalidEndBeforeStart"] = 1] = "InvalidEndBeforeStart";
	CalendarEventValidity$1[CalendarEventValidity$1["InvalidPre1970"] = 2] = "InvalidPre1970";
	CalendarEventValidity$1[CalendarEventValidity$1["Valid"] = 3] = "Valid";
	return CalendarEventValidity$1;
}({});
function checkEventValidity(event) {
	if (!isValidDate(event.startTime) || !isValidDate(event.endTime)) return CalendarEventValidity.InvalidContainsInvalidDate;
else if (event.endTime.getTime() <= event.startTime.getTime()) return CalendarEventValidity.InvalidEndBeforeStart;
else if (event.startTime.getTime() < TIMESTAMP_ZERO_YEAR) return CalendarEventValidity.InvalidPre1970;
	return CalendarEventValidity.Valid;
}
const MAX_EVENT_ITERATIONS = 1e4;
function addDaysForEventInstance(daysToEvents, event, range, zone) {
	const { start: rangeStart, end: rangeEnd } = range;
	const clippedRange = clipRanges(getEventStart(event, zone).getTime(), getEventEnd(event, zone).getTime(), rangeStart, rangeEnd);
	if (clippedRange == null) return;
	const { start: eventStartInRange, end: eventEndInRange } = clippedRange;
	let calculationDate = getStartOfDayWithZone(new Date(eventStartInRange), zone);
	let calculationTime = calculationDate.getTime();
	let iterations = 0;
	while (calculationTime < rangeEnd) {
		assertDateIsValid(calculationDate);
		assert(iterations <= MAX_EVENT_ITERATIONS, "Run into the infinite loop, addDaysForEvent");
		if (calculationTime < eventEndInRange) {
			const eventsForCalculationDate = getFromMap(daysToEvents, calculationTime, () => []);
			insertIntoSortedArray(event, eventsForCalculationDate, eventComparator, isSameEventInstance);
		} else {
			const removed = findAllAndRemove(getFromMap(daysToEvents, calculationTime, () => []), (e) => isSameEventInstance(e, event));
			if (!removed) break;
		}
		calculationDate = incrementByRepeatPeriod(calculationDate, RepeatPeriod.DAILY, 1, zone);
		calculationTime = calculationDate.getTime();
		iterations++;
	}
}
function addDaysForRecurringEvent(daysToEvents, event, range, timeZone = getTimeZone()) {
	const repeatRule = event.repeatRule;
	if (repeatRule == null) throw new Error("Invalid argument: event doesn't have a repeatRule" + JSON.stringify(event));
	const allDay = isAllDayEvent(event);
	const exclusions = allDay ? repeatRule.excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) })) : repeatRule.excludedDates;
	for (const { startTime, endTime } of generateEventOccurrences(event, timeZone)) {
		if (startTime.getTime() > range.end) break;
		if (endTime.getTime() < range.start) continue;
		if (isExcludedDate(startTime, exclusions)) {
			const eventsOnExcludedDay = daysToEvents.get(getStartOfDayWithZone(startTime, timeZone).getTime());
			if (!eventsOnExcludedDay) continue;
		} else {
			const eventClone = clone(event);
			if (allDay) {
				eventClone.startTime = getAllDayDateUTCFromZone(startTime, timeZone);
				eventClone.endTime = getAllDayDateUTCFromZone(endTime, timeZone);
			} else {
				eventClone.startTime = new Date(startTime);
				eventClone.endTime = new Date(endTime);
			}
			addDaysForEventInstance(daysToEvents, eventClone, range, timeZone);
		}
	}
}
function generateCalendarInstancesInRange(progenitors, range, max = Infinity, timeZone = getTimeZone()) {
	const ret = [];
	const getNextCandidate = (previousCandidate, generator, excludedDates) => {
		const allDay = isAllDayEvent(previousCandidate);
		const exclusions = allDay ? excludedDates.map(({ date }) => createDateWrapper({ date: getAllDayDateForTimezone(date, timeZone) })) : excludedDates;
		let current;
		while (ret.length < max) {
			current = generator.next();
			if (current.done) break;
			let { startTime, endTime } = current.value;
			if (startTime.getTime() > range.end) break;
			if (endTime.getTime() <= range.start) continue;
			if (!isExcludedDate(startTime, exclusions)) {
				const nextCandidate = clone(previousCandidate);
				if (allDay) {
					nextCandidate.startTime = getAllDayDateUTCFromZone(startTime, timeZone);
					nextCandidate.endTime = getAllDayDateUTCFromZone(endTime, timeZone);
				} else {
					nextCandidate.startTime = new Date(startTime);
					nextCandidate.endTime = new Date(endTime);
				}
				return nextCandidate;
			}
		}
		return null;
	};
	const generators = progenitors.map((p) => {
		const generator = generateEventOccurrences(p, timeZone);
		const excludedDates = p.repeatRule?.excludedDates ?? [];
		const nextCandidate = getNextCandidate(p, generator, excludedDates);
		if (nextCandidate == null) return null;
		return {
			excludedDates,
			generator,
			nextCandidate
		};
	}).filter(isNotNull);
	while (generators.length > 0) {
		generators.sort((a, b) => (a.nextCandidate?.startTime.getTime() ?? 0) - (b.nextCandidate?.startTime.getTime() ?? 0));
		const first = getFirstOrThrow(generators);
		const newNext = getNextCandidate(first.nextCandidate, first.generator, first.excludedDates);
		ret.push(first.nextCandidate);
		if (newNext == null) {
			generators.splice(0, 1);
			continue;
		}
		first.nextCandidate = newNext;
	}
	return ret;
}
function getRepeatEndTimeForDisplay(repeatRule, isAllDay, timeZone) {
	if (repeatRule.endType !== EndType.UntilDate) throw new Error("Event has no repeat rule end type is not UntilDate: " + JSON.stringify(repeatRule));
	const rawEndDate = new Date(filterInt(repeatRule.endValue ?? "0"));
	const localDate = isAllDay ? getAllDayDateForTimezone(rawEndDate, timeZone) : rawEndDate;
	return incrementByRepeatPeriod(localDate, RepeatPeriod.DAILY, -1, timeZone);
}
/**
* generates all event occurrences in chronological order, including the progenitor.
* terminates once the end condition of the repeat rule is hit.
* @param event the event to iterate occurrences on.
* @param timeZone
*/
function* generateEventOccurrences(event, timeZone) {
	const { repeatRule } = event;
	if (repeatRule == null) {
		yield event;
		return;
	}
	const frequency = downcast(repeatRule.frequency);
	const interval = Number(repeatRule.interval);
	let eventStartTime = getEventStart(event, timeZone);
	let eventEndTime = getEventEnd(event, timeZone);
	let repeatEndTime = null;
	let endOccurrences = null;
	const allDay = isAllDayEvent(event);
	const repeatTimeZone = allDay ? timeZone : getValidTimeZone(repeatRule.timeZone);
	if (repeatRule.endType === EndType.Count) endOccurrences = Number(repeatRule.endValue);
else if (repeatRule.endType === EndType.UntilDate) if (allDay) repeatEndTime = getAllDayDateForTimezone(new Date(Number(repeatRule.endValue)), timeZone);
else repeatEndTime = new Date(Number(repeatRule.endValue));
	let calcStartTime = eventStartTime;
	const calcDuration = allDay ? getDiffIn24hIntervals(eventStartTime, eventEndTime, timeZone) : eventEndTime.getTime() - eventStartTime.getTime();
	let calcEndTime = eventEndTime;
	let iteration = 1;
	while ((endOccurrences == null || iteration <= endOccurrences) && (repeatEndTime == null || calcStartTime.getTime() < repeatEndTime.getTime())) {
		assertDateIsValid(calcStartTime);
		assertDateIsValid(calcEndTime);
		yield {
			startTime: calcStartTime,
			endTime: calcEndTime
		};
		calcStartTime = incrementByRepeatPeriod(eventStartTime, frequency, interval * iteration, repeatTimeZone);
		calcEndTime = allDay ? incrementByRepeatPeriod(calcStartTime, RepeatPeriod.DAILY, calcDuration, repeatTimeZone) : DateTime.fromJSDate(calcStartTime).plus(calcDuration).toJSDate();
		iteration++;
	}
}
function calendarEventHasMoreThanOneOccurrencesLeft({ progenitor, alteredInstances }) {
	if (progenitor == null) return alteredInstances.length > 1;
	const { repeatRule } = progenitor;
	if (repeatRule == null) return false;
	const { endType, endValue, excludedDates } = repeatRule;
	if (endType === EndType.Never) return true;
else if (endType === EndType.Count && Number(endValue ?? "0") + alteredInstances.length > excludedDates.length + 1) return true;
else if (alteredInstances.length > 1) return true;
else {
		const excludedTimestamps = excludedDates.map(({ date }) => date.getTime());
		let i = 0;
		let occurrencesFound = alteredInstances.length;
		for (const { startTime } of generateEventOccurrences(progenitor, getTimeZone())) {
			const startTimestamp = startTime.getTime();
			while (i < excludedTimestamps.length && startTimestamp > excludedTimestamps[i]) i++;
			if (startTimestamp !== excludedTimestamps[i]) {
				occurrencesFound += 1;
				if (occurrencesFound > 1) return true;
			}
		}
		return false;
	}
}
/**
* find out if a given date is in a list of excluded dates
* @param currentDate the date to check
* @param excludedDates a sorted list of excluded dates, earliest to latest
*/
function isExcludedDate(currentDate, excludedDates = []) {
	return excludedDates.some((dw) => dw.date.getTime() === currentDate.getTime());
}
function findNextAlarmOccurrence(now, timeZone, eventStart, eventEnd, frequency, interval, endType, endValue, exclusions, alarmTrigger, localTimeZone) {
	let occurrenceNumber = 0;
	const isAllDayEvent$1 = isAllDayEventByTimes(eventStart, eventEnd);
	const calcEventStart = isAllDayEvent$1 ? getAllDayDateForTimezone(eventStart, localTimeZone) : eventStart;
	assertDateIsValid(calcEventStart);
	const endDate = endType === EndType.UntilDate ? isAllDayEvent$1 ? getAllDayDateForTimezone(new Date(endValue), localTimeZone) : new Date(endValue) : null;
	while (endType !== EndType.Count || occurrenceNumber < endValue) {
		const occurrenceDate = incrementByRepeatPeriod(calcEventStart, frequency, interval * occurrenceNumber, isAllDayEvent$1 ? localTimeZone : timeZone);
		if (endDate && occurrenceDate.getTime() >= endDate.getTime()) return null;
		if (!exclusions.some((d) => d.getTime() === occurrenceDate.getTime())) {
			const alarmTime = calculateAlarmTime(occurrenceDate, alarmTrigger, localTimeZone);
			if (alarmTime >= now) return {
				alarmTime,
				occurrenceNumber,
				eventTime: occurrenceDate
			};
		}
		occurrenceNumber++;
	}
	return null;
}
function incrementSequence(sequence) {
	const current = filterInt(sequence) || 0;
	return String(current + 1);
}
function findFirstPrivateCalendar(calendarInfo) {
	for (const calendar of calendarInfo.values()) if (calendar.userIsOwner && !calendar.isExternal) return calendar;
	return null;
}
function prepareCalendarDescription(description, sanitizer) {
	const prepared = description.replace(/<(http|https):\/\/[A-z0-9$-_.+!*â€˜(),/?]+>/gi, (possiblyLink) => {
		try {
			const withoutBrackets = possiblyLink.slice(1, -1);
			const url = new URL(withoutBrackets);
			return `<a href="${url.toString()}">${withoutBrackets}</a>`;
		} catch (e) {
			return possiblyLink;
		}
	});
	return sanitizer(prepared);
}
const DEFAULT_HOUR_OF_DAY = 6;
function getDateIndicator(day, selectedDate) {
	if (isSameDayOfDate(day, selectedDate)) return ".accent-bg.circle";
else return "";
}
function getTimeTextFormatForLongEvent(ev, startDay, endDay, zone) {
	const startsBefore = eventStartsBefore(startDay, zone, ev);
	const endsAfter = eventEndsAfterOrOn(endDay, zone, ev);
	if (startsBefore && endsAfter || isAllDayEvent(ev)) return null;
else if (startsBefore && !endsAfter) return EventTextTimeOption.END_TIME;
else if (!startsBefore && endsAfter) return EventTextTimeOption.START_TIME;
else return EventTextTimeOption.START_END_TIME;
}
function combineDateWithTime(date, time) {
	const newDate = new Date(date);
	newDate.setHours(time.hour);
	newDate.setMinutes(time.minute);
	return newDate;
}
function isEventBetweenDays(event, firstDay, lastDay, zone) {
	const endOfDay = DateTime.fromJSDate(lastDay, { zone }).endOf("day").toJSDate();
	return !(eventEndsBefore(firstDay, zone, event) || eventStartsAfter(endOfDay, zone, event));
}
function getFirstDayOfMonth(d) {
	const date = new Date(d);
	date.setDate(1);
	return date;
}
async function resolveCalendarEventProgenitor(calendarEvent, entityClient) {
	return calendarEvent.repeatRule ? await entityClient.load(CalendarEventTypeRef, calendarEvent._id) : calendarEvent;
}
function clipRanges(start, end, min, max) {
	const res = {
		start: Math.max(start, min),
		end: Math.min(end, max)
	};
	return res.start < res.end ? res : null;
}
let AlarmIntervalUnit = function(AlarmIntervalUnit$1) {
	AlarmIntervalUnit$1["MINUTE"] = "M";
	AlarmIntervalUnit$1["HOUR"] = "H";
	AlarmIntervalUnit$1["DAY"] = "D";
	AlarmIntervalUnit$1["WEEK"] = "W";
	return AlarmIntervalUnit$1;
}({});
const StandardAlarmInterval = Object.freeze({
	ZERO_MINUTES: {
		value: 0,
		unit: AlarmIntervalUnit.MINUTE
	},
	FIVE_MINUTES: {
		value: 5,
		unit: AlarmIntervalUnit.MINUTE
	},
	TEN_MINUTES: {
		value: 10,
		unit: AlarmIntervalUnit.MINUTE
	},
	THIRTY_MINUTES: {
		value: 30,
		unit: AlarmIntervalUnit.MINUTE
	},
	ONE_HOUR: {
		value: 1,
		unit: AlarmIntervalUnit.HOUR
	},
	ONE_DAY: {
		value: 1,
		unit: AlarmIntervalUnit.DAY
	},
	TWO_DAYS: {
		value: 2,
		unit: AlarmIntervalUnit.DAY
	},
	THREE_DAYS: {
		value: 3,
		unit: AlarmIntervalUnit.DAY
	},
	ONE_WEEK: {
		value: 1,
		unit: AlarmIntervalUnit.WEEK
	}
});
function alarmIntervalToLuxonDurationLikeObject(alarmInterval) {
	switch (alarmInterval.unit) {
		case AlarmIntervalUnit.MINUTE: return { minutes: alarmInterval.value };
		case AlarmIntervalUnit.HOUR: return { hours: alarmInterval.value };
		case AlarmIntervalUnit.DAY: return { days: alarmInterval.value };
		case AlarmIntervalUnit.WEEK: return { weeks: alarmInterval.value };
	}
}
function areExcludedDatesEqual(e1, e2) {
	if (e1.length !== e2.length) return false;
	return e1.every(({ date }, i) => e2[i].date.getTime() === date.getTime());
}
function areRepeatRulesEqual(r1, r2) {
	return r1 === r2 || r1?.endType === r2?.endType && r1?.endValue === r2?.endValue && r1?.frequency === r2?.frequency && r1?.interval === r2?.interval && areExcludedDatesEqual(r1?.excludedDates ?? [], r2?.excludedDates ?? []) && deepEqual(r1?.advancedRules, r2?.advancedRules);
}
function parseAlarmInterval(serialized) {
	const matched = serialized.match(/^(\d+)([MHDW])$/);
	if (matched) {
		const [_, digits, unit] = matched;
		const value = filterInt(digits);
		if (isNaN(value)) throw new ParserError(`Invalid value: ${value}`);
else return {
			value,
			unit
		};
	} else throw new ParserError(`Invalid alarm interval: ${serialized}`);
}
let CalendarType = function(CalendarType$1) {
	CalendarType$1[CalendarType$1["NORMAL"] = 0] = "NORMAL";
	CalendarType$1[CalendarType$1["URL"] = 1] = "URL";
	CalendarType$1[CalendarType$1["CLIENT_ONLY"] = 2] = "CLIENT_ONLY";
	return CalendarType$1;
}({});
function isClientOnlyCalendar(calendarId) {
	const clientOnlyId = calendarId.match(/#(.*)/)?.[1];
	return CLIENT_ONLY_CALENDARS.has(clientOnlyId);
}
function isClientOnlyCalendarType(calendarType) {
	return calendarType === CalendarType.CLIENT_ONLY;
}
function isNormalCalendarType(calendarType) {
	return calendarType === CalendarType.NORMAL;
}
function isExternalCalendarType(calendarType) {
	return calendarType === CalendarType.URL;
}
function hasSourceUrl(groupSettings) {
	return isNotNull(groupSettings?.sourceUrl) && groupSettings?.sourceUrl !== "";
}
function getCalendarType(groupSettings, groupInfo) {
	if (hasSourceUrl(groupSettings)) return CalendarType.URL;
	if (isClientOnlyCalendar(groupSettings ? groupSettings._id : groupInfo.group)) return CalendarType.CLIENT_ONLY;
	return CalendarType.NORMAL;
}
function extractYearFromBirthday(birthday) {
	if (!birthday) return null;
	const dateParts = birthday.split("-");
	const partsLength = dateParts.length;
	if (partsLength !== 3) return null;
	return Number.parseInt(dateParts[0]);
}
async function retrieveClientOnlyEventsForUser(logins, events, localEvents) {
	if (!await logins.getUserController().isNewPaidPlan()) return [];
	const clientOnlyEvents = events.filter(([calendarId, _]) => isClientOnlyCalendar(calendarId)).flatMap((event) => event.join("/"));
	const retrievedEvents = [];
	for (const event of Array.from(localEvents.values()).flat()) if (clientOnlyEvents.includes(event.event._id.join("/"))) retrievedEvents.push(event.event);
	return retrievedEvents;
}
function calculateContactsAge(birthYear, currentYear) {
	if (!birthYear) return null;
	return currentYear - birthYear;
}
function extractContactIdFromEvent(id) {
	if (id == null) return null;
	return decodeBase64("utf-8", id);
}

//#endregion
export { AlarmIntervalUnit, CalendarEventValidity, CalendarType, DEFAULT_HOUR_OF_DAY, DefaultDateProvider, StandardAlarmInterval, addDaysForEventInstance, addDaysForRecurringEvent, alarmIntervalToLuxonDurationLikeObject, areExcludedDatesEqual, areRepeatRulesEqual, assignEventId, calculateAlarmTime, calculateContactsAge, calendarEventHasMoreThanOneOccurrencesLeft, checkEventValidity, clipRanges, combineDateWithTime, createRepeatRuleWithValues, eventComparator, eventEndsAfterDay, eventEndsAfterOrOn, eventEndsBefore, eventStartsAfter, eventStartsBefore, extractContactIdFromEvent, extractYearFromBirthday, findFirstPrivateCalendar, findNextAlarmOccurrence, generateCalendarInstancesInRange, generateUid, getAllDayDateForTimezone, getAllDayDateUTCFromZone, getCalendarType, getDateIndicator, getDayRange, getDiffIn24hIntervals, getDiffIn60mIntervals, getEndOfDayWithZone, getEventEnd, getEventStart, getEventStartByTimes, getFirstDayOfMonth, getMonthRange, getRangeOfDays, getRepeatEndTimeForDisplay, getStartOfDayWithZone, getStartOfNextDayWithZone, getStartOfTheWeekOffset, getStartOfTheWeekOffsetForUser, getStartOfWeek, getTimeFormatForUser, getTimeTextFormatForLongEvent, getTimeZone, getValidTimeZone, getWeekNumber, hasAlarmsForTheUser, hasSourceUrl, incrementByRepeatPeriod, incrementSequence, isBirthdayEvent, isClientOnlyCalendar, isClientOnlyCalendarType, isEventBetweenDays, isExternalCalendarType, isLongEvent, isNormalCalendarType, isSameEventInstance, parseAlarmInterval, prepareCalendarDescription, resolveCalendarEventProgenitor, retrieveClientOnlyEventsForUser };
//# sourceMappingURL=CalendarUtils-C6jeYrj9.js.map