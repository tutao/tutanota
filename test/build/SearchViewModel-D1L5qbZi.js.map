{"version":3,"file":"SearchViewModel-D1L5qbZi.js","names":["backgroundColor: string | null","color: string","Label","iconMap: Record<MailSetKind, string>","entry: SearchableTypes","router: SearchRouter","search: SearchModel","searchFacade: SearchFacade","mailboxModel: MailboxModel","logins: LoginController","indexerFacade: Indexer","entityClient: EntityClient","eventController: EventController","mailOpenedListener: MailOpenedListener | null","calendarFacade: CalendarFacade","progressTracker: ProgressTracker","conversationViewModelFactory: ConversationViewModelFactory | null","eventsRepository: CalendarEventsRepository","updateUi: () => unknown","selectionBehavior: ListAutoSelectBehavior","localCalendars: Map<Id, ClientOnlyCalendarsInfo>","extendIndexConfirmationCallback: SearchViewModel[\"extendIndexConfirmationCallback\"]","update: EntityUpdateData","updates: readonly EntityUpdateData[]","listId: string","restriction: SearchRestriction","args: Record<string, any>","requestedPath: string","listIds: string[]","id: string | null","finder?: (a: ListElement) => boolean","id: string","finder: ((a: ListElement) => boolean) | undefined","field: string | null","startDate: Date | null","endDate: Date","calendarInfo: CalendarInfo | string | null","folder: Array<string>","include: boolean","category: SearchCategoryTypes","latestRestriction: SearchRestriction | null","filter: MailFilterType | null","liftedFilter: ListFilter<SearchResultListEntry> | null","element: CalendarEvent | null","element: Mail | null","element: Contact | null","element: SearchableTypes | null","mailboxes: MailboxDetail[]","newIdTuple: IdTuple","newState: ListState<SearchResultListEntry>","mail: Mail","lastFetchedEntity: SearchResultListEntry","count: number","_listId: Id","elementId: Id","o1: SearchResultListEntry","o2: SearchResultListEntry","typeRef: TypeRef<unknown>","id: IdTuple","id1: IdTuple","id2: IdTuple","ignoreList: boolean","currentResult: SearchResult","startId: Id","start: number","end: number","events: IdTuple[]","type: TypeRef<T>","toLoad: IdTuple[]","startIndex: number","searchModel: SearchModel"],"sources":["../../src/common/gui/base/Label.ts","../../src/mail-app/mail/view/MailRow.ts","../../src/mail-app/search/view/SearchListView.ts","../../src/mail-app/search/view/SearchViewModel.ts"],"sourcesContent":["import { pureComponent } from \"./PureComponent.js\"\nimport m from \"mithril\"\nimport { colorForBg } from \"./GuiUtils.js\"\nimport { size } from \"../size.js\"\nimport { theme } from \"../theme.js\"\nimport { isColorLight } from \"./Color.js\"\n\nconst supportsRelativeHslColors = CSS.supports(\"color\", `hsl(from #ccc h calc(min(50, s)) l)`)\n\nexport function getLabelColor(backgroundColor: string | null): string {\n\tconst labelColor = backgroundColor ?? theme.content_accent\n\tconst isDarkTheme = !isColorLight(theme.content_bg)\n\t// make a color have the same hue and lightness with saturation capped to 50\n\treturn isDarkTheme ? limitedSaturationColor(labelColor) : labelColor\n}\n\nfunction limitedSaturationColor(color: string): string {\n\t// iOS only implements relative HSL colors from 16.4 on and only the legacy syntax (with percents) while FF does not\n\t// recognize the legacy syntax anymore.\n\treturn supportsRelativeHslColors ? `hsl(from ${color} h calc(min(50, s)) l)` : `hsl(from ${color} h calc(min(50%, s)) l)`\n}\n\n/**\n * Displays a mail label with color and name.\n */\nexport const Label = pureComponent(function Label({ text, color }: { text: string; color: string | null }) {\n\tconst labelColor = getLabelColor(color)\n\treturn m(\n\t\t\"span.small.text-center.text-ellipsis.border-radius-m\",\n\t\t{\n\t\t\tstyle: {\n\t\t\t\t// in dark theme override saturation to aid readability. This is not relative but absolute saturation. We preserve the hue.\n\t\t\t\tbackgroundColor: labelColor,\n\t\t\t\tcolor: colorForBg(color ?? theme.content_accent),\n\t\t\t\tpadding: `1px ${size.vpad_xsm}px`,\n\t\t\t},\n\t\t},\n\t\ttext,\n\t)\n})\n","import { getMailFolderType, MailSetKind, MailState, ReplyType } from \"../../../common/api/common/TutanotaConstants\"\nimport { FontIcons } from \"../../../common/gui/base/icons/FontIcons\"\nimport type { Mail, MailFolder } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { formatTimeOrDateOrYesterday } from \"../../../common/misc/Formatter.js\"\nimport m, { Children } from \"mithril\"\nimport Badge from \"../../../common/gui/base/Badge\"\nimport {\n\tcheckboxOpacity,\n\tscaleXHide,\n\tscaleXShow,\n\tselectableRowAnimParams,\n\tSelectableRowContainer,\n\tSelectableRowSelectedSetter,\n\tsetVisibility,\n\tshouldAlwaysShowMultiselectCheckbox,\n} from \"../../../common/gui/SelectableRowContainer.js\"\nimport { px, size } from \"../../../common/gui/size.js\"\nimport { NBSP, noOp } from \"@tutao/tutanota-utils\"\nimport { VirtualRow } from \"../../../common/gui/base/ListUtils.js\"\nimport { companyTeamLabel } from \"../../../common/misc/ClientConstants.js\"\nimport { getConfidentialFontIcon, isTutanotaTeamMail } from \"./MailGuiUtils.js\"\nimport { mailLocator } from \"../../mailLocator.js\"\nimport { getSenderOrRecipientHeading } from \"./MailViewerUtils.js\"\nimport { getLabelColor } from \"../../../common/gui/base/Label\"\nimport { colorForBg } from \"../../../common/gui/base/GuiUtils\"\nimport { theme } from \"../../../common/gui/theme\"\n\nconst iconMap: Record<MailSetKind, string> = {\n\t[MailSetKind.CUSTOM]: FontIcons.Folder,\n\t[MailSetKind.INBOX]: FontIcons.Inbox,\n\t[MailSetKind.SENT]: FontIcons.Sent,\n\t[MailSetKind.TRASH]: FontIcons.Trash,\n\t[MailSetKind.ARCHIVE]: FontIcons.Archive,\n\t[MailSetKind.SPAM]: FontIcons.Spam,\n\t[MailSetKind.DRAFT]: FontIcons.Draft,\n\t[MailSetKind.ALL]: FontIcons.Folder,\n\t[MailSetKind.LABEL]: FontIcons.Folder,\n\t[MailSetKind.Imported]: FontIcons.Folder,\n}\n\nexport const MAIL_ROW_V_MARGIN = 3\n\nconst shiftByForCheckbox = px(10)\nconst translateXHide = \"translateX(0)\"\nconst translateXShow = `translateX(${shiftByForCheckbox})`\n\nconst ELLIPSIS = \"\\u2026\"\n\nconst MAX_DISPLAYED_LABELS = 6\n\nexport class MailRow implements VirtualRow<Mail> {\n\ttop: number\n\tdomElement: HTMLElement | null = null\n\n\tentity: Mail | null = null\n\tprivate subjectDom!: HTMLElement\n\tprivate senderDom!: HTMLElement\n\tprivate dateDom!: HTMLElement\n\tprivate iconsDom!: HTMLElement\n\tprivate unreadDom!: HTMLElement\n\tprivate teamLabelDom!: HTMLElement\n\tprivate labelsDom: HTMLElement[] = []\n\tprivate moreLabelsIndicatorDom!: HTMLElement\n\tprivate checkboxDom!: HTMLInputElement\n\tprivate checkboxWasVisible = shouldAlwaysShowMultiselectCheckbox()\n\tprivate selectionSetter!: SelectableRowSelectedSetter\n\n\tconstructor(\n\t\tprivate readonly showFolderIcon: boolean,\n\t\tprivate readonly getLabelsForMail: (mail: Mail) => ReadonlyArray<MailFolder>,\n\t\tprivate readonly onSelected: (mail: Mail, selected: boolean) => unknown,\n\t) {\n\t\tthis.top = 0\n\t\tthis.entity = null\n\t}\n\n\tupdate(mail: Mail, selected: boolean, isInMultiSelect: boolean): void {\n\t\tthis.entity = mail\n\n\t\tthis.selectionSetter(selected, isInMultiSelect)\n\t\tthis.checkboxDom.checked = isInMultiSelect && selected\n\n\t\tthis.iconsDom.textContent = this.iconsText(mail)\n\t\tthis.dateDom.textContent = formatTimeOrDateOrYesterday(mail.receivedDate)\n\t\tthis.senderDom.textContent = getSenderOrRecipientHeading(mail, true)\n\t\tthis.subjectDom.textContent = mail.subject || NBSP\n\n\t\tif (mail.unread) {\n\t\t\tthis.unreadDom.classList.remove(\"hidden\")\n\n\t\t\tthis.subjectDom.classList.add(\"b\")\n\t\t\tthis.senderDom.classList.add(\"b\")\n\t\t} else {\n\t\t\tthis.unreadDom.classList.add(\"hidden\")\n\n\t\t\tthis.subjectDom.classList.remove(\"b\")\n\t\t\tthis.senderDom.classList.remove(\"b\")\n\t\t}\n\t\tthis.updateLabels(mail)\n\n\t\tsetVisibility(this.teamLabelDom, isTutanotaTeamMail(mail))\n\t\tthis.showCheckboxAnimated(shouldAlwaysShowMultiselectCheckbox() || isInMultiSelect)\n\n\t\tcheckboxOpacity(this.checkboxDom, selected)\n\t}\n\n\tprivate updateLabels(mail: Mail) {\n\t\tconst labels = this.getLabelsForMail(mail)\n\n\t\tfor (const [i, element] of this.labelsDom.entries()) {\n\t\t\tconst label = labels[i]\n\t\t\tif (label) {\n\t\t\t\telement.style.display = \"\"\n\t\t\t\telement.style.backgroundColor = getLabelColor(label.color)\n\t\t\t\telement.style.color = colorForBg(label.color ?? theme.content_accent)\n\t\t\t\telement.textContent = label.name\n\t\t\t} else {\n\t\t\t\telement.style.display = \"none\"\n\t\t\t}\n\t\t}\n\t\tthis.moreLabelsIndicatorDom.style.display = labels.length > this.labelsDom.length ? \"\" : \"none\"\n\t}\n\n\tprivate showCheckboxAnimated(show: boolean) {\n\t\t// this causes a slide animation where checkbox pops up and the text is shifted to make space for it.\n\t\t// we can't animate the width of the checkbox as it causes the layout shifts and is very slow so instead we change the padding of the text elements in\n\t\t// a single step and then shift them in an animation. The effect is almost the same as if we would expand/shrink the checkbox.\n\t\t// using requestAnimationFrame() because when we toggle it some elements might not be there yet. Could also for the end of the event loop too.\n\t\t// using web animations to be able to cancel them easily. Could probably use transition and listen for the end instead but it would be harder to\n\t\t// do the bookkeeping.\n\t\t// using noOp to catch rejection when the animation is cancelled\n\t\tconst shouldShowCheckbox = show\n\t\tif (this.checkboxWasVisible === shouldShowCheckbox) return\n\n\t\tif (shouldShowCheckbox) {\n\t\t\tthis.senderDom.style.paddingRight = shiftByForCheckbox\n\t\t\tthis.subjectDom.style.paddingRight = shiftByForCheckbox\n\n\t\t\tconst showTranslateTransform = { transform: [translateXHide, translateXShow] }\n\t\t\tconst senderAnim = this.senderDom.animate(showTranslateTransform, selectableRowAnimParams)\n\t\t\tconst subjectAnim = this.subjectDom.animate(showTranslateTransform, selectableRowAnimParams)\n\t\t\tconst badgeAnim = this.teamLabelDom.animate(showTranslateTransform, selectableRowAnimParams)\n\t\t\tconst checkboxAnim = this.checkboxDom.animate({ transform: [scaleXHide, scaleXShow] }, selectableRowAnimParams)\n\n\t\t\tPromise.all([senderAnim.finished, subjectAnim.finished, checkboxAnim.finished]).then(() => {\n\t\t\t\tthis.showCheckbox(true)\n\n\t\t\t\tsenderAnim.cancel()\n\t\t\t\tsubjectAnim.cancel()\n\t\t\t\tbadgeAnim.cancel()\n\t\t\t\tcheckboxAnim.cancel()\n\t\t\t}, noOp)\n\t\t} else {\n\t\t\tthis.senderDom.style.paddingRight = \"0\"\n\t\t\tthis.subjectDom.style.paddingRight = \"0\"\n\n\t\t\tconst hideTranslateTransform = { transform: [translateXShow, translateXHide] }\n\t\t\tconst senderAnim = this.senderDom.animate(hideTranslateTransform, selectableRowAnimParams)\n\t\t\tconst subjectAnim = this.subjectDom.animate(hideTranslateTransform, selectableRowAnimParams)\n\t\t\tconst badgeAnim = this.teamLabelDom.animate(hideTranslateTransform, selectableRowAnimParams)\n\t\t\tconst checkboxAnim = this.checkboxDom.animate({ transform: [scaleXShow, scaleXHide] }, selectableRowAnimParams)\n\n\t\t\tPromise.all([senderAnim.finished, subjectAnim.finished, checkboxAnim.finished]).then(() => {\n\t\t\t\tthis.showCheckbox(false)\n\n\t\t\t\tsenderAnim.cancel()\n\t\t\t\tsubjectAnim.cancel()\n\t\t\t\tbadgeAnim.cancel()\n\t\t\t\tcheckboxAnim.cancel()\n\t\t\t}, noOp)\n\t\t}\n\t\tthis.checkboxWasVisible = shouldShowCheckbox\n\t}\n\n\tprivate showCheckbox(show: boolean) {\n\t\tlet translate\n\t\tlet scale\n\t\tlet padding\n\t\tif (show) {\n\t\t\ttranslate = translateXShow\n\t\t\tscale = scaleXShow\n\t\t\tpadding = shiftByForCheckbox\n\t\t} else {\n\t\t\ttranslate = translateXHide\n\t\t\tscale = scaleXHide\n\t\t\tpadding = \"0\"\n\t\t}\n\t\tthis.senderDom.style.transform = translate\n\t\tthis.subjectDom.style.transform = translate\n\t\tthis.teamLabelDom.style.transform = translate\n\t\tthis.checkboxDom.style.transform = scale\n\n\t\tthis.senderDom.style.paddingRight = padding\n\t\tthis.subjectDom.style.paddingRight = padding\n\n\t\t// we effectively remove it from interaction\n\t\tthis.checkboxDom.disabled = !show\n\t\tthis.checkboxDom.tabIndex = show ? 0 : -1\n\t}\n\n\t/**\n\t * Only the structure is managed by mithril. We set all contents on our own (see update) in order to avoid the vdom overhead (not negligible on mobiles)\n\t */\n\trender(): Children {\n\t\treturn m(\n\t\t\tSelectableRowContainer,\n\t\t\t{\n\t\t\t\tonSelectedChangeRef: (changer) => {\n\t\t\t\t\tthis.selectionSetter = changer\n\t\t\t\t},\n\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\tthis.domElement = vnode.dom as HTMLElement\n\t\t\t\t\t// doing it right away to avoid visual glitch of it appearing/disappearing\n\t\t\t\t\t// but doing it at the end of the event loop because we touch other DOM elements too which might not be there yet\n\t\t\t\t\tPromise.resolve().then(() => this.showCheckbox(shouldAlwaysShowMultiselectCheckbox()))\n\t\t\t\t},\n\t\t\t},\n\t\t\t[\n\t\t\t\tm(\n\t\t\t\t\t\".flex.col.items-center.flex-no-grow.no-shrink.pt-xs.abs\",\n\t\t\t\t\tm(\"input.checkbox.list-checkbox\", {\n\t\t\t\t\t\ttype: \"checkbox\",\n\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\tmarginBottom: \"7px\",\n\t\t\t\t\t\t\ttransformOrigin: \"left\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonclick: (e: MouseEvent) => {\n\t\t\t\t\t\t\te.stopPropagation()\n\t\t\t\t\t\t\t// e.redraw = false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonchange: () => {\n\t\t\t\t\t\t\tif (this.entity) this.onSelected(this.entity, this.checkboxDom.checked)\n\t\t\t\t\t\t},\n\t\t\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\t\t\tthis.checkboxDom = vnode.dom as HTMLInputElement\n\t\t\t\t\t\t\tcheckboxOpacity(this.checkboxDom, false)\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\tm(\".dot.bg-accent-fg.hidden\", {\n\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\tmarginTop: px(MAIL_ROW_V_MARGIN),\n\t\t\t\t\t\t},\n\t\t\t\t\t\toncreate: (vnode) => (this.unreadDom = vnode.dom as HTMLElement),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t\tm(\n\t\t\t\t\t\".flex-grow.min-width-0\",\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\tmarginLeft: px(size.checkbox_size + size.vpad_xs),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t[\n\t\t\t\t\t\tm(\".flex.badge-line-height\", [\n\t\t\t\t\t\t\tm(\n\t\t\t\t\t\t\t\tBadge,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tclasses: \".small.mr-s\",\n\t\t\t\t\t\t\t\t\toncreate: (vnode) => (this.teamLabelDom = vnode.dom as HTMLElement),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcompanyTeamLabel,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tm(\".text-ellipsis\", {\n\t\t\t\t\t\t\t\toncreate: (vnode) => (this.senderDom = vnode.dom as HTMLElement),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tm(\n\t\t\t\t\t\t\t\t\".flex.flex-grow-shrink-0.justify-end\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\t\t\t\tminWidth: px(34), // so the moreLabelIndicator is visible on smaller screens\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tthis.renderLabels(),\n\t\t\t\t\t\t\t\tthis.renderLabelsMoreIndicator(),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tm(\"small.text-ellipsis.flex-fixed\", {\n\t\t\t\t\t\t\t\toncreate: (vnode) => (this.dateDom = vnode.dom as HTMLElement),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t]),\n\t\t\t\t\t\tm(\".flex.mt-xxs\", [\n\t\t\t\t\t\t\tm(\".smaller.text-ellipsis\", {\n\t\t\t\t\t\t\t\toncreate: (vnode) => (this.subjectDom = vnode.dom as HTMLElement),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tm(\".flex-grow\"),\n\t\t\t\t\t\t\tm(\"span.ion.ml-s.list-font-icons\", {\n\t\t\t\t\t\t\t\toncreate: (vnode) => (this.iconsDom = vnode.dom as HTMLElement),\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t]),\n\t\t\t\t\t],\n\t\t\t\t),\n\t\t\t],\n\t\t)\n\t}\n\n\tprivate renderLabelsMoreIndicator(): Children {\n\t\treturn m(\n\t\t\t\"span.smaller.text-center.text-ellipsis.border-radius-m\",\n\t\t\t{\n\t\t\t\tstyle: {\n\t\t\t\t\t// in dark theme override saturation to aid readability. This is not relative but absolute saturation. We preserve the hue.\n\t\t\t\t\tborder: `2px solid ${getLabelColor(theme.content_button)}`,\n\t\t\t\t\tcolor: getLabelColor(theme.content_button),\n\t\t\t\t\tpadding: `0px ${size.vpad_xsm}px 1px`,\n\t\t\t\t\tmarginRight: px(size.vpad_xsm),\n\t\t\t\t\tminWidth: px(16),\n\t\t\t\t\tlineHeight: px(8),\n\t\t\t\t},\n\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\tthis.moreLabelsIndicatorDom = vnode.dom as HTMLElement\n\t\t\t\t},\n\t\t\t},\n\t\t\tELLIPSIS,\n\t\t)\n\t}\n\n\tprivate renderLabels(): Children {\n\t\treturn m(\n\t\t\t\".flex.overflow-hidden\",\n\t\t\t{\n\t\t\t\tstyle: {\n\t\t\t\t\tmargin: `0 ${size.vpad_xsm}px`,\n\t\t\t\t\tcolumnGap: px(size.vpad_xsm),\n\t\t\t\t\tmaxWidth: \"fit-content\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tArray(MAX_DISPLAYED_LABELS)\n\t\t\t\t.fill(0)\n\t\t\t\t.map((_, i) =>\n\t\t\t\t\t// Not using the regular Label component as we have too\n\t\t\t\t\t// many differences and list is a special case anyway.\n\t\t\t\t\tm(\"span.small.text-center.text-ellipsis.border-radius-m\", {\n\t\t\t\t\t\tstyle: {\n\t\t\t\t\t\t\tpadding: `2px ${size.vpad_xsm}px`,\n\t\t\t\t\t\t\tminWidth: \"4ch\",\n\t\t\t\t\t\t\tmaxWidth: px(48),\n\t\t\t\t\t\t\tlineHeight: \"100%\",\n\t\t\t\t\t\t\ttextOverflow: \"'â€¥'\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\toncreate: (vnode) => {\n\t\t\t\t\t\t\tthis.labelsDom[i] = vnode.dom as HTMLElement\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t)\n\t}\n\n\tprivate iconsText(mail: Mail): string {\n\t\tlet iconText = \"\"\n\n\t\tif (this.showFolderIcon) {\n\t\t\tlet folder = mailLocator.mailModel.getMailFolderForMail(mail)\n\t\t\ticonText += folder ? this.folderIcon(getMailFolderType(folder)) : \"\"\n\t\t}\n\n\t\ticonText += mail._errors ? FontIcons.Warning : \"\"\n\n\t\tif (mail.state === MailState.DRAFT) {\n\t\t\ticonText += FontIcons.Edit\n\t\t}\n\n\t\tswitch (mail.replyType) {\n\t\t\tcase ReplyType.REPLY:\n\t\t\t\ticonText += FontIcons.Reply\n\t\t\t\tbreak\n\n\t\t\tcase ReplyType.FORWARD:\n\t\t\t\ticonText += FontIcons.Forward\n\t\t\t\tbreak\n\n\t\t\tcase ReplyType.REPLY_FORWARD:\n\t\t\t\ticonText += FontIcons.Reply\n\t\t\t\ticonText += FontIcons.Forward\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (mail.confidential) {\n\t\t\ticonText += getConfidentialFontIcon(mail)\n\t\t}\n\n\t\tif (mail.attachments.length > 0) {\n\t\t\ticonText += FontIcons.Attach\n\t\t}\n\n\t\treturn iconText\n\t}\n\n\tprivate folderIcon(type: MailSetKind): string {\n\t\treturn iconMap[type]\n\t}\n}\n","import m, { Children, Component, Vnode } from \"mithril\"\nimport { assertMainOrNode } from \"../../../common/api/common/Env\"\nimport { downcast, isSameTypeRef, TypeRef } from \"@tutao/tutanota-utils\"\nimport { MailRow } from \"../../mail/view/MailRow\"\nimport { ListElementListModel } from \"../../../common/misc/ListElementListModel.js\"\nimport { List, ListAttrs, MultiselectMode, RenderConfig } from \"../../../common/gui/base/List.js\"\nimport { size } from \"../../../common/gui/size.js\"\nimport { KindaContactRow } from \"../../contacts/view/ContactListView.js\"\nimport { SearchableTypes } from \"./SearchViewModel.js\"\nimport { CalendarEvent, CalendarEventTypeRef, Contact, ContactTypeRef, Mail, MailFolder } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport ColumnEmptyMessageBox from \"../../../common/gui/base/ColumnEmptyMessageBox.js\"\nimport { BootIcons } from \"../../../common/gui/base/icons/BootIcons.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { theme } from \"../../../common/gui/theme.js\"\nimport { VirtualRow } from \"../../../common/gui/base/ListUtils.js\"\nimport { styles } from \"../../../common/gui/styles.js\"\nimport { KindaCalendarRow } from \"../../../calendar-app/calendar/gui/CalendarRow.js\"\nimport { AllIcons } from \"../../../common/gui/base/Icon.js\"\n\nassertMainOrNode()\n\nexport class SearchResultListEntry {\n\tconstructor(readonly entry: SearchableTypes) {}\n\n\tget _id(): IdTuple {\n\t\treturn this.entry._id\n\t}\n}\n\nexport interface SearchListViewAttrs {\n\tlistModel: ListElementListModel<SearchResultListEntry>\n\tonSingleSelection: (item: SearchResultListEntry) => unknown\n\tcurrentType: TypeRef<Mail> | TypeRef<Contact> | TypeRef<CalendarEvent>\n\tisFreeAccount: boolean\n\tcancelCallback: () => unknown | null\n\tgetLabelsForMail: (mail: Mail) => MailFolder[]\n}\n\nexport class SearchListView implements Component<SearchListViewAttrs> {\n\tprivate attrs: SearchListViewAttrs\n\n\tprivate get listModel(): ListElementListModel<SearchResultListEntry> {\n\t\treturn this.attrs.listModel\n\t}\n\n\tconstructor({ attrs }: Vnode<SearchListViewAttrs>) {\n\t\tthis.attrs = attrs\n\t}\n\n\tview({ attrs }: Vnode<SearchListViewAttrs>): Children {\n\t\tthis.attrs = attrs\n\t\tconst { icon, renderConfig } = this.getRenderItems(attrs.currentType)\n\n\t\treturn attrs.listModel.isEmptyAndDone()\n\t\t\t? m(ColumnEmptyMessageBox, {\n\t\t\t\t\ticon,\n\t\t\t\t\tmessage: \"searchNoResults_msg\",\n\t\t\t\t\tcolor: theme.list_message_bg,\n\t\t\t  })\n\t\t\t: m(List, {\n\t\t\t\t\tstate: attrs.listModel.state,\n\t\t\t\t\trenderConfig,\n\t\t\t\t\tonLoadMore: () => {\n\t\t\t\t\t\tattrs.listModel?.loadMore()\n\t\t\t\t\t},\n\t\t\t\t\tonRetryLoading: () => {\n\t\t\t\t\t\tattrs.listModel?.retryLoading()\n\t\t\t\t\t},\n\t\t\t\t\tonSingleSelection: (item: SearchResultListEntry) => {\n\t\t\t\t\t\tattrs.listModel?.onSingleSelection(item)\n\t\t\t\t\t\tattrs.onSingleSelection(item)\n\t\t\t\t\t},\n\t\t\t\t\tonSingleTogglingMultiselection: (item: SearchResultListEntry) => {\n\t\t\t\t\t\tattrs.listModel.onSingleInclusiveSelection(item, styles.isSingleColumnLayout())\n\t\t\t\t\t},\n\t\t\t\t\tonRangeSelectionTowards: (item: SearchResultListEntry) => {\n\t\t\t\t\t\tattrs.listModel.selectRangeTowards(item)\n\t\t\t\t\t},\n\t\t\t\t\tonStopLoading() {\n\t\t\t\t\t\tif (attrs.cancelCallback != null) {\n\t\t\t\t\t\t\tattrs.cancelCallback()\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tattrs.listModel.stopLoading()\n\t\t\t\t\t},\n\t\t\t  } satisfies ListAttrs<SearchResultListEntry, SearchResultListRow>)\n\t}\n\n\tprivate getRenderItems(type: TypeRef<Mail> | TypeRef<Contact> | TypeRef<CalendarEvent>): {\n\t\ticon: AllIcons\n\t\trenderConfig: RenderConfig<SearchResultListEntry, SearchResultListRow>\n\t} {\n\t\tif (isSameTypeRef(type, ContactTypeRef)) {\n\t\t\treturn {\n\t\t\t\ticon: BootIcons.Contacts,\n\t\t\t\trenderConfig: this.contactRenderConfig,\n\t\t\t}\n\t\t} else if (isSameTypeRef(type, CalendarEventTypeRef)) {\n\t\t\treturn {\n\t\t\t\ticon: BootIcons.Calendar,\n\t\t\t\trenderConfig: this.calendarRenderConfig,\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ticon: BootIcons.Mail,\n\t\t\t\trenderConfig: this.mailRenderConfig,\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly calendarRenderConfig: RenderConfig<SearchResultListEntry, SearchResultListRow> = {\n\t\titemHeight: size.list_row_height,\n\t\tmultiselectionAllowed: MultiselectMode.Disabled,\n\t\tswipe: null,\n\t\tcreateElement: (dom) => {\n\t\t\tconst row: SearchResultListRow = new SearchResultListRow(new KindaCalendarRow(dom))\n\t\t\tm.render(dom, row.render())\n\t\t\treturn row\n\t\t},\n\t}\n\n\tprivate readonly mailRenderConfig: RenderConfig<SearchResultListEntry, SearchResultListRow> = {\n\t\titemHeight: size.list_row_height,\n\t\tmultiselectionAllowed: MultiselectMode.Enabled,\n\t\tswipe: null,\n\t\tcreateElement: (dom) => {\n\t\t\tconst row: SearchResultListRow = new SearchResultListRow(\n\t\t\t\tnew MailRow(\n\t\t\t\t\ttrue,\n\t\t\t\t\t(mail) => this.attrs.getLabelsForMail(mail),\n\t\t\t\t\t() => row.entity && this.listModel.onSingleExclusiveSelection(row.entity),\n\t\t\t\t),\n\t\t\t)\n\t\t\tm.render(dom, row.render())\n\t\t\treturn row\n\t\t},\n\t}\n\n\tprivate readonly contactRenderConfig: RenderConfig<SearchResultListEntry, SearchResultListRow> = {\n\t\titemHeight: size.list_row_height,\n\t\tmultiselectionAllowed: MultiselectMode.Enabled,\n\t\tswipe: null,\n\t\tcreateElement: (dom) => {\n\t\t\tconst row: SearchResultListRow = new SearchResultListRow(\n\t\t\t\tnew KindaContactRow(dom, () => row.entity && this.listModel.onSingleExclusiveSelection(row.entity)),\n\t\t\t)\n\t\t\tm.render(dom, row.render())\n\t\t\treturn row\n\t\t},\n\t}\n}\n\nexport class SearchResultListRow implements VirtualRow<SearchResultListEntry> {\n\ttop: number\n\t// set from List\n\tdomElement: HTMLElement | null = null\n\n\t// this is our own entry which we need for some reason (probably easier to deal with than a lot of sum type entries)\n\tprivate _entity: SearchResultListEntry | null = null\n\tget entity(): SearchResultListEntry | null {\n\t\treturn this._entity\n\t}\n\n\tprivate _delegate: MailRow | KindaContactRow | KindaCalendarRow\n\n\tconstructor(delegate: MailRow | KindaContactRow | KindaCalendarRow) {\n\t\tthis._delegate = delegate\n\t\tthis.top = 0\n\t}\n\n\tupdate(entry: SearchResultListEntry, selected: boolean, isInMultiSelect: boolean): void {\n\t\tthis._delegate.domElement = this.domElement\n\t\tthis._entity = entry\n\n\t\tthis._delegate.update(downcast(entry.entry), selected, isInMultiSelect)\n\t}\n\n\trender(): Children {\n\t\treturn this._delegate.render()\n\t}\n}\n","import { ListElementListModel } from \"../../../common/misc/ListElementListModel.js\"\nimport { SearchResultListEntry } from \"./SearchListView.js\"\nimport { SearchRestriction, SearchResult } from \"../../../common/api/worker/search/SearchTypes.js\"\nimport { EntityEventsListener, EventController } from \"../../../common/api/main/EventController.js\"\nimport { CalendarEvent, CalendarEventTypeRef, Contact, ContactTypeRef, Mail, MailFolder, MailTypeRef } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ListElementEntity, SomeEntity } from \"../../../common/api/common/EntityTypes.js\"\nimport {\n\tCLIENT_ONLY_CALENDARS,\n\tFULL_INDEXED_TIMESTAMP,\n\tMailSetKind,\n\tNOTHING_INDEXED_TIMESTAMP,\n\tOperationType,\n} from \"../../../common/api/common/TutanotaConstants.js\"\nimport {\n\tassertIsEntity,\n\tassertIsEntity2,\n\telementIdPart,\n\tGENERATED_MAX_ID,\n\tgetElementId,\n\tisSameId,\n\tListElement,\n\tlistIdPart,\n\tsortCompareByReverseId,\n} from \"../../../common/api/common/utils/EntityUtils.js\"\nimport { ListLoadingState, ListState } from \"../../../common/gui/base/List.js\"\nimport {\n\tassertNotNull,\n\tdeepEqual,\n\tdefer,\n\tdowncast,\n\tgetEndOfDay,\n\tgetStartOfDay,\n\tincrementMonth,\n\tisSameDayOfDate,\n\tisSameTypeRef,\n\tLazyLoaded,\n\tneverNull,\n\tofClass,\n\tstringToBase64,\n\tTypeRef,\n} from \"@tutao/tutanota-utils\"\nimport { areResultsForTheSameQuery, hasMoreResults, isSameSearchRestriction, SearchModel } from \"../model/SearchModel.js\"\nimport { NotFoundError } from \"../../../common/api/common/error/RestError.js\"\nimport { compareContacts } from \"../../contacts/view/ContactGuiUtils.js\"\nimport { ConversationViewModel, ConversationViewModelFactory } from \"../../mail/view/ConversationViewModel.js\"\nimport {\n\tcreateRestriction,\n\tdecodeCalendarSearchKey,\n\tencodeCalendarSearchKey,\n\tgetRestriction,\n\tgetSearchUrl,\n\tsearchCategoryForRestriction,\n\tSearchCategoryTypes,\n} from \"../model/SearchUtils.js\"\nimport Stream from \"mithril/stream\"\nimport { MailboxDetail, MailboxModel } from \"../../../common/mailFunctionality/MailboxModel.js\"\nimport { SearchFacade } from \"../../workerUtils/index/SearchFacade.js\"\nimport { LoginController } from \"../../../common/api/main/LoginController.js\"\nimport { Indexer } from \"../../workerUtils/index/Indexer.js\"\nimport { EntityClient, loadMultipleFromLists } from \"../../../common/api/common/EntityClient.js\"\nimport { SearchRouter } from \"../../../common/search/view/SearchRouter.js\"\nimport { MailOpenedListener } from \"../../mail/view/MailViewModel.js\"\nimport { containsEventOfType, EntityUpdateData, getEventOfType, isUpdateForTypeRef } from \"../../../common/api/common/utils/EntityUpdateUtils.js\"\nimport { CalendarInfo } from \"../../../calendar-app/calendar/model/CalendarModel.js\"\nimport { locator } from \"../../../common/api/main/CommonLocator.js\"\nimport m from \"mithril\"\nimport { CalendarFacade } from \"../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport { ProgressTracker } from \"../../../common/api/main/ProgressTracker.js\"\nimport { ClientOnlyCalendarsInfo, ListAutoSelectBehavior } from \"../../../common/misc/DeviceConfig.js\"\nimport {\n\tgenerateCalendarInstancesInRange,\n\tgetStartOfTheWeekOffsetForUser,\n\tretrieveClientOnlyEventsForUser,\n} from \"../../../common/calendar/date/CalendarUtils.js\"\nimport { mailLocator } from \"../../mailLocator.js\"\nimport { getMailFilterForType, MailFilterType } from \"../../mail/view/MailViewerUtils.js\"\nimport { CalendarEventsRepository } from \"../../../common/calendar/date/CalendarEventsRepository.js\"\nimport { getClientOnlyCalendars } from \"../../../calendar-app/calendar/gui/CalendarGuiUtils.js\"\nimport { YEAR_IN_MILLIS } from \"@tutao/tutanota-utils/dist/DateUtils.js\"\nimport { ListFilter } from \"../../../common/misc/ListModel\"\n\nconst SEARCH_PAGE_SIZE = 100\n\nexport type SearchableTypes = Mail | Contact | CalendarEvent\n\nexport enum PaidFunctionResult {\n\tSuccess,\n\tPaidSubscriptionNeeded,\n}\n\nexport class SearchViewModel {\n\tprivate _listModel: ListElementListModel<SearchResultListEntry>\n\tget listModel(): ListElementListModel<SearchResultListEntry> {\n\t\treturn this._listModel\n\t}\n\n\tprivate _includeRepeatingEvents: boolean = true\n\tget includeRepeatingEvents(): boolean {\n\t\treturn this._includeRepeatingEvents\n\t}\n\n\tget warning(): \"long\" | \"startafterend\" | null {\n\t\tif (this.startDate && this.startDate.getTime() > this.endDate.getTime()) {\n\t\t\treturn \"startafterend\"\n\t\t} else if (this.startDate && this.endDate.getTime() - this.startDate.getTime() > YEAR_IN_MILLIS) {\n\t\t\treturn \"long\"\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * the type ref that determines which search filters and details\n\t * viewers this view should show.\n\t * taken from the current results' restriction or, if result is nonexistent,\n\t * the URL.\n\t *\n\t * result might be nonexistent if there is no query or we're not done searching\n\t * yet.\n\t */\n\tget searchedType(): TypeRef<Mail> | TypeRef<Contact> | TypeRef<CalendarEvent> {\n\t\treturn (this.searchResult?.restriction ?? this.router.getRestriction()).type\n\t}\n\n\tprivate _conversationViewModel: ConversationViewModel | null = null\n\tget conversationViewModel(): ConversationViewModel | null {\n\t\treturn this._conversationViewModel\n\t}\n\n\tprivate _startDate: Date | null = null // null = current mail index date. this allows us to start the search (and the url) without end date set\n\tget startDate(): Date | null {\n\t\treturn this._startDate ?? this.getCurrentMailIndexDate()\n\t}\n\n\tprivate _endDate: Date | null = null // null = today (mail), end of 2 months in the future (calendar)\n\tget endDate(): Date {\n\t\tif (this._endDate) {\n\t\t\treturn this._endDate\n\t\t} else {\n\t\t\tif (this.getCategory() === SearchCategoryTypes.calendar) {\n\t\t\t\tlet returnDate = incrementMonth(new Date(), 3)\n\t\t\t\treturnDate.setDate(0)\n\t\t\t\treturn returnDate\n\t\t\t} else {\n\t\t\t\treturn new Date()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _selectedMailFolder: Array<Id> = []\n\tget selectedMailFolder(): Array<Id> {\n\t\treturn this._selectedMailFolder\n\t}\n\n\t// isn't an IdTuple because it is two list ids\n\tprivate _selectedCalendar: readonly [Id, Id] | string | null = null\n\tget selectedCalendar(): readonly [Id, Id] | string | null {\n\t\treturn this._selectedCalendar\n\t}\n\n\tprivate _mailboxes: MailboxDetail[] = []\n\tget mailboxes(): MailboxDetail[] {\n\t\treturn this._mailboxes\n\t}\n\n\tprivate _selectedMailField: string | null = null\n\tget selectedMailField(): string | null {\n\t\treturn this._selectedMailField\n\t}\n\n\t// Contains load more results even when searchModel doesn't.\n\t// Load more should probably be moved to the model to update it's result stream.\n\tprivate searchResult: SearchResult | null = null\n\tprivate mailFilterType: MailFilterType | null = null\n\tprivate latestMailRestriction: SearchRestriction | null = null\n\tprivate latestCalendarRestriction: SearchRestriction | null = null\n\tprivate mailboxSubscription: Stream<void> | null = null\n\tprivate resultSubscription: Stream<void> | null = null\n\tprivate listStateSubscription: Stream<unknown> | null = null\n\tloadingAllForSearchResult: SearchResult | null = null\n\tprivate readonly lazyCalendarInfos: LazyLoaded<ReadonlyMap<string, CalendarInfo>> = new LazyLoaded(async () => {\n\t\tconst calendarModel = await locator.calendarModel()\n\t\tconst calendarInfos = await calendarModel.getCalendarInfos()\n\t\tm.redraw()\n\t\treturn calendarInfos\n\t})\n\n\tprivate readonly userHasNewPaidPlan: LazyLoaded<boolean> = new LazyLoaded<boolean>(async () => {\n\t\treturn await this.logins.getUserController().isNewPaidPlan()\n\t})\n\n\tcurrentQuery: string = \"\"\n\n\tprivate extendIndexConfirmationCallback: (() => Promise<boolean>) | null = null\n\n\tconstructor(\n\t\treadonly router: SearchRouter,\n\t\tprivate readonly search: SearchModel,\n\t\tprivate readonly searchFacade: SearchFacade,\n\t\tprivate readonly mailboxModel: MailboxModel,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly indexerFacade: Indexer,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly eventController: EventController,\n\t\tprivate readonly mailOpenedListener: MailOpenedListener | null,\n\t\tprivate readonly calendarFacade: CalendarFacade,\n\t\tprivate readonly progressTracker: ProgressTracker,\n\t\tprivate readonly conversationViewModelFactory: ConversationViewModelFactory | null,\n\t\tprivate readonly eventsRepository: CalendarEventsRepository,\n\t\tprivate readonly updateUi: () => unknown,\n\t\tprivate readonly selectionBehavior: ListAutoSelectBehavior,\n\t\tprivate readonly localCalendars: Map<Id, ClientOnlyCalendarsInfo>,\n\t) {\n\t\tthis.currentQuery = this.search.result()?.query ?? \"\"\n\t\tthis._listModel = this.createList()\n\t}\n\n\tgetLazyCalendarInfos() {\n\t\treturn this.lazyCalendarInfos\n\t}\n\n\tgetUserHasNewPaidPlan() {\n\t\treturn this.userHasNewPaidPlan\n\t}\n\n\tinit(extendIndexConfirmationCallback: SearchViewModel[\"extendIndexConfirmationCallback\"]) {\n\t\tif (this.extendIndexConfirmationCallback) {\n\t\t\treturn\n\t\t}\n\t\tthis.extendIndexConfirmationCallback = extendIndexConfirmationCallback\n\t\tthis.resultSubscription = this.search.result.map((result) => {\n\t\t\tif (!result || !isSameTypeRef(result.restriction.type, MailTypeRef)) {\n\t\t\t\tthis.mailFilterType = null\n\t\t\t}\n\n\t\t\tif (this.searchResult == null || result == null || !areResultsForTheSameQuery(result, this.searchResult)) {\n\t\t\t\tthis._listModel.cancelLoadAll()\n\n\t\t\t\tthis.searchResult = result\n\n\t\t\t\tthis._listModel = this.createList()\n\t\t\t\tthis.setMailFilter(this.mailFilterType)\n\t\t\t\tthis.applyMailFilterIfNeeded()\n\t\t\t\tthis._listModel.loadInitial()\n\t\t\t\tthis.listStateSubscription?.end(true)\n\t\t\t\tthis.listStateSubscription = this._listModel.stateStream.map((state) => this.onListStateChange(state))\n\t\t\t}\n\t\t})\n\n\t\tthis.mailboxSubscription = this.mailboxModel.mailboxDetails.map((mailboxes) => {\n\t\t\tthis.onMailboxesChanged(mailboxes)\n\t\t})\n\t\tthis.eventController.addEntityListener(this.entityEventsListener)\n\t}\n\n\tgetRestriction(): SearchRestriction {\n\t\treturn this.router.getRestriction()\n\t}\n\n\tprivate readonly entityEventsListener: EntityEventsListener = async (updates) => {\n\t\tfor (const update of updates) {\n\t\t\tconst mergedUpdate = this.mergeOperationsIfNeeded(update, updates)\n\n\t\t\tif (mergedUpdate == null) continue\n\n\t\t\tawait this.entityEventReceived(mergedUpdate)\n\t\t}\n\t}\n\n\tprivate mergeOperationsIfNeeded(update: EntityUpdateData, updates: readonly EntityUpdateData[]): EntityUpdateData | null {\n\t\t// We are trying to keep the mails that are moved and would match the search criteria displayed.\n\t\t// This is a bit hacky as we reimplement part of the filtering by list.\n\t\t// Ideally search result would update by itself and we would only need to reconcile the changes.\n\t\tif (!isUpdateForTypeRef(MailTypeRef, update) || this.searchResult == null) {\n\t\t\treturn update\n\t\t}\n\t\tif (update.operation === OperationType.CREATE && containsEventOfType(updates, OperationType.DELETE, update.instanceId)) {\n\t\t\t// This is a move operation, is destination list included in the restrictions?\n\t\t\tif (this.listIdMatchesRestriction(update.instanceListId, this.searchResult.restriction)) {\n\t\t\t\t// If it's included, we want to keep showing the item but we will simulate the UPDATE\n\t\t\t\treturn { ...update, operation: OperationType.UPDATE }\n\t\t\t} else {\n\t\t\t\t// If it's not going to be included we might as well skip the create operation\n\t\t\t\treturn null\n\t\t\t}\n\t\t} else if (update.operation === OperationType.DELETE && containsEventOfType(updates, OperationType.CREATE, update.instanceId)) {\n\t\t\t// This is a move operation and we are in the delete part of it.\n\t\t\t// Grab the other part to check the move destination.\n\t\t\tconst createOperation = assertNotNull(getEventOfType(updates, OperationType.CREATE, update.instanceId))\n\t\t\t// Is destination included in the search?\n\t\t\tif (this.listIdMatchesRestriction(createOperation.instanceListId, this.searchResult.restriction)) {\n\t\t\t\t// If so, skip the delete.\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\t// Otherwise delete\n\t\t\t\treturn update\n\t\t\t}\n\t\t} else {\n\t\t\treturn update\n\t\t}\n\t}\n\n\tprivate listIdMatchesRestriction(listId: string, restriction: SearchRestriction): boolean {\n\t\treturn restriction.folderIds.length === 0 || restriction.folderIds.includes(listId)\n\t}\n\n\tonNewUrl(args: Record<string, any>, requestedPath: string) {\n\t\tlet restriction\n\t\ttry {\n\t\t\trestriction = getRestriction(requestedPath)\n\t\t} catch (e) {\n\t\t\t// if restriction is broken replace it with non-broken version\n\t\t\tthis.router.routeTo(args.query, createRestriction(SearchCategoryTypes.mail, null, null, null, [], null))\n\t\t\treturn\n\t\t}\n\n\t\tthis.currentQuery = args.query\n\t\tconst lastQuery = this.search.lastQueryString()\n\t\tconst maxResults = isSameTypeRef(MailTypeRef, restriction.type) ? SEARCH_PAGE_SIZE : null\n\t\tconst listModel = this._listModel\n\t\t// using hasOwnProperty to distinguish case when url is like '/search/mail/query='\n\t\tif (Object.hasOwn(args, \"query\") && this.search.isNewSearch(args.query, restriction)) {\n\t\t\tthis.searchResult = null\n\t\t\tlistModel.updateLoadingStatus(ListLoadingState.Loading)\n\t\t\tthis.search\n\t\t\t\t.search(\n\t\t\t\t\t{\n\t\t\t\t\t\tquery: args.query,\n\t\t\t\t\t\trestriction,\n\t\t\t\t\t\tminSuggestionCount: 0,\n\t\t\t\t\t\tmaxResults,\n\t\t\t\t\t},\n\t\t\t\t\tthis.progressTracker,\n\t\t\t\t)\n\t\t\t\t.then(() => listModel.updateLoadingStatus(ListLoadingState.Done))\n\t\t\t\t.catch(() => listModel.updateLoadingStatus(ListLoadingState.ConnectionLost))\n\t\t} else if (lastQuery && this.search.isNewSearch(lastQuery, restriction)) {\n\t\t\tthis.searchResult = null\n\n\t\t\t// If query is not set for some reason (e.g. switching search type), use the last query value\n\t\t\tlistModel.selectNone()\n\t\t\tlistModel.updateLoadingStatus(ListLoadingState.Loading)\n\t\t\tthis.search\n\t\t\t\t.search(\n\t\t\t\t\t{\n\t\t\t\t\t\tquery: lastQuery,\n\t\t\t\t\t\trestriction,\n\t\t\t\t\t\tminSuggestionCount: 0,\n\t\t\t\t\t\tmaxResults,\n\t\t\t\t\t},\n\t\t\t\t\tthis.progressTracker,\n\t\t\t\t)\n\t\t\t\t.then(() => listModel.updateLoadingStatus(ListLoadingState.Done))\n\t\t\t\t.catch(() => listModel.updateLoadingStatus(ListLoadingState.ConnectionLost))\n\t\t} else if (!Object.hasOwn(args, \"query\") && !lastQuery) {\n\t\t\t// no query at all yet\n\t\t\tlistModel.updateLoadingStatus(ListLoadingState.Done)\n\t\t}\n\n\t\tif (isSameTypeRef(restriction.type, ContactTypeRef)) {\n\t\t\tthis.loadAndSelectIfNeeded(args.id)\n\t\t} else {\n\t\t\tif (isSameTypeRef(restriction.type, MailTypeRef)) {\n\t\t\t\tthis._selectedMailField = restriction.field\n\t\t\t\tthis._startDate = restriction.end ? new Date(restriction.end) : null\n\t\t\t\tthis._endDate = restriction.start ? new Date(restriction.start) : null\n\t\t\t\tthis._selectedMailFolder = restriction.folderIds\n\t\t\t\tthis.loadAndSelectIfNeeded(args.id)\n\t\t\t\tthis.latestMailRestriction = restriction\n\t\t\t} else if (isSameTypeRef(restriction.type, CalendarEventTypeRef)) {\n\t\t\t\tthis._startDate = restriction.start ? new Date(restriction.start) : null\n\t\t\t\tthis._endDate = restriction.end ? new Date(restriction.end) : null\n\t\t\t\tthis._includeRepeatingEvents = restriction.eventSeries ?? true\n\t\t\t\tthis.lazyCalendarInfos.load()\n\t\t\t\tthis.userHasNewPaidPlan.load()\n\t\t\t\tthis.latestCalendarRestriction = restriction\n\n\t\t\t\t// Check if user is trying to search in a client only calendar while using a free account\n\t\t\t\tconst selectedCalendar = this.extractCalendarListIds(restriction.folderIds)\n\t\t\t\tif (!selectedCalendar || Array.isArray(selectedCalendar)) {\n\t\t\t\t\tthis._selectedCalendar = selectedCalendar\n\t\t\t\t} else if (CLIENT_ONLY_CALENDARS.has(selectedCalendar.toString())) {\n\t\t\t\t\tthis.getUserHasNewPaidPlan()\n\t\t\t\t\t\t.getAsync()\n\t\t\t\t\t\t.then((isNewPaidPlan) => {\n\t\t\t\t\t\t\tif (!isNewPaidPlan) {\n\t\t\t\t\t\t\t\treturn (this._selectedCalendar = null)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._selectedCalendar = selectedCalendar\n\t\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (args.id != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { start, id } = decodeCalendarSearchKey(args.id)\n\t\t\t\t\t\tthis.loadAndSelectIfNeeded(id, ({ entry }: SearchResultListEntry) => {\n\t\t\t\t\t\t\tentry = entry as CalendarEvent\n\t\t\t\t\t\t\treturn id === getElementId(entry) && start === entry.startTime.getTime()\n\t\t\t\t\t\t})\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tconsole.log(\"Invalid ID, selecting none\")\n\t\t\t\t\t\tthis.listModel.selectNone()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate extractCalendarListIds(listIds: string[]): readonly [string, string] | string | null {\n\t\tif (listIds.length < 1) return null\n\t\telse if (listIds.length === 1) return listIds[0]\n\n\t\treturn [listIds[0], listIds[1]]\n\t}\n\n\tprivate loadAndSelectIfNeeded(id: string | null, finder?: (a: ListElement) => boolean) {\n\t\t// nothing to select\n\t\tif (id == null) {\n\t\t\treturn\n\t\t}\n\n\t\tif (!this._listModel.isItemSelected(id)) {\n\t\t\tif (!this._listModel.isItemSelected(id)) {\n\t\t\t\tthis.handleLoadAndSelection(id, finder)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate handleLoadAndSelection(id: string, finder: ((a: ListElement) => boolean) | undefined) {\n\t\tif (this._listModel.isLoadedCompletely()) {\n\t\t\treturn this.selectItem(id, finder)\n\t\t}\n\n\t\tconst listStateStream = Stream.combine((a) => a(), [this._listModel.stateStream])\n\t\tlistStateStream.map((state) => {\n\t\t\tif (state.loadingStatus === ListLoadingState.Done) {\n\t\t\t\tthis.selectItem(id, finder)\n\t\t\t\tlistStateStream.end(true)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate selectItem(id: string, finder: ((a: ListElement) => boolean) | undefined) {\n\t\tconst listModel = this._listModel\n\t\tthis._listModel.loadAndSelect(id, () => !deepEqual(this._listModel, listModel), finder)\n\t}\n\n\tasync loadAll() {\n\t\tif (this.loadingAllForSearchResult != null) return\n\t\tthis.loadingAllForSearchResult = this.searchResult ?? null\n\t\tthis._listModel.selectAll()\n\t\ttry {\n\t\t\twhile (\n\t\t\t\tthis.searchResult?.restriction &&\n\t\t\t\tthis.loadingAllForSearchResult &&\n\t\t\t\tisSameSearchRestriction(this.searchResult?.restriction, this.loadingAllForSearchResult.restriction) &&\n\t\t\t\t!this._listModel.isLoadedCompletely()\n\t\t\t) {\n\t\t\t\tawait this._listModel.loadMore()\n\t\t\t\tif (\n\t\t\t\t\tthis.searchResult.restriction &&\n\t\t\t\t\tthis.loadingAllForSearchResult.restriction &&\n\t\t\t\t\tisSameSearchRestriction(this.searchResult.restriction, this.loadingAllForSearchResult.restriction)\n\t\t\t\t) {\n\t\t\t\t\tthis._listModel.selectAll()\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.loadingAllForSearchResult = null\n\t\t}\n\t}\n\n\tstopLoadAll() {\n\t\tthis._listModel.cancelLoadAll()\n\t}\n\n\tselectMailField(field: string | null): PaidFunctionResult {\n\t\tif (this.logins.getUserController().isFreeAccount() && field != null) {\n\t\t\treturn PaidFunctionResult.PaidSubscriptionNeeded\n\t\t} else {\n\t\t\tthis._selectedMailField = field\n\t\t\tthis.searchAgain()\n\t\t\treturn PaidFunctionResult.Success\n\t\t}\n\t}\n\n\tcanSelectTimePeriod(): boolean {\n\t\treturn !this.logins.getUserController().isFreeAccount()\n\t}\n\n\tgetStartOfTheWeekOffset(): number {\n\t\treturn getStartOfTheWeekOffsetForUser(this.logins.getUserController().userSettingsGroupRoot)\n\t}\n\n\tasync selectStartDate(startDate: Date | null): Promise<PaidFunctionResult> {\n\t\tif (isSameDayOfDate(this.startDate, startDate)) {\n\t\t\treturn PaidFunctionResult.Success\n\t\t}\n\n\t\tif (!this.canSelectTimePeriod()) {\n\t\t\treturn PaidFunctionResult.PaidSubscriptionNeeded\n\t\t}\n\n\t\t// If start date is outside the indexed range, suggest to extend the index and only if confirmed change the selected date.\n\t\t// Otherwise, keep the date as it was.\n\t\tif (\n\t\t\tstartDate &&\n\t\t\tthis.getCategory() === SearchCategoryTypes.mail &&\n\t\t\tstartDate.getTime() < this.search.indexState().currentMailIndexTimestamp &&\n\t\t\tstartDate\n\t\t) {\n\t\t\tconst confirmed = (await this.extendIndexConfirmationCallback?.()) ?? true\n\t\t\tif (confirmed) {\n\t\t\t\tthis._startDate = startDate\n\t\t\t\tthis.indexerFacade.extendMailIndex(startDate.getTime()).then(() => {\n\t\t\t\t\tthis.updateSearchUrl()\n\t\t\t\t\tthis.updateUi()\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// In this case it is not a success of payment, but we don't need to prompt for upgrade\n\t\t\t\treturn PaidFunctionResult.Success\n\t\t\t}\n\t\t} else {\n\t\t\tthis._startDate = startDate\n\t\t}\n\n\t\tthis.searchAgain()\n\n\t\treturn PaidFunctionResult.Success\n\t}\n\n\tselectEndDate(endDate: Date): PaidFunctionResult {\n\t\tif (isSameDayOfDate(this.endDate, endDate)) {\n\t\t\treturn PaidFunctionResult.Success\n\t\t}\n\n\t\tif (!this.canSelectTimePeriod()) {\n\t\t\treturn PaidFunctionResult.PaidSubscriptionNeeded\n\t\t}\n\n\t\tthis._endDate = endDate\n\n\t\tthis.searchAgain()\n\n\t\treturn PaidFunctionResult.Success\n\t}\n\n\tselectCalendar(calendarInfo: CalendarInfo | string | null) {\n\t\tif (typeof calendarInfo === \"string\" || calendarInfo == null) {\n\t\t\tthis._selectedCalendar = calendarInfo\n\t\t} else {\n\t\t\tthis._selectedCalendar = [calendarInfo.groupRoot.longEvents, calendarInfo.groupRoot.shortEvents]\n\t\t}\n\t\tthis.searchAgain()\n\t}\n\n\tselectMailFolder(folder: Array<string>): PaidFunctionResult {\n\t\tif (this.logins.getUserController().isFreeAccount() && folder != null) {\n\t\t\treturn PaidFunctionResult.PaidSubscriptionNeeded\n\t\t} else {\n\t\t\tthis._selectedMailFolder = folder\n\t\t\tthis.searchAgain()\n\t\t\treturn PaidFunctionResult.Success\n\t\t}\n\t}\n\n\tselectIncludeRepeatingEvents(include: boolean) {\n\t\tthis._includeRepeatingEvents = include\n\t\tthis.searchAgain()\n\t}\n\n\t/**\n\t * @returns null if the complete mailbox is indexed\n\t */\n\tgetCurrentMailIndexDate(): Date | null {\n\t\tlet timestamp = this.search.indexState().currentMailIndexTimestamp\n\n\t\tif (timestamp === FULL_INDEXED_TIMESTAMP) {\n\t\t\treturn null\n\t\t} else if (timestamp === NOTHING_INDEXED_TIMESTAMP) {\n\t\t\treturn getEndOfDay(new Date())\n\t\t} else {\n\t\t\treturn new Date(timestamp)\n\t\t}\n\t}\n\n\tprivate searchAgain() {\n\t\tthis.updateSearchUrl()\n\t\tthis.updateUi()\n\t}\n\n\tgetUrlFromSearchCategory(category: SearchCategoryTypes): string {\n\t\tif (this.currentQuery) {\n\t\t\tlet latestRestriction: SearchRestriction | null = null\n\t\t\tswitch (category) {\n\t\t\t\tcase SearchCategoryTypes.mail:\n\t\t\t\t\tlatestRestriction = this.latestMailRestriction\n\t\t\t\t\tbreak\n\t\t\t\tcase SearchCategoryTypes.calendar:\n\t\t\t\t\tlatestRestriction = this.latestCalendarRestriction\n\t\t\t\t\tbreak\n\t\t\t\tcase SearchCategoryTypes.contact:\n\t\t\t\t\t// contacts do not have restrictions at this time\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif (latestRestriction) {\n\t\t\t\treturn getSearchUrl(this.currentQuery, latestRestriction)\n\t\t\t} else {\n\t\t\t\treturn getSearchUrl(this.currentQuery, createRestriction(category, null, null, null, [], null))\n\t\t\t}\n\t\t} else {\n\t\t\treturn getSearchUrl(\"\", createRestriction(category, null, null, null, [], null))\n\t\t}\n\t}\n\n\tget mailFilter(): MailFilterType | null {\n\t\treturn this.mailFilterType\n\t}\n\n\tsetMailFilter(filter: MailFilterType | null) {\n\t\tthis.mailFilterType = filter\n\t\tthis.applyMailFilterIfNeeded()\n\t}\n\n\tprivate applyMailFilterIfNeeded() {\n\t\tif (isSameTypeRef(this.searchedType, MailTypeRef)) {\n\t\t\tconst filterFunction = getMailFilterForType(this.mailFilterType)\n\t\t\tconst liftedFilter: ListFilter<SearchResultListEntry> | null = filterFunction ? (entry) => filterFunction(entry.entry as Mail) : null\n\t\t\tthis._listModel?.setFilter(liftedFilter)\n\t\t}\n\t}\n\n\tprivate updateSearchUrl() {\n\t\tconst selectedElement = this._listModel.state.selectedItems.size === 1 ? this._listModel.getSelectedAsArray().at(0) : null\n\n\t\tif (isSameTypeRef(this.searchedType, MailTypeRef)) {\n\t\t\tthis.routeMail(\n\t\t\t\t(selectedElement?.entry as Mail) ?? null,\n\t\t\t\tcreateRestriction(\n\t\t\t\t\tthis.getCategory(),\n\t\t\t\t\tthis._endDate ? getEndOfDay(this._endDate).getTime() : null,\n\t\t\t\t\tthis._startDate ? getStartOfDay(this._startDate).getTime() : null,\n\t\t\t\t\tthis._selectedMailField,\n\t\t\t\t\tthis._selectedMailFolder,\n\t\t\t\t\tnull,\n\t\t\t\t),\n\t\t\t)\n\t\t} else if (isSameTypeRef(this.searchedType, CalendarEventTypeRef)) {\n\t\t\tthis.routeCalendar(\n\t\t\t\t(selectedElement?.entry as CalendarEvent) ?? null,\n\t\t\t\tcreateRestriction(\n\t\t\t\t\tthis.getCategory(),\n\t\t\t\t\tthis._startDate ? getStartOfDay(this._startDate).getTime() : null,\n\t\t\t\t\tthis._endDate ? getEndOfDay(this._endDate).getTime() : null,\n\t\t\t\t\tnull,\n\t\t\t\t\tthis.getFolderIds(),\n\t\t\t\t\tthis._includeRepeatingEvents,\n\t\t\t\t),\n\t\t\t)\n\t\t} else if (isSameTypeRef(this.searchedType, ContactTypeRef)) {\n\t\t\tthis.routeContact((selectedElement?.entry as Contact) ?? null, createRestriction(this.getCategory(), null, null, null, [], null))\n\t\t}\n\t}\n\n\tprivate getFolderIds() {\n\t\tif (typeof this.selectedCalendar === \"string\") {\n\t\t\treturn [this.selectedCalendar]\n\t\t} else if (this.selectedCalendar != null) {\n\t\t\treturn [...this.selectedCalendar]\n\t\t}\n\n\t\treturn []\n\t}\n\n\tprivate routeCalendar(element: CalendarEvent | null, restriction: SearchRestriction) {\n\t\tconst selectionKey = this.generateSelectionKey(element)\n\t\tthis.router.routeTo(this.currentQuery, restriction, selectionKey)\n\t}\n\n\tprivate routeMail(element: Mail | null, restriction: SearchRestriction) {\n\t\tthis.router.routeTo(this.currentQuery, restriction, this.generateSelectionKey(element))\n\t}\n\n\tprivate routeContact(element: Contact | null, restriction: SearchRestriction) {\n\t\tthis.router.routeTo(this.currentQuery, restriction, this.generateSelectionKey(element))\n\t}\n\n\tprivate generateSelectionKey(element: SearchableTypes | null): string | null {\n\t\tif (element == null) return null\n\t\tif (assertIsEntity(element, CalendarEventTypeRef)) {\n\t\t\treturn encodeCalendarSearchKey(element)\n\t\t} else {\n\t\t\treturn getElementId(element)\n\t\t}\n\t}\n\n\tprivate getCategory(): SearchCategoryTypes {\n\t\tconst restriction = this.router.getRestriction()\n\t\treturn searchCategoryForRestriction(restriction)\n\t}\n\n\tprivate async onMailboxesChanged(mailboxes: MailboxDetail[]) {\n\t\tthis._mailboxes = mailboxes\n\n\t\t// if selected folder no longer exist select another one\n\t\tconst selectedMailFolder = this._selectedMailFolder\n\n\t\tif (selectedMailFolder[0]) {\n\t\t\tconst mailFolder = await mailLocator.mailModel.getMailSetById(selectedMailFolder[0])\n\t\t\tif (!mailFolder) {\n\t\t\t\tconst folderSystem = assertNotNull(mailLocator.mailModel.getFolderSystemByGroupId(mailboxes[0].mailGroup._id))\n\t\t\t\tthis._selectedMailFolder = [getElementId(assertNotNull(folderSystem.getSystemFolderByType(MailSetKind.INBOX)))]\n\t\t\t\tthis.updateUi()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isPossibleABirthdayContactUpdate(update: EntityUpdateData): boolean {\n\t\tif (isUpdateForTypeRef(ContactTypeRef, update) && isSameTypeRef(this.searchedType, CalendarEventTypeRef)) {\n\t\t\tconst { instanceListId, instanceId } = update\n\t\t\tconst encodedContactId = stringToBase64(`${instanceListId}/${instanceId}`)\n\n\t\t\treturn this.listModel.stateStream().items.some((searchEntry) => searchEntry._id[1].endsWith(encodedContactId))\n\t\t}\n\n\t\treturn false\n\t}\n\n\tprivate isSelectedEventAnUpdatedBirthday(update: EntityUpdateData): boolean {\n\t\tif (isUpdateForTypeRef(ContactTypeRef, update) && isSameTypeRef(this.searchedType, CalendarEventTypeRef)) {\n\t\t\tconst { instanceListId, instanceId } = update\n\t\t\tconst encodedContactId = stringToBase64(`${instanceListId}/${instanceId}`)\n\n\t\t\tconst selectedItem = this.listModel.getSelectedAsArray().at(0)\n\t\t\tif (!selectedItem) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn selectedItem._id[1].endsWith(encodedContactId)\n\t\t}\n\n\t\treturn false\n\t}\n\n\tprivate async entityEventReceived(update: EntityUpdateData): Promise<void> {\n\t\tconst lastType = this.searchedType\n\t\tconst isPossibleABirthdayContactUpdate = this.isPossibleABirthdayContactUpdate(update)\n\n\t\tif (!isUpdateForTypeRef(lastType, update) && !isPossibleABirthdayContactUpdate) {\n\t\t\treturn\n\t\t}\n\n\t\tconst { instanceListId, instanceId, operation } = update\n\t\tconst id = [neverNull(instanceListId), instanceId] as const\n\t\tconst typeRef = new TypeRef<SomeEntity>(update.application, update.type)\n\n\t\tif (!this.isInSearchResult(typeRef, id) && !isPossibleABirthdayContactUpdate) {\n\t\t\treturn\n\t\t}\n\n\t\tif (isUpdateForTypeRef(MailTypeRef, update) && operation === OperationType.UPDATE) {\n\t\t\tif (this.searchResult && this.searchResult.results) {\n\t\t\t\tconst index = this.searchResult?.results.findIndex(\n\t\t\t\t\t(email) => update.instanceId === elementIdPart(email) && update.instanceListId !== listIdPart(email),\n\t\t\t\t)\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tconst restrictionLength = this.searchResult.restriction.folderIds.length\n\t\t\t\t\tif ((restrictionLength > 0 && this.searchResult.restriction.folderIds.includes(update.instanceListId)) || restrictionLength === 0) {\n\t\t\t\t\t\t// We need to update the listId of the updated item, since it was moved to another folder.\n\t\t\t\t\t\tconst newIdTuple: IdTuple = [update.instanceListId, update.instanceId]\n\t\t\t\t\t\tthis.searchResult.results[index] = newIdTuple\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ((isUpdateForTypeRef(CalendarEventTypeRef, update) && isSameTypeRef(lastType, CalendarEventTypeRef)) || isPossibleABirthdayContactUpdate) {\n\t\t\t// due to the way calendar event changes are sort of non-local, we throw away the whole list and re-render it if\n\t\t\t// the contents are edited. we do the calculation on a new list and then swap the old list out once the new one is\n\t\t\t// ready\n\t\t\tconst selectedItem = this._listModel.getSelectedAsArray().at(0)\n\t\t\tconst listModel = this.createList()\n\t\t\tthis.setMailFilter(this.mailFilterType)\n\t\t\tthis.applyMailFilterIfNeeded()\n\n\t\t\tif (isPossibleABirthdayContactUpdate && (await this.eventsRepository.canLoadBirthdaysCalendar())) {\n\t\t\t\tawait this.eventsRepository.loadContactsBirthdays(true)\n\t\t\t}\n\n\t\t\tawait listModel.loadInitial()\n\t\t\tif (selectedItem != null) {\n\t\t\t\tif (isPossibleABirthdayContactUpdate && this.isSelectedEventAnUpdatedBirthday(update)) {\n\t\t\t\t\t// We must invalidate the selected item to refresh the contact preview\n\t\t\t\t\tthis.listModel.selectNone()\n\t\t\t\t}\n\t\t\t\tawait listModel.loadAndSelect(elementIdPart(selectedItem._id), () => false)\n\t\t\t}\n\t\t\tthis._listModel = listModel\n\t\t\tthis.listStateSubscription?.end(true)\n\t\t\tthis.listStateSubscription = this._listModel.stateStream.map((state) => this.onListStateChange(state))\n\t\t\tthis.updateSearchUrl()\n\t\t\tthis.updateUi()\n\t\t\treturn\n\t\t}\n\n\t\tthis._listModel.getUnfilteredAsArray()\n\t\tawait this._listModel.entityEventReceived(instanceListId, instanceId, operation)\n\t\t// run the mail or contact update after the update on the list is finished to avoid parallel loading\n\t\tif (operation === OperationType.UPDATE && this._listModel?.isItemSelected(elementIdPart(id))) {\n\t\t\ttry {\n\t\t\t\tawait this.entityClient.load(typeRef, id)\n\t\t\t\tthis.updateUi()\n\t\t\t} catch (e) {\n\t\t\t\t// ignore. might happen if a mail was just sent\n\t\t\t}\n\t\t}\n\t}\n\n\tgetSelectedMails(): Mail[] {\n\t\treturn this._listModel\n\t\t\t.getSelectedAsArray()\n\t\t\t.map((e) => e.entry)\n\t\t\t.filter(assertIsEntity2(MailTypeRef))\n\t}\n\n\tgetSelectedContacts(): Contact[] {\n\t\treturn this._listModel\n\t\t\t.getSelectedAsArray()\n\t\t\t.map((e) => e.entry)\n\t\t\t.filter(assertIsEntity2(ContactTypeRef))\n\t}\n\n\tgetSelectedEvents(): CalendarEvent[] {\n\t\treturn this._listModel\n\t\t\t.getSelectedAsArray()\n\t\t\t.map((e) => e.entry)\n\t\t\t.filter(assertIsEntity2(CalendarEventTypeRef))\n\t}\n\n\tprivate onListStateChange(newState: ListState<SearchResultListEntry>) {\n\t\tif (isSameTypeRef(this.searchedType, MailTypeRef)) {\n\t\t\tif (!newState.inMultiselect && newState.selectedItems.size === 1) {\n\t\t\t\tconst mail = this.getSelectedMails()[0]\n\n\t\t\t\t// Sometimes a stale state is passed through, resulting in no mail\n\t\t\t\tif (mail) {\n\t\t\t\t\tif (!this._conversationViewModel) {\n\t\t\t\t\t\tthis.updateDisplayedConversation(mail)\n\t\t\t\t\t} else if (this._conversationViewModel) {\n\t\t\t\t\t\tconst isSameElementId = isSameId(elementIdPart(this._conversationViewModel?.primaryMail._id), elementIdPart(mail._id))\n\t\t\t\t\t\tconst isSameListId = isSameId(listIdPart(this._conversationViewModel?.primaryMail._id), listIdPart(mail._id))\n\t\t\t\t\t\tif (!isSameElementId || !isSameListId) {\n\t\t\t\t\t\t\tthis.updateSearchUrl()\n\t\t\t\t\t\t\tthis.updateDisplayedConversation(mail)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._conversationViewModel = null\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._conversationViewModel = null\n\t\t\t}\n\t\t} else {\n\t\t\tthis._conversationViewModel = null\n\t\t}\n\t\tthis.updateUi()\n\t}\n\n\tprivate updateDisplayedConversation(mail: Mail): void {\n\t\tif (this.conversationViewModelFactory && this.mailOpenedListener) {\n\t\t\tthis._conversationViewModel = this.conversationViewModelFactory({ mail, showFolder: true })\n\t\t\t// Notify the admin client about the mail being selected\n\t\t\tthis.mailOpenedListener.onEmailOpened(mail)\n\t\t}\n\t}\n\n\tprivate createList(): ListElementListModel<SearchResultListEntry> {\n\t\t// since we recreate the list every time we set a new result object,\n\t\t// we bind the value of result for the lifetime of this list model\n\t\t// at this point\n\t\t// note in case of refactor: the fact that the list updates the URL every time it changes\n\t\t// its state is a major source of complexity and makes everything very order-dependent\n\t\treturn new ListElementListModel<SearchResultListEntry>({\n\t\t\tfetch: async (lastFetchedEntity: SearchResultListEntry, count: number) => {\n\t\t\t\tconst startId = lastFetchedEntity == null ? GENERATED_MAX_ID : getElementId(lastFetchedEntity)\n\n\t\t\t\tconst lastResult = this.searchResult\n\t\t\t\tif (lastResult !== this.searchResult) {\n\t\t\t\t\tconsole.warn(\"got a fetch request for outdated results object, ignoring\")\n\t\t\t\t\t// this._searchResults was reassigned, we'll create a new ListElementListModel soon\n\t\t\t\t\treturn { items: [], complete: true }\n\t\t\t\t}\n\t\t\t\tawait awaitSearchInitialized(this.search)\n\n\t\t\t\tif (!lastResult || (lastResult.results.length === 0 && !hasMoreResults(lastResult))) {\n\t\t\t\t\treturn { items: [], complete: true }\n\t\t\t\t}\n\n\t\t\t\tconst { items, newSearchResult } = await this.loadSearchResults(lastResult, startId, count)\n\t\t\t\tconst entries = items.map((instance) => new SearchResultListEntry(instance))\n\t\t\t\tconst complete = !hasMoreResults(newSearchResult)\n\n\t\t\t\treturn { items: entries, complete }\n\t\t\t},\n\t\t\tloadSingle: async (_listId: Id, elementId: Id) => {\n\t\t\t\tconst lastResult = this.searchResult\n\t\t\t\tif (!lastResult) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tconst id = lastResult.results.find((resultId) => elementIdPart(resultId) === elementId)\n\t\t\t\tif (id) {\n\t\t\t\t\treturn this.entityClient\n\t\t\t\t\t\t.load(lastResult.restriction.type, id)\n\t\t\t\t\t\t.then((entity) => new SearchResultListEntry(entity))\n\t\t\t\t\t\t.catch(\n\t\t\t\t\t\t\tofClass(NotFoundError, (_) => {\n\t\t\t\t\t\t\t\treturn null\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t},\n\t\t\tsortCompare: (o1: SearchResultListEntry, o2: SearchResultListEntry) => {\n\t\t\t\tif (isSameTypeRef(o1.entry._type, ContactTypeRef)) {\n\t\t\t\t\treturn compareContacts(o1.entry as any, o2.entry as any)\n\t\t\t\t} else if (isSameTypeRef(o1.entry._type, CalendarEventTypeRef)) {\n\t\t\t\t\treturn downcast(o1.entry).startTime.getTime() - downcast(o2.entry).startTime.getTime()\n\t\t\t\t} else {\n\t\t\t\t\treturn sortCompareByReverseId(o1.entry, o2.entry)\n\t\t\t\t}\n\t\t\t},\n\t\t\tautoSelectBehavior: () => (isSameTypeRef(this.searchedType, MailTypeRef) ? this.selectionBehavior : ListAutoSelectBehavior.OLDER),\n\t\t})\n\t}\n\n\tprivate isInSearchResult(typeRef: TypeRef<unknown>, id: IdTuple): boolean {\n\t\tconst result = this.searchResult\n\n\t\tif (result && isSameTypeRef(typeRef, result.restriction.type)) {\n\t\t\t// The list id must be null/empty, otherwise the user is filtering by list, and it shouldn't be ignored\n\n\t\t\tconst ignoreList = isSameTypeRef(typeRef, MailTypeRef) && result.restriction.folderIds.length === 0\n\n\t\t\treturn result.results.some((r) => this.compareItemId(r, id, ignoreList))\n\t\t}\n\n\t\treturn false\n\t}\n\n\tprivate compareItemId(id1: IdTuple, id2: IdTuple, ignoreList: boolean) {\n\t\treturn ignoreList ? isSameId(elementIdPart(id1), elementIdPart(id2)) : isSameId(id1, id2)\n\t}\n\n\tprivate async loadSearchResults<T extends SearchableTypes>(\n\t\tcurrentResult: SearchResult,\n\t\tstartId: Id,\n\t\tcount: number,\n\t): Promise<{ items: T[]; newSearchResult: SearchResult }> {\n\t\tconst updatedResult = hasMoreResults(currentResult) ? await this.searchFacade.getMoreSearchResults(currentResult, count) : currentResult\n\n\t\t// we need to override global reference for other functions\n\t\tthis.searchResult = updatedResult\n\n\t\tlet items\n\t\tif (isSameTypeRef(currentResult.restriction.type, MailTypeRef)) {\n\t\t\tlet startIndex = 0\n\n\t\t\tif (startId !== GENERATED_MAX_ID) {\n\t\t\t\t// this relies on the results being sorted from newest to oldest ID\n\t\t\t\tstartIndex = updatedResult.results.findIndex((id) => id[1] <= startId)\n\t\t\t\tif (elementIdPart(updatedResult.results[startIndex]) === startId) {\n\t\t\t\t\t// the start element is already loaded, so we exclude it from the next load\n\t\t\t\t\tstartIndex++\n\t\t\t\t} else if (startIndex === -1) {\n\t\t\t\t\t// there is nothing in our result that's not loaded yet, so we\n\t\t\t\t\t// have nothing to do\n\t\t\t\t\tstartIndex = Math.max(updatedResult.results.length - 1, 0)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ignore count when slicing here because we would have to modify SearchResult too\n\t\t\tconst toLoad = updatedResult.results.slice(startIndex)\n\t\t\titems = await this.loadAndFilterInstances(currentResult.restriction.type, toLoad, updatedResult, startIndex)\n\t\t} else if (isSameTypeRef(currentResult.restriction.type, ContactTypeRef)) {\n\t\t\ttry {\n\t\t\t\t// load all contacts to sort them by name afterwards\n\t\t\t\titems = await this.loadAndFilterInstances(currentResult.restriction.type, updatedResult.results, updatedResult, 0)\n\t\t\t} finally {\n\t\t\t\tthis.updateUi()\n\t\t\t}\n\t\t} else if (isSameTypeRef(currentResult.restriction.type, CalendarEventTypeRef)) {\n\t\t\ttry {\n\t\t\t\tconst { start, end } = currentResult.restriction\n\t\t\t\tif (start == null || end == null) {\n\t\t\t\t\tthrow new ProgrammingError(\"invalid search time range for calendar\")\n\t\t\t\t}\n\t\t\t\titems = [\n\t\t\t\t\t...(await this.calendarFacade.reifyCalendarSearchResult(start, end, updatedResult.results)),\n\t\t\t\t\t...(await this.getClientOnlyEventsSeries(start, end, updatedResult.results)),\n\t\t\t\t]\n\t\t\t} finally {\n\t\t\t\tthis.updateUi()\n\t\t\t}\n\t\t} else {\n\t\t\t// this type is not shown in the search view, e.g. group info\n\t\t\titems = []\n\t\t}\n\n\t\treturn { items: items, newSearchResult: updatedResult }\n\t}\n\n\tprivate async getClientOnlyEventsSeries(start: number, end: number, events: IdTuple[]) {\n\t\tconst eventList = await retrieveClientOnlyEventsForUser(this.logins, events, this.eventsRepository.getBirthdayEvents())\n\t\treturn generateCalendarInstancesInRange(eventList, { start, end })\n\t}\n\n\t/**\n\t * take a list of IDs and load them by list, filtering out the ones that could not be loaded.\n\t * updates the passed currentResult.result list to not include the failed IDs anymore\n\t */\n\tprivate async loadAndFilterInstances<T extends ListElementEntity>(\n\t\ttype: TypeRef<T>,\n\t\ttoLoad: IdTuple[],\n\t\tcurrentResult: SearchResult,\n\t\tstartIndex: number,\n\t): Promise<T[]> {\n\t\tconst instances = await loadMultipleFromLists(type, this.entityClient, toLoad)\n\t\t// Filter not found instances from the current result as well so we donâ€™t loop trying to load them\n\t\tif (instances.length < toLoad.length) {\n\t\t\tconst resultLength = currentResult.results.length\n\t\t\tconsole.log(`Could not load some results: ${instances.length} out of ${toLoad.length}`)\n\n\t\t\t// loop backwards to remove correct elements by index\n\t\t\tfor (let i = toLoad.length - 1; i >= 0; i--) {\n\t\t\t\tconst toLoadId = toLoad[i]\n\n\t\t\t\tif (!instances.some((instance) => isSameId(instance._id, toLoadId))) {\n\t\t\t\t\tcurrentResult.results.splice(startIndex + i, 1)\n\n\t\t\t\t\tif (instances.length === toLoad.length) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(`Fixed results, before ${resultLength}, after: ${currentResult.results.length}`)\n\t\t}\n\n\t\treturn instances\n\t}\n\n\tsendStopLoadingSignal() {\n\t\tthis.search.sendCancelSignal()\n\t}\n\n\tgetLocalCalendars() {\n\t\treturn getClientOnlyCalendars(this.logins.getUserController().userId, this.localCalendars)\n\t}\n\n\tdispose() {\n\t\tthis.stopLoadAll()\n\t\tthis.extendIndexConfirmationCallback = null\n\t\tthis.resultSubscription?.end(true)\n\t\tthis.resultSubscription = null\n\t\tthis.mailboxSubscription?.end(true)\n\t\tthis.mailboxSubscription = null\n\t\tthis.listStateSubscription?.end(true)\n\t\tthis.listStateSubscription = null\n\t\tthis.search.sendCancelSignal()\n\t\tthis.eventController.removeEntityListener(this.entityEventsListener)\n\t}\n\n\tgetLabelsForMail(mail: Mail): MailFolder[] {\n\t\treturn mailLocator.mailModel.getLabelsForMail(mail)\n\t}\n}\n\nfunction awaitSearchInitialized(searchModel: SearchModel): Promise<unknown> {\n\tconst deferred = defer<unknown>()\n\tconst dep = searchModel.indexState.map((state) => {\n\t\tif (!state.initializing) {\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tdep.end(true)\n\t\t\t\tdeferred.resolve(undefined)\n\t\t\t})\n\t\t}\n\t})\n\treturn deferred.promise\n}\n"],"mappings":"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"}