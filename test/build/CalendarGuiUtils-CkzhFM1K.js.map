{"version":3,"file":"CalendarGuiUtils-CkzhFM1K.js","names":["initialValues: Partial<Stripped<CalendarEvent>>","eventType: EventType","operation: CalendarOperation","calendars: ReadonlyMap<Id, CalendarInfo>","_selectedCalendar: CalendarInfo","userController: UserController","isNew: boolean","ownMailAddresses: ReadonlyArray<EncryptedMailAddress>","recipientsModel: RecipientsModel","responseTo: Mail | null","passwordStrengthModel: (password: string, recipientInfo: PartialRecipient) => number","sendMailModelFactory: lazy<SendMailModel>","uiUpdateCallback: () => void","v: CalendarInfo","groupSettings: GroupSettings[]","groupId: Id","a: PartialRecipient","recipient: Recipient","a: CalendarEventAttendee","address: string","contact: Contact | null","address: EncryptedMailAddress","status: CalendarAttendeeStatus","password: string","attendees: ReadonlyArray<CalendarEventAttendee>","responseModel: SendMailModel","initialAttendees: ReadonlyMap<unknown, CalendarEventAttendee>","currentAttendees: ReadonlyMap<unknown, CalendarEventAttendee>","isOrganizer: boolean","attendeesToInvite: ReadonlyArray<CalendarEventAttendee>","attendeesToUpdate: ReadonlyArray<CalendarEventAttendee>","organizer: CalendarEventAttendee | null","ownAttendee: CalendarEventAttendee | null","allAttendees: Array<CalendarEventAttendee>","eventType: EventType","alarms: Array<AlarmInterval>","dateProvider: DateProvider","uiUpdateCallback: () => void","trigger: AlarmInterval | null","alarmInterval: AlarmInterval","alarmIntervalList: AlarmInterval[]","alarmOne: AlarmInterval","alarmTwo: AlarmInterval","text: string","sanitizer: HtmlSanitizer","uiUpdateCallback: () => void","v: string","notificationSender: CalendarNotificationSender","loginController: LoginController","event: CalendarEvent","recurrenceIds: Array<Date>","sendModels: CalendarNotificationSendModels","inviteModel: SendMailModel","cancelModel: SendMailModel","updateModel: SendMailModel","newEvent: CalendarEvent","responseModel: SendMailModel","calendarModel: CalendarModel","logins: LoginController","notificationModel: CalendarNotificationModel","lazyRecurrenceIds: (uid?: string | null) => Promise<Array<Date>>","showProgress: ShowProgressCallback","zone: string","editModels: CalendarEventEditModels","editModelsForProgenitor: CalendarEventEditModels","existingEvent: CalendarEvent","recurrenceIds: Array<Date>","sendModels","newEvent","newAlarms","existingInstance: CalendarEvent","progenitor: CalendarEvent","existingAlteredInstance: CalendarEvent","text: string","uiUpdateCallback: () => void","operation: CalendarOperation","initialValues: Partial<CalendarEvent>","recipientsModel: RecipientsModel","calendarModel: CalendarModel","logins: LoginController","mailboxDetail: MailboxDetail","mailboxProperties: MailboxProperties","sendMailModelFactory: lazy<SendMailModel>","notificationSender: CalendarNotificationSender","entityClient: EntityClient","responseTo: Mail | null","zone: string","showProgress: ShowProgressCallback","uiUpdateCallback: () => void","m","password: string","recipientInfo: PartialRecipient","initializationEvent: CalendarEvent","uid?: string","makeEditModels: (i: StrippedEntity<CalendarEvent>) => CalendarEventEditModels","applyStrategies: CalendarEventApplyStrategies","resolveProgenitor: () => Promise<CalendarEvent | null>","existingInstanceIdentity: CalendarEvent","cleanInitialValues: StrippedEntity<CalendarEvent>","editModels: CalendarEventEditModels","apply: () => Promise<void>","mayRequireSendingUpdates: () => boolean","strategy: CalendarEventModelStrategy","eventType: EventType","userController: UserController","distributor: CalendarNotificationSender","calendars: ReadonlyMap<Id, CalendarInfo>","now: CalendarEvent","previous: Partial<CalendarEvent> | null","models: CalendarEventEditModels","existingEvent: CalendarEvent","values: CalendarEventValues","identity: Require<\"uid\", Partial<CalendarEventIdentity>>","identity","alarms: CalendarEvent[\"alarmInfos\"]","user: User","initialValues: StrippedEntity<CalendarEvent>","event?: Partial<CalendarEvent> | null","ownerGroup: string | null","alertDialog: Dialog","positive: boolean","weeks: Array<Array<Date>>","hourDivision: number","date: Date","firstDayOfWeekFromOffset: number","weekdayNarrowFormat: boolean","weeks: Array<Array<CalendarDay>>","weekdays: string[]","event: CalendarEventTimes","zone: string","includeTimezone: boolean","value: AlarmInterval","locale: string","unit: AlarmIntervalUnit","CALENDAR_EVENT_HEIGHT: number","event: CalendarEvent","groupColors: GroupColors","status: CalendarAttendeeStatus","iconForAttendeeStatus: Record<CalendarAttendeeStatus, AllIcons>","userSettingsGroupRoot: UserSettingsGroupRoot","userId: Id","clientOnlyCalendarsInfo: Map<Id, ClientOnlyCalendarsInfo>","colors: Map<Id, string>","clientOnlyCalendarInfo: Map<Id, ClientOnlyCalendarsInfo>","userCalendars: (ClientOnlyCalendarsInfo & { id: string; name: string })[]","existingEvent: Partial<CalendarEvent>","calendars: ReadonlyMap<Id, CalendarInfo>","ownMailAddresses: ReadonlyArray<string>","userController: UserController","wouldRequireUpdates: boolean","e: CalendarEvent","hiddenCalendars: ReadonlySet<Id>","model: CalendarEventPreviewViewModel","ev: MouseEvent","receiver: HTMLElement","onClose?: () => unknown","title: string","selectedCalendar: CalendarInfo | null","groupColors: Map<Id, string>"],"sources":["../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventWhoModel.ts","../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventAlarmModel.ts","../../src/common/misc/SanitizedTextViewModel.ts","../../src/calendar-app/calendar/gui/eventeditor-model/CalendarNotificationModel.ts","../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventModelStrategy.ts","../../src/common/misc/SimpleTextViewModel.ts","../../src/calendar-app/calendar/gui/eventeditor-model/CalendarEventModel.ts","../../src/calendar-app/calendar/gui/CalendarGuiUtils.ts"],"sourcesContent":["import {\n\tCalendarEvent,\n\tCalendarEventAttendee,\n\tContact,\n\tcreateCalendarEventAttendee,\n\tcreateEncryptedMailAddress,\n\tEncryptedMailAddress,\n\tGroupSettings,\n\tMail,\n} from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { PartialRecipient, Recipient, RecipientType } from \"../../../../common/api/common/recipients/Recipient.js\"\nimport { haveSameId, Stripped } from \"../../../../common/api/common/utils/EntityUtils.js\"\nimport { cleanMailAddress, findRecipientWithAddress } from \"../../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { assertNotNull, clone, defer, DeferredObject, findAll, lazy, noOp, trisectingDiff } from \"@tutao/tutanota-utils\"\nimport { CalendarAttendeeStatus, ConversationType, ShareCapability } from \"../../../../common/api/common/TutanotaConstants.js\"\nimport { RecipientsModel, ResolveMode } from \"../../../../common/api/main/RecipientsModel.js\"\nimport { Guest } from \"../../view/CalendarInvites.js\"\nimport { isSecurePassword } from \"../../../../common/misc/passwords/PasswordUtils.js\"\nimport { SendMailModel } from \"../../../../common/mailFunctionality/SendMailModel.js\"\nimport { CalendarInfo } from \"../../model/CalendarModel.js\"\nimport { hasCapabilityOnGroup } from \"../../../../common/sharing/GroupUtils.js\"\nimport { UserController } from \"../../../../common/api/main/UserController.js\"\nimport { UserError } from \"../../../../common/api/main/UserError.js\"\nimport { CalendarOperation, EventType } from \"./CalendarEventModel.js\"\nimport { ProgrammingError } from \"../../../../common/api/common/error/ProgrammingError.js\"\nimport { CalendarNotificationSendModels } from \"./CalendarNotificationModel.js\"\nimport { getContactDisplayName } from \"../../../../common/contactsFunctionality/ContactUtils.js\"\nimport { RecipientField } from \"../../../../common/mailFunctionality/SharedMailUtils.js\"\nimport { hasSourceUrl } from \"../../../../common/calendar/date/CalendarUtils\"\nimport { lang } from \"../../../../common/misc/LanguageViewModel.js\"\n\n/** there is no point in returning recipients, the SendMailModel will re-resolve them anyway. */\ntype AttendanceModelResult = {\n\tattendees: CalendarEvent[\"attendees\"]\n\torganizer: CalendarEvent[\"organizer\"]\n\tisConfidential: boolean\n\t/** which calendar should the result be assigned to */\n\tcalendar: CalendarInfo\n} & CalendarNotificationSendModels\n\n/** model to decouple attendee list edit operations from other changes to a calendar event.\n * tracks external passwords, attendance status, list of attendees, recipients to invite,\n * update, cancel and the calendar the event is in.\n */\nexport class CalendarEventWhoModel {\n\t/** we need to resolve recipients to know if we need to show an external password field. */\n\tprivate readonly resolvedRecipients: Map<string, Recipient> = new Map()\n\tprivate pendingRecipients: number = 0\n\tprivate _recipientsSettled: DeferredObject<void> = defer()\n\t/** it's possible that the consumer cares about all the recipient information being resolved, but that's only possible in an async way. */\n\tget recipientsSettled(): Promise<void> {\n\t\treturn this._recipientsSettled.promise\n\t}\n\n\t/** external password for an external attendee with an address */\n\tprivate readonly externalPasswords: Map<string, string> = new Map()\n\n\t/** to know who to update, we need to know who was already on the guest list.\n\t * we keep the attendees in maps for deduplication, keyed by their address.\n\t * */\n\tprivate initialAttendees: Map<string, CalendarEventAttendee> = new Map()\n\tprivate initialOwnAttendeeStatus: CalendarAttendeeStatus | null = null\n\t/** we only show the send update checkbox if there are attendees that require updates from us. */\n\treadonly initiallyHadOtherAttendees: boolean\n\t/** the current list of attendees. */\n\tprivate _attendees: Map<string, CalendarEventAttendee> = new Map()\n\t/** organizer MUST be set if _ownAttendee is - we're either both, we're invited and someone else is organizer or there are no guests at all. */\n\tprivate _organizer: CalendarEventAttendee | null = null\n\t/** the attendee that has one of our mail addresses. MUST NOT be in _attendees */\n\tprivate _ownAttendee: CalendarEventAttendee | null = null\n\n\tpublic isConfidential: boolean\n\t/**\n\t * whether this user will send updates for this event.\n\t * * this needs to be our event.\n\t * * we need a paid account\n\t * * there need to be changes that require updating the attendees (eg alarms do not)\n\t * * there also need to be attendees that require updates/invites/cancellations/response\n\t */\n\tshouldSendUpdates: boolean = false\n\n\t/**\n\t *\n\t * @param initialValues\n\t * @param eventType\n\t * @param operation the operation the user is currently attempting. we could use recurrenceId on initialvalues for this information, but this is safer.\n\t * @param calendars\n\t * @param _selectedCalendar\n\t * @param userController\n\t * @param isNew whether the event is new (never been saved)\n\t * @param ownMailAddresses an array of the mail addresses this user could be mentioned as as an attendee or organizer.\n\t * @param recipientsModel\n\t * @param responseTo\n\t * @param passwordStrengthModel\n\t * @param sendMailModelFactory\n\t * @param uiUpdateCallback\n\t */\n\tconstructor(\n\t\tinitialValues: Partial<Stripped<CalendarEvent>>,\n\t\tprivate readonly eventType: EventType,\n\t\tprivate readonly operation: CalendarOperation,\n\t\tprivate readonly calendars: ReadonlyMap<Id, CalendarInfo>,\n\t\t/** this should only be relevant to saving so could be put in the apply strategy, but at the moment we restrict attendees depending on the\n\t\t * calendar we're saving to.\n\t\t * think of it as configuring who has access to the event.\n\t\t * */\n\t\tprivate _selectedCalendar: CalendarInfo,\n\t\tprivate readonly userController: UserController,\n\t\tprivate readonly isNew: boolean,\n\t\tprivate readonly ownMailAddresses: ReadonlyArray<EncryptedMailAddress>,\n\t\tprivate readonly recipientsModel: RecipientsModel,\n\t\tprivate readonly responseTo: Mail | null,\n\t\tprivate readonly passwordStrengthModel: (password: string, recipientInfo: PartialRecipient) => number,\n\t\tprivate readonly sendMailModelFactory: lazy<SendMailModel>,\n\t\tprivate readonly uiUpdateCallback: () => void = noOp,\n\t) {\n\t\tthis.setupAttendees(initialValues)\n\t\t// resolve current recipients so that we know what external passwords to display\n\t\tconst resolvePromises = initialValues.attendees?.map((a) => this.resolveAndCacheAddress(a.address)).concat() ?? []\n\t\tif (initialValues.organizer) {\n\t\t\tresolvePromises.push(this.resolveAndCacheAddress(initialValues.organizer))\n\t\t}\n\t\tPromise.all(resolvePromises).then(this.uiUpdateCallback)\n\n\t\tthis.initiallyHadOtherAttendees = this.hasNotifyableOtherAttendees()\n\t\tthis.isConfidential = initialValues.invitedConfidentially ?? false\n\t}\n\n\tset selectedCalendar(v: CalendarInfo) {\n\t\t/**\n\t\t * when changing the calendar of an event, if the user is the organiser\n\t\t * they can link any of their owned calendars(private or shared) to said event\n\t\t * even if the event has guests\n\t\t **/\n\t\tif (!v.userIsOwner && v.shared && this._attendees.size > 0) {\n\t\t\tthrow new ProgrammingError(\"tried to select shared calendar while there are guests.\")\n\t\t} else if (!v.userIsOwner && v.shared && this.isNew && this._organizer != null) {\n\t\t\t// for new events, it's possible to have an organizer but no attendees if you only add yourself.\n\t\t\tthis._organizer = null\n\t\t}\n\t\tthis._selectedCalendar = v\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget selectedCalendar(): CalendarInfo {\n\t\treturn this._selectedCalendar\n\t}\n\n\t/**\n\t * whether the current user can modify the guest list of the event depending on event type and the calendar it's in.\n\t *\n\t * * at the moment, we can never modify guests when editing only part of a series.\n\t * * selected calendar is our own:\n\t *   * event is invite (we're not organizer): can't modify guest list, any edit operation will be local only.\n\t *   * event is our own: can do what we want.\n\t * * if the selected calendar is a shared one:\n\t *   * ro: don't show editor at all\n\t *   * rw, new event: don't show attendee list editor - we can't invite in shared calendars.\n\t *   * rw, existing event without attendees: not our own calendar, can't invite, don't show attendee list.\n\t *   * rw, existing event with attendees:  this is the case where we can see attendees, but can't edit them.\n\t *                                         but we also can't edit the event since there are attendees and we're\n\t *                                         unable to send updates.\n\t */\n\tget canModifyGuests(): boolean {\n\t\t/**\n\t\t * if the user is the event's organiser and the owner of its linked calendar, the user can modify the guests freely\n\t\t **/\n\t\tconst userIsOwner = this.eventType === EventType.OWN && this.selectedCalendar.userIsOwner\n\t\treturn userIsOwner || !(this.selectedCalendar?.shared || this.eventType === EventType.INVITE || this.operation === CalendarOperation.EditThis)\n\t}\n\n\t/**\n\t * filter the calendars an event can be saved to depending on the event type, attendee status and edit operation.\n\t * Prevent moving the event to another calendar if you only have read permission or if the event has attendees.\n\t * */\n\tgetAvailableCalendars(): ReadonlyArray<CalendarInfo> {\n\t\tconst { groupSettings } = this.userController.userSettingsGroupRoot\n\t\tconst calendarArray = Array.from(this.calendars.values()).filter((cal) => !this.isExternalCalendar(groupSettings, cal.group._id))\n\n\t\tif (this.eventType === EventType.LOCKED || this.operation === CalendarOperation.EditThis) {\n\t\t\treturn [this.selectedCalendar]\n\t\t} else if (this.isNew && this._attendees.size > 0) {\n\t\t\t// if we added guests, we cannot select a shared calendar to create the event.\n\t\t\t/**\n\t\t\t * when changing the calendar of an event, if the user is the organiser\n\t\t\t * they can link any of their owned calendars(private or shared) to said event\n\t\t\t * even if the event has guests\n\t\t\t **/\n\t\t\treturn calendarArray.filter((calendarInfo) => calendarInfo.userIsOwner || !calendarInfo.shared)\n\t\t} else if (this._attendees.size > 0 && this.eventType === EventType.OWN) {\n\t\t\treturn calendarArray.filter((calendarInfo) => calendarInfo.userIsOwner)\n\t\t} else if (this._attendees.size > 0 || this.eventType === EventType.INVITE) {\n\t\t\t// We don't allow inviting in a shared calendar.\n\t\t\t// If we have attendees, we cannot select a shared calendar.\n\t\t\t// We also don't allow accepting invites into shared calendars.\n\t\t\treturn calendarArray.filter((calendarInfo) => !calendarInfo.shared || haveSameId(calendarInfo.group, this.selectedCalendar.group))\n\t\t} else {\n\t\t\treturn calendarArray.filter((calendarInfo) => hasCapabilityOnGroup(this.userController.user, calendarInfo.group, ShareCapability.Write))\n\t\t}\n\t}\n\n\tprivate isExternalCalendar(groupSettings: GroupSettings[], groupId: Id) {\n\t\tconst existingGroupSettings = groupSettings.find((gc) => gc.group === groupId)\n\t\treturn hasSourceUrl(existingGroupSettings)\n\t}\n\n\tprivate async resolveAndCacheAddress(a: PartialRecipient): Promise<void> {\n\t\tif (this.resolvedRecipients.has(a.address)) return\n\t\tthis.pendingRecipients = this.pendingRecipients + 1\n\t\tconst recipient = await this.recipientsModel.resolve(a, ResolveMode.Eager).resolved()\n\t\tthis.cacheRecipient(recipient)\n\t\tthis.pendingRecipients = this.pendingRecipients - 1\n\t\tif (this.pendingRecipients === 0) {\n\t\t\tthis._recipientsSettled.resolve()\n\t\t\tthis._recipientsSettled = defer()\n\t\t}\n\t}\n\n\tprivate cacheRecipient(recipient: Recipient): void {\n\t\tthis.resolvedRecipients.set(recipient.address, recipient)\n\t\tif (recipient.type !== RecipientType.EXTERNAL) return\n\t\tthis.externalPasswords.set(recipient.address, recipient.contact?.presharedPassword ?? \"\")\n\t\tif (recipient.contact != null && this._attendees.has(recipient.address)) {\n\t\t\tconst attendee = this._attendees.get(recipient.address)!\n\t\t\tattendee.address.name = getContactDisplayName(recipient.contact)\n\t\t}\n\t}\n\n\t/**\n\t * internally, we want to keep ourselves and the organizer separate from the other attendees\n\t */\n\tprivate setupAttendees(initialValues: Partial<Stripped<CalendarEvent>>) {\n\t\tconst ownAddresses = this.ownMailAddresses.map((a) => cleanMailAddress(a.address))\n\n\t\t// convert the list of attendees into a map for easier use.\n\t\tfor (const a of initialValues.attendees ?? []) {\n\t\t\tconst attendee = createCalendarEventAttendee({\n\t\t\t\tstatus: a.status,\n\t\t\t\taddress: createEncryptedMailAddress({\n\t\t\t\t\tname: a.address.name,\n\t\t\t\t\taddress: cleanMailAddress(a.address.address),\n\t\t\t\t}),\n\t\t\t})\n\t\t\t// we will remove own attendees + organizer later.\n\t\t\tthis.initialAttendees.set(attendee.address.address, attendee)\n\t\t}\n\n\t\t// get the organizer out of the attendees and into a separate field\n\t\tconst initialOrganizerAddress =\n\t\t\tinitialValues.organizer == null\n\t\t\t\t? null\n\t\t\t\t: createEncryptedMailAddress({\n\t\t\t\t\t\taddress: cleanMailAddress(initialValues.organizer.address),\n\t\t\t\t\t\tname: initialValues.organizer.name,\n\t\t\t\t  })\n\n\t\tif (initialOrganizerAddress != null) {\n\t\t\t// check if the organizer is also in the attendees array and remove them if so\n\t\t\tconst organizerAttendee = this.initialAttendees.get(initialOrganizerAddress.address)\n\t\t\tthis._organizer =\n\t\t\t\torganizerAttendee ??\n\t\t\t\tcreateCalendarEventAttendee({\n\t\t\t\t\taddress: initialOrganizerAddress,\n\t\t\t\t\t// the organizer added themselves, but did not specify if they're participating\n\t\t\t\t\tstatus: CalendarAttendeeStatus.NEEDS_ACTION,\n\t\t\t\t})\n\t\t\tthis.initialAttendees.delete(this._organizer.address.address)\n\t\t}\n\n\t\t// we don't want ourselves in the attendee list, since we're using it to track updates we need to send.\n\t\tconst ownAttendeeAddresses = findAll(Array.from(this.initialAttendees.keys()), (address) => ownAddresses.includes(address))\n\t\tthis._ownAttendee = this.initialAttendees.get(ownAttendeeAddresses[0]) ?? null\n\t\tthis.initialOwnAttendeeStatus = (this._ownAttendee?.status as CalendarAttendeeStatus) ?? null\n\t\tfor (const match of ownAttendeeAddresses) {\n\t\t\tthis.initialAttendees.delete(match)\n\t\t}\n\n\t\t// set up the attendees map that tracks the actual changes\n\t\tfor (const [initialAttendeeAddress, initialAttendee] of this.initialAttendees.entries()) {\n\t\t\tthis._attendees.set(initialAttendeeAddress, clone(initialAttendee))\n\t\t}\n\n\t\t// we now have cleaned versions of organizer, ownAttendee and other attendees in separate fields.\n\t\t// now the sanity checks.\n\n\t\tif (this._organizer != null && this._attendees.size === 0 && this._ownAttendee == null) {\n\t\t\t// if there are no attendees besides the organizer, the organizer must not be specified.\n\t\t\tthis._organizer = null\n\t\t}\n\n\t\tif (\n\t\t\tthis.eventType === EventType.OWN &&\n\t\t\tthis._organizer != null &&\n\t\t\t!ownAddresses.includes(this._organizer.address.address) &&\n\t\t\tArray.from(this._attendees.values()).some((a) => a.status !== CalendarAttendeeStatus.ADDED)\n\t\t) {\n\t\t\t// this is technically an invalid state now that should not happen with new events.\n\t\t\t// we previously assigned the event creator (which might not be the calendar owner) to the organizer field,\n\t\t\t// even when there were no attendees.\n\t\t\tconsole.warn(\"got an event with attendees and an organizer that's not the owner of the calendar, replacing organizer.\")\n\t\t\tthis._attendees.set(this._organizer.address.address, this._organizer)\n\t\t\tthis._organizer =\n\t\t\t\tthis._ownAttendee ??\n\t\t\t\tcreateCalendarEventAttendee({\n\t\t\t\t\taddress: createEncryptedMailAddress({\n\t\t\t\t\t\taddress: ownAddresses[0],\n\t\t\t\t\t\tname: \"\",\n\t\t\t\t\t}),\n\t\t\t\t\tstatus: CalendarAttendeeStatus.ACCEPTED,\n\t\t\t\t})\n\t\t}\n\n\t\tif (\n\t\t\tthis._organizer &&\n\t\t\townAddresses.includes(this._organizer.address.address) &&\n\t\t\tthis._organizer.address.address !== this._ownAttendee?.address.address\n\t\t) {\n\t\t\t// if we're the organizer, ownAttendee should be the same. we don't modify organizer here because someone might already have sent invites.\n\t\t\tthis._ownAttendee = this._organizer\n\t\t}\n\t}\n\n\t/**\n\t * figure out if there are currently other people that might need to be notified if this event is modified.\n\t * attendees that were just added and not invited yet are ignored for this.\n\t * @private\n\t */\n\tprivate hasNotifyableOtherAttendees() {\n\t\treturn (\n\t\t\t// if the event is new we can do what we want (no attendee was notified yet)\n\t\t\t!this.isNew &&\n\t\t\t// if the event is not new, but the attendee list did not have any attendees that were already notified,\n\t\t\t// there are no attendees that are not either us or the organizer\n\t\t\tArray.from(this.initialAttendees.values()).some((a) => a.status !== CalendarAttendeeStatus.ADDED)\n\t\t)\n\t}\n\n\t/*\n\t * return a list of mail addresses that we can set as an organizer.\n\t */\n\tget possibleOrganizers(): ReadonlyArray<EncryptedMailAddress> {\n\t\tif (this.eventType !== EventType.OWN) {\n\t\t\treturn this._organizer ? [this._organizer.address] : []\n\t\t} else if (!this.hasNotifyableOtherAttendees()) {\n\t\t\t// if we have no attendees that require an update, we can use whatever address\n\t\t\treturn this.ownMailAddresses\n\t\t} else if (this._organizer != null && this.ownGuest?.address === this._organizer?.address.address) {\n\t\t\t// if there are other attendees and we have an organizer that's us, we must use that organizer\n\t\t\t// because changing the organizer address after the attendees were invited is suboptimal.\n\t\t\treturn [this._organizer.address]\n\t\t} else if (this.eventType === EventType.OWN) {\n\t\t\treturn this.ownMailAddresses\n\t\t} else {\n\t\t\t// something is wrong.\n\t\t\tthrow new ProgrammingError(\"could not figure out which addresses are a valid organizer for this event.\")\n\t\t}\n\t}\n\n\t/**\n\t * get our own guest, if any\n\t */\n\tget ownGuest(): Guest | null {\n\t\treturn this._ownAttendee && this.getGuestForAttendee(this._ownAttendee)\n\t}\n\n\t/**\n\t * get the current organizer of the event\n\t *\n\t * there is no setter - if we're changing attendees, we're ensured to be the organizer.\n\t */\n\tget organizer(): Guest | null {\n\t\treturn this._organizer && this.getGuestForAttendee(this._organizer)\n\t}\n\n\t/**\n\t * a list of the attendees of the event that are not the organizer or ourselves, with their status and type\n\t */\n\tget guests(): ReadonlyArray<Guest> {\n\t\treturn Array.from(this._attendees.values()).map((a) => this.getGuestForAttendee(a))\n\t}\n\n\tprivate getGuestForAttendee(a: CalendarEventAttendee): Guest {\n\t\tif (this.resolvedRecipients.has(a.address.address)) {\n\t\t\tconst recipient: Recipient = this.resolvedRecipients.get(a.address.address)!\n\t\t\treturn {\n\t\t\t\t...recipient,\n\t\t\t\tstatus: a.status as CalendarAttendeeStatus,\n\t\t\t}\n\t\t} else {\n\t\t\t// this is a temporary situation, an attendee that is set in this model\n\t\t\t// will be resolved sometime after it was added.\n\t\t\treturn {\n\t\t\t\taddress: a.address.address,\n\t\t\t\tname: a.address.name,\n\t\t\t\tstatus: a.status as CalendarAttendeeStatus,\n\t\t\t\ttype: RecipientType.UNKNOWN,\n\t\t\t\tcontact: null,\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * add a mail address to the list of invitees.\n\t * the organizer will always be set to the last of the current user's mail addresses that has been added.\n\t *\n\t * if an attendee is deleted an re-added, the status is retained.\n\t *\n\t * @param address the mail address to send the invite to\n\t * @param contact a contact for a display name.\n\t */\n\taddAttendee(address: string, contact: Contact | null = null): void {\n\t\tif (!this.canModifyGuests) {\n\t\t\tthrow new UserError(lang.makeTranslation(\"cannotAddAttendees_msg\", \"Cannot add attendees\"))\n\t\t}\n\t\tconst cleanAddress = cleanMailAddress(address)\n\t\t// We don't add an attendee if they are already an attendee\n\t\tif (this._attendees.has(cleanAddress) || this._organizer?.address.address === cleanAddress || this._ownAttendee?.address.address === cleanAddress) {\n\t\t\treturn\n\t\t}\n\n\t\tconst ownAttendee = findRecipientWithAddress(this.ownMailAddresses, cleanAddress)\n\t\tif (ownAttendee != null) {\n\t\t\tthis.addOwnAttendee(ownAttendee)\n\t\t} else {\n\t\t\tconst name = contact != null ? getContactDisplayName(contact) : \"\"\n\t\t\tthis.addOtherAttendee(createEncryptedMailAddress({ address: cleanAddress, name }))\n\t\t}\n\t}\n\n\t/**\n\t * this is a no-op if there are already\n\t * @param address MUST be one of ours and MUST NOT be in the attendees array or set on _organizer\n\t * @private\n\t */\n\tprivate addOwnAttendee(address: EncryptedMailAddress): void {\n\t\tif (this.hasNotifyableOtherAttendees()) {\n\t\t\tconsole.log(\"can't change organizer if there are other invitees already\")\n\t\t\treturn\n\t\t}\n\t\tconst attendeeToAdd = createCalendarEventAttendee({ address, status: CalendarAttendeeStatus.ACCEPTED })\n\t\tthis._ownAttendee = attendeeToAdd\n\n\t\t// make sure that the organizer on the event is the same address as we added as an own attendee.\n\t\tthis._organizer = attendeeToAdd\n\t\tif (!this.resolvedRecipients.has(address.address)) {\n\t\t\tthis.resolveAndCacheAddress(address).then(this.uiUpdateCallback)\n\t\t}\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t *\n\t * @param address must NOT be one of ours.\n\t * @private\n\t */\n\tprivate addOtherAttendee(address: EncryptedMailAddress) {\n\t\tif (this._ownAttendee == null) {\n\t\t\t// we're adding someone that's not us while we're not an attendee,\n\t\t\t// so we add ourselves as an attendee and as organizer.\n\t\t\tthis.addOwnAttendee(this.ownMailAddresses[0])\n\t\t}\n\n\t\taddress.address = cleanMailAddress(address.address)\n\t\tconst previousAttendee = this.initialAttendees.get(address.address)\n\n\t\t//  we now know that this address is not in the list and that it's also\n\t\t//  not us under another address that's already added, so we can just add it.\n\t\t//  we reuse the entry from the initial attendees in case we already had this attendee at the start\n\t\tif (previousAttendee != null) {\n\t\t\tthis._attendees.set(address.address, previousAttendee)\n\t\t} else {\n\t\t\tthis._attendees.set(address.address, createCalendarEventAttendee({ address, status: CalendarAttendeeStatus.ADDED }))\n\t\t}\n\t\tif (!this.resolvedRecipients.has(address.address)) {\n\t\t\tthis.resolveAndCacheAddress(address).then(this.uiUpdateCallback)\n\t\t}\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * remove a single attendee from the list.\n\t * * if it's the organizer AND there are other attendees, this is a no-op - if there are attendees, someone must be organizer (and it's us)\n\t * * if it's the organizer AND there are no other attendees, this sets the organizer and ownAttendee\n\t * * if it's not the organizer, but the last non-organizer attendee, only removes the attendee from the list, but the\n\t *   result will have an empty attendee list and no organizer if no other attendees are added in the meantime.\n\t * * if it's not the organizer but not the last non-organizer attendee, just removes that attendee from the list.\n\t * @param address the attendee to remove.\n\t */\n\tremoveAttendee(address: string) {\n\t\tconst cleanRemoveAddress = cleanMailAddress(address)\n\t\tif (this._organizer?.address.address === cleanRemoveAddress) {\n\t\t\tif (this._attendees.size > 0) {\n\t\t\t\tconsole.log(\"tried to remove organizer while there are other attendees, ignoring.\")\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tthis._organizer = null\n\t\t\t\t// we must be the organizer since we're removing guests.\n\t\t\t\tthis._ownAttendee = null\n\n\t\t\t\tthis.uiUpdateCallback()\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._attendees.has(cleanRemoveAddress)) {\n\t\t\t\tthis._attendees.delete(cleanRemoveAddress)\n\t\t\t\tif (this._attendees.size === 0) {\n\t\t\t\t\tthis._organizer = null\n\t\t\t\t\t// we must be the organizer since we're removing guests.\n\t\t\t\t\tthis._ownAttendee = null\n\t\t\t\t}\n\t\t\t\tthis.uiUpdateCallback()\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * modify your own attendance to the selected value.\n\t * is a no-op if we're not actually an attendee\n\t * @param status\n\t */\n\tsetOwnAttendance(status: CalendarAttendeeStatus) {\n\t\tif (this._ownAttendee) this._ownAttendee.status = status\n\t}\n\n\tsetPresharedPassword(address: string, password: string) {\n\t\tthis.externalPasswords.set(address, password)\n\t}\n\n\t/** for a stored address, get the preshared password and an indicator value for its strength */\n\tgetPresharedPassword(address: string): { password: string; strength: number } {\n\t\tconst password = this.externalPasswords.get(address) ?? \"\"\n\t\tconst recipient = this.resolvedRecipients.get(address)\n\t\tconst strength = recipient != null ? this.passwordStrengthModel(password, recipient) : 0\n\t\treturn { password, strength }\n\t}\n\n\t/**\n\t * return whether any of the attendees have a password set that warrants asking the user if they really want to use it.\n\t *\n\t * ignores empty passwords since those are always a hard fail when sending external mail.\n\t */\n\thasInsecurePasswords(): boolean {\n\t\tif (!this.isConfidential) {\n\t\t\treturn false\n\t\t}\n\t\tfor (const g of this._attendees.values()) {\n\t\t\tconst { password, strength } = this.getPresharedPassword(g.address.address)\n\t\t\tif (password === \"\" || isSecurePassword(strength)) continue\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\tprivate prepareSendModel(attendees: ReadonlyArray<CalendarEventAttendee>): SendMailModel | null {\n\t\tif (!this._ownAttendee) return null\n\t\tconst recipients = attendees.map(({ address }) => address)\n\t\tconst model = this.sendMailModelFactory()\n\t\t// do not pass recipients in template arguments as recipient checks in sendMailModel are done in sync part of send\n\t\tmodel.initWithTemplate([], \"\", \"\")\n\n\t\tfor (const recipient of recipients) {\n\t\t\tmodel.addRecipient(RecipientField.BCC, recipient)\n\t\t\t// Only set the password if we have an entry.\n\t\t\t// The recipients might not be resolved at this point yet, so we shouldn't set the password on the model unless we have one for sure.\n\t\t\t// SendMailModel will anyway resolve the recipients, but it won't detect the right password if it's already pre-filled by us.\n\t\t\tif (this.externalPasswords.has(recipient.address)) {\n\t\t\t\tconst password = assertNotNull(this.externalPasswords.get(recipient.address))\n\t\t\t\tmodel.setPassword(recipient.address, password)\n\t\t\t}\n\t\t}\n\t\tmodel.setSender(this._ownAttendee.address.address)\n\t\tmodel.setConfidential(this.isConfidential)\n\t\treturn model\n\t}\n\n\tprivate prepareResponseModel(): SendMailModel | null {\n\t\tif (this.eventType !== EventType.INVITE || this._ownAttendee === null || this._organizer == null || this._ownAttendee == null) {\n\t\t\t// not checking for initialAttendees.size === 0 because we and the organizer might be the only attendees, which do not show\n\t\t\t// up there.\n\t\t\treturn null\n\t\t}\n\n\t\tconst initialOwnAttendeeStatus = assertNotNull(\n\t\t\tthis.initialOwnAttendeeStatus,\n\t\t\t\"somehow managed to become an attendee on an invite we weren't invited to before\",\n\t\t)\n\n\t\tif (!(initialOwnAttendeeStatus !== this._ownAttendee.status && this._ownAttendee.status !== CalendarAttendeeStatus.NEEDS_ACTION)) {\n\t\t\t// either our status did not actually change or our new status is \"NEEDS_ACTION\"\n\t\t\treturn null\n\t\t}\n\n\t\tconst responseModel: SendMailModel = this.sendMailModelFactory()\n\n\t\tif (this.responseTo != null) {\n\t\t\t// do not pass recipients in template arguments as recipient checks in sendMailModel are done in sync part of send\n\t\t\tresponseModel.initAsResponse(\n\t\t\t\t{\n\t\t\t\t\tpreviousMail: this.responseTo,\n\t\t\t\t\tconversationType: ConversationType.REPLY,\n\t\t\t\t\tsenderMailAddress: this._ownAttendee.address.address,\n\t\t\t\t\trecipients: [],\n\t\t\t\t\tattachments: [],\n\t\t\t\t\tbodyText: \"\",\n\t\t\t\t\tsubject: \"\",\n\t\t\t\t\treplyTos: [],\n\t\t\t\t},\n\t\t\t\tnew Map(),\n\t\t\t)\n\t\t} else {\n\t\t\t// do not pass recipients in template arguments as recipient checks in sendMailModel are done in sync part of send\n\t\t\tresponseModel.initWithTemplate({}, \"\", \"\")\n\t\t}\n\t\tresponseModel.addRecipient(RecipientField.TO, this._organizer.address)\n\n\t\treturn responseModel\n\t}\n\n\tget result(): AttendanceModelResult {\n\t\tif (this._selectedCalendar == null) {\n\t\t\tthrow new UserError(\"noCalendar_msg\")\n\t\t}\n\n\t\tconst isOrganizer = this._organizer != null && this._ownAttendee?.address.address === this._organizer.address.address\n\n\t\tconst {\n\t\t\tkept: attendeesToUpdate,\n\t\t\tdeleted: attendeesToCancel,\n\t\t\tadded: attendeesToInvite,\n\t\t} = getRecipientLists(this.initialAttendees, this._attendees, isOrganizer, this.isNew)\n\n\t\tconst { allAttendees, organizerToPublish } = assembleAttendees(attendeesToInvite, attendeesToUpdate, this._organizer, this._ownAttendee)\n\n\t\treturn {\n\t\t\tattendees: allAttendees,\n\t\t\torganizer: organizerToPublish,\n\t\t\tisConfidential: this.isConfidential,\n\t\t\tcancelModel: isOrganizer && attendeesToCancel.length > 0 ? this.prepareSendModel(attendeesToCancel) : null,\n\t\t\tinviteModel: isOrganizer && attendeesToInvite.length > 0 ? this.prepareSendModel(attendeesToInvite) : null,\n\t\t\tupdateModel: isOrganizer && attendeesToUpdate.length > 0 && this.shouldSendUpdates ? this.prepareSendModel(attendeesToUpdate) : null,\n\t\t\tresponseModel: !isOrganizer && organizerToPublish != null ? this.prepareResponseModel() : null,\n\t\t\tcalendar: this._selectedCalendar,\n\t\t}\n\t}\n}\n\nfunction getRecipientLists(\n\tinitialAttendees: ReadonlyMap<unknown, CalendarEventAttendee>,\n\tcurrentAttendees: ReadonlyMap<unknown, CalendarEventAttendee>,\n\tisOrganizer: boolean,\n\tisNew: boolean,\n): ReturnType<typeof trisectingDiff<CalendarEventAttendee>> {\n\tif (!isOrganizer) {\n\t\t// if we're not the organizer, we can't have changed the guest list.\n\t\treturn { added: [], deleted: [], kept: Array.from(initialAttendees.values()) }\n\t} else if (isNew) {\n\t\t// a new event will always have everyone on the guest list have to be invited.\n\t\treturn { added: Array.from(currentAttendees.values()), deleted: [], kept: [] }\n\t} else {\n\t\t// in this case, the guest list may have changed arbitrarily\n\t\treturn trisectingDiff(initialAttendees, currentAttendees)\n\t}\n}\n\n/** get the list of attendees and the organizer address to publish.\n * the array contains the organizer as an attendee.\n *\n * if there's only an organizer but no other attendees, no attendees or organizers are returned.\n * */\nfunction assembleAttendees(\n\tattendeesToInvite: ReadonlyArray<CalendarEventAttendee>,\n\tattendeesToUpdate: ReadonlyArray<CalendarEventAttendee>,\n\torganizer: CalendarEventAttendee | null,\n\townAttendee: CalendarEventAttendee | null,\n): {\n\tallAttendees: Array<CalendarEventAttendee>\n\torganizerToPublish: EncryptedMailAddress | null\n} {\n\tif (\n\t\torganizer == null ||\n\t\t(attendeesToInvite.length + attendeesToUpdate.length === 0 && (ownAttendee == null || ownAttendee.address.address === organizer?.address.address))\n\t) {\n\t\t// there's no attendees besides the organizer (which may be us) or there's no organizer at all.\n\t\treturn { allAttendees: [], organizerToPublish: null }\n\t}\n\tconst allAttendees: Array<CalendarEventAttendee> = []\n\tif (organizer.address.address !== ownAttendee?.address.address) {\n\t\tallAttendees.push(organizer)\n\t}\n\tif (ownAttendee != null) {\n\t\tallAttendees.push(ownAttendee)\n\t}\n\tallAttendees.push(...attendeesToUpdate)\n\tallAttendees.push(...attendeesToInvite)\n\n\treturn {\n\t\tallAttendees,\n\t\torganizerToPublish: organizer.address,\n\t}\n}\n","import { generateEventElementId, serializeAlarmInterval } from \"../../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { noOp, remove } from \"@tutao/tutanota-utils\"\nimport { EventType } from \"./CalendarEventModel.js\"\nimport { DateProvider } from \"../../../../common/api/common/DateProvider.js\"\nimport { AlarmInterval, alarmIntervalToLuxonDurationLikeObject } from \"../../../../common/calendar/date/CalendarUtils.js\"\nimport { Duration } from \"luxon\"\nimport { AlarmInfoTemplate } from \"../../../../common/api/worker/facades/lazy/CalendarFacade.js\"\n\nexport type CalendarEventAlarmModelResult = {\n\talarms: Array<AlarmInfoTemplate>\n}\n\n/**\n * edit the alarms set on a calendar event.\n */\nexport class CalendarEventAlarmModel {\n\tprivate readonly _alarms: Array<AlarmInterval> = []\n\t/** we can set reminders only if we're able to edit the event on the server because we have to add them to the entity. */\n\treadonly canEditReminders: boolean\n\n\tconstructor(\n\t\teventType: EventType,\n\t\talarms: Array<AlarmInterval> = [],\n\t\tprivate readonly dateProvider: DateProvider,\n\t\tprivate readonly uiUpdateCallback: () => void = noOp,\n\t) {\n\t\tthis.canEditReminders =\n\t\t\teventType === EventType.OWN || eventType === EventType.SHARED_RW || eventType === EventType.LOCKED || eventType === EventType.INVITE\n\t\tthis._alarms = [...alarms]\n\t}\n\n\t/**\n\t * @param trigger the interval to add.\n\t */\n\taddAlarm(trigger: AlarmInterval | null) {\n\t\tif (trigger == null) return\n\n\t\t// Checks if an alarm with the same duration already exists\n\t\tconst alreadyHasAlarm = this._alarms.some((e) => this.isEqualAlarms(trigger, e))\n\t\tif (alreadyHasAlarm) return\n\n\t\tthis._alarms.push(trigger)\n\t\tthis.uiUpdateCallback()\n\t}\n\n\t/**\n\t * deactivate the alarm for the given interval.\n\t */\n\tremoveAlarm(alarmInterval: AlarmInterval) {\n\t\tremove(this._alarms, alarmInterval)\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tremoveAll() {\n\t\tthis._alarms.splice(0)\n\t}\n\n\taddAll(alarmIntervalList: AlarmInterval[]) {\n\t\tthis._alarms.push(...alarmIntervalList)\n\t}\n\n\tget alarms(): ReadonlyArray<AlarmInterval> {\n\t\treturn this._alarms\n\t}\n\n\tget result(): CalendarEventAlarmModelResult {\n\t\treturn {\n\t\t\talarms: Array.from(this._alarms.values()).map((t) => this.makeNewAlarm(t)),\n\t\t}\n\t}\n\n\tprivate makeNewAlarm(alarmInterval: AlarmInterval): AlarmInfoTemplate {\n\t\treturn {\n\t\t\talarmIdentifier: generateEventElementId(this.dateProvider.now()),\n\t\t\ttrigger: serializeAlarmInterval(alarmInterval),\n\t\t}\n\t}\n\n\t/**\n\t * Compares two AlarmIntervals if they have the same duration\n\t * eg: 60 minutes === 1 hour\n\t * @param alarmOne base interval\n\t * @param alarmTwo interval to be compared with\n\t * @return true if they have the same duration\n\t */\n\tisEqualAlarms(alarmOne: AlarmInterval, alarmTwo: AlarmInterval): boolean {\n\t\tconst luxonAlarmOne = Duration.fromDurationLike(alarmIntervalToLuxonDurationLikeObject(alarmOne)).shiftToAll()\n\t\tconst luxonAlarmTwo = Duration.fromDurationLike(alarmIntervalToLuxonDurationLikeObject(alarmTwo)).shiftToAll()\n\n\t\treturn luxonAlarmOne.equals(luxonAlarmTwo)\n\t}\n}\n","import type { HtmlSanitizer } from \"./HtmlSanitizer.js\"\nimport { noOp } from \"@tutao/tutanota-utils\"\n\nexport class SanitizedTextViewModel {\n\tprivate sanitizedText: string | null = null\n\n\tconstructor(private text: string, private readonly sanitizer: HtmlSanitizer, private readonly uiUpdateCallback: () => void = noOp) {}\n\n\tset content(v: string) {\n\t\tthis.sanitizedText = null\n\t\tthis.text = v\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget content(): string {\n\t\tif (this.sanitizedText == null) {\n\t\t\tthis.sanitizedText = this.sanitizer.sanitizeHTML(this.text, { blockExternalContent: false }).html\n\t\t}\n\t\treturn this.sanitizedText\n\t}\n}\n","import { SendMailModel } from \"../../../../common/mailFunctionality/SendMailModel.js\"\nimport { CalendarNotificationSender } from \"../../view/CalendarNotificationSender.js\"\nimport { LoginController } from \"../../../../common/api/main/LoginController.js\"\nimport { CalendarEvent } from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ProgrammingError } from \"../../../../common/api/common/error/ProgrammingError.js\"\nimport { AccountType, CalendarAttendeeStatus } from \"../../../../common/api/common/TutanotaConstants.js\"\nimport { clone } from \"@tutao/tutanota-utils\"\nimport { TooManyRequestsError } from \"../../../../common/api/common/error/RestError.js\"\nimport { UserError } from \"../../../../common/api/main/UserError.js\"\nimport { getNonOrganizerAttendees } from \"./CalendarEventModel.js\"\nimport { UpgradeRequiredError } from \"../../../../common/api/main/UpgradeRequiredError.js\"\n\n/** all the people that may be interested in changes to an event get stored in these models.\n * if one of them is null, it's because there is no one that needs that kind of update.\n * */\nexport type CalendarNotificationSendModels = {\n\tinviteModel: SendMailModel | null\n\tupdateModel: SendMailModel | null\n\tcancelModel: SendMailModel | null\n\tresponseModel: SendMailModel | null\n}\n\n/** contains the logic to distribute the necessary updates to whom it may concern\n *  and checks the preconditions\n * */\nexport class CalendarNotificationModel {\n\tconstructor(private readonly notificationSender: CalendarNotificationSender, private readonly loginController: LoginController) {}\n\n\t/**\n\t * send all notifications required for the new event, determined by the contents of the sendModels parameter.\n\t *\n\t * will modify the attendee list of newEvent if invites/cancellations are sent.\n\t */\n\tasync send(event: CalendarEvent, recurrenceIds: Array<Date>, sendModels: CalendarNotificationSendModels): Promise<void> {\n\t\tif (sendModels.updateModel == null && sendModels.cancelModel == null && sendModels.inviteModel == null && sendModels.responseModel == null) {\n\t\t\treturn\n\t\t}\n\t\tif (\n\t\t\t// sending responses is OK for free users.\n\t\t\t(sendModels.updateModel != null || sendModels.cancelModel != null || sendModels.inviteModel != null) &&\n\t\t\t!(await hasPlanWithInvites(this.loginController))\n\t\t) {\n\t\t\tconst { getAvailablePlansWithCalendarInvites } = await import(\"../../../../common/subscription/SubscriptionUtils.js\")\n\t\t\tthrow new UpgradeRequiredError(\"upgradeRequired_msg\", await getAvailablePlansWithCalendarInvites())\n\t\t}\n\t\t// we need to exclude the exclusions that are only there because of altered instances specifically\n\t\t// so google calendar handles our invitations\n\t\tconst recurrenceTimes = recurrenceIds.map((date) => date.getTime())\n\t\tconst originalExclusions = event.repeatRule?.excludedDates ?? []\n\t\tconst filteredExclusions = originalExclusions.filter(({ date }) => !recurrenceTimes.includes(date.getTime()))\n\t\tif (event.repeatRule != null) event.repeatRule.excludedDates = filteredExclusions\n\n\t\ttry {\n\t\t\tconst invitePromise = sendModels.inviteModel != null ? this.sendInvites(event, sendModels.inviteModel) : Promise.resolve()\n\t\t\tconst cancelPromise = sendModels.cancelModel != null ? this.sendCancellation(event, sendModels.cancelModel) : Promise.resolve()\n\t\t\tconst updatePromise = sendModels.updateModel != null ? this.sendUpdates(event, sendModels.updateModel) : Promise.resolve()\n\t\t\tconst responsePromise = sendModels.responseModel != null ? this.respondToOrganizer(event, sendModels.responseModel) : Promise.resolve()\n\t\t\tawait Promise.all([invitePromise, cancelPromise, updatePromise, responsePromise])\n\t\t} finally {\n\t\t\tif (event.repeatRule != null) event.repeatRule.excludedDates = originalExclusions\n\t\t}\n\t}\n\n\t/**\n\t * invite all new attendees for an event and set their status from \"ADDED\" to \"NEEDS_ACTION\"\n\t * @param event will be modified if invites are sent.\n\t * @param inviteModel\n\t * @private\n\t */\n\tprivate async sendInvites(event: CalendarEvent, inviteModel: SendMailModel): Promise<void> {\n\t\tif (event.organizer == null || inviteModel?.allRecipients().length === 0) {\n\t\t\tthrow new ProgrammingError(\"event has no organizer or no invitable attendees, can't send invites.\")\n\t\t}\n\t\tconst newAttendees = getNonOrganizerAttendees(event).filter((a) => a.status === CalendarAttendeeStatus.ADDED)\n\t\tawait inviteModel.waitForResolvedRecipients()\n\t\tif (event.invitedConfidentially != null) {\n\t\t\tinviteModel.setConfidential(event.invitedConfidentially)\n\t\t}\n\t\tawait this.notificationSender.sendInvite(event, inviteModel)\n\t\tfor (const attendee of newAttendees) {\n\t\t\tif (attendee.status === CalendarAttendeeStatus.ADDED) {\n\t\t\t\tattendee.status = CalendarAttendeeStatus.NEEDS_ACTION\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendCancellation(event: CalendarEvent, cancelModel: SendMailModel): Promise<void> {\n\t\tconst updatedEvent = clone(event)\n\n\t\ttry {\n\t\t\tif (event.invitedConfidentially != null) {\n\t\t\t\tcancelModel.setConfidential(event.invitedConfidentially)\n\t\t\t}\n\t\t\tawait this.notificationSender.sendCancellation(updatedEvent, cancelModel)\n\t\t} catch (e) {\n\t\t\tif (e instanceof TooManyRequestsError) {\n\t\t\t\tthrow new UserError(\"mailAddressDelay_msg\") // This will be caught and open error dialog\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async sendUpdates(event: CalendarEvent, updateModel: SendMailModel): Promise<void> {\n\t\tawait updateModel.waitForResolvedRecipients()\n\t\tif (event.invitedConfidentially != null) {\n\t\t\tupdateModel.setConfidential(event.invitedConfidentially)\n\t\t}\n\t\tawait this.notificationSender.sendUpdate(event, updateModel)\n\t}\n\n\t/**\n\t * send a response mail to the organizer as stated on the original event. calling this for an event that is not an invite or\n\t * does not contain address as an attendee or that has no organizer is an error.\n\t * @param newEvent the event to send the update for, this should be identical to existingEvent except for the own status.\n\t * @param responseModel\n\t * @private\n\t */\n\tprivate async respondToOrganizer(newEvent: CalendarEvent, responseModel: SendMailModel): Promise<void> {\n\t\tawait responseModel.waitForResolvedRecipients()\n\t\tif (newEvent.invitedConfidentially != null) {\n\t\t\tresponseModel.setConfidential(newEvent.invitedConfidentially)\n\t\t}\n\n\t\tawait this.notificationSender.sendResponse(newEvent, responseModel)\n\t\tresponseModel.dispose()\n\t}\n}\n\n/** determine if we should show the \"sending invites is not available for your plan, please upgrade\" dialog\n * to the currently logged in user.\n */\nexport async function hasPlanWithInvites(loginController: LoginController): Promise<boolean> {\n\tconst userController = loginController.getUserController()\n\tconst { user } = userController\n\tif (user.accountType === AccountType.FREE || user.accountType === AccountType.EXTERNAL) {\n\t\treturn false\n\t}\n\n\tconst customer = await loginController.getUserController().loadCustomer()\n\n\treturn (await userController.getPlanConfig()).eventInvites\n}\n","/**\n * this file contains the strategies used to create, edit and delete calendar events under different scenarios.\n * the scenarios are mostly divided into deciding the type of operation (edit, delete, create)\n * and the scope of the operation (only the clicked instance or all instances)\n * */\nimport { CalendarEvent } from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { assertEventValidity, CalendarModel } from \"../../model/CalendarModel.js\"\nimport { CalendarNotificationModel } from \"./CalendarNotificationModel.js\"\nimport { assertNotNull, identity } from \"@tutao/tutanota-utils\"\nimport { generateUid } from \"../../../../common/calendar/date/CalendarUtils.js\"\nimport {\n\tassembleCalendarEventEditResult,\n\tassembleEditResultAndAssignFromExisting,\n\tassignEventIdentity,\n\tCalendarEventEditModels,\n\tCalendarOperation,\n\tShowProgressCallback,\n} from \"./CalendarEventModel.js\"\nimport { LoginController } from \"../../../../common/api/main/LoginController.js\"\nimport { DateTime } from \"luxon\"\nimport { RecipientField } from \"../../../../common/mailFunctionality/SharedMailUtils.js\"\n\n/** when starting an edit or delete operation of an event, we\n * need to know how to apply it and whether to send updates. */\nexport interface CalendarEventModelStrategy {\n\t/** apply the changes to the server and notify attendees */\n\tapply(): Promise<void>\n\n\t/** check if the current state of the operation would cause updates to be sent*/\n\tmayRequireSendingUpdates(): boolean\n\n\teditModels: CalendarEventEditModels\n}\n\n/** strategies to apply calendar operations with some common setup */\nexport class CalendarEventApplyStrategies {\n\tconstructor(\n\t\tprivate readonly calendarModel: CalendarModel,\n\t\tprivate readonly logins: LoginController,\n\t\tprivate readonly notificationModel: CalendarNotificationModel,\n\t\tprivate readonly lazyRecurrenceIds: (uid?: string | null) => Promise<Array<Date>>,\n\t\tprivate readonly showProgress: ShowProgressCallback = identity,\n\t\tprivate readonly zone: string,\n\t) {}\n\n\t/**\n\t * save a new event to the selected calendar, invite all attendees except for the organizer and set up alarms.\n\t */\n\tasync saveNewEvent(editModels: CalendarEventEditModels): Promise<void> {\n\t\tconst { eventValues, newAlarms, sendModels, calendar } = assembleCalendarEventEditResult(editModels)\n\t\tconst uid = generateUid(calendar.group._id, Date.now())\n\t\tconst newEvent = assignEventIdentity(eventValues, { uid })\n\t\tassertEventValidity(newEvent)\n\t\tconst { groupRoot } = calendar\n\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\tawait this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** all instances of an event will be updated. if the recurrenceIds are invalidated (rrule or startTime changed),\n\t * will delete all altered instances and exclusions. */\n\tasync saveEntireExistingEvent(editModelsForProgenitor: CalendarEventEditModels, existingEvent: CalendarEvent): Promise<void> {\n\t\tconst uid = assertNotNull(existingEvent.uid, \"no uid to update existing event\")\n\t\tassertNotNull(existingEvent?._id, \"no id to update existing event\")\n\t\tassertNotNull(existingEvent?._ownerGroup, \"no ownerGroup to update existing event\")\n\t\tassertNotNull(existingEvent?._permissions, \"no permissions to update existing event\")\n\n\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\texistingEvent,\n\t\t\teditModelsForProgenitor,\n\t\t\tCalendarOperation.EditAll,\n\t\t)\n\t\tconst { groupRoot } = calendar\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tconst recurrenceIds: Array<Date> = await this.lazyRecurrenceIds(uid)\n\t\t\t\tawait this.notificationModel.send(newEvent, recurrenceIds, sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingEvent)\n\t\t\t\tconst invalidateAlteredInstances = newEvent.repeatRule && newEvent.repeatRule.excludedDates.length === 0\n\n\t\t\t\tconst newDuration = editModelsForProgenitor.whenModel.duration\n\t\t\t\tconst index = await this.calendarModel.getEventsByUid(uid)\n\t\t\t\tif (index == null) return\n\n\t\t\t\t// note: if we ever allow editing guests separately, we need to update this to not use the\n\t\t\t\t// note: progenitor edit models since the guest list might be different from the instance\n\t\t\t\t// note: we're looking at.\n\t\t\t\tfor (const occurrence of index.alteredInstances) {\n\t\t\t\t\tif (invalidateAlteredInstances) {\n\t\t\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\t\t\tconst { sendModels } = assembleEditResultAndAssignFromExisting(occurrence, editModelsForProgenitor, CalendarOperation.EditThis)\n\t\t\t\t\t\t// in cases where guests were removed and the start time/repeat rule changed, we might\n\t\t\t\t\t\t// have both a cancel model (containing the removed recipients) and an update model (the rest)\n\t\t\t\t\t\t// we're copying all of them to cancel if the altered instances were invalidated, since the\n\t\t\t\t\t\t// update (and invite for that matter) is irrelevant for those instances.\n\t\t\t\t\t\tfor (const recipient of sendModels.cancelModel?.allRecipients() ?? []) {\n\t\t\t\t\t\t\tsendModels.updateModel?.addRecipient(RecipientField.BCC, recipient)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\t\t\tsendModels.updateModel = null\n\t\t\t\t\t\tsendModels.inviteModel = null\n\t\t\t\t\t\tawait this.notificationModel.send(occurrence, [], sendModels)\n\t\t\t\t\t\tawait this.calendarModel.deleteEvent(occurrence)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst { newEvent, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\t\t\toccurrence,\n\t\t\t\t\t\t\teditModelsForProgenitor,\n\t\t\t\t\t\t\tCalendarOperation.EditThis,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t// we need to use the time we had before, not the time of the progenitor (which did not change since we still have altered occurrences)\n\t\t\t\t\t\tnewEvent.startTime = occurrence.startTime\n\t\t\t\t\t\tnewEvent.endTime = DateTime.fromJSDate(newEvent.startTime, { zone: this.zone }).plus(newDuration).toJSDate()\n\t\t\t\t\t\t// altered instances never have a repeat rule\n\t\t\t\t\t\tnewEvent.repeatRule = null\n\t\t\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, occurrence)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})(),\n\t\t)\n\t}\n\n\tasync saveNewAlteredInstance({\n\t\teditModels,\n\t\teditModelsForProgenitor,\n\t\texistingInstance,\n\t\tprogenitor,\n\t}: {\n\t\teditModels: CalendarEventEditModels\n\t\teditModelsForProgenitor: CalendarEventEditModels\n\t\texistingInstance: CalendarEvent\n\t\tprogenitor: CalendarEvent\n\t}) {\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\t// NEW: edit models that we used so far are for the new event (rescheduled one). this should be an invite.\n\t\t\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\texistingInstance,\n\t\t\t\t\teditModels,\n\t\t\t\t\tCalendarOperation.EditThis,\n\t\t\t\t)\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\n\t\t\t\t// OLD: but we need to update the existing one as well, to add an exclusion for the original instance that we edited.\n\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\teditModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime)\n\t\t\t\tconst {\n\t\t\t\t\tnewEvent: newProgenitor,\n\t\t\t\t\tsendModels: progenitorSendModels,\n\t\t\t\t\tnewAlarms: progenitorAlarms,\n\t\t\t\t} = assembleEditResultAndAssignFromExisting(progenitor, editModelsForProgenitor, CalendarOperation.EditAll)\n\t\t\t\tconst recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid)\n\t\t\t\trecurrenceIds.push(existingInstance.startTime)\n\t\t\t\tawait this.notificationModel.send(newProgenitor, recurrenceIds, progenitorSendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newProgenitor, progenitorAlarms, this.zone, calendar.groupRoot, progenitor)\n\n\t\t\t\t// NEW\n\t\t\t\tconst { groupRoot } = calendar\n\t\t\t\tawait this.calendarModel.createEvent(newEvent, newAlarms, this.zone, groupRoot)\n\t\t\t})(),\n\t\t)\n\t}\n\n\tasync saveExistingAlteredInstance(editModels: CalendarEventEditModels, existingInstance: CalendarEvent): Promise<void> {\n\t\tconst { newEvent, calendar, newAlarms, sendModels } = assembleEditResultAndAssignFromExisting(existingInstance, editModels, CalendarOperation.EditThis)\n\t\tconst { groupRoot } = calendar\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(newEvent, [], sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, groupRoot, existingInstance)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** delete a whole event and all the instances generated by it */\n\tasync deleteEntireExistingEvent(editModels: CalendarEventEditModels, existingEvent: CalendarEvent): Promise<void> {\n\t\teditModels.whoModel.shouldSendUpdates = true\n\t\tconst { sendModels } = assembleCalendarEventEditResult(editModels)\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tconst alteredOccurrences = await this.calendarModel.getEventsByUid(assertNotNull(existingEvent.uid))\n\t\t\t\tif (alteredOccurrences) {\n\t\t\t\t\tfor (const occurrence of alteredOccurrences.alteredInstances) {\n\t\t\t\t\t\tif (occurrence.attendees.length === 0) continue\n\t\t\t\t\t\tconst { sendModels } = assembleEditResultAndAssignFromExisting(occurrence, editModels, CalendarOperation.DeleteAll)\n\t\t\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\t\t\tsendModels.updateModel = null\n\t\t\t\t\t\tawait this.notificationModel.send(occurrence, [], sendModels)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsendModels.cancelModel = sendModels.updateModel\n\t\t\t\tsendModels.updateModel = null\n\t\t\t\tawait this.notificationModel.send(existingEvent, [], sendModels)\n\t\t\t\tif (existingEvent.uid != null) {\n\t\t\t\t\tawait this.calendarModel.deleteEventsByUid(existingEvent.uid)\n\t\t\t\t}\n\t\t\t\t// doing this explicitly because we might have clicked an event that's not listed in\n\t\t\t\t// the uid index for some reason. this prevents bugs from creating undeletable events.\n\t\t\t\tawait this.calendarModel.deleteEvent(existingEvent)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** add an exclusion to the progenitor and send an update. */\n\tasync excludeSingleInstance(editModelsForProgenitor: CalendarEventEditModels, existingInstance: CalendarEvent, progenitor: CalendarEvent): Promise<void> {\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\teditModelsForProgenitor.whoModel.shouldSendUpdates = true\n\t\t\t\teditModelsForProgenitor.whenModel.excludeDate(existingInstance.startTime)\n\t\t\t\tconst { newEvent, sendModels, calendar, newAlarms } = assembleEditResultAndAssignFromExisting(\n\t\t\t\t\tprogenitor,\n\t\t\t\t\teditModelsForProgenitor,\n\t\t\t\t\tCalendarOperation.DeleteThis,\n\t\t\t\t)\n\t\t\t\tconst recurrenceIds = await this.lazyRecurrenceIds(progenitor.uid)\n\t\t\t\trecurrenceIds.push(existingInstance.startTime)\n\t\t\t\tawait this.notificationModel.send(newEvent, recurrenceIds, sendModels)\n\t\t\t\tawait this.calendarModel.updateEvent(newEvent, newAlarms, this.zone, calendar.groupRoot, progenitor)\n\t\t\t})(),\n\t\t)\n\t}\n\n\t/** only remove a single altered instance from the server & the uid index. will not modify the progenitor. */\n\tasync deleteAlteredInstance(editModels: CalendarEventEditModels, existingAlteredInstance: CalendarEvent): Promise<void> {\n\t\teditModels.whoModel.shouldSendUpdates = true\n\t\tconst { sendModels } = assembleCalendarEventEditResult(editModels)\n\t\tsendModels.cancelModel = sendModels.updateModel\n\t\tsendModels.updateModel = null\n\t\tawait this.showProgress(\n\t\t\t(async () => {\n\t\t\t\tawait this.notificationModel.send(existingAlteredInstance, [], sendModels)\n\t\t\t\tawait this.calendarModel.deleteEvent(existingAlteredInstance)\n\t\t\t})(),\n\t\t)\n\t}\n}\n","import { noOp } from \"@tutao/tutanota-utils\"\n\n/**\n * Text view model suitable for data entry that isn't rendered as HTML\n */\nexport class SimpleTextViewModel {\n\tconstructor(private text: string, private readonly uiUpdateCallback: () => void = noOp) {}\n\n\tset content(text: string) {\n\t\tthis.text = text\n\t\tthis.uiUpdateCallback()\n\t}\n\n\tget content(): string {\n\t\treturn this.text\n\t}\n}\n","/**\n * This file contains the most important functions and classes to determine the event type, the organizer of the event and possible\n * organizers in accordance with the capabilities for events (see table).\n *\n * The most important restriction is that it is impossible to change the guest list or send updates to attendees on events in\n * calendars you do not own, which means that the event has no organizer (guest list is empty) or that the event has guests\n * and therefore also an organizer that's not us.\n *\n * Capability for events is fairly complicated:\n * Note: \"shared\" calendar means \"not owner of the calendar\". Calendar always looks like personal for the owner.\n * Note: \"has attendees\" applies to events for which invites were already sent. while editing and adding attendees, \"no attendees\" applies.\n * Note: the only organizer that an event can have is the owner of the calendar the event is defined in.\n *\n * | Event State\t\t\t                         || Possible operations\n * | calendar access  | event origin | has attendees || edit details  | edit own attendance | modify attendees | add alarms |\n * |------------------+--------------+---------------++---------------+---------------------+------------------|------------|\n * | own              | calendar     | no            || yes           | n/a                 | yes              | yes        |\n * | own              | invite       | no            || n/a           | n/a                 | n/a              | yes        |\n * | shared rw        | calendar     | no            || yes           | n/a                 | no               | yes        |\n * | shared rw        | invite       | no            || n/a           | n/a                 | n/a              | yes        |\n * | shared ro        | any          | no            || no            | n/a                 | no               | no         |\n * |------------------+--------------+---------------++---------------+---------------------+------------------|------------|\n * | own              | calendar     | yes           || yes           | yes                 | yes              | yes        |\n * | own              | invite       | yes           || no            | yes                 | no               | yes        |\n * | shared rw        | any          | yes           || no            | no                  | no               | yes        |\n * | shared ro        | any          | yes           || no            | no                  | no               | no         |\n *\n * The fairly complicated event edit operation is split into several submodels that are stored on the CalendarEventModel.editModels field.\n * They roughly correspond to the questions of\n * * when and how often the event happens (see CalendarEventWhenModel.ts)\n * * who participates and has access to the event (see CalendarEventWhoModel.ts)\n * * the alarms the current user set for the event (CalendarEventAlarmModel.ts)\n * * what the event is about (description, summary)\n * * where the event takes place (location)\n *\n * These are in descending order of complexity, the last two points are essentially just (rich)text fields.\n *\n * The general flow for editing an event is as follows:\n * * call makeCalendarEventModel (probably via the locator). The most important decision here is what EventType we are dealing with.\n * * edit the properties that need to be edited\n * * call \"saveNewEvent\" or \"updateExistingEvent\" on the CalendarEventModel. internally, this means:\n *   * the model takes the contents of the editModels field and uses them to assemble the result of the edit operation\n *   * the event identity is assigned\n *   * notify the attendees that the CalendarEventWhoModel determined need to be notified\n *   * save the event and its alarms to the server\n *\n * While it's possible to call the save operation multiple times, the intention is to use a new model for each edit operation.\n *\n * Future improvements: CalendarEventModel should probably be several classes with a generic \"save\" and \"editModels\" interface instead\n * of being capable of doing whatever and being controlled by the caller.\n *     * invite: save sends update to organizer, then saves (if it's in own calendar)\n *     * new event: save notifies attendees, saves the event as new.\n *     * existing event: updates/invites/cancels attendees, then updates.\n *     * etc.\n */\n\nimport { AccountType } from \"../../../../common/api/common/TutanotaConstants.js\"\nimport {\n\tCalendarEvent,\n\tCalendarEventAttendee,\n\tcreateCalendarEvent,\n\tcreateEncryptedMailAddress,\n\tEncryptedMailAddress,\n\tMail,\n\tMailboxProperties,\n} from \"../../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { User } from \"../../../../common/api/entities/sys/TypeRefs.js\"\nimport type { MailboxDetail } from \"../../../../common/mailFunctionality/MailboxModel.js\"\nimport {\n\tAlarmInterval,\n\tareRepeatRulesEqual,\n\tDefaultDateProvider,\n\tfindFirstPrivateCalendar,\n\tgetTimeZone,\n\tincrementSequence,\n\tparseAlarmInterval,\n} from \"../../../../common/calendar/date/CalendarUtils.js\"\nimport { arrayEqualsWithPredicate, assertNonNull, assertNotNull, identity, lazy, Require } from \"@tutao/tutanota-utils\"\nimport { cleanMailAddress } from \"../../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { assertEventValidity, CalendarInfo, CalendarModel } from \"../../model/CalendarModel.js\"\nimport { NotFoundError, PayloadTooLargeError } from \"../../../../common/api/common/error/RestError.js\"\nimport { CalendarNotificationSender } from \"../../view/CalendarNotificationSender.js\"\nimport { SendMailModel } from \"../../../../common/mailFunctionality/SendMailModel.js\"\nimport { UserError } from \"../../../../common/api/main/UserError.js\"\nimport { EntityClient } from \"../../../../common/api/common/EntityClient.js\"\nimport { RecipientsModel } from \"../../../../common/api/main/RecipientsModel.js\"\nimport { LoginController } from \"../../../../common/api/main/LoginController.js\"\nimport m from \"mithril\"\nimport { PartialRecipient } from \"../../../../common/api/common/recipients/Recipient.js\"\nimport { getPasswordStrengthForUser } from \"../../../../common/misc/passwords/PasswordUtils.js\"\nimport { CalendarEventWhenModel } from \"./CalendarEventWhenModel.js\"\nimport { CalendarEventWhoModel } from \"./CalendarEventWhoModel.js\"\nimport { CalendarEventAlarmModel } from \"./CalendarEventAlarmModel.js\"\nimport { SanitizedTextViewModel } from \"../../../../common/misc/SanitizedTextViewModel.js\"\nimport { getStrippedClone, Stripped, StrippedEntity } from \"../../../../common/api/common/utils/EntityUtils.js\"\nimport { UserController } from \"../../../../common/api/main/UserController.js\"\nimport { CalendarNotificationModel, CalendarNotificationSendModels } from \"./CalendarNotificationModel.js\"\nimport { CalendarEventApplyStrategies, CalendarEventModelStrategy } from \"./CalendarEventModelStrategy.js\"\nimport { ProgrammingError } from \"../../../../common/api/common/error/ProgrammingError.js\"\nimport { SimpleTextViewModel } from \"../../../../common/misc/SimpleTextViewModel.js\"\nimport { AlarmInfoTemplate } from \"../../../../common/api/worker/facades/lazy/CalendarFacade.js\"\nimport { getEventType } from \"../CalendarGuiUtils.js\"\nimport { getDefaultSender } from \"../../../../common/mailFunctionality/SharedMailUtils.js\"\n\n/** the type of the event determines which edit operations are available to us. */\nexport const enum EventType {\n\t/** event in our own calendar and we are organizer */\n\tOWN = \"own\",\n\t/** event in shared calendar with read permission */\n\tSHARED_RO = \"shared_ro\",\n\t/** event in shared calendar with write permission, that has no attendees */\n\tSHARED_RW = \"shared_rw\",\n\t/** shared with write permissions, but we can't edit anything but alarms because it has attendees. might be something the calendar owner was invited to. */\n\tLOCKED = \"locked\",\n\t/** invite from calendar invitation which is not stored in calendar yet, or event stored in **own calendar** and we are not organizer. */\n\tINVITE = \"invite\",\n\t/** we are an external user and see an event in our mailbox */\n\tEXTERNAL = \"external\",\n}\n\nexport const enum ReadonlyReason {\n\t/** it's a shared event, so at least the attendees are read-only */\n\tSHARED,\n\t/** this edit operation applies to only part of a series, so attendees and calendar are read-only */\n\tSINGLE_INSTANCE,\n\t/** the organizer is not the current user */\n\tNOT_ORGANIZER,\n\t/** the event cannot be edited for an unspecified reason. This is the default value */\n\tUNKNOWN,\n\t/** we can edit anything here */\n\tNONE,\n}\n\n/**\n * complete calendar event except the parts that define the identity of the event instance (in ical terms) and the technical fields.\n * when the excluded fields are added, this type can be used to set up a series, update a series or reschedule an instance of a series\n * hashedUid is excluded separately since it's not really relevant to the client's logic.\n */\nexport type CalendarEventValues = Omit<Stripped<CalendarEvent>, EventIdentityFieldNames | \"hashedUid\">\n\n/**\n * the parts of a calendar event that define the identity of the event instance.\n */\nexport type CalendarEventIdentity = Pick<Stripped<CalendarEvent>, EventIdentityFieldNames>\n\n/**\n * which parts of a calendar event series to apply an edit operation to.\n * consumers must take care to only use appropriate values for the operation\n * in question (ie removing a repeat rule from a single event in a series is nonsensical)\n */\nexport const enum CalendarOperation {\n\t/** create a new event */\n\tCreate,\n\t/** only apply an edit to only one particular instance of the series */\n\tEditThis,\n\t/** Delete a single instance from a series, altered or not */\n\tDeleteThis,\n\t/** apply the edit operation to all instances of the series*/\n\tEditAll,\n\t/** delete the whole series */\n\tDeleteAll,\n}\n\n/**\n * get the models enabling consistent calendar event updates.\n */\nexport async function makeCalendarEventModel(\n\toperation: CalendarOperation,\n\tinitialValues: Partial<CalendarEvent>,\n\trecipientsModel: RecipientsModel,\n\tcalendarModel: CalendarModel,\n\tlogins: LoginController,\n\tmailboxDetail: MailboxDetail,\n\tmailboxProperties: MailboxProperties,\n\tsendMailModelFactory: lazy<SendMailModel>,\n\tnotificationSender: CalendarNotificationSender,\n\tentityClient: EntityClient,\n\tresponseTo: Mail | null,\n\tzone: string = getTimeZone(),\n\tshowProgress: ShowProgressCallback = identity,\n\tuiUpdateCallback: () => void = m.redraw,\n): Promise<CalendarEventModel | null> {\n\tconst { htmlSanitizer } = await import(\"../../../../common/misc/HtmlSanitizer.js\")\n\tconst ownMailAddresses = getOwnMailAddressesWithDefaultSenderInFront(logins, mailboxDetail, mailboxProperties)\n\tif (operation === CalendarOperation.DeleteAll || operation === CalendarOperation.EditAll) {\n\t\tassertNonNull(initialValues.uid, \"tried to edit/delete all with nonexistent uid\")\n\t\tconst index = await calendarModel.getEventsByUid(initialValues.uid)\n\t\tif (index != null && index.progenitor != null) {\n\t\t\tinitialValues = index.progenitor\n\t\t}\n\t}\n\n\tconst user = logins.getUserController().user\n\tconst [alarms, calendars] = await Promise.all([\n\t\tresolveAlarmsForEvent(initialValues.alarmInfos ?? [], calendarModel, user),\n\t\tcalendarModel.getCalendarInfos(),\n\t])\n\tconst selectedCalendar = getPreselectedCalendar(calendars, initialValues)\n\tconst getPasswordStrength = (password: string, recipientInfo: PartialRecipient) =>\n\t\tgetPasswordStrengthForUser(password, recipientInfo, mailboxDetail, logins)\n\n\tconst eventType = getEventType(\n\t\tinitialValues,\n\t\tcalendars,\n\t\townMailAddresses.map(({ address }) => address),\n\t\tlogins.getUserController(),\n\t)\n\n\tconst makeEditModels = (initializationEvent: CalendarEvent) => ({\n\t\twhenModel: new CalendarEventWhenModel(initializationEvent, zone, uiUpdateCallback),\n\t\twhoModel: new CalendarEventWhoModel(\n\t\t\tinitializationEvent,\n\t\t\teventType,\n\t\t\toperation,\n\t\t\tcalendars,\n\t\t\tselectedCalendar,\n\t\t\tlogins.getUserController(),\n\t\t\toperation === CalendarOperation.Create,\n\t\t\townMailAddresses,\n\t\t\trecipientsModel,\n\t\t\tresponseTo,\n\t\t\tgetPasswordStrength,\n\t\t\tsendMailModelFactory,\n\t\t\tuiUpdateCallback,\n\t\t),\n\t\talarmModel: new CalendarEventAlarmModel(eventType, alarms, new DefaultDateProvider(), uiUpdateCallback),\n\t\tlocation: new SimpleTextViewModel(initializationEvent.location, uiUpdateCallback),\n\t\tsummary: new SimpleTextViewModel(initializationEvent.summary, uiUpdateCallback),\n\t\tdescription: new SanitizedTextViewModel(initializationEvent.description, htmlSanitizer, uiUpdateCallback),\n\t})\n\n\tconst recurrenceIds = async (uid?: string) =>\n\t\tuid == null ? [] : (await calendarModel.getEventsByUid(uid))?.alteredInstances.map((i) => i.recurrenceId) ?? []\n\tconst notificationModel = new CalendarNotificationModel(notificationSender, logins)\n\tconst applyStrategies = new CalendarEventApplyStrategies(calendarModel, logins, notificationModel, recurrenceIds, showProgress, zone)\n\tconst initialOrDefaultValues = Object.assign(makeEmptyCalendarEvent(), initialValues)\n\tconst cleanInitialValues = cleanupInitialValuesForEditing(initialOrDefaultValues)\n\tconst progenitor = () => calendarModel.resolveCalendarEventProgenitor(cleanInitialValues)\n\tconst strategy = await selectStrategy(\n\t\tmakeEditModels,\n\t\tapplyStrategies,\n\t\toperation,\n\t\tprogenitor,\n\t\tcreateCalendarEvent(initialOrDefaultValues),\n\t\tcleanInitialValues,\n\t)\n\treturn strategy && new CalendarEventModel(strategy, eventType, operation, logins.getUserController(), notificationSender, entityClient, calendars)\n}\n\nasync function selectStrategy(\n\tmakeEditModels: (i: StrippedEntity<CalendarEvent>) => CalendarEventEditModels,\n\tapplyStrategies: CalendarEventApplyStrategies,\n\toperation: CalendarOperation,\n\tresolveProgenitor: () => Promise<CalendarEvent | null>,\n\texistingInstanceIdentity: CalendarEvent,\n\tcleanInitialValues: StrippedEntity<CalendarEvent>,\n): Promise<CalendarEventModelStrategy | null> {\n\tlet editModels: CalendarEventEditModels\n\tlet apply: () => Promise<void>\n\tlet mayRequireSendingUpdates: () => boolean\n\tif (operation === CalendarOperation.Create) {\n\t\teditModels = makeEditModels(cleanInitialValues)\n\t\tapply = () => applyStrategies.saveNewEvent(editModels)\n\t\tmayRequireSendingUpdates = () => true\n\t} else if (operation === CalendarOperation.EditThis) {\n\t\tcleanInitialValues.repeatRule = null\n\t\tif (cleanInitialValues.recurrenceId == null) {\n\t\t\tconst progenitor = await resolveProgenitor()\n\t\t\tif (progenitor == null || progenitor.repeatRule == null) {\n\t\t\t\tconsole.warn(\"no repeating progenitor during EditThis operation?\")\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tapply = () =>\n\t\t\t\tapplyStrategies.saveNewAlteredInstance({\n\t\t\t\t\teditModels: editModels,\n\t\t\t\t\teditModelsForProgenitor: makeEditModels(progenitor),\n\t\t\t\t\texistingInstance: existingInstanceIdentity,\n\t\t\t\t\tprogenitor: progenitor,\n\t\t\t\t})\n\t\t\tmayRequireSendingUpdates = () => true\n\t\t\teditModels = makeEditModels(cleanInitialValues)\n\t\t} else {\n\t\t\teditModels = makeEditModels(cleanInitialValues)\n\t\t\tapply = () => applyStrategies.saveExistingAlteredInstance(editModels, existingInstanceIdentity)\n\t\t\tmayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges\n\t\t}\n\t} else if (operation === CalendarOperation.DeleteThis) {\n\t\tif (cleanInitialValues.recurrenceId == null) {\n\t\t\tconst progenitor = await resolveProgenitor()\n\t\t\tif (progenitor == null) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\teditModels = makeEditModels(progenitor)\n\t\t\tapply = () => applyStrategies.excludeSingleInstance(editModels, existingInstanceIdentity, progenitor)\n\t\t\tmayRequireSendingUpdates = () => true\n\t\t} else {\n\t\t\teditModels = makeEditModels(cleanInitialValues)\n\t\t\tapply = () => applyStrategies.deleteAlteredInstance(editModels, existingInstanceIdentity)\n\t\t\tmayRequireSendingUpdates = () => true\n\t\t}\n\t} else if (operation === CalendarOperation.EditAll) {\n\t\tconst progenitor = await resolveProgenitor()\n\t\tif (progenitor == null) {\n\t\t\treturn null\n\t\t}\n\t\teditModels = makeEditModels(cleanInitialValues)\n\t\tapply = () => applyStrategies.saveEntireExistingEvent(editModels, progenitor)\n\t\tmayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges\n\t} else if (operation === CalendarOperation.DeleteAll) {\n\t\teditModels = makeEditModels(cleanInitialValues)\n\t\tapply = () => applyStrategies.deleteEntireExistingEvent(editModels, existingInstanceIdentity)\n\t\tmayRequireSendingUpdates = () => assembleEditResultAndAssignFromExisting(existingInstanceIdentity, editModels, operation).hasUpdateWorthyChanges\n\t} else {\n\t\tthrow new ProgrammingError(`unknown calendar operation: ${operation}`)\n\t}\n\n\treturn { apply, mayRequireSendingUpdates, editModels }\n}\n\n/** return all the attendees in the list of attendees that are not the given organizer. */\nexport function getNonOrganizerAttendees({\n\torganizer,\n\tattendees,\n}: Partial<Pick<Readonly<CalendarEvent>, \"attendees\" | \"organizer\">>): ReadonlyArray<CalendarEventAttendee> {\n\tif (attendees == null) return []\n\tif (organizer == null) return attendees\n\tconst organizerAddress = cleanMailAddress(organizer.address)\n\treturn attendees.filter((a) => cleanMailAddress(a.address.address) !== organizerAddress) ?? []\n}\n\n/**\n * Determines the event type, the organizer of the event and possible organizers in accordance with the capabilities for events (see table).\n */\nexport class CalendarEventModel {\n\tprocessing: boolean = false\n\n\tget editModels(): CalendarEventEditModels {\n\t\treturn this.strategy.editModels\n\t}\n\n\tconstructor(\n\t\tprivate readonly strategy: CalendarEventModelStrategy,\n\t\tpublic readonly eventType: EventType,\n\t\tpublic readonly operation: CalendarOperation,\n\t\t// UserController already keeps track of user updates, it is better to not have our own reference to the user, we might miss\n\t\t// important updates like premium upgrade\n\t\treadonly userController: UserController,\n\t\tprivate readonly distributor: CalendarNotificationSender,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly calendars: ReadonlyMap<Id, CalendarInfo>,\n\t) {\n\t\tthis.calendars = calendars\n\t}\n\n\tasync apply(): Promise<EventSaveResult> {\n\t\tif (this.userController.user.accountType === AccountType.EXTERNAL) {\n\t\t\tconsole.log(\"did not apply event changes, we're an external user.\")\n\t\t\treturn EventSaveResult.Failed\n\t\t}\n\t\tif (this.processing) {\n\t\t\treturn EventSaveResult.Failed\n\t\t}\n\t\tthis.processing = true\n\n\t\ttry {\n\t\t\tawait this.strategy.apply()\n\t\t\treturn EventSaveResult.Saved\n\t\t} catch (e) {\n\t\t\tif (e instanceof PayloadTooLargeError) {\n\t\t\t\tthrow new UserError(\"requestTooLarge_msg\")\n\t\t\t} else if (e instanceof NotFoundError) {\n\t\t\t\treturn EventSaveResult.NotFound\n\t\t\t} else {\n\t\t\t\tthrow e\n\t\t\t}\n\t\t} finally {\n\t\t\tthis.processing = false\n\t\t}\n\t}\n\n\t/** false if the event is only partially or not at all writable */\n\tisFullyWritable(): boolean {\n\t\treturn this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW\n\t}\n\n\t/** some edit operations apply to the whole event series.\n\t * they are not possible if the operation the model was created with only applies to a single instance.\n\t *\n\t * returns true if such operations can be attempted.\n\t * */\n\tcanEditSeries(): boolean {\n\t\treturn this.operation !== CalendarOperation.EditThis && (this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW)\n\t}\n\n\tcanChangeCalendar(): boolean {\n\t\treturn (\n\t\t\tthis.operation !== CalendarOperation.EditThis &&\n\t\t\t(this.eventType === EventType.OWN || this.eventType === EventType.SHARED_RW || this.eventType === EventType.INVITE)\n\t\t)\n\t}\n\n\tisAskingForUpdatesNeeded(): boolean {\n\t\treturn (\n\t\t\tthis.eventType === EventType.OWN &&\n\t\t\t!this.editModels.whoModel.shouldSendUpdates &&\n\t\t\tthis.editModels.whoModel.initiallyHadOtherAttendees &&\n\t\t\tthis.strategy.mayRequireSendingUpdates()\n\t\t)\n\t}\n\n\tgetReadonlyReason(): ReadonlyReason {\n\t\tconst isFullyWritable = this.isFullyWritable()\n\t\tconst canEditSeries = this.canEditSeries()\n\t\tconst canModifyGuests = this.editModels.whoModel.canModifyGuests\n\n\t\tif (isFullyWritable && canEditSeries && canModifyGuests) return ReadonlyReason.NONE\n\t\tif (!isFullyWritable && !canEditSeries && !canModifyGuests) return ReadonlyReason.NOT_ORGANIZER\n\t\t// fully writable and !canModifyGuests happens on shared calendars\n\t\tif (!canModifyGuests) {\n\t\t\tif (canEditSeries) {\n\t\t\t\treturn ReadonlyReason.SHARED\n\t\t\t} else {\n\t\t\t\treturn ReadonlyReason.SINGLE_INSTANCE\n\t\t\t}\n\t\t}\n\t\treturn ReadonlyReason.UNKNOWN\n\t}\n}\n\n/**\n *\n * @param now the new event.\n * @param previous the event as it originally was\n * @returns {boolean} true if changes were made to the event that justify sending updates to attendees.\n * exported for testing\n */\nexport function eventHasChanged(now: CalendarEvent, previous: Partial<CalendarEvent> | null): boolean {\n\tif (previous == null) return true\n\t// we do not check for the sequence number (as it should be changed with every update) or the default instance properties such as _id\n\treturn (\n\t\tnow.startTime.getTime() !== previous?.startTime?.getTime() ||\n\t\tnow.description !== previous?.description ||\n\t\tnow.summary !== previous.summary ||\n\t\tnow.location !== previous.location ||\n\t\tnow.endTime.getTime() !== previous?.endTime?.getTime() ||\n\t\tnow.invitedConfidentially !== previous.invitedConfidentially ||\n\t\t// should this be a hard error, we never want to change the uid or compare events with different UIDs?\n\t\tnow.uid !== previous.uid ||\n\t\t!areRepeatRulesEqual(now.repeatRule, previous?.repeatRule ?? null) ||\n\t\t!arrayEqualsWithPredicate(\n\t\t\tnow.attendees,\n\t\t\tprevious?.attendees ?? [],\n\t\t\t(a1, a2) => a1.status === a2.status && cleanMailAddress(a1.address.address) === cleanMailAddress(a2.address.address),\n\t\t) || // we ignore the names\n\t\t(now.organizer !== previous.organizer && now.organizer?.address !== previous.organizer?.address)\n\t) // we ignore the names\n}\n\n/**\n * construct a usable calendar event from the result of one or more edit operations.\n * returns the new alarms separately so they can be set up\n * on the server before assigning the ids.\n * @param models\n */\nexport function assembleCalendarEventEditResult(models: CalendarEventEditModels): {\n\teventValues: CalendarEventValues\n\tnewAlarms: ReadonlyArray<AlarmInfoTemplate>\n\tsendModels: CalendarNotificationSendModels\n\tcalendar: CalendarInfo\n} {\n\tconst whenResult = models.whenModel.result\n\tconst whoResult = models.whoModel.result\n\tconst alarmResult = models.alarmModel.result\n\tconst summary = models.summary.content\n\tconst description = models.description.content\n\tconst location = models.location.content\n\n\treturn {\n\t\teventValues: {\n\t\t\t// when?\n\t\t\tstartTime: whenResult.startTime,\n\t\t\tendTime: whenResult.endTime,\n\t\t\trepeatRule: whenResult.repeatRule,\n\t\t\t// what?\n\t\t\tsummary,\n\t\t\tdescription,\n\t\t\t// where?\n\t\t\tlocation,\n\t\t\t// who?\n\t\t\tinvitedConfidentially: whoResult.isConfidential,\n\t\t\torganizer: whoResult.organizer,\n\t\t\tattendees: whoResult.attendees,\n\t\t\t// fields related to the event instance's identity are excluded.\n\t\t\t// reminders. will be set up separately.\n\t\t\talarmInfos: [],\n\t\t},\n\t\tnewAlarms: alarmResult.alarms,\n\t\tsendModels: whoResult,\n\t\tcalendar: whoResult.calendar,\n\t}\n}\n\n/** assemble the edit result from an existing event edit operation and apply some fields from the original event\n * @param existingEvent the event we will be updating and take id, ownerGroup and permissions from as well as the uid, sequence to increment and recurrenceId\n * @param editModels the editModels providing the values for the new event.\n * @param operation determines the source of the recurrenceId - in the case of EditThis it's the start time of the original event, otherwise existingEvents' recurrenceId is used.\n */\nexport function assembleEditResultAndAssignFromExisting(existingEvent: CalendarEvent, editModels: CalendarEventEditModels, operation: CalendarOperation) {\n\tconst assembleResult = assembleCalendarEventEditResult(editModels)\n\tconst { uid: oldUid, sequence: oldSequence, recurrenceId } = existingEvent\n\tconst newEvent = assignEventIdentity(assembleResult.eventValues, {\n\t\tuid: oldUid!,\n\t\tsequence: incrementSequence(oldSequence),\n\t\trecurrenceId: operation === CalendarOperation.EditThis && recurrenceId == null ? existingEvent.startTime : recurrenceId,\n\t})\n\n\tassertEventValidity(newEvent)\n\n\tnewEvent._id = existingEvent._id\n\tnewEvent._ownerGroup = existingEvent._ownerGroup\n\tnewEvent._permissions = existingEvent._permissions\n\n\treturn {\n\t\thasUpdateWorthyChanges: eventHasChanged(newEvent, existingEvent),\n\t\tnewEvent,\n\t\tcalendar: assembleResult.calendar,\n\t\tnewAlarms: assembleResult.newAlarms,\n\t\tsendModels: assembleResult.sendModels,\n\t}\n}\n\n/**\n * combine event values with the fields required to identify a particular instance of the event.\n * @param values\n * @param identity sequence (default \"0\") and recurrenceId (default null) are optional, but the uid must be specified.\n */\nexport function assignEventIdentity(values: CalendarEventValues, identity: Require<\"uid\", Partial<CalendarEventIdentity>>): CalendarEvent {\n\treturn createCalendarEvent({\n\t\tsequence: \"0\",\n\t\trecurrenceId: null,\n\t\thashedUid: null,\n\t\t...values,\n\t\t...identity,\n\t})\n}\n\nasync function resolveAlarmsForEvent(alarms: CalendarEvent[\"alarmInfos\"], calendarModel: CalendarModel, user: User): Promise<Array<AlarmInterval>> {\n\tconst alarmInfos = await calendarModel.loadAlarms(alarms, user)\n\treturn alarmInfos.map(({ alarmInfo }) => parseAlarmInterval(alarmInfo.trigger))\n}\n\nfunction makeEmptyCalendarEvent(): StrippedEntity<CalendarEvent> {\n\treturn {\n\t\talarmInfos: [],\n\t\tinvitedConfidentially: null,\n\t\thashedUid: null,\n\t\tuid: null,\n\t\trecurrenceId: null,\n\t\tendTime: new Date(),\n\t\tsummary: \"\",\n\t\tstartTime: new Date(),\n\t\tlocation: \"\",\n\t\trepeatRule: null,\n\t\tdescription: \"\",\n\t\tattendees: [],\n\t\torganizer: null,\n\t\tsequence: \"\",\n\t}\n}\n\nfunction cleanupInitialValuesForEditing(initialValues: StrippedEntity<CalendarEvent>): CalendarEvent {\n\t// the event we got passed may already have some technical fields assigned, so we remove them.\n\tconst stripped = getStrippedClone<CalendarEvent>(initialValues)\n\tconst result = createCalendarEvent(stripped)\n\n\t// remove the alarm infos from the result, they don't contain any useful information for the editing operation.\n\t// selected alarms are returned in the edit result separate from the event.\n\tresult.alarmInfos = []\n\n\treturn result\n}\n\n/** whether to close dialog */\nexport const enum EventSaveResult {\n\tSaved,\n\tFailed,\n\tNotFound,\n}\n\n/** generic function that asynchronously returns whatever type the caller passed in, but not necessarily the same promise. */\nexport type ShowProgressCallback = <T>(input: Promise<T>) => Promise<T>\n\n/** exported for testing */\nexport type CalendarEventEditModels = {\n\twhenModel: CalendarEventWhenModel\n\twhoModel: CalendarEventWhoModel\n\talarmModel: CalendarEventAlarmModel\n\tlocation: SimpleTextViewModel\n\tsummary: SimpleTextViewModel\n\tdescription: SanitizedTextViewModel\n}\n\n/** the fields that together with the start time point to a specific version and instance of an event */\ntype EventIdentityFieldNames = \"uid\" | \"sequence\" | \"recurrenceId\"\n\n/**\n * return the calendar the given event belongs to, if any, otherwise get the first one from the given calendars.\n * @param calendars must contain at least one calendar\n * @param event\n */\nfunction getPreselectedCalendar(calendars: ReadonlyMap<Id, CalendarInfo>, event?: Partial<CalendarEvent> | null): CalendarInfo {\n\tconst ownerGroup: string | null = event?._ownerGroup ?? null\n\tif (ownerGroup == null || !calendars.has(ownerGroup)) {\n\t\tconst calendar = findFirstPrivateCalendar(calendars)\n\t\tif (!calendar) throw new Error(\"Can't find a private calendar\")\n\t\treturn calendar\n\t} else {\n\t\treturn assertNotNull(calendars.get(ownerGroup), \"invalid ownergroup for existing event?\")\n\t}\n}\n\n/** get the list of mail addresses that are enabled for this mailbox with the configured sender names\n * will put the sender that matches the default sender address in the first spot. this enables us to use\n * it as an easy default without having to pass it around separately */\nfunction getOwnMailAddressesWithDefaultSenderInFront(\n\tlogins: LoginController,\n\tmailboxDetail: MailboxDetail,\n\tmailboxProperties: MailboxProperties,\n): Array<EncryptedMailAddress> {\n\tconst defaultSender = getDefaultSender(logins, mailboxDetail)\n\tconst ownMailAddresses = mailboxProperties.mailAddressProperties.map(({ mailAddress, senderName }) =>\n\t\tcreateEncryptedMailAddress({\n\t\t\taddress: mailAddress,\n\t\t\tname: senderName,\n\t\t}),\n\t)\n\tconst defaultIndex = ownMailAddresses.findIndex((address) => address.address === defaultSender)\n\tif (defaultIndex < 0) {\n\t\t// should not happen\n\t\treturn ownMailAddresses\n\t}\n\tconst defaultEncryptedMailAddress = ownMailAddresses.splice(defaultIndex, 1)\n\treturn [...defaultEncryptedMailAddress, ...ownMailAddresses]\n}\n","import m, { Child, ChildArray, Children } from \"mithril\"\nimport type { TranslationKey } from \"../../../common/misc/LanguageViewModel.js\"\nimport { lang } from \"../../../common/misc/LanguageViewModel.js\"\nimport { ButtonType } from \"../../../common/gui/base/Button.js\"\nimport { Icons } from \"../../../common/gui/base/icons/Icons.js\"\nimport { Dialog } from \"../../../common/gui/base/Dialog.js\"\nimport type { MousePosAndBounds } from \"../../../common/gui/base/GuiUtils.js\"\nimport { Time } from \"../../../common/calendar/date/Time.js\"\nimport {\n\tassert,\n\tassertNotNull,\n\tclamp,\n\tclone,\n\tgetFromMap,\n\tgetStartOfDay,\n\tincrementDate,\n\tisNotEmpty,\n\tisSameDay,\n\tisSameDayOfDate,\n\tmemoized,\n\tnumberRange,\n\ttypedValues,\n} from \"@tutao/tutanota-utils\"\nimport { IconButton } from \"../../../common/gui/base/IconButton.js\"\nimport {\n\tformatDateTime,\n\tformatDateWithMonth,\n\tformatDateWithWeekday,\n\tformatMonthWithFullYear,\n\tformatTime,\n\ttimeStringFromParts,\n} from \"../../../common/misc/Formatter.js\"\nimport {\n\tAlarmInterval,\n\talarmIntervalToLuxonDurationLikeObject,\n\tAlarmIntervalUnit,\n\tCalendarDay,\n\tCalendarMonth,\n\teventEndsAfterDay,\n\teventStartsBefore,\n\tgetAllDayDateForTimezone,\n\tgetEndOfDayWithZone,\n\tgetEventEnd,\n\tgetEventStart,\n\tgetStartOfDayWithZone,\n\tgetStartOfNextDayWithZone,\n\tgetStartOfTheWeekOffset,\n\tgetStartOfWeek,\n\tgetTimeZone,\n\tgetWeekNumber,\n\tincrementByRepeatPeriod,\n\tStandardAlarmInterval,\n} from \"../../../common/calendar/date/CalendarUtils.js\"\nimport {\n\tAccountType,\n\tCalendarAttendeeStatus,\n\tCLIENT_ONLY_CALENDARS,\n\tDEFAULT_CLIENT_ONLY_CALENDAR_COLORS,\n\tdefaultCalendarColor,\n\tEndType,\n\tEventTextTimeOption,\n\tRepeatPeriod,\n\tShareCapability,\n\tWeekStart,\n} from \"../../../common/api/common/TutanotaConstants.js\"\nimport { AllIcons } from \"../../../common/gui/base/Icon.js\"\nimport { SelectorItemList } from \"../../../common/gui/base/DropDownSelector.js\"\nimport { DateTime, Duration } from \"luxon\"\nimport { CalendarEventTimes, CalendarViewType, cleanMailAddress, isAllDayEvent } from \"../../../common/api/common/utils/CommonCalendarUtils.js\"\nimport { CalendarEvent, UserSettingsGroupRoot } from \"../../../common/api/entities/tutanota/TypeRefs.js\"\nimport { ProgrammingError } from \"../../../common/api/common/error/ProgrammingError.js\"\nimport { size } from \"../../../common/gui/size.js\"\nimport { hslToHex, isColorLight, isValidColorCode, MAX_HUE_ANGLE } from \"../../../common/gui/base/Color.js\"\nimport { GroupColors } from \"../view/CalendarView.js\"\nimport { CalendarInfo } from \"../model/CalendarModel.js\"\nimport { EventType } from \"./eventeditor-model/CalendarEventModel.js\"\nimport { hasCapabilityOnGroup } from \"../../../common/sharing/GroupUtils.js\"\nimport { EventsOnDays } from \"../view/CalendarViewModel.js\"\nimport { CalendarEventPreviewViewModel } from \"./eventpopup/CalendarEventPreviewViewModel.js\"\nimport { createAsyncDropdown } from \"../../../common/gui/base/Dropdown.js\"\nimport { UserController } from \"../../../common/api/main/UserController.js\"\nimport { ClientOnlyCalendarsInfo } from \"../../../common/misc/DeviceConfig.js\"\nimport { SelectOption } from \"../../../common/gui/base/Select.js\"\nimport { RadioGroupOption } from \"../../../common/gui/base/RadioGroup.js\"\nimport { ColorPickerModel } from \"../../../common/gui/base/colorPicker/ColorPickerModel.js\"\nimport { theme } from \"../../../common/gui/theme.js\"\n\nexport interface IntervalOption {\n\tvalue: number\n\tariaValue: string\n\tname: string\n}\n\nexport function renderCalendarSwitchLeftButton(label: TranslationKey, click: () => unknown): Child {\n\treturn m(IconButton, {\n\t\ttitle: label,\n\t\ticon: Icons.ArrowBackward,\n\t\tclick,\n\t})\n}\n\nexport function renderCalendarSwitchRightButton(label: TranslationKey, click: () => unknown): Child {\n\treturn m(IconButton, {\n\t\ttitle: label,\n\t\ticon: Icons.ArrowForward,\n\t\tclick,\n\t})\n}\n\nfunction weekTitle(date: Date, weekStart: WeekStart): string {\n\tconst startOfTheWeekOffset = getStartOfTheWeekOffset(weekStart)\n\tconst firstDate = getStartOfWeek(date, startOfTheWeekOffset)\n\tconst lastDate = incrementDate(new Date(firstDate), 6)\n\n\tif (firstDate.getMonth() !== lastDate.getMonth()) {\n\t\tif (firstDate.getFullYear() !== lastDate.getFullYear()) {\n\t\t\treturn `${lang.formats.monthShortWithFullYear.format(firstDate)} - ${lang.formats.monthShortWithFullYear.format(lastDate)}`\n\t\t}\n\t\treturn `${lang.formats.monthShort.format(firstDate)} - ${lang.formats.monthShort.format(lastDate)} ${lang.formats.yearNumeric.format(firstDate)}`\n\t} else {\n\t\treturn `${lang.formats.monthLong.format(firstDate)} ${lang.formats.yearNumeric.format(firstDate)}`\n\t}\n}\n\nexport function getNextFourteenDays(startOfToday: Date): Array<Date> {\n\tlet calculationDate = new Date(startOfToday)\n\tconst days: Date[] = []\n\n\tfor (let i = 0; i < 14; i++) {\n\t\tdays.push(new Date(calculationDate.getTime()))\n\t\tcalculationDate = incrementDate(calculationDate, 1)\n\t}\n\n\treturn days\n}\n\nexport type CalendarNavConfiguration = { back: Child; title: string; forward: Child }\n\nexport function calendarWeek(date: Date, weekStart: WeekStart) {\n\t// According to ISO 8601, weeks always start on Monday. Week numbering systems for\n\t// weeks that do not start on Monday are not strictly defined, so we only display\n\t// a week number if the user's client is configured to start weeks on Monday\n\tif (weekStart !== WeekStart.MONDAY) {\n\t\treturn null\n\t}\n\n\treturn lang.get(\"weekNumber_label\", {\n\t\t\"{week}\": String(getWeekNumber(date)),\n\t})\n}\n\nexport function calendarNavConfiguration(\n\tviewType: CalendarViewType,\n\tdate: Date,\n\tweekStart: WeekStart,\n\ttitleType: \"short\" | \"detailed\",\n\tswitcher: (viewType: CalendarViewType, next: boolean) => unknown,\n): CalendarNavConfiguration {\n\tconst onBack = () => switcher(viewType, false)\n\tconst onForward = () => switcher(viewType, true)\n\tswitch (viewType) {\n\t\tcase CalendarViewType.DAY:\n\t\t\treturn {\n\t\t\t\tback: renderCalendarSwitchLeftButton(\"prevDay_label\", onBack),\n\t\t\t\tforward: renderCalendarSwitchRightButton(\"nextDay_label\", onForward),\n\t\t\t\ttitle: titleType === \"short\" ? formatMonthWithFullYear(date) : formatDateWithWeekday(date),\n\t\t\t}\n\t\tcase CalendarViewType.MONTH:\n\t\t\treturn {\n\t\t\t\tback: renderCalendarSwitchLeftButton(\"prevMonth_label\", onBack),\n\t\t\t\tforward: renderCalendarSwitchRightButton(\"nextMonth_label\", onForward),\n\t\t\t\ttitle: formatMonthWithFullYear(date),\n\t\t\t}\n\t\tcase CalendarViewType.WEEK:\n\t\t\treturn {\n\t\t\t\tback: renderCalendarSwitchLeftButton(\"prevWeek_label\", onBack),\n\t\t\t\tforward: renderCalendarSwitchRightButton(\"nextWeek_label\", onForward),\n\t\t\t\ttitle: titleType === \"short\" ? formatMonthWithFullYear(date) : weekTitle(date, weekStart),\n\t\t\t}\n\t\tcase CalendarViewType.AGENDA:\n\t\t\treturn {\n\t\t\t\tback: renderCalendarSwitchLeftButton(\"prevDay_label\", onBack),\n\t\t\t\tforward: renderCalendarSwitchRightButton(\"nextDay_label\", onForward),\n\t\t\t\ttitle: titleType === \"short\" ? formatMonthWithFullYear(date) : formatDateWithWeekday(date),\n\t\t\t}\n\t}\n}\n\nexport function askIfShouldSendCalendarUpdatesToAttendees(): Promise<\"yes\" | \"no\" | \"cancel\"> {\n\treturn new Promise((resolve) => {\n\t\tlet alertDialog: Dialog\n\t\tconst cancelButton = {\n\t\t\tlabel: \"cancel_action\",\n\t\t\tclick: () => {\n\t\t\t\tresolve(\"cancel\")\n\t\t\t\talertDialog.close()\n\t\t\t},\n\t\t\ttype: ButtonType.Secondary,\n\t\t} as const\n\t\tconst noButton = {\n\t\t\tlabel: \"no_label\",\n\t\t\tclick: () => {\n\t\t\t\tresolve(\"no\")\n\t\t\t\talertDialog.close()\n\t\t\t},\n\t\t\ttype: ButtonType.Secondary,\n\t\t} as const\n\t\tconst yesButton = {\n\t\t\tlabel: \"yes_label\",\n\t\t\tclick: () => {\n\t\t\t\tresolve(\"yes\")\n\t\t\t\talertDialog.close()\n\t\t\t},\n\t\t\ttype: ButtonType.Primary,\n\t\t} as const\n\n\t\tconst onclose = (positive: boolean) => (positive ? resolve(\"yes\") : resolve(\"cancel\"))\n\n\t\talertDialog = Dialog.confirmMultiple(\"sendUpdates_msg\", [cancelButton, noButton, yesButton], onclose)\n\t})\n}\n\n/**\n * Map the location of a mouse click on an element to a give date, given a list of weeks\n * there should be neither zero weeks, nor zero length weeks\n */\nexport function getDateFromMousePos({ x, y, targetWidth, targetHeight }: MousePosAndBounds, weeks: Array<Array<Date>>): Date {\n\tassert(weeks.length > 0, \"Weeks must not be zero length\")\n\tconst unitHeight = targetHeight / weeks.length\n\tconst currentSquareY = Math.floor(y / unitHeight)\n\tconst week = weeks[clamp(currentSquareY, 0, weeks.length - 1)]\n\tassert(week.length > 0, \"Week must not be zero length\")\n\tconst unitWidth = targetWidth / week.length\n\tconst currentSquareX = Math.floor(x / unitWidth)\n\treturn week[clamp(currentSquareX, 0, week.length - 1)]\n}\n\n/**\n * Map the vertical position of a mouse click on an element to a time of day\n * @param y\n * @param targetHeight\n * @param hourDivision: how many times to divide the hour\n */\nexport function getTimeFromMousePos({ y, targetHeight }: MousePosAndBounds, hourDivision: number): Time {\n\tconst sectionHeight = targetHeight / 24\n\tconst hour = y / sectionHeight\n\tconst hourRounded = Math.floor(hour)\n\tconst minutesInc = 60 / hourDivision\n\tconst minute = Math.floor((hour - hourRounded) * hourDivision) * minutesInc\n\treturn new Time(hourRounded, minute)\n}\n\nexport const SELECTED_DATE_INDICATOR_THICKNESS = 4\n\nexport function getIconForViewType(viewType: CalendarViewType): AllIcons {\n\tconst lookupTable: Record<CalendarViewType, AllIcons> = {\n\t\t[CalendarViewType.DAY]: Icons.TableSingle,\n\t\t[CalendarViewType.WEEK]: Icons.TableColumns,\n\t\t[CalendarViewType.MONTH]: Icons.Table,\n\t\t[CalendarViewType.AGENDA]: Icons.ListUnordered,\n\t}\n\treturn lookupTable[viewType]\n}\n\nexport function shouldDefaultToAmPmTimeFormat(): boolean {\n\treturn lang.code === \"en\"\n}\n\n/**\n * get an object representing the calendar month the given date is in.\n */\nexport function getCalendarMonth(date: Date, firstDayOfWeekFromOffset: number, weekdayNarrowFormat: boolean): CalendarMonth {\n\tconst weeks: Array<Array<CalendarDay>> = [[]]\n\tconst calculationDate = getStartOfDay(date)\n\tcalculationDate.setDate(1)\n\tconst beginningOfMonth = new Date(calculationDate)\n\tlet currentYear = calculationDate.getFullYear()\n\tlet month = calculationDate.getMonth()\n\t// add \"padding\" days\n\t// getDay returns the day of the week (from 0 to 6) for the specified date (with first one being Sunday)\n\tlet firstDay\n\n\tif (firstDayOfWeekFromOffset > calculationDate.getDay()) {\n\t\tfirstDay = calculationDate.getDay() + 7 - firstDayOfWeekFromOffset\n\t} else {\n\t\tfirstDay = calculationDate.getDay() - firstDayOfWeekFromOffset\n\t}\n\n\tlet dayCount\n\tincrementDate(calculationDate, -firstDay)\n\n\tfor (dayCount = 0; dayCount < firstDay; dayCount++) {\n\t\tweeks[0].push({\n\t\t\tdate: new Date(calculationDate),\n\t\t\tday: calculationDate.getDate(),\n\t\t\tmonth: calculationDate.getMonth(),\n\t\t\tyear: calculationDate.getFullYear(),\n\t\t\tisPaddingDay: true,\n\t\t})\n\t\tincrementDate(calculationDate, 1)\n\t}\n\n\t// add actual days\n\twhile (calculationDate.getMonth() === month) {\n\t\tif (weeks[0].length && dayCount % 7 === 0) {\n\t\t\t// start new week\n\t\t\tweeks.push([])\n\t\t}\n\n\t\tconst dayInfo = {\n\t\t\tdate: new Date(currentYear, month, calculationDate.getDate()),\n\t\t\tyear: currentYear,\n\t\t\tmonth: month,\n\t\t\tday: calculationDate.getDate(),\n\t\t\tisPaddingDay: false,\n\t\t}\n\t\tweeks[weeks.length - 1].push(dayInfo)\n\t\tincrementDate(calculationDate, 1)\n\t\tdayCount++\n\t}\n\n\t// add remaining \"padding\" days\n\twhile (dayCount < 42) {\n\t\tif (dayCount % 7 === 0) {\n\t\t\tweeks.push([])\n\t\t}\n\n\t\tweeks[weeks.length - 1].push({\n\t\t\tday: calculationDate.getDate(),\n\t\t\tyear: calculationDate.getFullYear(),\n\t\t\tmonth: calculationDate.getMonth(),\n\t\t\tdate: new Date(calculationDate),\n\t\t\tisPaddingDay: true,\n\t\t})\n\t\tincrementDate(calculationDate, 1)\n\t\tdayCount++\n\t}\n\n\tconst weekdays: string[] = []\n\tconst weekdaysDate = new Date()\n\tincrementDate(weekdaysDate, -weekdaysDate.getDay() + firstDayOfWeekFromOffset) // get first day of week\n\n\tfor (let i = 0; i < 7; i++) {\n\t\tweekdays.push(weekdayNarrowFormat ? lang.formats.weekdayNarrow.format(weekdaysDate) : lang.formats.weekdayShort.format(weekdaysDate))\n\t\tincrementDate(weekdaysDate, 1)\n\t}\n\n\treturn {\n\t\tbeginningOfMonth,\n\t\tweekdays,\n\t\tweeks,\n\t}\n}\n\nexport function formatEventDuration(event: CalendarEventTimes, zone: string, includeTimezone: boolean): string {\n\tif (isAllDayEvent(event)) {\n\t\tconst startTime = getEventStart(event, zone)\n\t\tconst startString = formatDateWithMonth(startTime)\n\t\tconst endTime = incrementByRepeatPeriod(getEventEnd(event, zone), RepeatPeriod.DAILY, -1, zone)\n\n\t\tif (isSameDayOfDate(startTime, endTime)) {\n\t\t\treturn `${lang.get(\"allDay_label\")}, ${startString}`\n\t\t} else {\n\t\t\treturn `${lang.get(\"allDay_label\")}, ${startString} - ${formatDateWithMonth(endTime)}`\n\t\t}\n\t} else {\n\t\tconst startString = formatDateTime(event.startTime)\n\t\tlet endString\n\n\t\tif (isSameDay(event.startTime, event.endTime)) {\n\t\t\tendString = formatTime(event.endTime)\n\t\t} else {\n\t\t\tendString = formatDateTime(event.endTime)\n\t\t}\n\n\t\treturn `${startString} - ${endString} ${includeTimezone ? getTimeZone() : \"\"}`\n\t}\n}\n\nexport const createRepeatRuleFrequencyValues = (): SelectorItemList<RepeatPeriod | null> => {\n\treturn [\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatIntervalNoRepeat_label\"),\n\t\t\tvalue: null,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatIntervalDaily_label\"),\n\t\t\tvalue: RepeatPeriod.DAILY,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatIntervalWeekly_label\"),\n\t\t\tvalue: RepeatPeriod.WEEKLY,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatIntervalMonthly_label\"),\n\t\t\tvalue: RepeatPeriod.MONTHLY,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatIntervalAnnually_label\"),\n\t\t\tvalue: RepeatPeriod.ANNUALLY,\n\t\t},\n\t]\n}\nexport const createRepeatRuleOptions = (): ReadonlyArray<RadioGroupOption<RepeatPeriod | \"CUSTOM\" | null>> => {\n\treturn [\n\t\t{\n\t\t\tname: \"calendarRepeatIntervalNoRepeat_label\",\n\t\t\tvalue: null,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatIntervalDaily_label\",\n\t\t\tvalue: RepeatPeriod.DAILY,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatIntervalWeekly_label\",\n\t\t\tvalue: RepeatPeriod.WEEKLY,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatIntervalMonthly_label\",\n\t\t\tvalue: RepeatPeriod.MONTHLY,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatIntervalAnnually_label\",\n\t\t\tvalue: RepeatPeriod.ANNUALLY,\n\t\t},\n\t\t{\n\t\t\tname: \"custom_label\",\n\t\t\tvalue: \"CUSTOM\",\n\t\t},\n\t]\n}\n\nexport const customFrequenciesOptions = [\n\t{\n\t\tname: { singular: \"day_label\", plural: \"days_label\" },\n\t\tvalue: RepeatPeriod.DAILY,\n\t},\n\t{\n\t\tname: { singular: \"week_label\", plural: \"weeks_label\" },\n\t\tvalue: RepeatPeriod.WEEKLY,\n\t},\n\t{\n\t\tname: { singular: \"month_label\", plural: \"months_label\" },\n\t\tvalue: RepeatPeriod.MONTHLY,\n\t},\n\t{\n\t\tname: { singular: \"year_label\", plural: \"years_label\" },\n\t\tvalue: RepeatPeriod.ANNUALLY,\n\t},\n]\n\nexport const createCustomEndTypeOptions = (): ReadonlyArray<RadioGroupOption<EndType>> => {\n\treturn [\n\t\t{\n\t\t\tname: \"calendarRepeatStopConditionNever_label\",\n\t\t\tvalue: EndType.Never,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatStopConditionOccurrences_label\",\n\t\t\tvalue: EndType.Count,\n\t\t},\n\t\t{\n\t\t\tname: \"calendarRepeatStopConditionDate_label\",\n\t\t\tvalue: EndType.UntilDate,\n\t\t},\n\t]\n}\n\nexport const createRepeatRuleEndTypeValues = (): SelectorItemList<EndType> => {\n\treturn [\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatStopConditionNever_label\"),\n\t\t\tvalue: EndType.Never,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatStopConditionOccurrences_label\"),\n\t\t\tvalue: EndType.Count,\n\t\t},\n\t\t{\n\t\t\tname: lang.get(\"calendarRepeatStopConditionDate_label\"),\n\t\t\tvalue: EndType.UntilDate,\n\t\t},\n\t]\n}\nexport const createIntervalValues = (): IntervalOption[] => numberRange(1, 256).map((n) => ({ name: String(n), value: n, ariaValue: String(n) }))\n\nexport function humanDescriptionForAlarmInterval<P>(value: AlarmInterval, locale: string): string {\n\tif (value.value === 0) return lang.get(\"calendarReminderIntervalAtEventStart_label\")\n\n\treturn Duration.fromObject(alarmIntervalToLuxonDurationLikeObject(value)).reconfigure({ locale: locale }).toHuman()\n}\n\nexport const createAlarmIntervalItems = (locale: string): SelectorItemList<AlarmInterval> =>\n\ttypedValues(StandardAlarmInterval).map((value) => {\n\t\treturn {\n\t\t\tvalue,\n\t\t\tname: humanDescriptionForAlarmInterval(value, locale),\n\t\t}\n\t})\n\nexport interface AttendingItem extends SelectOption<CalendarAttendeeStatus> {\n\tname: string\n\tselectable?: boolean\n}\n\nexport const createAttendingItems = (): AttendingItem[] => [\n\t{\n\t\tname: lang.get(\"attending_label\"),\n\t\tvalue: CalendarAttendeeStatus.ACCEPTED,\n\t\tariaValue: lang.get(\"attending_label\"),\n\t},\n\t{\n\t\tname: lang.get(\"maybeAttending_label\"),\n\t\tvalue: CalendarAttendeeStatus.TENTATIVE,\n\t\tariaValue: lang.get(\"maybeAttending_label\"),\n\t},\n\t{\n\t\tname: lang.get(\"notAttending_label\"),\n\t\tvalue: CalendarAttendeeStatus.DECLINED,\n\t\tariaValue: lang.get(\"notAttending_label\"),\n\t},\n\t{\n\t\tname: lang.get(\"pending_label\"),\n\t\tvalue: CalendarAttendeeStatus.NEEDS_ACTION,\n\t\tselectable: false,\n\t\tariaValue: lang.get(\"pending_label\"),\n\t},\n]\n\nexport function humanDescriptionForAlarmIntervalUnit(unit: AlarmIntervalUnit): string {\n\tswitch (unit) {\n\t\tcase AlarmIntervalUnit.MINUTE:\n\t\t\treturn lang.get(\"calendarReminderIntervalUnitMinutes_label\")\n\t\tcase AlarmIntervalUnit.HOUR:\n\t\t\treturn lang.get(\"calendarReminderIntervalUnitHours_label\")\n\t\tcase AlarmIntervalUnit.DAY:\n\t\t\treturn lang.get(\"calendarReminderIntervalUnitDays_label\")\n\t\tcase AlarmIntervalUnit.WEEK:\n\t\t\treturn lang.get(\"calendarReminderIntervalUnitWeeks_label\")\n\t}\n}\n\nexport function timeString(date: Date, amPm: boolean): string {\n\treturn timeStringFromParts(date.getHours(), date.getMinutes(), amPm)\n}\n\nexport function timeStringInZone(date: Date, amPm: boolean, zone: string): string {\n\tconst { hour, minute } = DateTime.fromJSDate(date, {\n\t\tzone,\n\t})\n\treturn timeStringFromParts(hour, minute, amPm)\n}\n\nexport function formatEventTime({ endTime, startTime }: CalendarEventTimes, showTime: EventTextTimeOption): string {\n\tswitch (showTime) {\n\t\tcase EventTextTimeOption.START_TIME:\n\t\t\treturn formatTime(startTime)\n\n\t\tcase EventTextTimeOption.END_TIME:\n\t\t\treturn ` - ${formatTime(endTime)}`\n\n\t\tcase EventTextTimeOption.START_END_TIME:\n\t\t\treturn `${formatTime(startTime)} - ${formatTime(endTime)}`\n\n\t\tdefault:\n\t\t\tthrow new ProgrammingError(`Unknown time option: ${showTime}`)\n\t}\n}\n\nexport function formatEventTimes(day: Date, event: CalendarEvent, zone: string): string {\n\tif (isAllDayEvent(event)) {\n\t\treturn lang.get(\"allDay_label\")\n\t} else {\n\t\tconst startsBefore = eventStartsBefore(day, zone, event)\n\t\tconst endsAfter = eventEndsAfterDay(day, zone, event)\n\t\tif (startsBefore && endsAfter) {\n\t\t\treturn lang.get(\"allDay_label\")\n\t\t} else {\n\t\t\tconst startTime: Date = startsBefore ? day : event.startTime\n\t\t\tconst endTime: Date = endsAfter ? getEndOfDayWithZone(day, zone) : event.endTime\n\t\t\treturn formatEventTime({ startTime, endTime }, EventTextTimeOption.START_END_TIME)\n\t\t}\n\t}\n}\n\nexport const createCustomRepeatRuleUnitValues = (): SelectorItemList<AlarmIntervalUnit | null> => {\n\treturn [\n\t\t{\n\t\t\tname: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.MINUTE),\n\t\t\tvalue: AlarmIntervalUnit.MINUTE,\n\t\t},\n\t\t{\n\t\t\tname: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.HOUR),\n\t\t\tvalue: AlarmIntervalUnit.HOUR,\n\t\t},\n\t\t{\n\t\t\tname: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.DAY),\n\t\t\tvalue: AlarmIntervalUnit.DAY,\n\t\t},\n\t\t{\n\t\t\tname: humanDescriptionForAlarmIntervalUnit(AlarmIntervalUnit.WEEK),\n\t\t\tvalue: AlarmIntervalUnit.WEEK,\n\t\t},\n\t]\n}\nexport const CALENDAR_EVENT_HEIGHT: number = size.calendar_line_height + 2\nexport const TEMPORARY_EVENT_OPACITY = 0.7\n\nexport const enum EventLayoutMode {\n\t/** Take event start and end times into account when laying out. */\n\tTimeBasedColumn,\n\t/** Each event is treated as if it would take the whole day when laying out. */\n\tDayBasedColumn,\n}\n\n/**\n * Function which sorts events into the \"columns\" and \"rows\" and renders them using {@param renderer}.\n * Columns are abstract and can be actually the rows. A single column progresses in time while multiple columns can happen in parallel.\n * in one column on a single day (it will \"stretch\" events from the day start until the next day).\n */\nexport function layOutEvents(\n\tevents: Array<CalendarEvent>,\n\tzone: string,\n\trenderer: (columns: Array<Array<CalendarEvent>>) => ChildArray,\n\tlayoutMode: EventLayoutMode,\n): ChildArray {\n\tevents.sort((e1, e2) => {\n\t\tconst e1Start = getEventStart(e1, zone)\n\t\tconst e2Start = getEventStart(e2, zone)\n\t\tif (e1Start < e2Start) return -1\n\t\tif (e1Start > e2Start) return 1\n\t\tconst e1End = getEventEnd(e1, zone)\n\t\tconst e2End = getEventEnd(e2, zone)\n\t\tif (e1End < e2End) return -1\n\t\tif (e1End > e2End) return 1\n\t\treturn 0\n\t})\n\tlet lastEventEnding: Date | null = null\n\tlet lastEventStart: Date | null = null\n\tlet columns: Array<Array<CalendarEvent>> = []\n\tconst children: Array<Children> = []\n\t// Cache for calculation events\n\tconst calcEvents = new Map()\n\tfor (const e of events) {\n\t\tconst calcEvent = getFromMap(calcEvents, e, () => getCalculationEvent(e, zone, layoutMode))\n\t\t// Check if a new event group needs to be started\n\t\tif (\n\t\t\tlastEventEnding != null &&\n\t\t\tlastEventStart != null &&\n\t\t\tlastEventEnding <= calcEvent.startTime.getTime() &&\n\t\t\t(layoutMode === EventLayoutMode.DayBasedColumn || !visuallyOverlaps(lastEventStart, lastEventEnding, calcEvent.startTime))\n\t\t) {\n\t\t\t// The latest event is later than any of the event in the\n\t\t\t// current group. There is no overlap. Output the current\n\t\t\t// event group and start a new event group.\n\t\t\tchildren.push(...renderer(columns))\n\t\t\tcolumns = [] // This starts new event group.\n\n\t\t\tlastEventEnding = null\n\t\t\tlastEventStart = null\n\t\t}\n\n\t\t// Try to place the event inside the existing columns\n\t\tlet placed = false\n\n\t\tfor (let i = 0; i < columns.length; i++) {\n\t\t\tconst col = columns[i]\n\t\t\tconst lastEvent = col[col.length - 1]\n\t\t\tconst lastCalcEvent = getFromMap(calcEvents, lastEvent, () => getCalculationEvent(lastEvent, zone, layoutMode))\n\n\t\t\tif (\n\t\t\t\t!collidesWith(lastCalcEvent, calcEvent) &&\n\t\t\t\t(layoutMode === EventLayoutMode.DayBasedColumn || !visuallyOverlaps(lastCalcEvent.startTime, lastCalcEvent.endTime, calcEvent.startTime))\n\t\t\t) {\n\t\t\t\tcol.push(e) // push real event here not calc event\n\n\t\t\t\tplaced = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// It was not possible to place the event. Add a new column\n\t\t// for the current event group.\n\t\tif (!placed) {\n\t\t\tcolumns.push([e])\n\t\t}\n\n\t\t// Remember the latest event end time and start time of the current group.\n\t\t// This is later used to determine if a new groups starts.\n\t\tif (lastEventEnding == null || lastEventEnding.getTime() < calcEvent.endTime.getTime()) {\n\t\t\tlastEventEnding = calcEvent.endTime\n\t\t}\n\t\tif (lastEventStart == null || lastEventStart.getTime() < calcEvent.startTime.getTime()) {\n\t\t\tlastEventStart = calcEvent.startTime\n\t\t}\n\t}\n\tchildren.push(...renderer(columns))\n\treturn children\n}\n\n/** get an event that can be rendered to the screen. in day view, the event is returned as-is, otherwise it's stretched to cover each day\n * it occurs on completely. */\nfunction getCalculationEvent(event: CalendarEvent, zone: string, eventLayoutMode: EventLayoutMode): CalendarEvent {\n\tif (eventLayoutMode === EventLayoutMode.DayBasedColumn) {\n\t\tconst calcEvent = clone(event)\n\n\t\tif (isAllDayEvent(event)) {\n\t\t\tcalcEvent.startTime = getAllDayDateForTimezone(event.startTime, zone)\n\t\t\tcalcEvent.endTime = getAllDayDateForTimezone(event.endTime, zone)\n\t\t} else {\n\t\t\tcalcEvent.startTime = getStartOfDayWithZone(event.startTime, zone)\n\t\t\tcalcEvent.endTime = getStartOfNextDayWithZone(event.endTime, zone)\n\t\t}\n\n\t\treturn calcEvent\n\t} else {\n\t\treturn event\n\t}\n}\n\n/**\n * This function checks whether two events collide based on their start and end time\n * Assuming vertical columns with time going top-to-bottom, this would be true in these cases:\n *\n * case 1:\n * +-----------+\n * |           |\n * |           |   +----------+\n * +-----------+   |          |\n *                 |          |\n *                 +----------+\n * case 2:\n * +-----------+\n * |           |   +----------+\n * |           |   |          |\n * |           |   +----------+\n * +-----------+\n *\n * There could be a case where they are flipped vertically, but we don't have them because earlier events will be always first. so the \"left\" top edge will\n * always be \"above\" the \"right\" top edge.\n */\nfunction collidesWith(a: CalendarEvent, b: CalendarEvent): boolean {\n\treturn a.endTime.getTime() > b.startTime.getTime() && a.startTime.getTime() < b.endTime.getTime()\n}\n\n/**\n * Due to the minimum height for events they overlap if a short event is directly followed by another event,\n * therefore, we check whether the event height is less than the minimum height.\n *\n * This does not cover all the cases but handles the case when the second event starts right after the first one.\n */\nfunction visuallyOverlaps(firstEventStart: Date, firstEventEnd: Date, secondEventStart: Date): boolean {\n\t// We are only interested in the height on the last day of the event because an event ending later will take up the whole column until the next day anyway.\n\tconst firstEventStartOnSameDay = isSameDay(firstEventStart, firstEventEnd) ? firstEventStart.getTime() : getStartOfDay(firstEventEnd).getTime()\n\tconst eventDurationMs = firstEventEnd.getTime() - firstEventStartOnSameDay\n\tconst eventDurationHours = eventDurationMs / (1000 * 60 * 60)\n\tconst height = eventDurationHours * size.calendar_hour_height - size.calendar_event_border\n\treturn firstEventEnd.getTime() === secondEventStart.getTime() && height < size.calendar_line_height\n}\n\nexport function expandEvent(ev: CalendarEvent, columnIndex: number, columns: Array<Array<CalendarEvent>>): number {\n\tlet colSpan = 1\n\n\tfor (let i = columnIndex + 1; i < columns.length; i++) {\n\t\tlet col = columns[i]\n\n\t\tfor (let j = 0; j < col.length; j++) {\n\t\t\tlet ev1 = col[j]\n\n\t\t\tif (collidesWith(ev, ev1) || visuallyOverlaps(ev.startTime, ev.endTime, ev1.startTime)) {\n\t\t\t\treturn colSpan\n\t\t\t}\n\t\t}\n\n\t\tcolSpan++\n\t}\n\n\treturn colSpan\n}\n\nexport function getEventColor(event: CalendarEvent, groupColors: GroupColors): string {\n\treturn (event._ownerGroup && groupColors.get(event._ownerGroup)) ?? defaultCalendarColor\n}\n\nexport function calendarAttendeeStatusSymbol(status: CalendarAttendeeStatus): string {\n\tswitch (status) {\n\t\tcase CalendarAttendeeStatus.ADDED:\n\t\tcase CalendarAttendeeStatus.NEEDS_ACTION:\n\t\t\treturn \"\"\n\n\t\tcase CalendarAttendeeStatus.TENTATIVE:\n\t\t\treturn \"?\"\n\n\t\tcase CalendarAttendeeStatus.ACCEPTED:\n\t\t\treturn \"\"\n\n\t\tcase CalendarAttendeeStatus.DECLINED:\n\t\t\treturn \"\"\n\n\t\tdefault:\n\t\t\tthrow new Error(\"Unknown calendar attendee status: \" + status)\n\t}\n}\n\nexport const iconForAttendeeStatus: Record<CalendarAttendeeStatus, AllIcons> = Object.freeze({\n\t[CalendarAttendeeStatus.ACCEPTED]: Icons.CircleCheckmark,\n\t[CalendarAttendeeStatus.TENTATIVE]: Icons.CircleHelp,\n\t[CalendarAttendeeStatus.DECLINED]: Icons.CircleReject,\n\t[CalendarAttendeeStatus.NEEDS_ACTION]: Icons.CircleHelp,\n\t[CalendarAttendeeStatus.ADDED]: Icons.CircleHelp,\n})\nexport const getGroupColors = memoized((userSettingsGroupRoot: UserSettingsGroupRoot) => {\n\treturn userSettingsGroupRoot.groupSettings.reduce((acc, { group, color }) => {\n\t\tif (!isValidColorCode(\"#\" + color)) {\n\t\t\tcolor = defaultCalendarColor\n\t\t}\n\t\tacc.set(group, color)\n\t\treturn acc\n\t}, new Map())\n})\n\nexport const getClientOnlyColors = (userId: Id, clientOnlyCalendarsInfo: Map<Id, ClientOnlyCalendarsInfo>) => {\n\tconst colors: Map<Id, string> = new Map()\n\tfor (const [id, _] of CLIENT_ONLY_CALENDARS) {\n\t\tconst calendarId = `${userId}#${id}`\n\t\tcolors.set(calendarId, clientOnlyCalendarsInfo.get(calendarId)?.color ?? DEFAULT_CLIENT_ONLY_CALENDAR_COLORS.get(id)!)\n\t}\n\treturn colors\n}\n\nexport const getClientOnlyCalendars = (userId: Id, clientOnlyCalendarInfo: Map<Id, ClientOnlyCalendarsInfo>) => {\n\tconst userCalendars: (ClientOnlyCalendarsInfo & { id: string; name: string })[] = []\n\n\tfor (const [id, key] of CLIENT_ONLY_CALENDARS) {\n\t\tconst calendarId = `${userId}#${id}`\n\t\tconst calendar = clientOnlyCalendarInfo.get(calendarId)\n\t\tif (calendar) {\n\t\t\tuserCalendars.push({\n\t\t\t\t...calendar,\n\t\t\t\tid: calendarId,\n\t\t\t\tname: calendar.name ? calendar.name : lang.get(key),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn userCalendars\n}\n\n/**\n *  find out how we ended up with this event, which determines the capabilities we have with it.\n *  for shared events in calendar where we have read-write access, we can still only view events that have\n *  attendees, because we could not send updates after we edit something\n * @param existingEvent the event in question.\n * @param calendars a list of calendars that this user has access to.\n * @param ownMailAddresses the list of mail addresses this user might be using.\n * @param userController\n */\nexport function getEventType(\n\texistingEvent: Partial<CalendarEvent>,\n\tcalendars: ReadonlyMap<Id, CalendarInfo>,\n\townMailAddresses: ReadonlyArray<string>,\n\tuserController: UserController,\n): EventType {\n\tconst { user, userSettingsGroupRoot } = userController\n\n\tif (user.accountType === AccountType.EXTERNAL) {\n\t\treturn EventType.EXTERNAL\n\t}\n\n\tconst existingOrganizer = existingEvent.organizer\n\tconst isOrganizer = existingOrganizer != null && ownMailAddresses.some((a) => cleanMailAddress(a) === existingOrganizer.address)\n\n\tif (existingEvent._ownerGroup == null) {\n\t\tif (existingOrganizer != null && !isOrganizer) {\n\t\t\t// OwnerGroup is not set for events from file, but we also require an organizer to treat it as an invite.\n\t\t\treturn EventType.INVITE\n\t\t} else {\n\t\t\t// either the organizer exists and it's us, or the organizer does not exist and we can treat this as our event,\n\t\t\t// like for newly created events.\n\t\t\treturn EventType.OWN\n\t\t}\n\t}\n\n\tconst calendarInfoForEvent = calendars.get(existingEvent._ownerGroup) ?? null\n\tif (calendarInfoForEvent == null || calendarInfoForEvent.isExternal) {\n\t\t// event has an ownergroup, but it's not in one of our calendars. this might actually be an error.\n\t\treturn EventType.SHARED_RO\n\t}\n\n\t/**\n\t * if the event has a _ownerGroup, it means there is a calendar set to it\n\t * so, if the user is the owner of said calendar they are free to manage the event however they want\n\t **/\n\tif ((isOrganizer || existingOrganizer === null) && calendarInfoForEvent.userIsOwner) {\n\t\treturn EventType.OWN\n\t}\n\n\tif (calendarInfoForEvent.shared) {\n\t\tconst canWrite = hasCapabilityOnGroup(user, calendarInfoForEvent.group, ShareCapability.Write)\n\t\tif (canWrite) {\n\t\t\tconst organizerAddress = cleanMailAddress(existingOrganizer?.address ?? \"\")\n\t\t\tconst wouldRequireUpdates: boolean =\n\t\t\t\texistingEvent.attendees != null && existingEvent.attendees.some((a) => cleanMailAddress(a.address.address) !== organizerAddress)\n\t\t\treturn wouldRequireUpdates ? EventType.LOCKED : EventType.SHARED_RW\n\t\t} else {\n\t\t\treturn EventType.SHARED_RO\n\t\t}\n\t}\n\n\t//For an event in a personal calendar there are 3 options\n\tif (existingOrganizer == null || existingEvent.attendees?.length === 0 || isOrganizer) {\n\t\t// 1. we are the organizer of the event or the event does not have an organizer yet\n\t\t// 2. we are not the organizer and the event does not have guests. it was created by someone we shared our calendar with (also considered our own event)\n\t\treturn EventType.OWN\n\t} else {\n\t\t// 3. the event is an invitation that has another organizer and/or attendees.\n\t\treturn EventType.INVITE\n\t}\n}\n\nexport function shouldDisplayEvent(e: CalendarEvent, hiddenCalendars: ReadonlySet<Id>): boolean {\n\treturn !hiddenCalendars.has(assertNotNull(e._ownerGroup, \"event without ownerGroup in getEventsOnDays\"))\n}\n\nexport function daysHaveEvents(eventsOnDays: EventsOnDays): boolean {\n\treturn eventsOnDays.shortEventsPerDay.some(isNotEmpty) || isNotEmpty(eventsOnDays.longEvents)\n}\n\n/**\n * A handler for `onwheel` to move to a forwards or previous view based on mouse wheel movement\n * @returns a function to be used by `onwheel`\n */\nexport function changePeriodOnWheel(callback: (isNext: boolean) => unknown): (event: WheelEvent) => void {\n\treturn (event: WheelEvent) => {\n\t\t// Go to the next period if scrolling down or right\n\t\tcallback(event.deltaY > 0 || event.deltaX > 0)\n\t}\n}\n\nexport async function showDeletePopup(model: CalendarEventPreviewViewModel, ev: MouseEvent, receiver: HTMLElement, onClose?: () => unknown) {\n\tif (await model.isRepeatingForDeleting()) {\n\t\tcreateAsyncDropdown({\n\t\t\tlazyButtons: () =>\n\t\t\t\tPromise.resolve([\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"deleteSingleEventRecurrence_action\",\n\t\t\t\t\t\tclick: async () => {\n\t\t\t\t\t\t\tawait model.deleteSingle()\n\t\t\t\t\t\t\tonClose?.()\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlabel: \"deleteAllEventRecurrence_action\",\n\t\t\t\t\t\tclick: () => confirmDeleteClose(model, onClose),\n\t\t\t\t\t},\n\t\t\t\t]),\n\t\t\twidth: 300,\n\t\t})(ev, receiver)\n\t} else {\n\t\t// noinspection JSIgnoredPromiseFromCall\n\t\tconfirmDeleteClose(model, onClose)\n\t}\n}\n\nasync function confirmDeleteClose(model: CalendarEventPreviewViewModel, onClose?: () => unknown): Promise<void> {\n\tif (!(await Dialog.confirm(\"deleteEventConfirmation_msg\"))) return\n\tawait model.deleteAll()\n\tonClose?.()\n}\n\nexport function getDisplayEventTitle(title: string): string {\n\treturn title ?? title !== \"\" ? title : lang.get(\"noTitle_label\")\n}\n\nexport type ColorString = string\n\nexport function generateRandomColor(): ColorString {\n\tconst model = new ColorPickerModel(!isColorLight(theme.content_bg))\n\treturn hslToHex(model.getColor(Math.floor(Math.random() * MAX_HUE_ANGLE), 2))\n}\n\nexport function renderCalendarColor(selectedCalendar: CalendarInfo | null, groupColors: Map<Id, string>) {\n\tconst color = selectedCalendar ? groupColors.get(selectedCalendar.groupInfo.group) ?? defaultCalendarColor : null\n\treturn m(\".mt-xs\", {\n\t\tstyle: {\n\t\t\twidth: \"100px\",\n\t\t\theight: \"10px\",\n\t\t\tbackground: color ? \"#\" + color : \"transparent\",\n\t\t},\n\t})\n}\n"],"mappings":"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"}