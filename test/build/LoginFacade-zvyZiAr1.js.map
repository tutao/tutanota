{"version":3,"file":"LoginFacade-zvyZiAr1.js","names":["restClient: RestClient","entityClient: EntityClient","loginListener: LoginListener","instanceMapper: InstanceMapper","cryptoFacade: CryptoFacade","keyRotationFacade: KeyRotationFacade","cacheInitializer: CacheStorageLateInitializer","serviceExecutor: IServiceExecutor","userFacade: UserFacade","blobAccessTokenFacade: BlobAccessTokenFacade","entropyFacade: EntropyFacade","databaseKeyFactory: DatabaseKeyFactory","argon2idFacade: Argon2idFacade","noncachingEntityClient: EntityClient","sendError: (error: Error) => Promise<void>","cacheManagementFacade: lazyAsync<CacheManagementFacade>","eventBusClient: EventBusClient","mailAddress: string","passphrase: string","clientIdentifier: string","sessionType: SessionType","databaseKey: Uint8Array | null","accessKey: AesKey | null","targetKdfType: KdfType","user: User","kdfType: KdfType","createSessionReturn: CreateSessionReturn","mailAddress: string | null","accessToken: Base64Url","sessionId: IdTuple","retryOnNetworkError: number","userId: Id","salt: Uint8Array","persistentSession: boolean","accessKey: Aes256Key | null","data: SecondFactorAuthData","host?: string","credentials: Credentials","externalUserKeyDeriver: ExternalUserKeyDeriver | null","timeRangeDays: number | null","userGroupInfo: GroupInfo","cacheInfo: CacheInfo","userPassphraseKey: AesKey","credentialsWithPassphraseKey: Credentials","sessionData: {\n\t\t\tuserId: Id\n\t\t\taccessKey: AesKey | null\n\t\t}","externalUserSalt: Uint8Array","accessToken: string","userPassphraseKey: Aes128Key","pushIdentifier: string | null","queryParams: Dict","currentPasswordKeyData: PassphraseKeyData","newPasswordKeyDataTemplate: Omit<PassphraseKeyData, \"salt\">","password: string","takeover: string","surveyData: SurveyData | null","recoverCode: string","newPassword: string","tempAuthDataProvider: AuthDataProvider","recoverCode: Hex","recoverCode: Hex | null","targetAccountMailAddress: string","recoverCodeVerifier: Base64 | null","time: number","key: Uint8Array"],"sources":["../../src/common/api/worker/facades/LoginFacade.ts"],"sourcesContent":["import {\n\tarrayEquals,\n\tassertNotNull,\n\tBase64,\n\tbase64ToBase64Ext,\n\tbase64ToBase64Url,\n\tbase64ToUint8Array,\n\tBase64Url,\n\tbase64UrlToBase64,\n\tdefer,\n\tDeferredObject,\n\tHex,\n\thexToUint8Array,\n\tlazyAsync,\n\tneverNull,\n\tofClass,\n\tuint8ArrayToBase64,\n\tutf8Uint8ArrayToString,\n} from \"@tutao/tutanota-utils\"\nimport {\n\tChangeKdfService,\n\tChangePasswordService,\n\tCustomerService,\n\tResetFactorsService,\n\tSaltService,\n\tSecondFactorAuthService,\n\tSessionService,\n\tTakeOverDeletedAddressService,\n\tVerifierTokenService,\n} from \"../../entities/sys/Services\"\nimport { AccountType, asKdfType, CloseEventBusOption, Const, DEFAULT_KDF_TYPE, KdfType } from \"../../common/TutanotaConstants\"\nimport {\n\tChallenge,\n\tcreateChangeKdfPostIn,\n\tcreateChangePasswordPostIn,\n\tcreateCreateSessionData,\n\tcreateDeleteCustomerData,\n\tcreateResetFactorsDeleteData,\n\tcreateSaltData,\n\tcreateSecondFactorAuthDeleteData,\n\tcreateSecondFactorAuthGetData,\n\tCreateSessionReturn,\n\tcreateTakeOverDeletedAddressData,\n\tcreateVerifierTokenServiceIn,\n\tGroupInfo,\n\tGroupInfoTypeRef,\n\tRecoverCodeTypeRef,\n\tSecondFactorAuthData,\n\tSessionTypeRef,\n\tSurveyData,\n\tUser,\n\tUserTypeRef,\n} from \"../../entities/sys/TypeRefs.js\"\nimport { TutanotaPropertiesTypeRef } from \"../../entities/tutanota/TypeRefs.js\"\nimport { HttpMethod, MediaType, resolveTypeReference } from \"../../common/EntityFunctions\"\nimport { assertWorkerOrNode, isAdminClient } from \"../../common/Env\"\nimport { ConnectMode, EventBusClient } from \"../EventBusClient\"\nimport { EntityRestClient, typeRefToPath } from \"../rest/EntityRestClient\"\nimport { AccessExpiredError, ConnectionError, LockedError, NotAuthenticatedError, NotFoundError, SessionExpiredError } from \"../../common/error/RestError\"\nimport { CancelledError } from \"../../common/error/CancelledError\"\nimport { RestClient } from \"../rest/RestClient\"\nimport { EntityClient } from \"../../common/EntityClient\"\nimport { GENERATED_ID_BYTES_LENGTH, isSameId } from \"../../common/utils/EntityUtils\"\nimport type { Credentials } from \"../../../misc/credentials/Credentials\"\nimport {\n\tAes128Key,\n\taes256DecryptWithRecoveryKey,\n\tAes256Key,\n\taes256RandomKey,\n\taesDecrypt,\n\tAesKey,\n\tbase64ToKey,\n\tcreateAuthVerifier,\n\tcreateAuthVerifierAsBase64Url,\n\tencryptKey,\n\tgenerateKeyFromPassphraseBcrypt,\n\tgenerateRandomSalt,\n\tKeyLength,\n\tkeyToUint8Array,\n\tsha256Hash,\n\tTotpSecret,\n\tTotpVerifier,\n\tuint8ArrayToBitArray,\n} from \"@tutao/tutanota-crypto\"\nimport { CryptoFacade } from \"../crypto/CryptoFacade\"\nimport { InstanceMapper } from \"../crypto/InstanceMapper\"\nimport { IServiceExecutor } from \"../../common/ServiceRequest\"\nimport { SessionType } from \"../../common/SessionType\"\nimport { CacheStorageLateInitializer } from \"../rest/CacheStorageProxy\"\nimport { AuthDataProvider, UserFacade } from \"./UserFacade\"\nimport { LoginFailReason } from \"../../main/PageContextLoginListener.js\"\nimport { LoginIncompleteError } from \"../../common/error/LoginIncompleteError.js\"\nimport { EntropyFacade } from \"./EntropyFacade.js\"\nimport { BlobAccessTokenFacade } from \"./BlobAccessTokenFacade.js\"\nimport { ProgrammingError } from \"../../common/error/ProgrammingError.js\"\nimport { DatabaseKeyFactory } from \"../../../misc/credentials/DatabaseKeyFactory.js\"\nimport { ExternalUserKeyDeriver } from \"../../../misc/LoginUtils.js\"\nimport { Argon2idFacade } from \"./Argon2idFacade.js\"\nimport { CredentialType } from \"../../../misc/credentials/CredentialType.js\"\nimport { KeyRotationFacade } from \"./KeyRotationFacade.js\"\nimport { encryptString } from \"../crypto/CryptoWrapper.js\"\nimport { CacheManagementFacade } from \"./lazy/CacheManagementFacade.js\"\n\nassertWorkerOrNode()\n\nexport type NewSessionData = {\n\tuser: User\n\tuserGroupInfo: GroupInfo\n\tsessionId: IdTuple\n\tcredentials: Credentials\n\tdatabaseKey: Uint8Array | null\n}\n\nexport type CacheInfo = {\n\tisPersistent: boolean\n\tisNewOfflineDb: boolean\n\tdatabaseKey: Uint8Array | null\n}\n\ninterface ResumeSessionResultData {\n\tuser: User\n\tuserGroupInfo: GroupInfo\n\tsessionId: IdTuple\n}\n\nexport const enum ResumeSessionErrorReason {\n\tOfflineNotAvailableForFree,\n}\n\nexport type InitCacheOptions = {\n\tuserId: Id\n\tdatabaseKey: Uint8Array | null\n\ttimeRangeDays: number | null\n\tforceNewDatabase: boolean\n}\n\ntype ResumeSessionSuccess = { type: \"success\"; data: ResumeSessionResultData }\ntype ResumeSessionFailure = { type: \"error\"; reason: ResumeSessionErrorReason }\ntype ResumeSessionResult = ResumeSessionSuccess | ResumeSessionFailure\n\ntype AsyncLoginState =\n\t| { state: \"idle\" }\n\t| { state: \"running\" }\n\t| {\n\t\t\tstate: \"failed\"\n\t\t\tcredentials: Credentials\n\t\t\tcacheInfo: CacheInfo\n\t  }\n\n/**\n * All attributes that are required to derive the passphrase key.\n */\nexport type PassphraseKeyData = {\n\tkdfType: KdfType\n\tsalt: Uint8Array\n\tpassphrase: string\n}\n\nexport interface LoginListener {\n\t/**\n\t * Full login reached: any network requests can be made\n\t */\n\tonFullLoginSuccess(sessionType: SessionType, cacheInfo: CacheInfo, credentials: Credentials): Promise<void>\n\n\t/**\n\t * call when the login fails for invalid session or other reasons\n\t */\n\tonLoginFailure(reason: LoginFailReason): Promise<void>\n\n\t/**\n\t * Shows a dialog with possibility to use second factor and with a message that the login can be approved from another client.\n\t */\n\tonSecondFactorChallenge(sessionId: IdTuple, challenges: ReadonlyArray<Challenge>, mailAddress: string | null): Promise<void>\n}\n\nexport class LoginFacade {\n\tprivate eventBusClient!: EventBusClient\n\t/**\n\t * Used for cancelling second factor and to not mix different attempts\n\t */\n\tprivate loginRequestSessionId: IdTuple | null = null\n\n\t/**\n\t * Used for cancelling second factor immediately\n\t */\n\tprivate loggingInPromiseWrapper: DeferredObject<void> | null = null\n\n\t/** On platforms with offline cache we do the actual login asynchronously and we can retry it. This is the state of such async login. */\n\tasyncLoginState: AsyncLoginState = { state: \"idle\" }\n\n\tconstructor(\n\t\tprivate readonly restClient: RestClient,\n\t\tprivate readonly entityClient: EntityClient,\n\t\tprivate readonly loginListener: LoginListener,\n\t\tprivate readonly instanceMapper: InstanceMapper,\n\t\tprivate readonly cryptoFacade: CryptoFacade,\n\t\tprivate readonly keyRotationFacade: KeyRotationFacade,\n\t\t/**\n\t\t *  Only needed so that we can initialize the offline storage after login.\n\t\t *  This is necessary because we don't know if we'll be persistent or not until the user tries to login\n\t\t *  Once the credentials handling has been changed to *always* save in desktop, then this should become obsolete\n\t\t */\n\t\tprivate readonly cacheInitializer: CacheStorageLateInitializer,\n\t\tprivate readonly serviceExecutor: IServiceExecutor,\n\t\tprivate readonly userFacade: UserFacade,\n\t\tprivate readonly blobAccessTokenFacade: BlobAccessTokenFacade,\n\t\tprivate readonly entropyFacade: EntropyFacade,\n\t\tprivate readonly databaseKeyFactory: DatabaseKeyFactory,\n\t\tprivate readonly argon2idFacade: Argon2idFacade,\n\t\tprivate readonly noncachingEntityClient: EntityClient,\n\t\tprivate readonly sendError: (error: Error) => Promise<void>,\n\t\tprivate readonly cacheManagementFacade: lazyAsync<CacheManagementFacade>,\n\t) {}\n\n\tinit(eventBusClient: EventBusClient) {\n\t\tthis.eventBusClient = eventBusClient\n\t}\n\n\tasync resetSession(): Promise<void> {\n\t\tthis.eventBusClient.close(CloseEventBusOption.Terminate)\n\t\tawait this.deInitCache()\n\t\tthis.userFacade.reset()\n\t}\n\n\t/**\n\t * Create session and log in. Changes internal state to refer to the logged in user.\n\t */\n\tasync createSession(\n\t\tmailAddress: string,\n\t\tpassphrase: string,\n\t\tclientIdentifier: string,\n\t\tsessionType: SessionType,\n\t\tdatabaseKey: Uint8Array | null,\n\t): Promise<NewSessionData> {\n\t\tif (this.userFacade.isPartiallyLoggedIn()) {\n\t\t\t// do not reset here because the event bus client needs to be kept if the same user is logged in as before\n\t\t\tconsole.log(\"session already exists, reuse data\")\n\t\t\t// check if it is the same user in _initSession()\n\t\t}\n\n\t\tconst { userPassphraseKey, kdfType } = await this.loadUserPassphraseKey(mailAddress, passphrase)\n\t\t// the verifier is always sent as url parameter, so it must be url encoded\n\t\tconst authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey)\n\t\tconst createSessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken: null,\n\t\t\tauthVerifier,\n\t\t\tclientIdentifier,\n\t\t\tmailAddress: mailAddress.toLowerCase().trim(),\n\t\t\trecoverCodeVerifier: null,\n\t\t\tuser: null,\n\t\t})\n\n\t\tlet accessKey: AesKey | null = null\n\n\t\tif (sessionType === SessionType.Persistent) {\n\t\t\taccessKey = aes256RandomKey()\n\t\t\tcreateSessionData.accessKey = keyToUint8Array(accessKey)\n\t\t}\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, createSessionData)\n\t\tconst sessionData = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, mailAddress)\n\n\t\tconst forceNewDatabase = sessionType === SessionType.Persistent && databaseKey == null\n\t\tif (forceNewDatabase) {\n\t\t\tconsole.log(\"generating new database key for persistent session\")\n\t\t\tdatabaseKey = await this.databaseKeyFactory.generateKey()\n\t\t}\n\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId: sessionData.userId,\n\t\t\tdatabaseKey,\n\t\t\ttimeRangeDays: null,\n\t\t\tforceNewDatabase,\n\t\t})\n\t\tconst { user, userGroupInfo, accessToken } = await this.initSession(sessionData.userId, sessionData.accessToken, userPassphraseKey)\n\n\t\tconst modernKdfType = this.isModernKdfType(kdfType)\n\t\tif (!modernKdfType) {\n\t\t\tawait this.migrateKdfType(KdfType.Argon2id, passphrase, user)\n\t\t}\n\n\t\tconst credentials = {\n\t\t\tlogin: mailAddress,\n\t\t\taccessToken,\n\t\t\tencryptedPassword: sessionType === SessionType.Persistent ? uint8ArrayToBase64(encryptString(neverNull(accessKey), passphrase)) : null,\n\t\t\tencryptedPassphraseKey: sessionType === SessionType.Persistent ? encryptKey(neverNull(accessKey), userPassphraseKey) : null,\n\t\t\tuserId: sessionData.userId,\n\t\t\ttype: CredentialType.Internal,\n\t\t}\n\t\tthis.loginListener.onFullLoginSuccess(sessionType, cacheInfo, credentials)\n\n\t\tif (!isAdminClient()) {\n\t\t\tawait this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType)\n\t\t}\n\n\t\treturn {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId: sessionData.sessionId,\n\t\t\tcredentials: credentials,\n\t\t\t// we always try to make a persistent cache with a key for persistent session, but this\n\t\t\t// falls back to ephemeral cache in browsers. no point storing the key then.\n\t\t\tdatabaseKey: cacheInfo.isPersistent ? databaseKey : null,\n\t\t}\n\t}\n\n\t/**\n\t * Ensure that the user is using a modern KDF type, migrating if not.\n\t * @param targetKdfType the current KDF type\n\t * @param passphrase either the plaintext passphrase or the encrypted passphrase with the access token necessary to decrypt it\n\t * @param user the user we are updating\n\t */\n\tpublic async migrateKdfType(targetKdfType: KdfType, passphrase: string, user: User): Promise<void> {\n\t\tif (!Const.EXECUTE_KDF_MIGRATION) {\n\t\t\t// Migration is not yet enabled on this version.\n\t\t\treturn\n\t\t}\n\t\tconst currentPassphraseKeyData = {\n\t\t\tpassphrase,\n\t\t\tkdfType: asKdfType(user.kdfVersion),\n\t\t\tsalt: assertNotNull(user.salt, `current salt for user ${user._id} not found`),\n\t\t}\n\n\t\tconst currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPassphraseKeyData)\n\t\tconst currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey)\n\n\t\tconst newPassphraseKeyData = {\n\t\t\tpassphrase,\n\t\t\tkdfType: targetKdfType,\n\t\t\tsalt: generateRandomSalt(),\n\t\t}\n\t\tconst newUserPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData)\n\n\t\tconst currentUserGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object)\n\t\tconst newAuthVerifier = createAuthVerifier(newUserPassphraseKey)\n\n\t\tconst changeKdfPostIn = createChangeKdfPostIn({\n\t\t\tkdfVersion: newPassphraseKeyData.kdfType,\n\t\t\tsalt: newPassphraseKeyData.salt,\n\t\t\tpwEncUserGroupKey,\n\t\t\tverifier: newAuthVerifier,\n\t\t\toldVerifier: currentAuthVerifier,\n\t\t\tuserGroupKeyVersion: String(currentUserGroupKey.version),\n\t\t})\n\t\tconsole.log(\"Migrate KDF from:\", user.kdfVersion, \"to\", targetKdfType)\n\t\tawait this.serviceExecutor.post(ChangeKdfService, changeKdfPostIn)\n\t\t// We reload the user because we experienced a race condition\n\t\t// were we do not process the User update after doing the argon2 migration from the web client.Â´\n\t\t// In order do not rework the entity processing and its initialization for new clients we\n\t\t// replace the cached instances after doing the migration\n\t\tawait (await this.cacheManagementFacade()).reloadUser()\n\t\tthis.userFacade.setUserGroupKeyDistributionKey(newUserPassphraseKey)\n\t}\n\n\t/**\n\t * Checks if the given KDF type is phased out.\n\t * @param kdfType\n\t * @private\n\t */\n\tprivate isModernKdfType(kdfType: KdfType): boolean {\n\t\t// resist the temptation to just check if it is equal to the default, because that will yield false for KDF types we don't know about yet\n\t\treturn kdfType !== KdfType.Bcrypt\n\t}\n\n\t/**\n\t * If the second factor login has been cancelled a CancelledError is thrown.\n\t */\n\tprivate waitUntilSecondFactorApprovedOrCancelled(\n\t\tcreateSessionReturn: CreateSessionReturn,\n\t\tmailAddress: string | null,\n\t): Promise<{\n\t\tsessionId: IdTuple\n\t\tuserId: Id\n\t\taccessToken: Base64Url\n\t}> {\n\t\tlet p = Promise.resolve()\n\t\tlet sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)] as const\n\t\tthis.loginRequestSessionId = sessionId\n\n\t\tif (createSessionReturn.challenges.length > 0) {\n\t\t\t// Show a message to the user and give them a chance to complete the challenges.\n\t\t\tthis.loginListener.onSecondFactorChallenge(sessionId, createSessionReturn.challenges, mailAddress)\n\n\t\t\tp = this.waitUntilSecondFactorApproved(createSessionReturn.accessToken, sessionId, 0)\n\t\t}\n\n\t\tthis.loggingInPromiseWrapper = defer()\n\t\t// Wait for either login or cancel\n\t\treturn Promise.race([this.loggingInPromiseWrapper.promise, p]).then(() => ({\n\t\t\tsessionId,\n\t\t\taccessToken: createSessionReturn.accessToken,\n\t\t\tuserId: createSessionReturn.user,\n\t\t}))\n\t}\n\n\tprivate async waitUntilSecondFactorApproved(accessToken: Base64Url, sessionId: IdTuple, retryOnNetworkError: number): Promise<void> {\n\t\tlet secondFactorAuthGetData = createSecondFactorAuthGetData({\n\t\t\taccessToken,\n\t\t})\n\t\ttry {\n\t\t\tconst secondFactorAuthGetReturn = await this.serviceExecutor.get(SecondFactorAuthService, secondFactorAuthGetData)\n\t\t\tif (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) {\n\t\t\t\tthrow new CancelledError(\"login cancelled\")\n\t\t\t}\n\n\t\t\tif (secondFactorAuthGetReturn.secondFactorPending) {\n\t\t\t\treturn this.waitUntilSecondFactorApproved(accessToken, sessionId, 0)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tif (e instanceof ConnectionError && retryOnNetworkError < 10) {\n\t\t\t\t// Connection error can occur on ios when switching between apps or just as a timeout (our request timeout is shorter than the overall\n\t\t\t\t// auth flow timeout). Just retry in this case.\n\t\t\t\treturn this.waitUntilSecondFactorApproved(accessToken, sessionId, retryOnNetworkError + 1)\n\t\t\t}\n\t\t\tthrow e\n\t\t}\n\t}\n\n\t/**\n\t * Create external (temporary mailbox for passphrase-protected emails) session and log in.\n\t * Changes internal state to refer to the logged-in user.\n\t */\n\tasync createExternalSession(\n\t\tuserId: Id,\n\t\tpassphrase: string,\n\t\tsalt: Uint8Array,\n\t\tkdfType: KdfType,\n\t\tclientIdentifier: string,\n\t\tpersistentSession: boolean,\n\t): Promise<NewSessionData> {\n\t\tif (this.userFacade.isPartiallyLoggedIn()) {\n\t\t\tthrow new Error(\"user already logged in\")\n\t\t}\n\n\t\tconst userPassphraseKey = await this.deriveUserPassphraseKey({ kdfType, passphrase, salt })\n\t\t// the verifier is always sent as url parameter, so it must be url encoded\n\t\tconst authVerifier = createAuthVerifierAsBase64Url(userPassphraseKey)\n\t\tconst authToken = base64ToBase64Url(uint8ArrayToBase64(sha256Hash(salt)))\n\t\tconst sessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken,\n\t\t\tauthVerifier,\n\t\t\tclientIdentifier,\n\t\t\tmailAddress: null,\n\t\t\trecoverCodeVerifier: null,\n\t\t\tuser: userId,\n\t\t})\n\t\tlet accessKey: Aes256Key | null = null\n\n\t\tif (persistentSession) {\n\t\t\taccessKey = aes256RandomKey()\n\t\t\tsessionData.accessKey = keyToUint8Array(accessKey)\n\t\t}\n\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData)\n\n\t\tlet sessionId = [this.getSessionListId(createSessionReturn.accessToken), this.getSessionElementId(createSessionReturn.accessToken)] as const\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId,\n\t\t\tdatabaseKey: null,\n\t\t\ttimeRangeDays: null,\n\t\t\tforceNewDatabase: true,\n\t\t})\n\t\tconst { user, userGroupInfo, accessToken } = await this.initSession(createSessionReturn.user, createSessionReturn.accessToken, userPassphraseKey)\n\t\tconst credentials = {\n\t\t\tlogin: userId,\n\t\t\taccessToken,\n\t\t\tencryptedPassword: accessKey ? uint8ArrayToBase64(encryptString(accessKey, passphrase)) : null,\n\t\t\tencryptedPassphraseKey: accessKey ? encryptKey(accessKey, userPassphraseKey) : null,\n\t\t\tuserId,\n\t\t\ttype: CredentialType.External,\n\t\t}\n\t\tthis.loginListener.onFullLoginSuccess(SessionType.Login, cacheInfo, credentials)\n\t\treturn {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId,\n\t\t\tcredentials: credentials,\n\t\t\tdatabaseKey: null,\n\t\t}\n\t}\n\n\t/**\n\t * Derive a key given a KDF type, passphrase, and salt\n\t */\n\tasync deriveUserPassphraseKey({ kdfType, passphrase, salt }: PassphraseKeyData): Promise<AesKey> {\n\t\tswitch (kdfType) {\n\t\t\tcase KdfType.Bcrypt: {\n\t\t\t\treturn generateKeyFromPassphraseBcrypt(passphrase, salt, KeyLength.b128)\n\t\t\t}\n\t\t\tcase KdfType.Argon2id: {\n\t\t\t\treturn this.argon2idFacade.generateKeyFromPassphrase(passphrase, salt)\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Cancels 2FA process. */\n\tasync cancelCreateSession(sessionId: IdTuple): Promise<void> {\n\t\tif (!this.loginRequestSessionId || !isSameId(this.loginRequestSessionId, sessionId)) {\n\t\t\tthrow new Error(\"Trying to cancel session creation but the state is invalid\")\n\t\t}\n\n\t\tconst secondFactorAuthDeleteData = createSecondFactorAuthDeleteData({\n\t\t\tsession: sessionId,\n\t\t})\n\t\tawait this.serviceExecutor\n\t\t\t.delete(SecondFactorAuthService, secondFactorAuthDeleteData)\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, (e) => {\n\t\t\t\t\t// This can happen during some odd behavior in browser where main loop would be blocked by webauthn (hello, FF) and then we would try to\n\t\t\t\t\t// cancel too late. No harm here anyway if the session is already gone.\n\t\t\t\t\tconsole.warn(\"Tried to cancel second factor but it was not there anymore\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(LockedError, (e) => {\n\t\t\t\t\t// Might happen if we trigger cancel and confirm at the same time.\n\t\t\t\t\tconsole.warn(\"Tried to cancel second factor but it is currently locked\", e)\n\t\t\t\t}),\n\t\t\t)\n\t\tthis.loginRequestSessionId = null\n\t\tthis.loggingInPromiseWrapper?.reject(new CancelledError(\"login cancelled\"))\n\t}\n\n\t/** Finishes 2FA process either using second factor or approving session on another client. */\n\tasync authenticateWithSecondFactor(data: SecondFactorAuthData, host?: string): Promise<void> {\n\t\tawait this.serviceExecutor.post(SecondFactorAuthService, data, { baseUrl: host })\n\t}\n\n\t/**\n\t * Resumes previously created session (using persisted credentials).\n\t * @param credentials the saved credentials to use\n\t * @param externalUserKeyDeriver information for deriving a key (if external user)\n\t * @param databaseKey key to unlock the local database (if enabled)\n\t * @param timeRangeDays the user configured time range for the offline database\n\t */\n\tasync resumeSession(\n\t\tcredentials: Credentials,\n\t\texternalUserKeyDeriver: ExternalUserKeyDeriver | null,\n\t\tdatabaseKey: Uint8Array | null,\n\t\ttimeRangeDays: number | null,\n\t): Promise<ResumeSessionResult> {\n\t\tif (this.userFacade.getUser() != null) {\n\t\t\tthrow new ProgrammingError(\n\t\t\t\t`Trying to resume the session for user ${credentials.userId} while already logged in for ${this.userFacade.getUser()?._id}`,\n\t\t\t)\n\t\t}\n\t\tif (this.asyncLoginState.state !== \"idle\") {\n\t\t\tthrow new ProgrammingError(`Trying to resume the session for user ${credentials.userId} while the asyncLoginState is ${this.asyncLoginState.state}`)\n\t\t}\n\t\tthis.userFacade.setAccessToken(credentials.accessToken)\n\t\t// important: any exit point from here on should deinit the cache if the login hasn't succeeded\n\t\tconst cacheInfo = await this.initCache({\n\t\t\tuserId: credentials.userId,\n\t\t\tdatabaseKey,\n\t\t\ttimeRangeDays,\n\t\t\tforceNewDatabase: false,\n\t\t})\n\t\tconst sessionId = this.getSessionId(credentials)\n\t\ttry {\n\t\t\t// using offline, free, have connection         -> sync login\n\t\t\t// using offline, free, no connection           -> indicate that offline login is not for free customers\n\t\t\t// using offline, premium, have connection      -> async login\n\t\t\t// using offline, premium, no connection        -> async login w/ later retry\n\t\t\t// no offline, free, have connection            -> sync login\n\t\t\t// no offline, free, no connection              -> sync login, fail with connection error\n\t\t\t// no offline, premium, have connection         -> sync login\n\t\t\t// no offline, premium, no connection           -> sync login, fail with connection error\n\n\t\t\t// If a user enables offline storage for the first time, after already having saved credentials\n\t\t\t// then upon their next login, they won't have an offline database available, meaning we have to do\n\t\t\t// synchronous login in order to load all the necessary keys and such\n\t\t\t// the next time they log in they will be able to do asynchronous login\n\t\t\tif (cacheInfo?.isPersistent && !cacheInfo.isNewOfflineDb) {\n\t\t\t\tconst user = await this.entityClient.load(UserTypeRef, credentials.userId)\n\t\t\t\tif (user.accountType !== AccountType.PAID) {\n\t\t\t\t\t// if account is free do not start offline login/async login workflow.\n\t\t\t\t\t// await before return to catch errors here\n\t\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo).catch(\n\t\t\t\t\t\tofClass(ConnectionError, async () => {\n\t\t\t\t\t\t\tawait this.resetSession()\n\t\t\t\t\t\t\treturn { type: \"error\", reason: ResumeSessionErrorReason.OfflineNotAvailableForFree }\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.userFacade.setUser(user)\n\n\t\t\t\t// Temporary workaround for the transitional period\n\t\t\t\t// Before offline login was enabled (in 3.96.4) we didn't use cache for the login process, only afterwards.\n\t\t\t\t// This could lead to a situation where we never loaded or saved user groupInfo but would try to use it now.\n\t\t\t\t// We can remove this after a few versions when the bulk of people who enabled offline will upgrade.\n\t\t\t\tlet userGroupInfo: GroupInfo\n\t\t\t\ttry {\n\t\t\t\t\tuserGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(\"Could not do start login, groupInfo is not cached, falling back to sync login\")\n\t\t\t\t\tif (e instanceof LoginIncompleteError) {\n\t\t\t\t\t\t// await before return to catch the errors here\n\t\t\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noinspection ExceptionCaughtLocallyJS: we want to make sure we go throw the same exit point\n\t\t\t\t\t\tthrow e\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start full login async\n\t\t\t\tPromise.resolve().then(() => this.asyncResumeSession(credentials, cacheInfo))\n\t\t\t\tconst data = {\n\t\t\t\t\tuser,\n\t\t\t\t\tuserGroupInfo,\n\t\t\t\t\tsessionId,\n\t\t\t\t}\n\t\t\t\treturn { type: \"success\", data }\n\t\t\t} else {\n\t\t\t\t// await before return to catch errors here\n\t\t\t\treturn await this.finishResumeSession(credentials, externalUserKeyDeriver, cacheInfo)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// If we initialized the cache, but then we couldn't authenticate we should de-initialize\n\t\t\t// the cache again because we will initialize it for the next attempt.\n\t\t\t// It might be also called in initSession but the error can be thrown even before that (e.g. if the db is empty for some reason) so we reset\n\t\t\t// the session here as well, otherwise we might try to open the DB twice.\n\t\t\tawait this.resetSession()\n\t\t\tthrow e\n\t\t}\n\t}\n\n\tprivate getSessionId(credentials: Credentials): IdTuple {\n\t\treturn [this.getSessionListId(credentials.accessToken), this.getSessionElementId(credentials.accessToken)]\n\t}\n\n\tprivate async asyncResumeSession(credentials: Credentials, cacheInfo: CacheInfo): Promise<void> {\n\t\tif (this.asyncLoginState.state === \"running\") {\n\t\t\tthrow new Error(\"finishLoginResume run in parallel\")\n\t\t}\n\t\tthis.asyncLoginState = { state: \"running\" }\n\t\ttry {\n\t\t\tawait this.finishResumeSession(credentials, null, cacheInfo)\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotAuthenticatedError || e instanceof SessionExpiredError) {\n\t\t\t\t// For this type of errors we cannot use credentials anymore.\n\t\t\t\tthis.asyncLoginState = { state: \"idle\" }\n\t\t\t\tawait this.loginListener.onLoginFailure(LoginFailReason.SessionExpired)\n\t\t\t} else {\n\t\t\t\tthis.asyncLoginState = { state: \"failed\", credentials, cacheInfo }\n\t\t\t\tif (!(e instanceof ConnectionError)) await this.sendError(e)\n\t\t\t\tawait this.loginListener.onLoginFailure(LoginFailReason.Error)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async finishResumeSession(\n\t\tcredentials: Credentials,\n\t\texternalUserKeyDeriver: ExternalUserKeyDeriver | null,\n\t\tcacheInfo: CacheInfo,\n\t): Promise<ResumeSessionSuccess> {\n\t\tconst sessionId = this.getSessionId(credentials)\n\t\tconst sessionData = await this.loadSessionData(credentials.accessToken)\n\n\t\tconst accessKey = assertNotNull(sessionData.accessKey, \"no access key on session data!\")\n\t\tconst isExternalUser = externalUserKeyDeriver != null\n\n\t\tlet userPassphraseKey: AesKey\n\t\tlet credentialsWithPassphraseKey: Credentials\n\n\t\t// Previously only the encryptedPassword was stored, now we prefer to use the key if it's already there\n\t\t// and keep passphrase for migrating KDF for now.\n\t\tif (credentials.encryptedPassword) {\n\t\t\tconst passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)))\n\t\t\tif (isExternalUser) {\n\t\t\t\tawait this.checkOutdatedExternalSalt(credentials, sessionData, externalUserKeyDeriver.salt)\n\t\t\t\tuserPassphraseKey = await this.deriveUserPassphraseKey({ ...externalUserKeyDeriver, passphrase })\n\t\t\t} else {\n\t\t\t\tconst passphraseData = await this.loadUserPassphraseKey(credentials.login, passphrase)\n\t\t\t\tuserPassphraseKey = passphraseData.userPassphraseKey\n\t\t\t}\n\t\t\tconst encryptedPassphraseKey = encryptKey(accessKey, userPassphraseKey)\n\t\t\tcredentialsWithPassphraseKey = { ...credentials, encryptedPassphraseKey }\n\t\t} else {\n\t\t\tthrow new ProgrammingError(\"no key or password stored in credentials!\")\n\t\t}\n\n\t\tconst { user, userGroupInfo } = await this.initSession(sessionData.userId, credentials.accessToken, userPassphraseKey)\n\t\tthis.loginListener.onFullLoginSuccess(SessionType.Persistent, cacheInfo, credentialsWithPassphraseKey)\n\n\t\tthis.asyncLoginState = { state: \"idle\" }\n\n\t\tconst data = {\n\t\t\tuser,\n\t\t\tuserGroupInfo,\n\t\t\tsessionId,\n\t\t}\n\n\t\t// We only need to migrate the kdf in case an internal user resumes the session.\n\t\tconst modernKdfType = this.isModernKdfType(asKdfType(user.kdfVersion))\n\t\tif (!isExternalUser && credentials.encryptedPassword != null && !modernKdfType) {\n\t\t\tconst passphrase = utf8Uint8ArrayToString(aesDecrypt(accessKey, base64ToUint8Array(credentials.encryptedPassword)))\n\t\t\tawait this.migrateKdfType(KdfType.Argon2id, passphrase, user)\n\t\t}\n\t\tif (!isExternalUser && !isAdminClient()) {\n\t\t\t// We trigger group key rotation only for internal users.\n\t\t\t// If we have not migrated to argon2 we postpone key rotation until next login\n\t\t\t// instead of reloading the pwKey, which would be updated by the KDF migration.\n\t\t\tawait this.keyRotationFacade.initialize(userPassphraseKey, modernKdfType)\n\t\t}\n\n\t\treturn { type: \"success\", data }\n\t}\n\n\tprivate async initSession(\n\t\tuserId: Id,\n\t\taccessToken: Base64Url,\n\t\tuserPassphraseKey: AesKey,\n\t): Promise<{ user: User; accessToken: string; userGroupInfo: GroupInfo }> {\n\t\t// We might have userId already if:\n\t\t// - session has expired and a new one was created\n\t\t// - if it's a partial login\n\t\tconst userIdFromFormerLogin = this.userFacade.getUser()?._id ?? null\n\n\t\tif (userIdFromFormerLogin && userId !== userIdFromFormerLogin) {\n\t\t\tthrow new Error(\"different user is tried to login in existing other user's session\")\n\t\t}\n\n\t\tthis.userFacade.setAccessToken(accessToken)\n\n\t\ttry {\n\t\t\t// We need to use up-to-date user to make sure that we are not checking for outdated verified against cached user.\n\t\t\tconst user = await this.noncachingEntityClient.load(UserTypeRef, userId)\n\t\t\tawait this.checkOutdatedVerifier(user, accessToken, userPassphraseKey)\n\n\t\t\t// this may be the second time we set user in case we had a partial offline login before\n\t\t\t// we do it unconditionally here, to make sure we unlock the latest user group key right below\n\t\t\tthis.userFacade.setUser(user)\n\t\t\tconst wasFullyLoggedIn = this.userFacade.isFullyLoggedIn()\n\n\t\t\tthis.userFacade.unlockUserGroupKey(userPassphraseKey)\n\t\t\tconst userGroupInfo = await this.entityClient.load(GroupInfoTypeRef, user.userGroup.groupInfo)\n\n\t\t\tawait this.loadEntropy()\n\n\t\t\t// If we have been fully logged in at least once already (probably expired ephemeral session)\n\t\t\t// then we just reconnect and re-download missing events.\n\t\t\t// For new connections we have special handling.\n\t\t\tif (wasFullyLoggedIn) {\n\t\t\t\tthis.eventBusClient.connect(ConnectMode.Reconnect)\n\t\t\t} else {\n\t\t\t\tthis.eventBusClient.connect(ConnectMode.Initial)\n\t\t\t}\n\n\t\t\tawait this.entropyFacade.storeEntropy()\n\t\t\treturn { user, accessToken, userGroupInfo }\n\t\t} catch (e) {\n\t\t\tthis.resetSession()\n\t\t\tthrow e\n\t\t}\n\t}\n\n\t/**\n\t * init an appropriate cache implementation. we will always try to create a persistent cache for persistent sessions and fall back to an ephemeral cache\n\t * in the browser.\n\t *\n\t * @param userId the user for which the cache is created\n\t * @param databaseKey the key to use\n\t * @param timeRangeDays how far into the past the cache keeps data around\n\t * @param forceNewDatabase true if the old database should be deleted if there is one\n\t * @private\n\t */\n\tprivate async initCache({ userId, databaseKey, timeRangeDays, forceNewDatabase }: InitCacheOptions): Promise<CacheInfo> {\n\t\tif (databaseKey != null) {\n\t\t\treturn {\n\t\t\t\tdatabaseKey,\n\t\t\t\t...(await this.cacheInitializer.initialize({\n\t\t\t\t\ttype: \"offline\",\n\t\t\t\t\tuserId,\n\t\t\t\t\tdatabaseKey,\n\t\t\t\t\ttimeRangeDays,\n\t\t\t\t\tforceNewDatabase,\n\t\t\t\t})),\n\t\t\t}\n\t\t} else {\n\t\t\treturn { databaseKey: null, ...(await this.cacheInitializer.initialize({ type: \"ephemeral\", userId })) }\n\t\t}\n\t}\n\n\tprivate async deInitCache(): Promise<void> {\n\t\treturn this.cacheInitializer.deInitialize()\n\t}\n\n\t/**\n\t * Check whether the passed salt for external user is up-to-date (whether an outdated link was used).\n\t */\n\tprivate async checkOutdatedExternalSalt(\n\t\tcredentials: Credentials,\n\t\tsessionData: {\n\t\t\tuserId: Id\n\t\t\taccessKey: AesKey | null\n\t\t},\n\t\texternalUserSalt: Uint8Array,\n\t) {\n\t\tthis.userFacade.setAccessToken(credentials.accessToken)\n\t\tconst user = await this.entityClient.load(UserTypeRef, sessionData.userId)\n\t\tconst latestSaltHash = assertNotNull(user.externalAuthInfo!.latestSaltHash, \"latestSaltHash is not set!\")\n\t\tif (!arrayEquals(latestSaltHash, sha256Hash(externalUserSalt))) {\n\t\t\t// Do not delete session or credentials, we can still use them if the password\n\t\t\t// hasn't been changed.\n\t\t\tthis.resetSession()\n\t\t\tthrow new AccessExpiredError(\"Salt changed, outdated link?\")\n\t\t}\n\t}\n\n\t/**\n\t * Check that the auth verifier is not changed e.g. due to the password change.\n\t * Normally this won't happen for internal users as all sessions are closed on password change. This may happen for external users when the sender has\n\t * changed the password.\n\t * We do not delete all sessions on the server when changing the external password to avoid that an external user is immediately logged out.\n\t *\n\t * @param user Should be up-to-date, i.e., not loaded from cache, but fresh from the server, otherwise an outdated verifier will cause a logout.\n\t */\n\tprivate async checkOutdatedVerifier(user: User, accessToken: string, userPassphraseKey: Aes128Key) {\n\t\tif (uint8ArrayToBase64(user.verifier) !== uint8ArrayToBase64(sha256Hash(createAuthVerifier(userPassphraseKey)))) {\n\t\t\tconsole.log(\"Auth verifier has changed\")\n\t\t\t// delete the obsolete session to make sure it can not be used any more\n\t\t\tawait this.deleteSession(accessToken).catch((e) => console.error(\"Could not delete session\", e))\n\t\t\tawait this.resetSession()\n\t\t\tthrow new NotAuthenticatedError(\"Auth verifier has changed\")\n\t\t}\n\t}\n\n\tprivate async loadUserPassphraseKey(\n\t\tmailAddress: string,\n\t\tpassphrase: string,\n\t): Promise<{\n\t\tkdfType: KdfType\n\t\tuserPassphraseKey: AesKey\n\t}> {\n\t\tmailAddress = mailAddress.toLowerCase().trim()\n\t\tconst saltRequest = createSaltData({ mailAddress })\n\t\tconst saltReturn = await this.serviceExecutor.get(SaltService, saltRequest)\n\t\tconst kdfType = asKdfType(saltReturn.kdfVersion)\n\t\treturn {\n\t\t\tuserPassphraseKey: await this.deriveUserPassphraseKey({ kdfType, passphrase, salt: saltReturn.salt }),\n\t\t\tkdfType,\n\t\t}\n\t}\n\n\t/**\n\t * We use the accessToken that should be deleted for authentication. Therefore it can be invoked while logged in or logged out.\n\t *\n\t * @param pushIdentifier identifier associated with this device, if any, to delete PushIdentifier on the server\n\t */\n\tasync deleteSession(accessToken: Base64Url, pushIdentifier: string | null = null): Promise<void> {\n\t\tlet path = typeRefToPath(SessionTypeRef) + \"/\" + this.getSessionListId(accessToken) + \"/\" + this.getSessionElementId(accessToken)\n\t\tconst sessionTypeModel = await resolveTypeReference(SessionTypeRef)\n\n\t\tconst headers = {\n\t\t\taccessToken: neverNull(accessToken),\n\t\t\tv: sessionTypeModel.version,\n\t\t}\n\t\tconst queryParams: Dict = pushIdentifier == null ? {} : { pushIdentifier }\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.DELETE, {\n\t\t\t\theaders,\n\t\t\t\tresponseType: MediaType.Json,\n\t\t\t\tqueryParams,\n\t\t\t})\n\t\t\t.catch(\n\t\t\t\tofClass(NotAuthenticatedError, () => {\n\t\t\t\t\tconsole.log(\"authentication failed => session is already closed\")\n\t\t\t\t}),\n\t\t\t)\n\t\t\t.catch(\n\t\t\t\tofClass(NotFoundError, () => {\n\t\t\t\t\tconsole.log(\"authentication failed => session instance is already deleted\")\n\t\t\t\t}),\n\t\t\t)\n\t}\n\n\tprivate getSessionElementId(accessToken: Base64Url): Id {\n\t\tlet byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)))\n\t\treturn base64ToBase64Url(uint8ArrayToBase64(sha256Hash(byteAccessToken.slice(GENERATED_ID_BYTES_LENGTH))))\n\t}\n\n\tprivate getSessionListId(accessToken: Base64Url): Id {\n\t\tlet byteAccessToken = base64ToUint8Array(base64UrlToBase64(neverNull(accessToken)))\n\t\treturn base64ToBase64Ext(uint8ArrayToBase64(byteAccessToken.slice(0, GENERATED_ID_BYTES_LENGTH)))\n\t}\n\n\tprivate async loadSessionData(accessToken: Base64Url): Promise<{\n\t\tuserId: Id\n\t\taccessKey: AesKey | null\n\t}> {\n\t\tconst path = typeRefToPath(SessionTypeRef) + \"/\" + this.getSessionListId(accessToken) + \"/\" + this.getSessionElementId(accessToken)\n\t\tconst SessionTypeModel = await resolveTypeReference(SessionTypeRef)\n\n\t\tlet headers = {\n\t\t\taccessToken: accessToken,\n\t\t\tv: SessionTypeModel.version,\n\t\t}\n\t\t// we cannot use the entity client yet because this type is encrypted and we don't have an owner key yet\n\t\treturn this.restClient\n\t\t\t.request(path, HttpMethod.GET, {\n\t\t\t\theaders,\n\t\t\t\tresponseType: MediaType.Json,\n\t\t\t})\n\t\t\t.then((instance) => {\n\t\t\t\tlet session = JSON.parse(instance)\n\t\t\t\treturn {\n\t\t\t\t\tuserId: session.user,\n\t\t\t\t\taccessKey: session.accessKey ? base64ToKey(session.accessKey) : null,\n\t\t\t\t}\n\t\t\t})\n\t}\n\n\t/**\n\t * Loads entropy from the last logout.\n\t */\n\tprivate async loadEntropy(): Promise<void> {\n\t\tconst tutanotaProperties = await this.entityClient.loadRoot(TutanotaPropertiesTypeRef, this.userFacade.getUserGroupId())\n\t\treturn this.entropyFacade.loadEntropy(tutanotaProperties)\n\t}\n\n\t/**\n\t * Change password and/or KDF type for the current user. This will cause all other sessions to be closed.\n\t * @return New password encrypted with accessKey if this is a persistent session or {@code null}  if it's an ephemeral one.\n\t */\n\tasync changePassword(\n\t\tcurrentPasswordKeyData: PassphraseKeyData,\n\t\tnewPasswordKeyDataTemplate: Omit<PassphraseKeyData, \"salt\">,\n\t): Promise<{\n\t\tnewEncryptedPassphrase: Base64\n\t\tnewEncryptedPassphraseKey: Uint8Array\n\t} | null> {\n\t\tconst currentUserPassphraseKey = await this.deriveUserPassphraseKey(currentPasswordKeyData)\n\t\tconst currentAuthVerifier = createAuthVerifier(currentUserPassphraseKey)\n\t\tconst newPasswordKeyData = { ...newPasswordKeyDataTemplate, salt: generateRandomSalt() }\n\n\t\tconst newUserPassphraseKey = await this.deriveUserPassphraseKey(newPasswordKeyData)\n\t\tconst currentUserGroupKey = this.userFacade.getCurrentUserGroupKey()\n\t\tconst pwEncUserGroupKey = encryptKey(newUserPassphraseKey, currentUserGroupKey.object)\n\t\tconst authVerifier = createAuthVerifier(newUserPassphraseKey)\n\t\tconst service = createChangePasswordPostIn({\n\t\t\tcode: null,\n\t\t\tkdfVersion: newPasswordKeyDataTemplate.kdfType,\n\t\t\toldVerifier: currentAuthVerifier,\n\t\t\tpwEncUserGroupKey: pwEncUserGroupKey,\n\t\t\trecoverCodeVerifier: null,\n\t\t\tsalt: newPasswordKeyData.salt,\n\t\t\tverifier: authVerifier,\n\t\t\tuserGroupKeyVersion: String(currentUserGroupKey.version),\n\t\t})\n\n\t\tawait this.serviceExecutor.post(ChangePasswordService, service)\n\n\t\tthis.userFacade.setUserGroupKeyDistributionKey(newUserPassphraseKey)\n\t\tconst accessToken = assertNotNull(this.userFacade.getAccessToken())\n\t\tconst sessionData = await this.loadSessionData(accessToken)\n\t\tif (sessionData.accessKey != null) {\n\t\t\t// if we have an accessKey, this means we are storing the encrypted password locally, in which case we need to store the new one\n\t\t\tconst newEncryptedPassphrase = uint8ArrayToBase64(encryptString(sessionData.accessKey, newPasswordKeyDataTemplate.passphrase))\n\t\t\tconst newEncryptedPassphraseKey = encryptKey(sessionData.accessKey, newUserPassphraseKey)\n\t\t\treturn { newEncryptedPassphrase, newEncryptedPassphraseKey }\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync deleteAccount(password: string, takeover: string, surveyData: SurveyData | null = null): Promise<void> {\n\t\tconst userSalt = assertNotNull(this.userFacade.getLoggedInUser().salt)\n\n\t\tconst passphraseKeyData = {\n\t\t\tkdfType: asKdfType(this.userFacade.getLoggedInUser().kdfVersion),\n\t\t\tpassphrase: password,\n\t\t\tsalt: userSalt,\n\t\t}\n\t\tconst passwordKey = await this.deriveUserPassphraseKey(passphraseKeyData)\n\t\tconst deleteCustomerData = createDeleteCustomerData({\n\t\t\tauthVerifier: createAuthVerifier(passwordKey),\n\t\t\treason: null,\n\t\t\ttakeoverMailAddress: null,\n\t\t\tundelete: false,\n\t\t\tcustomer: neverNull(neverNull(this.userFacade.getLoggedInUser()).customer),\n\t\t\tsurveyData: surveyData,\n\t\t})\n\n\t\tif (takeover !== \"\") {\n\t\t\tdeleteCustomerData.takeoverMailAddress = takeover\n\t\t} else {\n\t\t\tdeleteCustomerData.takeoverMailAddress = null\n\t\t}\n\t\tawait this.serviceExecutor.delete(CustomerService, deleteCustomerData)\n\t}\n\n\t/** Changes user password to another one using recoverCode instead of the old password. */\n\tasync recoverLogin(mailAddress: string, recoverCode: string, newPassword: string, clientIdentifier: string): Promise<void> {\n\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\tconst recoverCodeVerifier = createAuthVerifier(recoverCodeKey)\n\t\tconst recoverCodeVerifierBase64 = base64ToBase64Url(uint8ArrayToBase64(recoverCodeVerifier))\n\t\tconst sessionData = createCreateSessionData({\n\t\t\taccessKey: null,\n\t\t\tauthToken: null,\n\t\t\tauthVerifier: null,\n\t\t\tclientIdentifier: clientIdentifier,\n\t\t\tmailAddress: mailAddress.toLowerCase().trim(),\n\t\t\trecoverCodeVerifier: recoverCodeVerifierBase64,\n\t\t\tuser: null,\n\t\t})\n\t\t// we need a separate entity rest client because to avoid caching of the user instance which is updated on password change. the web socket is not connected because we\n\t\t// don't do a normal login, and therefore we would not get any user update events. we can not use permanentLogin=false with initSession because caching would be enabled,\n\t\t// and therefore we would not be able to read the updated user\n\t\t// additionally we do not want to use initSession() to keep the LoginFacade stateless (except second factor handling) because we do not want to have any race conditions\n\t\t// when logging in normally after resetting the password\n\t\tconst tempAuthDataProvider: AuthDataProvider = {\n\t\t\tcreateAuthHeaders(): Dict {\n\t\t\t\treturn {}\n\t\t\t},\n\t\t\tisFullyLoggedIn(): boolean {\n\t\t\t\treturn false\n\t\t\t},\n\t\t}\n\t\tconst eventRestClient = new EntityRestClient(\n\t\t\ttempAuthDataProvider,\n\t\t\tthis.restClient,\n\t\t\t() => this.cryptoFacade,\n\t\t\tthis.instanceMapper,\n\t\t\tthis.blobAccessTokenFacade,\n\t\t)\n\t\tconst entityClient = new EntityClient(eventRestClient)\n\t\tconst createSessionReturn = await this.serviceExecutor.post(SessionService, sessionData) // Don't pass email address to avoid proposing to reset second factor when we're resetting password\n\n\t\tconst { userId, accessToken } = await this.waitUntilSecondFactorApprovedOrCancelled(createSessionReturn, null)\n\t\tconst user = await entityClient.load(UserTypeRef, userId, {\n\t\t\textraHeaders: {\n\t\t\t\taccessToken,\n\t\t\t},\n\t\t})\n\t\tif (user.auth == null || user.auth.recoverCode == null) {\n\t\t\tthrow new Error(\"missing recover code\")\n\t\t}\n\t\tconst recoverCodeExtraHeaders = {\n\t\t\taccessToken,\n\t\t\trecoverCodeVerifier: recoverCodeVerifierBase64,\n\t\t}\n\n\t\tconst recoverCodeData = await entityClient.load(RecoverCodeTypeRef, user.auth.recoverCode, { extraHeaders: recoverCodeExtraHeaders })\n\t\ttry {\n\t\t\tconst groupKey = aes256DecryptWithRecoveryKey(recoverCodeKey, recoverCodeData.recoverCodeEncUserGroupKey)\n\t\t\tconst salt = generateRandomSalt()\n\t\t\tconst newKdfType = DEFAULT_KDF_TYPE\n\n\t\t\tconst newPassphraseKeyData = { kdfType: newKdfType, passphrase: newPassword, salt }\n\t\t\tconst userPassphraseKey = await this.deriveUserPassphraseKey(newPassphraseKeyData)\n\t\t\tconst pwEncUserGroupKey = encryptKey(userPassphraseKey, groupKey)\n\t\t\tconst newPasswordVerifier = createAuthVerifier(userPassphraseKey)\n\t\t\tconst postData = createChangePasswordPostIn({\n\t\t\t\tcode: null,\n\t\t\t\tkdfVersion: newKdfType,\n\t\t\t\toldVerifier: null,\n\t\t\t\tsalt: salt,\n\t\t\t\tpwEncUserGroupKey: pwEncUserGroupKey,\n\t\t\t\tverifier: newPasswordVerifier,\n\t\t\t\trecoverCodeVerifier: recoverCodeVerifier,\n\t\t\t\tuserGroupKeyVersion: recoverCodeData.userKeyVersion,\n\t\t\t})\n\n\t\t\tconst extraHeaders = {\n\t\t\t\taccessToken,\n\t\t\t}\n\t\t\tawait this.serviceExecutor.post(ChangePasswordService, postData, { extraHeaders })\n\t\t} finally {\n\t\t\tthis.deleteSession(accessToken)\n\t\t}\n\t}\n\n\t/** Deletes second factors using recoverCode as second factor. */\n\tresetSecondFactors(mailAddress: string, password: string, recoverCode: Hex): Promise<void> {\n\t\treturn this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {\n\t\t\tconst authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey)\n\t\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\t\tconst recoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey)\n\t\t\tconst deleteData = createResetFactorsDeleteData({\n\t\t\t\tmailAddress,\n\t\t\t\tauthVerifier,\n\t\t\t\trecoverCodeVerifier,\n\t\t\t})\n\t\t\treturn this.serviceExecutor.delete(ResetFactorsService, deleteData)\n\t\t})\n\t}\n\n\ttakeOverDeletedAddress(mailAddress: string, password: string, recoverCode: Hex | null, targetAccountMailAddress: string): Promise<void> {\n\t\treturn this.loadUserPassphraseKey(mailAddress, password).then((passphraseReturn) => {\n\t\t\tconst authVerifier = createAuthVerifierAsBase64Url(passphraseReturn.userPassphraseKey)\n\t\t\tlet recoverCodeVerifier: Base64 | null = null\n\n\t\t\tif (recoverCode) {\n\t\t\t\tconst recoverCodeKey = uint8ArrayToBitArray(hexToUint8Array(recoverCode))\n\t\t\t\trecoverCodeVerifier = createAuthVerifierAsBase64Url(recoverCodeKey)\n\t\t\t}\n\n\t\t\tlet data = createTakeOverDeletedAddressData({\n\t\t\t\tmailAddress,\n\t\t\t\tauthVerifier,\n\t\t\t\trecoverCodeVerifier,\n\t\t\t\ttargetAccountMailAddress,\n\t\t\t})\n\t\t\treturn this.serviceExecutor.post(TakeOverDeletedAddressService, data)\n\t\t})\n\t}\n\n\tgenerateTotpSecret(): Promise<TotpSecret> {\n\t\treturn this.getTotpVerifier().then((totp) => totp.generateSecret())\n\t}\n\n\tgenerateTotpCode(time: number, key: Uint8Array): Promise<number> {\n\t\treturn this.getTotpVerifier().then((totp) => totp.generateTotp(time, key))\n\t}\n\n\tprivate getTotpVerifier(): Promise<TotpVerifier> {\n\t\treturn Promise.resolve(new TotpVerifier())\n\t}\n\n\tasync retryAsyncLogin(): Promise<void> {\n\t\tif (this.asyncLoginState.state === \"running\") {\n\t\t\treturn\n\t\t} else if (this.asyncLoginState.state === \"failed\") {\n\t\t\tawait this.asyncResumeSession(this.asyncLoginState.credentials, this.asyncLoginState.cacheInfo)\n\t\t} else {\n\t\t\tthrow new Error(\"credentials went missing\")\n\t\t}\n\t}\n\n\t/**\n\t * Returns a verifier token, which is proof of password authentication and is valid for a limited time.\n\t * This token will have to be passed back to the server with the appropriate call.\n\t */\n\tasync getVerifierToken(passphrase: string): Promise<string> {\n\t\tconst user = this.userFacade.getLoggedInUser()\n\t\tconst passphraseKey = await this.deriveUserPassphraseKey({\n\t\t\tkdfType: asKdfType(user.kdfVersion),\n\t\t\tpassphrase,\n\t\t\tsalt: assertNotNull(user.salt),\n\t\t})\n\n\t\tconst authVerifier = createAuthVerifier(passphraseKey)\n\t\tconst out = await this.serviceExecutor.post(VerifierTokenService, createVerifierTokenServiceIn({ authVerifier }))\n\t\treturn out.token\n\t}\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuGA,oBAAoB;IAsBF,gEAAX;AACN;;AACA;IAgDY,cAAN,MAAkB;CACxB,AAAQ;;;;CAIR,AAAQ,wBAAwC;;;;CAKhD,AAAQ,0BAAuD;;CAG/D,kBAAmC,EAAE,OAAO,OAAQ;CAEpD,YACkBA,YACAC,cACAC,eACAC,gBACAC,cACAC,mBAMAC,kBACAC,iBACAC,YACAC,uBACAC,eACAC,oBACAC,gBACAC,wBACAC,WACAC,uBAChB;EAw6BF,KA77BkB;EA67BjB,KA57BiB;EA47BhB,KA37BgB;EA27Bf,KA17Be;EA07Bd,KAz7Bc;EAy7Bb,KAx7Ba;EAw7BZ,KAl7BY;EAk7BX,KAj7BW;EAi7BV,KAh7BU;EAg7BT,KA/6BS;EA+6BR,KA96BQ;EA86BP,KA76BO;EA66BN,KA56BM;EA46BL,KA36BK;EA26BJ,KA16BI;EA06BH,KAz6BG;CACd;CAEJ,KAAKC,gBAAgC;AACpC,OAAK,iBAAiB;CACtB;CAED,MAAM,eAA8B;AACnC,OAAK,eAAe,MAAM,oBAAoB,UAAU;AACxD,QAAM,KAAK,aAAa;AACxB,OAAK,WAAW,OAAO;CACvB;;;;CAKD,MAAM,cACLC,aACAC,YACAC,kBACAC,aACAC,aAC0B;AAC1B,MAAI,KAAK,WAAW,qBAAqB,CAExC,SAAQ,IAAI,qCAAqC;EAIlD,MAAM,EAAE,mBAAmB,SAAS,GAAG,MAAM,KAAK,sBAAsB,aAAa,WAAW;EAEhG,MAAM,eAAe,8BAA8B,kBAAkB;EACrE,MAAM,oBAAoB,wBAAwB;GACjD,WAAW;GACX,WAAW;GACX;GACA;GACA,aAAa,YAAY,aAAa,CAAC,MAAM;GAC7C,qBAAqB;GACrB,MAAM;EACN,EAAC;EAEF,IAAIC,YAA2B;AAE/B,MAAI,gBAAgB,YAAY,YAAY;AAC3C,eAAY,iBAAiB;AAC7B,qBAAkB,YAAY,gBAAgB,UAAU;EACxD;EACD,MAAM,sBAAsB,MAAM,KAAK,gBAAgB,KAAK,gBAAgB,kBAAkB;EAC9F,MAAM,cAAc,MAAM,KAAK,yCAAyC,qBAAqB,YAAY;EAEzG,MAAM,mBAAmB,gBAAgB,YAAY,cAAc,eAAe;AAClF,MAAI,kBAAkB;AACrB,WAAQ,IAAI,qDAAqD;AACjE,iBAAc,MAAM,KAAK,mBAAmB,aAAa;EACzD;EAED,MAAM,YAAY,MAAM,KAAK,UAAU;GACtC,QAAQ,YAAY;GACpB;GACA,eAAe;GACf;EACA,EAAC;EACF,MAAM,EAAE,MAAM,eAAe,aAAa,GAAG,MAAM,KAAK,YAAY,YAAY,QAAQ,YAAY,aAAa,kBAAkB;EAEnI,MAAM,gBAAgB,KAAK,gBAAgB,QAAQ;AACnD,OAAK,cACJ,OAAM,KAAK,eAAe,QAAQ,UAAU,YAAY,KAAK;EAG9D,MAAM,cAAc;GACnB,OAAO;GACP;GACA,mBAAmB,gBAAgB,YAAY,aAAa,mBAAmB,cAAc,UAAU,UAAU,EAAE,WAAW,CAAC,GAAG;GAClI,wBAAwB,gBAAgB,YAAY,aAAa,WAAW,UAAU,UAAU,EAAE,kBAAkB,GAAG;GACvH,QAAQ,YAAY;GACpB,MAAM,eAAe;EACrB;AACD,OAAK,cAAc,mBAAmB,aAAa,WAAW,YAAY;AAE1E,OAAK,eAAe,CACnB,OAAM,KAAK,kBAAkB,WAAW,mBAAmB,cAAc;AAG1E,SAAO;GACN;GACA;GACA,WAAW,YAAY;GACV;GAGb,aAAa,UAAU,eAAe,cAAc;EACpD;CACD;;;;;;;CAQD,MAAa,eAAeC,eAAwBL,YAAoBM,MAA2B;AAClG,OAAK,MAAM,sBAEV;EAED,MAAM,2BAA2B;GAChC;GACA,SAAS,UAAU,KAAK,WAAW;GACnC,MAAM,cAAc,KAAK,OAAO,wBAAwB,KAAK,IAAI,YAAY;EAC7E;EAED,MAAM,2BAA2B,MAAM,KAAK,wBAAwB,yBAAyB;EAC7F,MAAM,sBAAsB,mBAAmB,yBAAyB;EAExE,MAAM,uBAAuB;GAC5B;GACA,SAAS;GACT,MAAM,oBAAoB;EAC1B;EACD,MAAM,uBAAuB,MAAM,KAAK,wBAAwB,qBAAqB;EAErF,MAAM,sBAAsB,KAAK,WAAW,wBAAwB;EACpE,MAAM,oBAAoB,WAAW,sBAAsB,oBAAoB,OAAO;EACtF,MAAM,kBAAkB,mBAAmB,qBAAqB;EAEhE,MAAM,kBAAkB,sBAAsB;GAC7C,YAAY,qBAAqB;GACjC,MAAM,qBAAqB;GAC3B;GACA,UAAU;GACV,aAAa;GACb,qBAAqB,OAAO,oBAAoB,QAAQ;EACxD,EAAC;AACF,UAAQ,IAAI,qBAAqB,KAAK,YAAY,MAAM,cAAc;AACtE,QAAM,KAAK,gBAAgB,KAAK,kBAAkB,gBAAgB;AAKlE,QAAM,CAAC,MAAM,KAAK,uBAAuB,EAAE,YAAY;AACvD,OAAK,WAAW,+BAA+B,qBAAqB;CACpE;;;;;;CAOD,AAAQ,gBAAgBC,SAA2B;AAElD,SAAO,YAAY,QAAQ;CAC3B;;;;CAKD,AAAQ,yCACPC,qBACAC,aAKE;EACF,IAAI,IAAI,QAAQ,SAAS;EACzB,IAAI,YAAY,CAAC,KAAK,iBAAiB,oBAAoB,YAAY,EAAE,KAAK,oBAAoB,oBAAoB,YAAY,AAAC;AACnI,OAAK,wBAAwB;AAE7B,MAAI,oBAAoB,WAAW,SAAS,GAAG;AAE9C,QAAK,cAAc,wBAAwB,WAAW,oBAAoB,YAAY,YAAY;AAElG,OAAI,KAAK,8BAA8B,oBAAoB,aAAa,WAAW,EAAE;EACrF;AAED,OAAK,0BAA0B,OAAO;AAEtC,SAAO,QAAQ,KAAK,CAAC,KAAK,wBAAwB,SAAS,CAAE,EAAC,CAAC,KAAK,OAAO;GAC1E;GACA,aAAa,oBAAoB;GACjC,QAAQ,oBAAoB;EAC5B,GAAE;CACH;CAED,MAAc,8BAA8BC,aAAwBC,WAAoBC,qBAA4C;EACnI,IAAI,0BAA0B,8BAA8B,EAC3D,YACA,EAAC;AACF,MAAI;GACH,MAAM,4BAA4B,MAAM,KAAK,gBAAgB,IAAI,yBAAyB,wBAAwB;AAClH,QAAK,KAAK,0BAA0B,SAAS,KAAK,uBAAuB,UAAU,CAClF,OAAM,IAAI,eAAe;AAG1B,OAAI,0BAA0B,oBAC7B,QAAO,KAAK,8BAA8B,aAAa,WAAW,EAAE;EAErE,SAAQ,GAAG;AACX,OAAI,aAAa,mBAAmB,sBAAsB,GAGzD,QAAO,KAAK,8BAA8B,aAAa,WAAW,sBAAsB,EAAE;AAE3F,SAAM;EACN;CACD;;;;;CAMD,MAAM,sBACLC,QACAb,YACAc,MACAP,SACAN,kBACAc,mBAC0B;AAC1B,MAAI,KAAK,WAAW,qBAAqB,CACxC,OAAM,IAAI,MAAM;EAGjB,MAAM,oBAAoB,MAAM,KAAK,wBAAwB;GAAE;GAAS;GAAY;EAAM,EAAC;EAE3F,MAAM,eAAe,8BAA8B,kBAAkB;EACrE,MAAM,YAAY,kBAAkB,mBAAmB,WAAW,KAAK,CAAC,CAAC;EACzE,MAAM,cAAc,wBAAwB;GAC3C,WAAW;GACX;GACA;GACA;GACA,aAAa;GACb,qBAAqB;GACrB,MAAM;EACN,EAAC;EACF,IAAIC,YAA8B;AAElC,MAAI,mBAAmB;AACtB,eAAY,iBAAiB;AAC7B,eAAY,YAAY,gBAAgB,UAAU;EAClD;EAED,MAAM,sBAAsB,MAAM,KAAK,gBAAgB,KAAK,gBAAgB,YAAY;EAExF,IAAI,YAAY,CAAC,KAAK,iBAAiB,oBAAoB,YAAY,EAAE,KAAK,oBAAoB,oBAAoB,YAAY,AAAC;EACnI,MAAM,YAAY,MAAM,KAAK,UAAU;GACtC;GACA,aAAa;GACb,eAAe;GACf,kBAAkB;EAClB,EAAC;EACF,MAAM,EAAE,MAAM,eAAe,aAAa,GAAG,MAAM,KAAK,YAAY,oBAAoB,MAAM,oBAAoB,aAAa,kBAAkB;EACjJ,MAAM,cAAc;GACnB,OAAO;GACP;GACA,mBAAmB,YAAY,mBAAmB,cAAc,WAAW,WAAW,CAAC,GAAG;GAC1F,wBAAwB,YAAY,WAAW,WAAW,kBAAkB,GAAG;GAC/E;GACA,MAAM,eAAe;EACrB;AACD,OAAK,cAAc,mBAAmB,YAAY,OAAO,WAAW,YAAY;AAChF,SAAO;GACN;GACA;GACA;GACa;GACb,aAAa;EACb;CACD;;;;CAKD,MAAM,wBAAwB,EAAE,SAAS,YAAY,MAAyB,EAAmB;AAChG,UAAQ,SAAR;AACC,QAAK,QAAQ,OACZ,QAAO,0BAAgC,YAAY,MAAM,UAAU,KAAK;AAEzE,QAAK,QAAQ,SACZ,QAAO,KAAK,eAAe,0BAA0B,YAAY,KAAK;EAEvE;CACD;;CAGD,MAAM,oBAAoBL,WAAmC;AAC5D,OAAK,KAAK,0BAA0B,SAAS,KAAK,uBAAuB,UAAU,CAClF,OAAM,IAAI,MAAM;EAGjB,MAAM,6BAA6B,iCAAiC,EACnE,SAAS,UACT,EAAC;AACF,QAAM,KAAK,gBACT,OAAO,yBAAyB,2BAA2B,CAC3D,MACA,QAAQ,eAAe,CAAC,MAAM;AAG7B,WAAQ,KAAK,8DAA8D,EAAE;EAC7E,EAAC,CACF,CACA,MACA,QAAQ,aAAa,CAAC,MAAM;AAE3B,WAAQ,KAAK,4DAA4D,EAAE;EAC3E,EAAC,CACF;AACF,OAAK,wBAAwB;AAC7B,OAAK,yBAAyB,OAAO,IAAI,eAAe,mBAAmB;CAC3E;;CAGD,MAAM,6BAA6BM,MAA4BC,MAA8B;AAC5F,QAAM,KAAK,gBAAgB,KAAK,yBAAyB,MAAM,EAAE,SAAS,KAAM,EAAC;CACjF;;;;;;;;CASD,MAAM,cACLC,aACAC,wBACAjB,aACAkB,eAC+B;AAC/B,MAAI,KAAK,WAAW,SAAS,IAAI,KAChC,OAAM,IAAI,kBACR,wCAAwC,YAAY,OAAO,+BAA+B,KAAK,WAAW,SAAS,EAAE,IAAI;AAG5H,MAAI,KAAK,gBAAgB,UAAU,OAClC,OAAM,IAAI,kBAAkB,wCAAwC,YAAY,OAAO,gCAAgC,KAAK,gBAAgB,MAAM;AAEnJ,OAAK,WAAW,eAAe,YAAY,YAAY;EAEvD,MAAM,YAAY,MAAM,KAAK,UAAU;GACtC,QAAQ,YAAY;GACpB;GACA;GACA,kBAAkB;EAClB,EAAC;EACF,MAAM,YAAY,KAAK,aAAa,YAAY;AAChD,MAAI;AAcH,OAAI,WAAW,iBAAiB,UAAU,gBAAgB;IACzD,MAAM,OAAO,MAAM,KAAK,aAAa,KAAK,aAAa,YAAY,OAAO;AAC1E,QAAI,KAAK,gBAAgB,YAAY,KAGpC,QAAO,MAAM,KAAK,oBAAoB,aAAa,wBAAwB,UAAU,CAAC,MACrF,QAAQ,iBAAiB,YAAY;AACpC,WAAM,KAAK,cAAc;AACzB,YAAO;MAAE,MAAM;MAAS,QAAQ,yBAAyB;KAA4B;IACrF,EAAC,CACF;AAEF,SAAK,WAAW,QAAQ,KAAK;IAM7B,IAAIC;AACJ,QAAI;AACH,qBAAgB,MAAM,KAAK,aAAa,KAAK,kBAAkB,KAAK,UAAU,UAAU;IACxF,SAAQ,GAAG;AACX,aAAQ,IAAI,gFAAgF;AAC5F,SAAI,aAAa,qBAEhB,QAAO,MAAM,KAAK,oBAAoB,aAAa,wBAAwB,UAAU;IAGrF,OAAM;IAEP;AAGD,YAAQ,SAAS,CAAC,KAAK,MAAM,KAAK,mBAAmB,aAAa,UAAU,CAAC;IAC7E,MAAM,OAAO;KACZ;KACA;KACA;IACA;AACD,WAAO;KAAE,MAAM;KAAW;IAAM;GAChC,MAEA,QAAO,MAAM,KAAK,oBAAoB,aAAa,wBAAwB,UAAU;EAEtF,SAAQ,GAAG;AAKX,SAAM,KAAK,cAAc;AACzB,SAAM;EACN;CACD;CAED,AAAQ,aAAaH,aAAmC;AACvD,SAAO,CAAC,KAAK,iBAAiB,YAAY,YAAY,EAAE,KAAK,oBAAoB,YAAY,YAAY,AAAC;CAC1G;CAED,MAAc,mBAAmBA,aAA0BI,WAAqC;AAC/F,MAAI,KAAK,gBAAgB,UAAU,UAClC,OAAM,IAAI,MAAM;AAEjB,OAAK,kBAAkB,EAAE,OAAO,UAAW;AAC3C,MAAI;AACH,SAAM,KAAK,oBAAoB,aAAa,MAAM,UAAU;EAC5D,SAAQ,GAAG;AACX,OAAI,aAAa,yBAAyB,aAAa,qBAAqB;AAE3E,SAAK,kBAAkB,EAAE,OAAO,OAAQ;AACxC,UAAM,KAAK,cAAc,eAAe,gBAAgB,eAAe;GACvE,OAAM;AACN,SAAK,kBAAkB;KAAE,OAAO;KAAU;KAAa;IAAW;AAClE,UAAM,aAAa,iBAAkB,OAAM,KAAK,UAAU,EAAE;AAC5D,UAAM,KAAK,cAAc,eAAe,gBAAgB,MAAM;GAC9D;EACD;CACD;CAED,MAAc,oBACbJ,aACAC,wBACAG,WACgC;EAChC,MAAM,YAAY,KAAK,aAAa,YAAY;EAChD,MAAM,cAAc,MAAM,KAAK,gBAAgB,YAAY,YAAY;EAEvE,MAAM,YAAY,cAAc,YAAY,WAAW,iCAAiC;EACxF,MAAM,iBAAiB,0BAA0B;EAEjD,IAAIC;EACJ,IAAIC;AAIJ,MAAI,YAAY,mBAAmB;GAClC,MAAM,aAAa,uBAAuB,WAAW,WAAW,mBAAmB,YAAY,kBAAkB,CAAC,CAAC;AACnH,OAAI,gBAAgB;AACnB,UAAM,KAAK,0BAA0B,aAAa,aAAa,uBAAuB,KAAK;AAC3F,wBAAoB,MAAM,KAAK,wBAAwB;KAAE,GAAG;KAAwB;IAAY,EAAC;GACjG,OAAM;IACN,MAAM,iBAAiB,MAAM,KAAK,sBAAsB,YAAY,OAAO,WAAW;AACtF,wBAAoB,eAAe;GACnC;GACD,MAAM,yBAAyB,WAAW,WAAW,kBAAkB;AACvE,kCAA+B;IAAE,GAAG;IAAa;GAAwB;EACzE,MACA,OAAM,IAAI,iBAAiB;EAG5B,MAAM,EAAE,MAAM,eAAe,GAAG,MAAM,KAAK,YAAY,YAAY,QAAQ,YAAY,aAAa,kBAAkB;AACtH,OAAK,cAAc,mBAAmB,YAAY,YAAY,WAAW,6BAA6B;AAEtG,OAAK,kBAAkB,EAAE,OAAO,OAAQ;EAExC,MAAM,OAAO;GACZ;GACA;GACA;EACA;EAGD,MAAM,gBAAgB,KAAK,gBAAgB,UAAU,KAAK,WAAW,CAAC;AACtE,OAAK,kBAAkB,YAAY,qBAAqB,SAAS,eAAe;GAC/E,MAAM,aAAa,uBAAuB,WAAW,WAAW,mBAAmB,YAAY,kBAAkB,CAAC,CAAC;AACnH,SAAM,KAAK,eAAe,QAAQ,UAAU,YAAY,KAAK;EAC7D;AACD,OAAK,mBAAmB,eAAe,CAItC,OAAM,KAAK,kBAAkB,WAAW,mBAAmB,cAAc;AAG1E,SAAO;GAAE,MAAM;GAAW;EAAM;CAChC;CAED,MAAc,YACbZ,QACAH,aACAc,mBACyE;EAIzE,MAAM,wBAAwB,KAAK,WAAW,SAAS,EAAE,OAAO;AAEhE,MAAI,yBAAyB,WAAW,sBACvC,OAAM,IAAI,MAAM;AAGjB,OAAK,WAAW,eAAe,YAAY;AAE3C,MAAI;GAEH,MAAM,OAAO,MAAM,KAAK,uBAAuB,KAAK,aAAa,OAAO;AACxE,SAAM,KAAK,sBAAsB,MAAM,aAAa,kBAAkB;AAItE,QAAK,WAAW,QAAQ,KAAK;GAC7B,MAAM,mBAAmB,KAAK,WAAW,iBAAiB;AAE1D,QAAK,WAAW,mBAAmB,kBAAkB;GACrD,MAAM,gBAAgB,MAAM,KAAK,aAAa,KAAK,kBAAkB,KAAK,UAAU,UAAU;AAE9F,SAAM,KAAK,aAAa;AAKxB,OAAI,iBACH,MAAK,eAAe,QAAQ,YAAY,UAAU;IAElD,MAAK,eAAe,QAAQ,YAAY,QAAQ;AAGjD,SAAM,KAAK,cAAc,cAAc;AACvC,UAAO;IAAE;IAAM;IAAa;GAAe;EAC3C,SAAQ,GAAG;AACX,QAAK,cAAc;AACnB,SAAM;EACN;CACD;;;;;;;;;;;CAYD,MAAc,UAAU,EAAE,QAAQ,aAAa,eAAe,kBAAoC,EAAsB;AACvH,MAAI,eAAe,KAClB,QAAO;GACN;GACA,GAAI,MAAM,KAAK,iBAAiB,WAAW;IAC1C,MAAM;IACN;IACA;IACA;IACA;GACA,EAAC;EACF;IAED,QAAO;GAAE,aAAa;GAAM,GAAI,MAAM,KAAK,iBAAiB,WAAW;IAAE,MAAM;IAAa;GAAQ,EAAC;EAAG;CAEzG;CAED,MAAc,cAA6B;AAC1C,SAAO,KAAK,iBAAiB,cAAc;CAC3C;;;;CAKD,MAAc,0BACbL,aACAO,aAIAC,kBACC;AACD,OAAK,WAAW,eAAe,YAAY,YAAY;EACvD,MAAM,OAAO,MAAM,KAAK,aAAa,KAAK,aAAa,YAAY,OAAO;EAC1E,MAAM,iBAAiB,cAAc,KAAK,iBAAkB,gBAAgB,6BAA6B;AACzG,OAAK,YAAY,gBAAgB,WAAW,iBAAiB,CAAC,EAAE;AAG/D,QAAK,cAAc;AACnB,SAAM,IAAI,mBAAmB;EAC7B;CACD;;;;;;;;;CAUD,MAAc,sBAAsBrB,MAAYsB,aAAqBC,mBAA8B;AAClG,MAAI,mBAAmB,KAAK,SAAS,KAAK,mBAAmB,WAAW,mBAAmB,kBAAkB,CAAC,CAAC,EAAE;AAChH,WAAQ,IAAI,4BAA4B;AAExC,SAAM,KAAK,cAAc,YAAY,CAAC,MAAM,CAAC,MAAM,QAAQ,MAAM,4BAA4B,EAAE,CAAC;AAChG,SAAM,KAAK,cAAc;AACzB,SAAM,IAAI,sBAAsB;EAChC;CACD;CAED,MAAc,sBACb9B,aACAC,YAIE;AACF,gBAAc,YAAY,aAAa,CAAC,MAAM;EAC9C,MAAM,cAAc,eAAe,EAAE,YAAa,EAAC;EACnD,MAAM,aAAa,MAAM,KAAK,gBAAgB,IAAI,aAAa,YAAY;EAC3E,MAAM,UAAU,UAAU,WAAW,WAAW;AAChD,SAAO;GACN,mBAAmB,MAAM,KAAK,wBAAwB;IAAE;IAAS;IAAY,MAAM,WAAW;GAAM,EAAC;GACrG;EACA;CACD;;;;;;CAOD,MAAM,cAAcU,aAAwBoB,iBAAgC,MAAqB;EAChG,IAAI,OAAO,cAAc,eAAe,GAAG,MAAM,KAAK,iBAAiB,YAAY,GAAG,MAAM,KAAK,oBAAoB,YAAY;EACjI,MAAM,mBAAmB,MAAM,qBAAqB,eAAe;EAEnE,MAAM,UAAU;GACf,aAAa,UAAU,YAAY;GACnC,GAAG,iBAAiB;EACpB;EACD,MAAMC,cAAoB,kBAAkB,OAAO,CAAE,IAAG,EAAE,eAAgB;AAC1E,SAAO,KAAK,WACV,QAAQ,MAAM,WAAW,QAAQ;GACjC;GACA,cAAc,UAAU;GACxB;EACA,EAAC,CACD,MACA,QAAQ,uBAAuB,MAAM;AACpC,WAAQ,IAAI,qDAAqD;EACjE,EAAC,CACF,CACA,MACA,QAAQ,eAAe,MAAM;AAC5B,WAAQ,IAAI,+DAA+D;EAC3E,EAAC,CACF;CACF;CAED,AAAQ,oBAAoBrB,aAA4B;EACvD,IAAI,kBAAkB,mBAAmB,kBAAkB,UAAU,YAAY,CAAC,CAAC;AACnF,SAAO,kBAAkB,mBAAmB,WAAW,gBAAgB,MAAM,0BAA0B,CAAC,CAAC,CAAC;CAC1G;CAED,AAAQ,iBAAiBA,aAA4B;EACpD,IAAI,kBAAkB,mBAAmB,kBAAkB,UAAU,YAAY,CAAC,CAAC;AACnF,SAAO,kBAAkB,mBAAmB,gBAAgB,MAAM,GAAG,0BAA0B,CAAC,CAAC;CACjG;CAED,MAAc,gBAAgBA,aAG3B;EACF,MAAM,OAAO,cAAc,eAAe,GAAG,MAAM,KAAK,iBAAiB,YAAY,GAAG,MAAM,KAAK,oBAAoB,YAAY;EACnI,MAAM,mBAAmB,MAAM,qBAAqB,eAAe;EAEnE,IAAI,UAAU;GACA;GACb,GAAG,iBAAiB;EACpB;AAED,SAAO,KAAK,WACV,QAAQ,MAAM,WAAW,KAAK;GAC9B;GACA,cAAc,UAAU;EACxB,EAAC,CACD,KAAK,CAAC,aAAa;GACnB,IAAI,UAAU,KAAK,MAAM,SAAS;AAClC,UAAO;IACN,QAAQ,QAAQ;IAChB,WAAW,QAAQ,YAAY,YAAY,QAAQ,UAAU,GAAG;GAChE;EACD,EAAC;CACH;;;;CAKD,MAAc,cAA6B;EAC1C,MAAM,qBAAqB,MAAM,KAAK,aAAa,SAAS,2BAA2B,KAAK,WAAW,gBAAgB,CAAC;AACxH,SAAO,KAAK,cAAc,YAAY,mBAAmB;CACzD;;;;;CAMD,MAAM,eACLsB,wBACAC,4BAIS;EACT,MAAM,2BAA2B,MAAM,KAAK,wBAAwB,uBAAuB;EAC3F,MAAM,sBAAsB,mBAAmB,yBAAyB;EACxE,MAAM,qBAAqB;GAAE,GAAG;GAA4B,MAAM,oBAAoB;EAAE;EAExF,MAAM,uBAAuB,MAAM,KAAK,wBAAwB,mBAAmB;EACnF,MAAM,sBAAsB,KAAK,WAAW,wBAAwB;EACpE,MAAM,oBAAoB,WAAW,sBAAsB,oBAAoB,OAAO;EACtF,MAAM,eAAe,mBAAmB,qBAAqB;EAC7D,MAAM,UAAU,2BAA2B;GAC1C,MAAM;GACN,YAAY,2BAA2B;GACvC,aAAa;GACM;GACnB,qBAAqB;GACrB,MAAM,mBAAmB;GACzB,UAAU;GACV,qBAAqB,OAAO,oBAAoB,QAAQ;EACxD,EAAC;AAEF,QAAM,KAAK,gBAAgB,KAAK,uBAAuB,QAAQ;AAE/D,OAAK,WAAW,+BAA+B,qBAAqB;EACpE,MAAM,cAAc,cAAc,KAAK,WAAW,gBAAgB,CAAC;EACnE,MAAM,cAAc,MAAM,KAAK,gBAAgB,YAAY;AAC3D,MAAI,YAAY,aAAa,MAAM;GAElC,MAAM,yBAAyB,mBAAmB,cAAc,YAAY,WAAW,2BAA2B,WAAW,CAAC;GAC9H,MAAM,4BAA4B,WAAW,YAAY,WAAW,qBAAqB;AACzF,UAAO;IAAE;IAAwB;GAA2B;EAC5D,MACA,QAAO;CAER;CAED,MAAM,cAAcC,UAAkBC,UAAkBC,aAAgC,MAAqB;EAC5G,MAAM,WAAW,cAAc,KAAK,WAAW,iBAAiB,CAAC,KAAK;EAEtE,MAAM,oBAAoB;GACzB,SAAS,UAAU,KAAK,WAAW,iBAAiB,CAAC,WAAW;GAChE,YAAY;GACZ,MAAM;EACN;EACD,MAAM,cAAc,MAAM,KAAK,wBAAwB,kBAAkB;EACzE,MAAM,qBAAqB,yBAAyB;GACnD,cAAc,mBAAmB,YAAY;GAC7C,QAAQ;GACR,qBAAqB;GACrB,UAAU;GACV,UAAU,UAAU,UAAU,KAAK,WAAW,iBAAiB,CAAC,CAAC,SAAS;GAC9D;EACZ,EAAC;AAEF,MAAI,aAAa,GAChB,oBAAmB,sBAAsB;IAEzC,oBAAmB,sBAAsB;AAE1C,QAAM,KAAK,gBAAgB,OAAO,iBAAiB,mBAAmB;CACtE;;CAGD,MAAM,aAAarC,aAAqBsC,aAAqBC,aAAqBrC,kBAAyC;EAC1H,MAAM,iBAAiB,qBAAqB,gBAAgB,YAAY,CAAC;EACzE,MAAM,sBAAsB,mBAAmB,eAAe;EAC9D,MAAM,4BAA4B,kBAAkB,mBAAmB,oBAAoB,CAAC;EAC5F,MAAM,cAAc,wBAAwB;GAC3C,WAAW;GACX,WAAW;GACX,cAAc;GACI;GAClB,aAAa,YAAY,aAAa,CAAC,MAAM;GAC7C,qBAAqB;GACrB,MAAM;EACN,EAAC;EAMF,MAAMsC,uBAAyC;GAC9C,oBAA0B;AACzB,WAAO,CAAE;GACT;GACD,kBAA2B;AAC1B,WAAO;GACP;EACD;EACD,MAAM,kBAAkB,IAAI,iBAC3B,sBACA,KAAK,YACL,MAAM,KAAK,cACX,KAAK,gBACL,KAAK;EAEN,MAAM,eAAe,IAAI,aAAa;EACtC,MAAM,sBAAsB,MAAM,KAAK,gBAAgB,KAAK,gBAAgB,YAAY;EAExF,MAAM,EAAE,QAAQ,aAAa,GAAG,MAAM,KAAK,yCAAyC,qBAAqB,KAAK;EAC9G,MAAM,OAAO,MAAM,aAAa,KAAK,aAAa,QAAQ,EACzD,cAAc,EACb,YACA,EACD,EAAC;AACF,MAAI,KAAK,QAAQ,QAAQ,KAAK,KAAK,eAAe,KACjD,OAAM,IAAI,MAAM;EAEjB,MAAM,0BAA0B;GAC/B;GACA,qBAAqB;EACrB;EAED,MAAM,kBAAkB,MAAM,aAAa,KAAK,oBAAoB,KAAK,KAAK,aAAa,EAAE,cAAc,wBAAyB,EAAC;AACrI,MAAI;GACH,MAAM,WAAW,6BAA6B,gBAAgB,gBAAgB,2BAA2B;GACzG,MAAM,OAAO,oBAAoB;GACjC,MAAM,aAAa;GAEnB,MAAM,uBAAuB;IAAE,SAAS;IAAY,YAAY;IAAa;GAAM;GACnF,MAAM,oBAAoB,MAAM,KAAK,wBAAwB,qBAAqB;GAClF,MAAM,oBAAoB,WAAW,mBAAmB,SAAS;GACjE,MAAM,sBAAsB,mBAAmB,kBAAkB;GACjE,MAAM,WAAW,2BAA2B;IAC3C,MAAM;IACN,YAAY;IACZ,aAAa;IACP;IACa;IACnB,UAAU;IACW;IACrB,qBAAqB,gBAAgB;GACrC,EAAC;GAEF,MAAM,eAAe,EACpB,YACA;AACD,SAAM,KAAK,gBAAgB,KAAK,uBAAuB,UAAU,EAAE,aAAc,EAAC;EAClF,UAAS;AACT,QAAK,cAAc,YAAY;EAC/B;CACD;;CAGD,mBAAmBxC,aAAqBmC,UAAkBM,aAAiC;AAC1F,SAAO,KAAK,sBAAsB,aAAa,SAAS,CAAC,KAAK,CAAC,qBAAqB;GACnF,MAAM,eAAe,8BAA8B,iBAAiB,kBAAkB;GACtF,MAAM,iBAAiB,qBAAqB,gBAAgB,YAAY,CAAC;GACzE,MAAM,sBAAsB,8BAA8B,eAAe;GACzE,MAAM,aAAa,6BAA6B;IAC/C;IACA;IACA;GACA,EAAC;AACF,UAAO,KAAK,gBAAgB,OAAO,qBAAqB,WAAW;EACnE,EAAC;CACF;CAED,uBAAuBzC,aAAqBmC,UAAkBO,aAAyBC,0BAAiD;AACvI,SAAO,KAAK,sBAAsB,aAAa,SAAS,CAAC,KAAK,CAAC,qBAAqB;GACnF,MAAM,eAAe,8BAA8B,iBAAiB,kBAAkB;GACtF,IAAIC,sBAAqC;AAEzC,OAAI,aAAa;IAChB,MAAM,iBAAiB,qBAAqB,gBAAgB,YAAY,CAAC;AACzE,0BAAsB,8BAA8B,eAAe;GACnE;GAED,IAAI,OAAO,iCAAiC;IAC3C;IACA;IACA;IACA;GACA,EAAC;AACF,UAAO,KAAK,gBAAgB,KAAK,+BAA+B,KAAK;EACrE,EAAC;CACF;CAED,qBAA0C;AACzC,SAAO,KAAK,iBAAiB,CAAC,KAAK,CAAC,SAAS,KAAK,gBAAgB,CAAC;CACnE;CAED,iBAAiBC,MAAcC,KAAkC;AAChE,SAAO,KAAK,iBAAiB,CAAC,KAAK,CAAC,SAAS,KAAK,aAAa,MAAM,IAAI,CAAC;CAC1E;CAED,AAAQ,kBAAyC;AAChD,SAAO,QAAQ,QAAQ,IAAI,eAAe;CAC1C;CAED,MAAM,kBAAiC;AACtC,MAAI,KAAK,gBAAgB,UAAU,UAClC;SACU,KAAK,gBAAgB,UAAU,SACzC,OAAM,KAAK,mBAAmB,KAAK,gBAAgB,aAAa,KAAK,gBAAgB,UAAU;IAE/F,OAAM,IAAI,MAAM;CAEjB;;;;;CAMD,MAAM,iBAAiB7C,YAAqC;EAC3D,MAAM,OAAO,KAAK,WAAW,iBAAiB;EAC9C,MAAM,gBAAgB,MAAM,KAAK,wBAAwB;GACxD,SAAS,UAAU,KAAK,WAAW;GACnC;GACA,MAAM,cAAc,KAAK,KAAK;EAC9B,EAAC;EAEF,MAAM,eAAe,mBAAmB,cAAc;EACtD,MAAM,MAAM,MAAM,KAAK,gBAAgB,KAAK,sBAAsB,6BAA6B,EAAE,aAAc,EAAC,CAAC;AACjH,SAAO,IAAI;CACX;AACD"}