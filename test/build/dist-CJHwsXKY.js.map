{"version":3,"file":"dist-CJHwsXKY.js","names":["min","max","min","max","compare","first","decoder","min","max"],"sources":["../../packages/tutanota-utils/dist/TypeRef.js","../../packages/tutanota-utils/dist/Utils.js","../../packages/tutanota-utils/dist/MapUtils.js","../../packages/tutanota-utils/dist/ArrayUtils.js","../../packages/tutanota-utils/dist/CollectionUtils.js","../../packages/tutanota-utils/dist/DateUtils.js","../../packages/tutanota-utils/dist/Encoding.js","../../packages/tutanota-utils/dist/LazyLoaded.js","../../packages/tutanota-utils/dist/PromiseMap.js","../../packages/tutanota-utils/dist/PromiseUtils.js","../../packages/tutanota-utils/dist/SortedArray.js","../../packages/tutanota-utils/dist/StringUtils.js","../../packages/tutanota-utils/dist/WebAssembly.js","../../packages/tutanota-utils/dist/MathUtils.js","../../packages/tutanota-utils/dist/Tokenizer.js"],"sourcesContent":["/**\n * T should be restricted to Entity.\n */\nexport class TypeRef {\n    app;\n    type;\n    /**\n     * Field that is never set. Used to make two TypeRefs incompatible (they are structurally compared otherwise).\n     * Cannot be private.\n     */\n    phantom = null;\n    constructor(app, type) {\n        this.app = app;\n        this.type = type;\n        Object.freeze(this);\n    }\n    /**\n     * breaks when the object passes worker barrier\n     */\n    toString() {\n        return `[TypeRef ${this.app} ${this.type}]`;\n    }\n}\nexport function getTypeId(typeRef) {\n    return typeRef.app + \"/\" + typeRef.type;\n}\nexport function isSameTypeRefByAttr(typeRef, app, typeName) {\n    return typeRef.app === app && typeRef.type === typeName;\n}\nexport function isSameTypeRef(typeRef1, typeRef2) {\n    return isSameTypeRefByAttr(typeRef1, typeRef2.app, typeRef2.type);\n}\nexport function isSameTypeRefNullable(typeRef1, typeRef2) {\n    return (typeRef1 == null && typeRef2 == null) || (typeRef1 != null && typeRef2 !== null && isSameTypeRef(typeRef1, typeRef2));\n}\n","import { TypeRef } from \"./TypeRef.js\";\n/**\n * Create a versioned object with version 0\n */\nexport function freshVersioned(object) {\n    return { object, version: 0 };\n}\nexport function defer() {\n    let ret = {};\n    ret.promise = new Promise((resolve, reject) => {\n        ret.resolve = resolve;\n        ret.reject = reject;\n    });\n    return ret;\n}\nexport function deferWithHandler(handler) {\n    const deferred = {};\n    deferred.promise = new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n    }).then(handler);\n    return deferred;\n}\nexport async function asyncFind(array, finder) {\n    for (let i = 0; i < array.length; i++) {\n        const item = array[i];\n        if (await finder(item, i, array.length)) {\n            return item;\n        }\n    }\n    return null;\n}\nexport async function asyncFindAndMap(array, finder) {\n    for (let i = 0; i < array.length; i++) {\n        const item = array[i];\n        const mapped = await finder(item, i, array.length);\n        if (mapped) {\n            return mapped;\n        }\n    }\n    return null;\n}\n/**\n * Calls an executor function for slices of nbrOfElementsInGroup items of the given array until the executor function returns false.\n */\nexport function executeInGroups(array, nbrOfElementsInGroup, executor) {\n    if (array.length > 0) {\n        let nextSlice = Math.min(array.length, nbrOfElementsInGroup);\n        return executor(array.slice(0, nextSlice)).then((doContinue) => {\n            if (doContinue) {\n                return executeInGroups(array.slice(nextSlice), nbrOfElementsInGroup, executor);\n            }\n        });\n    }\n    else {\n        return Promise.resolve();\n    }\n}\nexport function neverNull(object) {\n    return object;\n}\n/**\n * returns its argument if it is not null, throws otherwise.\n * @param value the value to check\n * @param message optional error message\n */\nexport function assertNotNull(value, message = \"null\") {\n    if (value == null) {\n        throw new Error(\"AssertNotNull failed : \" + message);\n    }\n    return value;\n}\n/**\n * assertion function that only returns if the argument is non-null\n * (acts as a type guard)\n * @param value the value to check\n * @param message optional error message\n */\nexport function assertNonNull(value, message = \"null\") {\n    if (value == null) {\n        throw new Error(\"AssertNonNull failed: \" + message);\n    }\n}\nexport function isNotNull(t) {\n    return t != null;\n}\nexport function assert(assertion, message) {\n    if (!resolveMaybeLazy(assertion)) {\n        throw new Error(`Assertion failed: ${message}`);\n    }\n}\nexport function downcast(object) {\n    return object;\n}\nexport function clone(instance) {\n    if (instance instanceof Uint8Array) {\n        return downcast(instance.slice());\n    }\n    else if (instance instanceof Array) {\n        return downcast(instance.map((i) => clone(i)));\n    }\n    else if (instance instanceof Date) {\n        return new Date(instance.getTime());\n    }\n    else if (instance instanceof TypeRef) {\n        return instance;\n    }\n    else if (instance instanceof Object) {\n        // Can only pass null or Object, cannot pass undefined\n        const copy = Object.create(Object.getPrototypeOf(instance) || null);\n        Object.assign(copy, instance);\n        for (let key of Object.keys(copy)) {\n            copy[key] = clone(copy[key]);\n        }\n        return copy;\n    }\n    else {\n        return instance;\n    }\n}\n/**\n * Function which accepts another function. On first invocation\n * of this resulting function result will be remembered and returned\n * on consequent invocations.\n */\nexport function lazyMemoized(source) {\n    // Using separate variable for tracking because value can be undefined and we want to the function call only once\n    let cached = false;\n    let value;\n    return () => {\n        if (cached) {\n            return value;\n        }\n        else {\n            cached = true;\n            return (value = source());\n        }\n    };\n}\n/**\n * accept a function taking exactly one argument and returning nothing and return a version of it\n * that will call the original function on the first call and ignore any further calls.\n * @param fn a function taking one argument and returning nothing\n */\nexport function makeSingleUse(fn) {\n    let called = false;\n    return (arg) => {\n        if (!called) {\n            called = true;\n            fn(arg);\n        }\n    };\n}\n/**\n * Returns a cached version of {@param fn}.\n * Cached function checks that argument is the same (with ===) and if it is then it returns the cached result.\n * If the cached argument has changed then {@param fn} will be called with new argument and result will be cached again.\n * Only remembers the last argument.\n */\nexport function memoized(fn) {\n    let lastArg;\n    let lastResult;\n    let didCache = false;\n    return (arg) => {\n        if (!didCache || arg !== lastArg) {\n            lastArg = arg;\n            didCache = true;\n            lastResult = fn(arg);\n        }\n        return lastResult;\n    };\n}\n/**\n * Like {@link memoized} but the argument is passed in via {@param argumentProvider}.\n * Useful for the cases where we want to keep only one field around e.g. for lazy getters\n */\nexport function memoizedWithHiddenArgument(argumentProvider, computationFunction) {\n    const memoizedComputation = memoized(computationFunction);\n    return () => memoizedComputation(argumentProvider());\n}\n/**\n * Function which returns what was passed into it\n */\nexport function identity(t) {\n    return t;\n}\n/**\n * Function which does nothing.\n */\nexport function noOp() { }\n/**\n * Return a function, which executed {@param toThrottle} only after it is not invoked for {@param timeout} ms.\n * Executes function with the last passed arguments\n * @return {Function}\n */\nexport function debounce(timeout, toThrottle) {\n    let timeoutId;\n    let toInvoke;\n    return downcast((...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        toInvoke = toThrottle.bind(null, ...args);\n        timeoutId = setTimeout(toInvoke, timeout);\n    });\n}\n/**\n * Returns a debounced function. When invoked for the first time, will just invoke\n * {@param toThrottle}. On subsequent invocations it will either invoke it right away\n * (if {@param timeout} has passed) or will schedule it to be run after {@param timeout}.\n * So the first and the last invocations in a series of invocations always take place\n * but ones in the middle (which happen too often) are discarded.\n */\nexport function debounceStart(timeout, toThrottle) {\n    let timeoutId;\n    let lastInvoked = 0;\n    return downcast((...args) => {\n        if (Date.now() - lastInvoked < timeout) {\n            if (timeoutId)\n                clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => {\n                timeoutId = null;\n                toThrottle.apply(null, args);\n            }, timeout);\n        }\n        else {\n            toThrottle.apply(null, args);\n        }\n        lastInvoked = Date.now();\n    });\n}\n/**\n * Returns a throttled function. When invoked for the first time will schedule {@param toThrottle}\n * to be called after {@param periodMs}. On subsequent invocations before {@param periodMs} amount of\n * time passes it will replace the arguments for the scheduled call (without rescheduling). After\n * {@param period} amount of time passes it will finally call {@param toThrottle} with the arguments\n * of the last call. New calls after that will behave like described in the beginning.\n *\n * This makes sure that the function is called not more often but also at most after {@param periodMs}\n * amount of time. Unlike {@link debounce}, it will get called after {@param periodMs} even if it\n * is being called repeatedly.\n */\nexport function throttle(periodMs, toThrottle) {\n    let lastArgs = null;\n    return ((...args) => {\n        if (lastArgs) {\n            return;\n        }\n        else {\n            setTimeout(() => {\n                try {\n                    toThrottle.apply(null, args);\n                }\n                finally {\n                    lastArgs = null;\n                }\n            }, periodMs);\n        }\n    });\n}\nexport function randomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\nexport function errorToString(error) {\n    let errorString = error.name ? error.name : \"?\";\n    if (error.message) {\n        errorString += `\\n Error message: ${error.message}`;\n    }\n    if (error.stack) {\n        // the error id is included in the stacktrace\n        errorString += `\\nStacktrace: \\n${error.stack}`;\n    }\n    return errorString;\n}\n/**\n * Like {@link Object.entries} but preserves the type of the key and value\n */\nexport function objectEntries(object) {\n    return downcast(Object.entries(object));\n}\n/**\n * modified deepEquals from ospec is only needed as long as we use custom classes (TypeRef) and Date is not properly handled\n */\nexport function deepEqual(a, b) {\n    if (a === b)\n        return true;\n    if (xor(a === null, b === null) || xor(a === undefined, b === undefined))\n        return false;\n    if (typeof a === \"object\" && typeof b === \"object\") {\n        const aIsArgs = isArguments(a), bIsArgs = isArguments(b);\n        if (a.length === b.length && ((a instanceof Array && b instanceof Array) || (aIsArgs && bIsArgs))) {\n            const aKeys = Object.getOwnPropertyNames(a), bKeys = Object.getOwnPropertyNames(b);\n            if (aKeys.length !== bKeys.length)\n                return false;\n            for (let i = 0; i < aKeys.length; i++) {\n                if (!hasOwn.call(b, aKeys[i]) || !deepEqual(a[aKeys[i]], b[aKeys[i]]))\n                    return false;\n            }\n            return true;\n        }\n        if (a instanceof Date && b instanceof Date)\n            return a.getTime() === b.getTime();\n        // for (let .. in ..) doesn't work with maps\n        if (a instanceof Map && b instanceof Map) {\n            for (const key of a.keys()) {\n                if (!b.has(key) || !deepEqual(a.get(key), b.get(key)))\n                    return false;\n            }\n            for (const key of b.keys()) {\n                if (!a.has(key))\n                    return false;\n            }\n            return true;\n        }\n        if (a instanceof Object && b instanceof Object && !aIsArgs && !bIsArgs) {\n            for (let i in a) {\n                if (!(i in b) || !deepEqual(a[i], b[i]))\n                    return false;\n            }\n            for (let i in b) {\n                if (!(i in a))\n                    return false;\n            }\n            return true;\n        }\n        // @ts-ignore: we would need to include all @types/node for this to work or import it explicitly. Should probably be rewritten for all typed arrays.\n        if (typeof Buffer === \"function\" && a instanceof Buffer && b instanceof Buffer) {\n            for (let i = 0; i < a.length; i++) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        if (a.valueOf() === b.valueOf())\n            return true;\n    }\n    return false;\n}\nfunction xor(a, b) {\n    const aBool = !!a;\n    const bBool = !!b;\n    return (aBool && !bBool) || (bBool && !aBool);\n}\nfunction isArguments(a) {\n    if (\"callee\" in a) {\n        for (let i in a)\n            if (i === \"callee\")\n                return false;\n        return true;\n    }\n}\nconst hasOwn = {}.hasOwnProperty;\n/**\n * returns an array of top-level properties that are in both objA and objB, but differ in value\n * does not handle functions or circular references\n * treats undefined and null as equal\n */\nexport function getChangedProps(objA, objB) {\n    if (objA == null || objB == null || objA === objB)\n        return [];\n    return Object.keys(objA)\n        .filter((k) => Object.keys(objB).includes(k))\n        .filter((k) => ![null, undefined].includes(objA[k]) || ![null, undefined].includes(objB[k]))\n        .filter((k) => !deepEqual(objA[k], objB[k]));\n}\n/**\n * Disallow set, delete and clear on Map.\n * Important: It is *not* a deep freeze.\n * @param myMap\n * @return {unknown}\n */\nexport function freezeMap(myMap) {\n    function mapSet(key, value) {\n        throw new Error(\"Can't add property \" + key + \", map is not extensible\");\n    }\n    function mapDelete(key) {\n        throw new Error(\"Can't delete property \" + key + \", map is frozen\");\n    }\n    function mapClear() {\n        throw new Error(\"Can't clear map, map is frozen\");\n    }\n    const anyMap = downcast(myMap);\n    anyMap.set = mapSet;\n    anyMap.delete = mapDelete;\n    anyMap.clear = mapClear;\n    Object.freeze(anyMap);\n    return anyMap;\n}\nexport function addressDomain(senderAddress) {\n    return senderAddress.slice(senderAddress.lastIndexOf(\"@\") + 1);\n}\n/**\n * Ignores the fact that Object.keys returns also not owned properties.\n */\nexport function typedKeys(obj) {\n    return downcast(Object.keys(obj));\n}\n/**\n * Ignores the fact that Object.keys returns also not owned properties.\n */\nexport function typedEntries(obj) {\n    return downcast(Object.entries(obj));\n}\n/**\n * Ignores the fact that Object.keys returns also not owned properties.\n */\nexport function typedValues(obj) {\n    return downcast(Object.values(obj));\n}\nexport function resolveMaybeLazy(maybe) {\n    return typeof maybe === \"function\" ? maybe() : maybe;\n}\nexport function getAsLazy(maybe) {\n    return typeof maybe === \"function\" ? downcast(maybe) : () => maybe;\n}\nexport function mapLazily(maybe, mapping) {\n    return () => mapping(resolveMaybeLazy(maybe));\n}\n/**\n * Stricter version of parseInt() from MDN. parseInt() allows some arbitrary characters at the end of the string.\n * Returns NaN in case there's anything non-number in the string.\n */\nexport function filterInt(value) {\n    if (/^\\d+$/.test(value)) {\n        return parseInt(value, 10);\n    }\n    else {\n        return NaN;\n    }\n}\nexport function insideRect(point, rect) {\n    return point.x >= rect.left && point.x < rect.right && point.y >= rect.top && point.y < rect.bottom;\n}\n/**\n * If val is non null, returns the result of val passed to action, else null\n */\nexport function mapNullable(val, action) {\n    if (val != null) {\n        const result = action(val);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\nexport function mapObject(mapper, obj) {\n    const newObj = {};\n    for (const key of Object.keys(obj)) {\n        const typedKey = key;\n        newObj[typedKey] = mapper(obj[typedKey]);\n    }\n    return newObj;\n}\n/**\n * Run jobs with defined max parallelism.\n */\nexport class BoundedExecutor {\n    maxParallelJobs;\n    runningJobsCount = 0;\n    currentJob = Promise.resolve();\n    constructor(maxParallelJobs) {\n        this.maxParallelJobs = maxParallelJobs;\n    }\n    async run(job) {\n        while (this.runningJobsCount === this.maxParallelJobs) {\n            await this.currentJob;\n        }\n        this.runningJobsCount++;\n        try {\n            const jobResult = job();\n            this.currentJob = jobResult.catch(noOp);\n            return await jobResult;\n        }\n        finally {\n            this.runningJobsCount--;\n        }\n    }\n}\nexport function assertValidURL(url) {\n    try {\n        return new URL(url);\n    }\n    catch (e) {\n        return false;\n    }\n}\n","import { neverNull } from \"./Utils.js\";\n/**\n * Merges multiple maps into a single map with lists of values.\n * @param maps\n */\nexport function mergeMaps(maps) {\n    return maps.reduce((mergedMap, map) => {\n        // merge same key of multiple attributes\n        for (const [key, value] of map.entries()) {\n            if (mergedMap.has(key)) {\n                neverNull(mergedMap.get(key)).push(value);\n            }\n            else {\n                mergedMap.set(key, [value]);\n            }\n        }\n        return mergedMap;\n    }, new Map());\n}\nexport function getFromMap(map, key, byDefault) {\n    let value = map.get(key);\n    if (!value) {\n        value = byDefault();\n        map.set(key, value);\n    }\n    return value;\n}\n/** Creates a new map with key and value added to {@param map}. It is like set() but for immutable map. */\nexport function addMapEntry(map, key, value) {\n    const newMap = new Map(map);\n    newMap.set(key, value);\n    return newMap;\n}\nexport function deleteMapEntry(map, key) {\n    const newMap = new Map(map);\n    newMap.delete(key);\n    return newMap;\n}\n/**\n * Convert values of {@param map} using {@param mapper} like {@link Array.prototype.map},\n */\nexport function mapMap(map, mapper) {\n    const resultMap = new Map();\n    for (const [key, oldValue] of map) {\n        const newValue = mapper(oldValue);\n        resultMap.set(key, newValue);\n    }\n    return resultMap;\n}\n","import { downcast, identity, neverNull } from \"./Utils.js\";\nimport { getFromMap } from \"./MapUtils.js\";\nexport function concat(...arrays) {\n    let length = arrays.reduce((previous, current) => previous + current.length, 0);\n    let result = new Uint8Array(length);\n    let index = 0;\n    for (const array of arrays) {\n        result.set(array, index);\n        index += array.length;\n    }\n    return result;\n}\n/**\n * Create an array filled with the numbers min..max (inclusive)\n */\nexport function numberRange(min, max) {\n    return [...Array(max + 1).keys()].slice(min);\n}\n/**\n * Compares two arrays for equality based on ===.\n * @param {Array} a1 The first array.\n * @param {Array} a2 The second array.\n * @return {boolean} True if the arrays are equal, false otherwise.\n *\n * It is valid to compare Uint8Array to Array<T>, don't restrict it to be one type\n */\nexport function arrayEquals(a1, a2) {\n    if (a1 === a2) {\n        return true;\n    }\n    if (a1.length === a2.length) {\n        for (let i = 0; i < a1.length; i++) {\n            if (a1[i] !== a2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Compares two arrays for equality based on a predicate\n * @param a1\n * @param a2\n * @param predicate\n * @returns {boolean}\n */\nexport function arrayEqualsWithPredicate(a1, a2, predicate) {\n    if (a1.length === a2.length) {\n        for (let i = 0; i < a1.length; i++) {\n            if (!predicate(a1[i], a2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexport function arrayHash(array) {\n    let hash = 0;\n    hash |= 0;\n    for (let i = 0; i < array.length; i++) {\n        hash = (hash << 5) - hash + array[i];\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n/**\n * Remove the element from theArray if it is contained in the array.\n * @param theArray The array to remove the element from.\n * @param elementToRemove The element to remove from the array.\n * @return True if the element was removed, false otherwise.\n */\nexport function remove(theArray, elementToRemove) {\n    let i = theArray.indexOf(elementToRemove);\n    if (i !== -1) {\n        theArray.splice(i, 1);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/**\n * truncates the array and discards all elements\n */\nexport function clear(theArray) {\n    theArray.length = 0;\n}\n/**\n * Find all items in an array that pass the given predicate\n */\nexport function findAll(theArray, finder) {\n    const found = [];\n    for (let element of theArray) {\n        if (finder(element)) {\n            found.push(element);\n        }\n    }\n    return found;\n}\n/**\n * @param theArray\n * @param finder\n * @return {boolean} if the element was found\n */\nexport function findAndRemove(theArray, finder) {\n    const index = theArray.findIndex(finder);\n    if (index !== -1) {\n        theArray.splice(index, 1);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/** find all matches inside an array and remove them. returns true if any instances were removed. */\nexport function findAllAndRemove(theArray, finder, startIndex = 0) {\n    let removedElement = false;\n    for (let i = theArray.length - 1; i >= startIndex; i--) {\n        if (finder(theArray[i])) {\n            theArray.splice(i, 1);\n            removedElement = true;\n        }\n    }\n    return removedElement;\n}\nexport function replace(theArray, oldElement, newElement) {\n    let i = theArray.indexOf(oldElement);\n    if (i !== -1) {\n        theArray.splice(i, 1, newElement);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Same as filterMap in some languages. Apply mapper and then only include non-nullable items.\n */\nexport function mapAndFilterNull(array, mapper) {\n    const resultList = [];\n    for (const item of array) {\n        const resultItem = mapper(item);\n        if (resultItem != null) {\n            resultList.push(resultItem);\n        }\n    }\n    return resultList;\n}\nexport function filterNull(array) {\n    return downcast(array.filter((item) => item != null));\n}\n/**\n * Provides the last element of the given array.\n * @param theArray The array.\n * @return The last element of the array.\n */\nexport function last(theArray) {\n    return theArray[theArray.length - 1];\n}\nexport function isEmpty(array) {\n    return array.length === 0;\n}\nexport function isNotEmpty(array) {\n    return array.length != 0;\n}\nexport function lastThrow(array) {\n    if (isEmpty(array)) {\n        throw new RangeError(\"Array is empty\");\n    }\n    return neverNull(last(array));\n}\n/**\n * get first item or throw if there is none\n */\nexport function getFirstOrThrow(array) {\n    if (isEmpty(array)) {\n        throw new RangeError(\"Array is empty\");\n    }\n    return array[0];\n}\nexport function first(array) {\n    return array[0] || null;\n}\nexport function findLast(array, predicate) {\n    const index = findLastIndex(array, predicate);\n    if (index !== -1) {\n        return array[index];\n    }\n    return null;\n}\nexport function findLastIndex(array, predicate) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        if (predicate(array[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function contains(theArray, elementToCheck) {\n    return theArray.indexOf(elementToCheck) !== -1;\n}\n/**\n * count how many of the items in {@param theArray} return true when passed to the predicate {@param pred}\n */\nexport function count(theArray, pred) {\n    return theArray.reduce((acc, next) => (pred(next) ? ++acc : acc), 0);\n}\nexport function addAll(array, elements) {\n    array.push(...elements);\n}\nexport function removeAll(array, elements) {\n    for (const element of elements) {\n        remove(array, element);\n    }\n}\n/**\n * Group an array based on the given discriminator, but each group will have only unique items\n */\nexport function groupByAndMapUniquely(iterable, discriminator, mapper) {\n    const map = new Map();\n    for (let el of iterable) {\n        const key = discriminator(el);\n        getFromMap(map, key, () => new Set()).add(mapper(el));\n    }\n    return map;\n}\n/**\n * convert an Array of T's into a Map of Arrays of E's by\n * * grouping them based on a discriminator\n * * mapping them from T to E\n * @param iterable the array to split into groups\n * @param discriminator a function that produces the keys to group the elements by\n * @param mapper a function that maps the array elements before they get added to the group\n * @returns {Map<R, Array<E>>}\n */\nexport function groupByAndMap(iterable, discriminator, mapper) {\n    const map = new Map();\n    for (const el of iterable) {\n        const key = discriminator(el);\n        getFromMap(map, key, () => []).push(mapper(el));\n    }\n    return map;\n}\n/**\n * Group array elements based on keys produced by a discriminator\n * @param iterable the array to split into groups\n * @param discriminator a function that produces the keys to group the elements by\n * @returns {NodeJS.Global.Map<R, Array<T>>}\n */\nexport function groupBy(iterable, discriminator) {\n    return groupByAndMap(iterable, discriminator, identity);\n}\n/**\n * Collect an iterable into a map based on {@param keyExtractor}.\n */\nexport function collectToMap(iterable, keyExtractor) {\n    const map = new Map();\n    for (const el of iterable) {\n        const key = keyExtractor(el);\n        if (map.has(key)) {\n            throw new Error(`The elements of iterable are not unique, duplicated key: ${key}`);\n        }\n        map.set(key, el);\n    }\n    return map;\n}\n/**\n * split an array into chunks of a given size.\n * the last chunk will be smaller if there are less than chunkSize elements left.\n * @param chunkSize\n * @param array\n * @returns {Array<Array<T>>}\n */\nexport function splitInChunks(chunkSize, array) {\n    return downcast(_chunk(chunkSize, array));\n}\nexport function splitUint8ArrayInChunks(chunkSize, array) {\n    return downcast(_chunk(chunkSize, array));\n}\nfunction _chunk(chunkSize, array) {\n    if (chunkSize < 1) {\n        return [];\n    }\n    let chunkNum = 0;\n    const chunks = [];\n    let end;\n    do {\n        let start = chunkNum * chunkSize;\n        end = start + chunkSize;\n        chunks[chunkNum] = array.slice(start, end);\n        chunkNum++;\n    } while (end < array.length);\n    return chunks;\n}\n/**\n * Maps an array into a nested array and then flattens it\n * @param array\n * @param mapper\n * @returns {T|*[]}\n */\nexport function flatMap(array, mapper) {\n    const result = [];\n    for (const item of array) {\n        const mapped = mapper(item);\n        result.push(...mapped);\n    }\n    return result;\n}\n/**\n * Inserts element into the sorted array. Will find <b>the last</b> matching position.\n * Might add or replace element based on {@param replaceIf} identity check.\n * Equality per {@param comparator} is precondition for replacement.\n * @param element to place\n * @param array where element should be placed\n * @param comparator for sorting\n * @param replaceIf identity comparison for replacement\n */\nexport function insertIntoSortedArray(element, array, comparator, replaceIf = () => false) {\n    let i = 0;\n    while (i < array.length) {\n        const compareResult = comparator(array[i], element);\n        // We need to check for replacement for each element that is equal or we might miss it\n        if (compareResult === 0 && replaceIf(element, array[i])) {\n            array.splice(i, 1, element);\n            return;\n        }\n        else if (compareResult <= 0) {\n            // We continue searching until the last suitable position\n            i++;\n        }\n        else {\n            break;\n        }\n    }\n    // This also handles empty array\n    array.splice(i, 0, element);\n}\nexport function zip(arr1, arr2) {\n    const zipped = [];\n    for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {\n        zipped.push([arr1[i], arr2[i]]);\n    }\n    return zipped;\n}\nexport function deduplicate(arr, comp = (a, b) => a === b) {\n    const deduplicated = [];\n    for (const a of arr) {\n        const isDuplicate = deduplicated.some((b) => comp(a, b));\n        if (!isDuplicate) {\n            deduplicated.push(a);\n        }\n    }\n    return deduplicated;\n}\n/**\n * http://jsfiddle.net/aryzhov/pkfst550/\n * Binary search in JavaScript.\n * Returns the index of the element in a sorted array or (-n-1) where n is the insertion point for the new element.\n * Parameters:\n *     array - A sorted array\n *     element - An element to search for\n *     compareFn - A comparator function. The function takes two arguments: (a, b) and returns:\n *        a negative number  if a is less than b;\n *        0 if a is equal to b;\n *        a positive number of a is greater than b.\n * The array may contain duplicate elements. If there are more than one equal elements in the array,\n * the returned value can be the index of any one of the equal elements.\n */\nexport function binarySearch(array, element, compareFn) {\n    let m = 0;\n    let n = array.length - 1;\n    while (m <= n) {\n        const k = (n + m) >> 1;\n        const cmp = compareFn(element, array[k]);\n        if (cmp > 0) {\n            m = k + 1;\n        }\n        else if (cmp < 0) {\n            n = k - 1;\n        }\n        else {\n            return k;\n        }\n    }\n    return -m - 1;\n}\nexport function lastIndex(array) {\n    if (array.length === 0) {\n        return 0;\n    }\n    else {\n        return array.length - 1;\n    }\n}\n/**\n * All of the elements in all of the arguments combined, and deduplicated\n */\nexport function union(...iterables) {\n    return new Set(...iterables.map((iterable) => Array.from(iterable)));\n}\n/**\n * return a new array containing every item from array1 that isn't in array2\n * @template T\n * @param array1\n * @param array2\n * @param compare {(l: T, r: T) => boolean} compare items in the array for equality\n * @returns {Array<T>}\n */\nexport function difference(array1, array2, compare = (a, b) => a === b) {\n    return array1.filter((element1) => !array2.some((element2) => compare(element1, element2)));\n}\n/**\n * Returns a set with elements that are *not* in both sets.\n *\n * {a, b, c} â–³ {b, c, d} == {a, d}\n */\nexport function symmetricDifference(set1, set2) {\n    const diff = new Set();\n    for (const el of set1) {\n        if (!set2.has(el)) {\n            diff.add(el);\n        }\n    }\n    for (const el of set2) {\n        if (!set1.has(el)) {\n            diff.add(el);\n        }\n    }\n    return diff;\n}\n// this is an implementation signature and is not visible from the outside\nexport function partition(array, predicate) {\n    const left = [];\n    const right = [];\n    for (let item of array) {\n        if (predicate(item)) {\n            left.push(item);\n        }\n        else {\n            right.push(item);\n        }\n    }\n    return [left, right];\n}\n/**\n * Like {@link partition}, but async and only for TL = TR.\n * Rejects if any of the predicates reject.\n */\nexport async function partitionAsync(array, predicate) {\n    const left = [];\n    const right = [];\n    for (let item of array) {\n        if (await predicate(item)) {\n            left.push(item);\n        }\n        else {\n            right.push(item);\n        }\n    }\n    return [left, right];\n}\n/**\n * Create an array with n elements by calling the provided factory\n */\nexport function arrayOf(n, factory) {\n    return numberRange(0, n - 1).map(factory);\n}\n/**\n * Destroy contents of the byte arrays passed. Useful for purging unwanted memory.\n */\nexport function zeroOut(...arrays) {\n    for (const a of arrays) {\n        a.fill(0);\n    }\n}\n/**\n * @return 1 if first is bigger than second, -1 if second is bigger than first and 0 otherwise\n */\nexport function compare(first, second) {\n    if (first.length > second.length) {\n        return 1;\n    }\n    else if (first.length < second.length) {\n        return -1;\n    }\n    for (let i = 0; i < first.length; i++) {\n        const a = first[i];\n        const b = second[i];\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n    }\n    return 0;\n}\n","import { identity } from \"./Utils.js\";\n/**\n * Everything that is in both array1 and array2\n * This is a naive implementation, don't use it on large inputs\n */\nexport function intersection(set1, set2) {\n    return new Set(Array.from(set1).filter((item) => set2.has(item)));\n}\nexport function setEquals(set1, set2) {\n    if (set1.size !== set2.size) {\n        return false;\n    }\n    for (let item of set1) {\n        if (!set2.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function setMap(set, mapper) {\n    const result = new Set();\n    for (const item of set) {\n        result.add(mapper(item));\n    }\n    return result;\n}\nexport function min(set) {\n    return minBy(set, identity);\n}\nexport function minBy(collection, selector) {\n    let min = null;\n    for (const item of collection) {\n        const value = selector(item);\n        if (min == null || value < min.value) {\n            min = { item, value };\n        }\n    }\n    return min ? min.item : null;\n}\nexport function max(set) {\n    return maxBy(set, identity);\n}\nexport function maxBy(collection, selector) {\n    let max = null;\n    for (const item of collection) {\n        const value = selector(item);\n        if (max == null || value > max.value) {\n            max = { item, value };\n        }\n    }\n    return max ? max.item : null;\n}\nexport function setAddAll(set, toAdd) {\n    for (const item of toAdd) {\n        set.add(item);\n    }\n}\n/**\n * Returns an element of the {@param collection} if it satisfies {@param selector} or {@code null} otherwise.\n */\nexport function findBy(collection, selector) {\n    for (const item of collection) {\n        if (selector(item)) {\n            return item;\n        }\n    }\n    return null;\n}\nexport function mapWith(map, key, value) {\n    const newMap = new Map(map);\n    newMap.set(key, value);\n    return newMap;\n}\nexport function mapWithout(map, key) {\n    const newMap = new Map(map);\n    newMap.delete(key);\n    return newMap;\n}\n/**\n * diff two maps by keys\n * @param before the map that's considered the old contents\n * @param after the map that's representing the current contents.\n * @returns arrays containing the kept, added, and deleted values.\n */\nexport function trisectingDiff(before, after) {\n    const kept = [];\n    const added = [];\n    const deleted = [];\n    const beforeScratch = new Map(before);\n    const afterScratch = new Map(after);\n    for (const [k, v] of beforeScratch.entries()) {\n        beforeScratch.delete(k);\n        if (afterScratch.has(k)) {\n            afterScratch.delete(k);\n            kept.push(v);\n        }\n        else {\n            deleted.push(v);\n        }\n    }\n    for (const v of afterScratch.values()) {\n        added.push(v);\n    }\n    return { kept, added, deleted };\n}\n","/**\n * @file DateUtils which do not use Luxon. Used in worker as well as in client parts.\n * As functions here do not use Luxon it cannot be used for calculating things in different time zones, they\n * are dependent on the system time zone.\n */\nexport const DAY_IN_MILLIS = 1000 * 60 * 60 * 24;\nexport const YEAR_IN_MILLIS = DAY_IN_MILLIS * 365;\n/**\n * dates from before 1970 have negative timestamps and are currently considered edge cases\n */\nexport const TIMESTAMP_ZERO_YEAR = 0;\n/**\n * Provides a date representing the beginning of the next day of the given date in local time.\n */\nexport function getStartOfNextDay(date) {\n    let d = new Date(date.getTime());\n    d.setDate(date.getDate() + 1);\n    d.setHours(0, 0, 0, 0); // sets the beginning of the day in local time\n    return d;\n}\n/**\n * Provides a date representing the end of the given date in local time.\n */\nexport function getEndOfDay(date) {\n    let d = new Date(date.getTime());\n    d.setHours(23, 59, 59, 999);\n    return d;\n}\n/**\n * Provides a date representing the beginning of the given date in local time.\n */\nexport function getStartOfDay(date) {\n    return getHourOfDay(date, 0);\n}\n/**\n * Provides a date representing the day of the given date at the given hour in local time.\n */\nexport function getHourOfDay(date, hour) {\n    let d = new Date(date.getTime());\n    d.setHours(hour, 0, 0, 0);\n    return d;\n}\nexport function isStartOfDay(date) {\n    return date.getHours() === 0 && date.getMinutes() === 0;\n}\n/**\n * Returns true if the given date is today in local time.\n */\nexport function isToday(date) {\n    return new Date().toDateString() === date.toDateString();\n}\n/**\n * Returns true if the given dates represent the same day (time of day is ignored).\n */\nexport function isSameDay(date1, date2) {\n    return date1.toDateString() === date2.toDateString();\n}\n/**\n * Creates new date in with {@param days} added to it as if the days are just fixed\n * periods of time and are not subject to daylight saving.\n */\nexport function getDayShifted(date, days) {\n    return new Date(date.getTime() + days * DAY_IN_MILLIS);\n}\n/**\n * Increment the date in place and return it\n */\nexport function incrementDate(date, byValue) {\n    date.setDate(date.getDate() + byValue);\n    return date;\n}\nexport function incrementMonth(d, byValue) {\n    const date = new Date(d);\n    date.setMonth(date.getMonth() + byValue);\n    return date;\n}\nexport function isSameDayOfDate(date1, date2) {\n    return ((!date1 && !date2) ||\n        (date1 != null &&\n            date2 != null &&\n            date1.getFullYear() === date2.getFullYear() &&\n            date1.getMonth() === date2.getMonth() &&\n            date1.getDate() === date2.getDate()));\n}\n/**\n * Formats as yyyy-mm-dd\n */\nexport function formatSortableDate(date) {\n    const month = (\"0\" + (date.getMonth() + 1)).slice(-2);\n    const day = (\"0\" + date.getDate()).slice(-2);\n    return `${date.getFullYear()}-${month}-${day}`;\n}\n/**\n * Formats as yyyy-mm-dd-<hh>h-<mm>m-<ss>\n */\nexport function formatSortableDateTime(date) {\n    const hours = (\"0\" + date.getHours()).slice(-2);\n    const minutes = (\"0\" + date.getMinutes()).slice(-2);\n    const seconds = (\"0\" + date.getSeconds()).slice(-2);\n    return `${formatSortableDate(date)}-${hours}h${minutes}m${seconds}s`;\n}\n/**\n * @returns {string} sortableDateTime of the current time\n */\nexport function sortableTimestamp() {\n    return formatSortableDateTime(new Date());\n}\nexport function isValidDate(date) {\n    return !isNaN(date.getTime());\n}\n/**\n * not interested in any fancy calendar edge cases, only use this where approximation is ok\n */\nexport function millisToDays(millis) {\n    return millis / DAY_IN_MILLIS;\n}\nexport function daysToMillis(days) {\n    return days * DAY_IN_MILLIS;\n}\n","// TODO rename methods according to their JAVA counterparts (e.g. Uint8Array == bytes, Utf8Uint8Array == bytes...)\nexport function uint8ArrayToArrayBuffer(uint8Array) {\n    if (uint8Array.byteLength === uint8Array.buffer.byteLength) {\n        return uint8Array.buffer;\n    }\n    else {\n        return new Uint8Array(uint8Array).buffer; // create a new instance with the correct length, if uint8Array is only a DataView on a longer Array.buffer\n    }\n}\n/**\n * Converts a hex coded string into a base64 coded string.\n *\n * @param hex A hex encoded string.\n * @return A base64 encoded string.\n */\nexport function hexToBase64(hex) {\n    return uint8ArrayToBase64(hexToUint8Array(hex));\n}\n/**\n * Converts a base64 coded string into a hex coded string.\n *\n * @param base64 A base64 encoded string.\n * @return A hex encoded string.\n */\nexport function base64ToHex(base64) {\n    return uint8ArrayToHex(base64ToUint8Array(base64));\n}\n/**\n * Converts a base64 string to a url-conform base64 string. This is used for\n * base64 coded url parameters.\n *\n * @param base64 The base64 string.\n * @return The base64url string.\n */\nexport function base64ToBase64Url(base64) {\n    let base64url = base64.replace(/\\+/g, \"-\");\n    base64url = base64url.replace(/\\//g, \"_\");\n    base64url = base64url.replace(/=/g, \"\");\n    return base64url;\n}\nfunction makeLookup(str) {\n    const lookup = {};\n    for (let i = 0; i < str.length; i++) {\n        lookup[str.charAt(i)] = i;\n    }\n    return lookup;\n}\nconst base64Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst base64Lookup = makeLookup(base64Alphabet);\nconst base64extAlphabet = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\nconst base64ExtLookup = makeLookup(base64extAlphabet);\n/**\n * Converts a base64 string to a base64ext string. Base64ext uses another character set than base64 in order to make it sortable.\n *\n *\n * @param base64 The base64 string.\n * @return The base64Ext string.\n */\nexport function base64ToBase64Ext(base64) {\n    base64 = base64.replace(/=/g, \"\");\n    let base64ext = \"\";\n    for (let i = 0; i < base64.length; i++) {\n        const index = base64Lookup[base64.charAt(i)];\n        base64ext += base64extAlphabet[index];\n    }\n    return base64ext;\n}\n/**\n * Converts a Base64Ext string to a Base64 string and appends the padding if needed.\n * @param base64ext The base64Ext string\n * @returns The base64 string\n */\nexport function base64ExtToBase64(base64ext) {\n    let base64 = \"\";\n    for (let i = 0; i < base64ext.length; i++) {\n        const index = base64ExtLookup[base64ext.charAt(i)];\n        base64 += base64Alphabet[index];\n    }\n    let padding;\n    if (base64.length % 4 === 2) {\n        padding = \"==\";\n    }\n    else if (base64.length % 4 === 3) {\n        padding = \"=\";\n    }\n    else {\n        padding = \"\";\n    }\n    return base64 + padding;\n}\n/**\n * Converts a base64 url string to a \"normal\" base64 string. This is used for\n * base64 coded url parameters.\n *\n * @param base64url The base64 url string.\n * @return The base64 string.\n */\nexport function base64UrlToBase64(base64url) {\n    let base64 = base64url.replace(/-/g, \"+\");\n    base64 = base64.replace(/_/g, \"/\");\n    let nbrOfRemainingChars = base64.length % 4;\n    if (nbrOfRemainingChars === 0) {\n        return base64;\n    }\n    else if (nbrOfRemainingChars === 2) {\n        return base64 + \"==\";\n    }\n    else if (nbrOfRemainingChars === 3) {\n        return base64 + \"=\";\n    }\n    throw new Error(\"Illegal base64 string.\");\n}\n// just for edge, as it does not support TextEncoder yet\nexport function _stringToUtf8Uint8ArrayLegacy(string) {\n    let fixedString;\n    try {\n        fixedString = encodeURIComponent(string);\n    }\n    catch (e) {\n        fixedString = encodeURIComponent(_replaceLoneSurrogates(string)); // we filter lone surrogates as trigger URIErrors, otherwise (see https://github.com/tutao/tutanota/issues/618)\n    }\n    let utf8 = unescape(fixedString);\n    let uint8Array = new Uint8Array(utf8.length);\n    for (let i = 0; i < utf8.length; i++) {\n        uint8Array[i] = utf8.charCodeAt(i);\n    }\n    return uint8Array;\n}\nconst REPLACEMENT_CHAR = \"\\uFFFD\";\nexport function _replaceLoneSurrogates(s) {\n    if (s == null) {\n        return \"\";\n    }\n    let result = [];\n    for (let i = 0; i < s.length; i++) {\n        let code = s.charCodeAt(i);\n        let char = s.charAt(i);\n        if (0xd800 <= code && code <= 0xdbff) {\n            if (s.length === i) {\n                // replace high surrogate without following low surrogate\n                result.push(REPLACEMENT_CHAR);\n            }\n            else {\n                let next = s.charCodeAt(i + 1);\n                if (0xdc00 <= next && next <= 0xdfff) {\n                    result.push(char);\n                    result.push(s.charAt(i + 1));\n                    i++; // valid high and low surrogate, skip next low surrogate check\n                }\n                else {\n                    result.push(REPLACEMENT_CHAR);\n                }\n            }\n        }\n        else if (0xdc00 <= code && code <= 0xdfff) {\n            // replace low surrogate without preceding high surrogate\n            result.push(REPLACEMENT_CHAR);\n        }\n        else {\n            result.push(char);\n        }\n    }\n    return result.join(\"\");\n}\nconst encoder = typeof TextEncoder == \"function\"\n    ? new TextEncoder()\n    : {\n        encode: _stringToUtf8Uint8ArrayLegacy,\n    };\nconst decoder = typeof TextDecoder == \"function\"\n    ? new TextDecoder()\n    : {\n        decode: _utf8Uint8ArrayToStringLegacy,\n    };\n/**\n * Converts a string to a Uint8Array containing a UTF-8 string data.\n *\n * @param string The string to convert.\n * @return The array.\n */\nexport function stringToUtf8Uint8Array(string) {\n    return encoder.encode(string);\n}\n// just for edge, as it does not support TextDecoder yet\nexport function _utf8Uint8ArrayToStringLegacy(uint8Array) {\n    let stringArray = [];\n    stringArray.length = uint8Array.length;\n    for (let i = 0; i < uint8Array.length; i++) {\n        stringArray[i] = String.fromCharCode(uint8Array[i]);\n    }\n    return decodeURIComponent(escape(stringArray.join(\"\")));\n}\n/**\n * Converts an Uint8Array containing UTF-8 string data into a string.\n *\n * @param uint8Array The Uint8Array.\n * @return The string.\n */\nexport function utf8Uint8ArrayToString(uint8Array) {\n    return decoder.decode(uint8Array);\n}\nexport function hexToUint8Array(hex) {\n    let bufView = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < bufView.byteLength; i++) {\n        bufView[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);\n    }\n    return bufView;\n}\nconst hexDigits = \"0123456789abcdef\";\nexport function uint8ArrayToHex(uint8Array) {\n    let hex = \"\";\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n        let value = uint8Array[i];\n        hex += hexDigits[value >> 4] + hexDigits[value & 15];\n    }\n    return hex;\n}\n/**\n * Converts an Uint8Array to a Base64 encoded string.\n *\n * @param bytes The bytes to convert.\n * @return The Base64 encoded string.\n */\nexport function uint8ArrayToBase64(bytes) {\n    if (bytes.length < 512) {\n        // Apply fails on big arrays fairly often. We tried it with 60000 but if you're already\n        // deep in the stack than we cannot allocate such a big argument array.\n        return btoa(String.fromCharCode(...bytes));\n    }\n    let binary = \"\";\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\nexport function int8ArrayToBase64(bytes) {\n    // Values 0 to 127 are the same for signed and unsigned bytes\n    // and -128 to -1 are mapped to the same chars as 128 to 255.\n    let converted = new Uint8Array(bytes);\n    return uint8ArrayToBase64(converted);\n}\n/**\n * Converts a base64 encoded string to a Uint8Array.\n *\n * @param base64 The Base64 encoded string.\n * @return The bytes.\n */\nexport function base64ToUint8Array(base64) {\n    if (base64.length % 4 !== 0) {\n        throw new Error(`invalid base64 length: ${base64} (${base64.length})`);\n    }\n    const binaryString = atob(base64);\n    const result = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        result[i] = binaryString.charCodeAt(i);\n    }\n    return result;\n}\n/**\n * Converts a Uint8Array containing string data into a string, given the charset the data is in.\n * @param charset The charset. Must be supported by TextDecoder.\n * @param bytes The string data\n * @trhows RangeError if the charset is not supported\n * @return The string\n */\nexport function uint8ArrayToString(charset, bytes) {\n    const decoder = new TextDecoder(charset);\n    return decoder.decode(bytes);\n}\n/**\n * Decodes a quoted-printable piece of text in a given charset.\n * This was copied and modified from https://github.com/mathiasbynens/quoted-printable/blob/master/src/quoted-printable.js (MIT licensed)\n *\n * @param charset Must be supported by TextEncoder\n * @param input The encoded text\n * @throws RangeError if the charset is not supported\n * @returns The text as a JavaScript string\n */\nexport function decodeQuotedPrintable(charset, input) {\n    return (input // https://tools.ietf.org/html/rfc2045#section-6.7, rule 3:\n        // â€œTherefore, when decoding a `Quoted-Printable` body, any trailing white\n        // space on a line must be deleted, as it will necessarily have been added\n        // by intermediate transport agents.â€\n        .replace(/[\\t\\x20]$/gm, \"\") // Remove hard line breaks preceded by `=`. Proper `Quoted-Printable`-\n        // encoded data only contains CRLF line  endings, but for compatibility\n        // reasons we support separate CR and LF too.\n        .replace(/=(?:\\r\\n?|\\n|$)/g, \"\") // Decode escape sequences of the form `=XX` where `XX` is any\n        // combination of two hexidecimal digits. For optimal compatibility,\n        // lowercase hexadecimal digits are supported as well. See\n        // https://tools.ietf.org/html/rfc2045#section-6.7, note 1.\n        .replace(/(=([a-fA-F0-9]{2}))+/g, (match) => {\n        const hexValues = match.split(/=/);\n        // splitting on '=' is convenient, but adds an empty string at the start due to the first byte\n        hexValues.shift();\n        const intArray = hexValues.map((char) => parseInt(char, 16));\n        const bytes = Uint8Array.from(intArray);\n        return uint8ArrayToString(charset, bytes);\n    }));\n}\nexport function decodeBase64(charset, input) {\n    return uint8ArrayToString(charset, base64ToUint8Array(input));\n}\nexport function stringToBase64(str) {\n    return uint8ArrayToBase64(stringToUtf8Uint8Array(str));\n}\n/**\n * Encodes a variable number of byte arrays as a single byte array. Format:\n * short(length of byteArray[0]) | byteArray[0] | ... | short(length of byteArray[n]) | byteArray[n]\n *\n * @return encoded byte array\n */\nexport function byteArraysToBytes(byteArrays) {\n    const totalBytesLength = byteArrays.reduce((acc, element) => acc + element.length, 0);\n    const encodingOverhead = byteArrays.length * 2; // two byte length overhead for each byte array\n    const encodedByteArrays = new Uint8Array(encodingOverhead + totalBytesLength);\n    let index = 0;\n    for (const byteArray of byteArrays) {\n        if (byteArray.length > MAX_ENCODED_BYTES_LENGTH) {\n            throw new Error(\"byte array is to long for encoding\");\n        }\n        index = writeByteArray(encodedByteArrays, byteArray, index);\n    }\n    return encodedByteArrays;\n}\n/**\n * Decodes a byte array encoded by #byteArraysToBytes.\n *\n * @return list of byte arrays\n */\nexport function bytesToByteArrays(encodedByteArrays, expectedByteArrays) {\n    const byteArrays = new Array();\n    let index = 0;\n    while (index < encodedByteArrays.length) {\n        const readResult = readByteArray(encodedByteArrays, index);\n        byteArrays.push(readResult.byteArray);\n        index = readResult.index;\n    }\n    if (byteArrays.length != expectedByteArrays) {\n        throw new Error(\"invalid amount of key parameters. Expected: \" + expectedByteArrays + \" actual:\" + byteArrays.length);\n    }\n    return byteArrays;\n}\n// Size of the length field for encoded byte arrays\nconst BYTE_ARRAY_LENGTH_FIELD_SIZE = 2;\nconst MAX_ENCODED_BYTES_LENGTH = 65535;\nfunction writeByteArray(result, byteArray, index) {\n    writeShort(result, byteArray.length, index);\n    index += BYTE_ARRAY_LENGTH_FIELD_SIZE;\n    result.set(byteArray, index);\n    index += byteArray.length;\n    return index;\n}\nfunction readByteArray(encoded, index) {\n    const length = readShort(encoded, index);\n    index += BYTE_ARRAY_LENGTH_FIELD_SIZE;\n    const byteArray = encoded.slice(index, length + index);\n    index += length;\n    if (byteArray.length != length) {\n        throw new Error(\"cannot read encoded byte array at pos:\" + index + \" expected bytes:\" + length + \" read bytes:\" + byteArray.length);\n    }\n    return { index, byteArray };\n}\nfunction writeShort(array, value, index) {\n    array[index] = (value & 0x0000ff00) >> 8;\n    array[index + 1] = (value & 0x000000ff) >> 0;\n}\nfunction readShort(array, index) {\n    const bytes = array.subarray(index, index + BYTE_ARRAY_LENGTH_FIELD_SIZE);\n    let n = 0;\n    for (const byte of bytes.values()) {\n        n = (n << 8) | byte;\n    }\n    return n;\n}\n","/**\n * A wrapper for an object that shall be lazy loaded asynchronously. If loading the object is triggered in parallel (getAsync()) the object is actually only loaded once but returned to all calls of getAsync().\n * If the object was loaded once it is not loaded again.\n */\nexport class LazyLoaded {\n    loadFunction;\n    defaultValue;\n    state = { state: \"not_loaded\" };\n    /**\n     * @param loadFunction The function that actually loads the object as soon as getAsync() is called the first time.\n     * @param defaultValue The value that shall be returned by getSync() or getLoaded() as long as the object is not loaded yet.\n     */\n    constructor(loadFunction, defaultValue = null) {\n        this.loadFunction = loadFunction;\n        this.defaultValue = defaultValue;\n    }\n    load() {\n        this.getAsync();\n        return this;\n    }\n    isLoaded() {\n        return this.state.state === \"loaded\";\n    }\n    isLoadedOrLoading() {\n        return this.state.state === \"loaded\" || this.state.state === \"loading\";\n    }\n    /**\n     * Loads the object if it is not loaded yet. May be called in parallel and takes care that the load function is only called once.\n     */\n    getAsync() {\n        switch (this.state.state) {\n            case \"not_loaded\": {\n                const loadingPromise = this.loadFunction().then((value) => {\n                    this.state = { state: \"loaded\", value };\n                    return value;\n                }, (e) => {\n                    this.state = { state: \"not_loaded\" };\n                    throw e;\n                });\n                this.state = { state: \"loading\", promise: loadingPromise };\n                return loadingPromise;\n            }\n            case \"loading\":\n                return this.state.promise;\n            case \"loaded\":\n                return Promise.resolve(this.state.value);\n        }\n    }\n    /**\n     * Returns null if the object is not loaded yet.\n     */\n    getSync() {\n        return this.state.state === \"loaded\" ? this.state.value : this.defaultValue;\n    }\n    /**\n     * Only call this function if you know that the object is already loaded.\n     */\n    getLoaded() {\n        if (this.state.state === \"loaded\") {\n            return this.state.value;\n        }\n        else {\n            throw new Error(\"Not loaded!\");\n        }\n    }\n    /**\n     * Removes the currently loaded object, so it will be loaded again with the next getAsync() call. Does not set any default value.\n     */\n    reset() {\n        this.state = { state: \"not_loaded\" };\n        this.defaultValue = null;\n    }\n    /**\n     * Loads the object again and replaces the current one\n     */\n    async reload() {\n        this.state = { state: \"not_loaded\" };\n        return this.getAsync();\n    }\n}\n","/**\n    @param iterable - Iterated over concurrently in the `mapper` function.\n    @param mapper - Function which is called for every item in `input`. Expected to return a `Promise` or value.\n    @param options\n    @returns A `Promise` that is fulfilled when all promises in `input` and ones returned from `mapper` are fulfilled, or rejects if any of the promises reject. The fulfilled value is an `Array` of the fulfilled values returned from `mapper` in `input` order.\n    @example\n    ```\n    import pMap from 'p-map';\n    import got from 'got';\n    const sites = [\n        getWebsiteFromUsername('sindresorhus'), //=> Promise\n        'https://avajs.dev',\n        'https://github.com'\n    ];\n    const mapper = async site => {\n        const {requestUrl} = await got.head(site);\n        return requestUrl;\n    };\n    const result = await pMap(sites, mapper, {concurrency: 2});\n    console.log(result);\n    //=> ['https://sindresorhus.com/', 'https://avajs.dev/', 'https://github.com/']\n    ```\n */\nexport async function pMap(iterable, mapper, options = {}) {\n    const { concurrency = 1 } = options;\n    return new Promise((resolve, reject) => {\n        if (typeof mapper !== \"function\") {\n            throw new TypeError(\"Mapper function is required\");\n        }\n        if (!((Number.isSafeInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n        }\n        const result = [];\n        const errors = [];\n        const iterator = iterable[Symbol.iterator]();\n        let isRejected = false;\n        let isIterableDone = false;\n        let resolvingCount = 0;\n        let currentIndex = 0;\n        const next = () => {\n            if (isRejected) {\n                return;\n            }\n            const nextItem = iterator.next();\n            const index = currentIndex;\n            currentIndex++;\n            if (nextItem.done) {\n                isIterableDone = true;\n                if (resolvingCount === 0) {\n                    resolve(result);\n                }\n                return;\n            }\n            resolvingCount++;\n            (async () => {\n                try {\n                    const element = await nextItem.value;\n                    result[index] = await mapper(element, index);\n                    resolvingCount--;\n                    next();\n                }\n                catch (error) {\n                    isRejected = true;\n                    reject(error);\n                }\n            })();\n        };\n        for (let index = 0; index < concurrency; index++) {\n            next();\n            if (isIterableDone) {\n                break;\n            }\n        }\n    });\n}\n","import { pMap as promiseMap } from \"./PromiseMap.js\";\n/**\n * Map array of values to promise of arrays or array. Mapper function may return promise or value. If value is returned,\n * we avoid promise scheduling.\n *\n * This is needed to run the whole operation in one microtask (e.g. keep IndexedDB transaction active, which is closed in\n * some browsers (e.g. Safari) when event loop iteration ends).\n */\nexport function mapInCallContext(values, callback) {\n    return new PromisableWrapper(_mapInCallContext(values, callback, 0, []));\n}\nfunction _mapInCallContext(values, callback, index, acc) {\n    if (index >= values.length) {\n        return acc;\n    }\n    let mappedValue = callback(values[index], index);\n    if (mappedValue instanceof Promise) {\n        return mappedValue.then((v) => {\n            acc.push(v);\n            return _mapInCallContext(values, callback, index + 1, acc);\n        });\n    }\n    else {\n        acc.push(mappedValue);\n        return _mapInCallContext(values, callback, index + 1, acc);\n    }\n}\nexport { pMap as promiseMap } from \"./PromiseMap.js\";\nfunction mapNoFallback(values, callback, options) {\n    return PromisableWrapper.from(promiseMap(values, callback, options));\n}\n/** Factory function which gives you ack promiseMap implementation. {@see mapInCallContext} for what it means. */\nexport function promiseMapCompat(useMapInCallContext) {\n    return useMapInCallContext ? mapInCallContext : mapNoFallback;\n}\nfunction flatWrapper(value) {\n    return value instanceof PromisableWrapper ? value.value : value;\n}\n// It kinda implements 'thenable' protocol so you can freely pass it around as a generic promise\nexport class PromisableWrapper {\n    static from(value) {\n        return new PromisableWrapper(value);\n    }\n    value;\n    constructor(value) {\n        this.value = value instanceof Promise ? value.then(flatWrapper) : flatWrapper(value);\n    }\n    thenOrApply(onFulfill, onReject) {\n        if (this.value instanceof Promise) {\n            const v = this.value.then(onFulfill, onReject);\n            return new PromisableWrapper(v);\n        }\n        else {\n            try {\n                return new PromisableWrapper(onFulfill(this.value));\n            }\n            catch (e) {\n                if (onReject) {\n                    return new PromisableWrapper(onReject(e));\n                }\n                throw e;\n            }\n        }\n    }\n    toPromise() {\n        return Promise.resolve(this.value);\n    }\n}\nexport function delay(ms) {\n    if (Number.isNaN(ms) || ms < 0) {\n        throw new Error(`Invalid delay: ${ms}`);\n    }\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n/**\n * Pass to Promise.then to perform an action while forwarding on the result\n * @param action\n */\nexport function tap(action) {\n    return function (value) {\n        action(value);\n        return value;\n    };\n}\n/**\n * Helper utility intended to be used with typed exceptions and .catch() method of promise like so:\n *\n * ```js\n *  class SpecificError extends Error {}\n *\n *  Promise.reject(new SpecificError())\n *      .catch(ofClass(SpecificError, (e) => console.log(\"some error\", e)))\n *      .catch((e) => console.log(\"generic error\", e))\n * ```\n *\n * @param cls Class which will be caught\n * @param catcher to handle only errors of type cls\n * @returns handler which either forwards to catcher or rethrows\n */\nexport function ofClass(cls, catcher) {\n    return async (e) => {\n        if (e instanceof cls) {\n            return catcher(e);\n        }\n        else {\n            // It's okay to rethrow because:\n            // 1. It preserves the original stacktrace\n            // 2. Because of 1. it is not that expensive\n            throw e;\n        }\n    };\n}\n/**\n * Filter iterable. Just like Array.prototype.filter but callback can return promises\n */\nexport async function promiseFilter(iterable, filter) {\n    let index = 0;\n    const result = [];\n    for (let item of iterable) {\n        if (await filter(item, index)) {\n            result.push(item);\n        }\n        index++;\n    }\n    return result;\n}\n/** Call the handler for both resolution and rejection. Unlike finally() will not propagate the error. */\nexport function settledThen(promise, handler) {\n    return promise.then(handler, handler);\n}\n","import { findAndRemove, insertIntoSortedArray } from \"./ArrayUtils.js\";\n/**\n * Compared based on the type's natural ordering\n */\nfunction numberCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n/**\n * An array that keeps itself sorted\n */\nexport class SortedArray {\n    contents;\n    compareFn;\n    constructor(contents, compareFn) {\n        this.contents = contents;\n        this.compareFn = compareFn;\n    }\n    static fromNumbers(array) {\n        return SortedArray.from(array, numberCompare);\n    }\n    static empty(compareFn) {\n        return new SortedArray([], compareFn);\n    }\n    static from(array, compareFn) {\n        const list = new SortedArray([], compareFn);\n        list.insertAll(array);\n        return list;\n    }\n    get length() {\n        return this.contents.length;\n    }\n    get array() {\n        return this.contents;\n    }\n    get(index) {\n        return this.contents[index];\n    }\n    insertAll(array) {\n        this.contents.push(...array);\n        this.contents.sort(this.compareFn);\n    }\n    insert(item) {\n        insertIntoSortedArray(item, this.contents, this.compareFn);\n    }\n    removeFirst(finder) {\n        return findAndRemove(this.contents, finder);\n    }\n}\n","/**\n * Returns a string which contains the given number padded with 0s.\n * @param num The number to pad.\n * @param size The number of resulting digits.\n * @return The padded number as string.\n */\nexport function pad(num, size) {\n    let s = num + \"\";\n    while (s.length < size)\n        s = \"0\" + s;\n    return s;\n}\n/**\n * Checks if a string starts with another string.\n * @param string The string to test.\n * @param substring If the other string begins with this one, we return true.\n * @return True if string begins with substring, false otherwise.\n */\nexport function startsWith(string, substring) {\n    return string.startsWith(substring);\n}\n/**\n * uppercase the first letter of a string, lowercase the rest\n * @param str string to transform\n * @returns {string} str in lowercase with first letter Capitalized\n */\nexport function capitalizeFirstLetter(str) {\n    return str[0].toUpperCase() + str.toLowerCase().slice(1);\n}\n/**\n * Checks if a string ends with another string.\n * @param string The string to test.\n * @param substring If the other string ends with this one, we return true.\n * @return True if string ends with substring, false otherwise.\n */\nexport function endsWith(string, substring) {\n    return string.endsWith(substring);\n}\nexport function lazyStringValue(valueOrLazy) {\n    return typeof valueOrLazy === \"function\" ? valueOrLazy() : valueOrLazy;\n}\nexport function repeat(value, length) {\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n        result += value;\n    }\n    return result;\n}\nexport function cleanMatch(s1, s2) {\n    return s1.toLowerCase().trim() === s2.toLowerCase().trim();\n}\n/**\n * Non-breaking space character\n */\nexport const NBSP = \"\\u00A0\";\n/**\n * split a string at a given index\n * @param str\n * @param index\n */\nexport function splitAt(str, index) {\n    return [str.substring(0, index), str.substring(index)];\n}\n/**\n * Wrapper around String.prototype.toLowerCase, nice for calls to Array.prototype.map\n * @param str\n */\nexport function toLowerCase(str) {\n    return str.toLowerCase();\n}\n/**\n * Wrapper around String.prototype.localeCompare, for passing to Array.prototype.sort\n * @param a\n * @param b\n * @returns {number}\n */\nexport function localeCompare(a, b) {\n    return a.localeCompare(b);\n}\nexport function byteLength(str) {\n    if (str == null)\n        return 0;\n    // returns the byte length of an utf8 string\n    let s = str.length;\n    for (let i = str.length - 1; i >= 0; i--) {\n        const code = str.charCodeAt(i);\n        if (code > 0x7f && code <= 0x7ff) {\n            s++;\n        }\n        else if (code > 0x7ff && code <= 0xffff)\n            s += 2;\n        if (code >= 0xdc00 && code <= 0xdfff)\n            i--; //trail surrogate\n    }\n    return s;\n}\n","import { stringToUtf8Uint8Array } from \"./Encoding.js\";\n/**\n * Call the WebAssembly function with the given arguments.\n *\n * Automatically allocates strings and buffers and frees them while passing booleans and numbers as-is.\n *\n * @param func function to call\n * @param exports WASM module instance's exports\n * @param args arguments to pass\n *\n * @return return value of the function\n */\nexport function callWebAssemblyFunctionWithArguments(func, exports, ...args) {\n    const argsToPass = [];\n    const toFree = [];\n    const toClear = [];\n    const toOverwrite = [];\n    try {\n        for (const arg of args) {\n            if (arg === null) {\n                // `NULL` in C is equal to 0\n                argsToPass.push(0);\n            }\n            else if (typeof arg === \"number\") {\n                // These can be passed as-is\n                argsToPass.push(arg);\n            }\n            else if (typeof arg === \"boolean\") {\n                // Convert to number\n                argsToPass.push(arg ? 1 : 0);\n            }\n            else if (typeof arg === \"string\") {\n                // Strings require null termination and copying, so we do this here\n                const s = allocateStringCopy(arg, exports, toFree);\n                try {\n                    toClear.push(s);\n                    argsToPass.push(s.byteOffset);\n                    toFree.push(s.byteOffset);\n                }\n                catch (e) {\n                    exports.free(s.byteOffset);\n                    throw e;\n                }\n            }\n            else if (arg instanceof MutableUint8Array) {\n                // Unwrap to get our original buffer back\n                const inputOutput = arg.uint8ArrayInputOutput;\n                let arrayInWASM;\n                if (inputOutput instanceof SecureFreeUint8Array) {\n                    arrayInWASM = allocateSecureArrayCopy(inputOutput.uint8ArrayInput, exports, toFree, toClear);\n                }\n                else {\n                    arrayInWASM = allocateArrayCopy(inputOutput, exports, toFree);\n                }\n                toOverwrite.push({ arrayInWASM: arrayInWASM, originalBufferYouPassedIn: arg });\n                argsToPass.push(arrayInWASM.byteOffset);\n            }\n            else if (arg instanceof SecureFreeUint8Array) {\n                const arrayInWASM = allocateSecureArrayCopy(arg.uint8ArrayInput, exports, toFree, toClear);\n                argsToPass.push(arrayInWASM.byteOffset);\n            }\n            else if (arg instanceof Uint8Array || arg instanceof Int8Array) {\n                const arrayInWASM = allocateArrayCopy(arg, exports, toFree);\n                argsToPass.push(arrayInWASM.byteOffset);\n            }\n            else {\n                throw new Error(`passed an unhandled argument type ${typeof arg}`);\n            }\n        }\n        return func(...argsToPass);\n    }\n    finally {\n        // First copy back in the contents from the WASM memory to JavaScript\n        for (const f of toOverwrite) {\n            const inputOutput = f.originalBufferYouPassedIn.uint8ArrayInputOutput;\n            if (inputOutput instanceof SecureFreeUint8Array) {\n                inputOutput.uint8ArrayInput.set(f.arrayInWASM);\n            }\n            else {\n                inputOutput.set(f.arrayInWASM);\n            }\n        }\n        // Handle secure free buffers\n        for (const f of toClear) {\n            f.fill(0);\n        }\n        // Finally free\n        for (const f of toFree) {\n            exports.free(f);\n        }\n    }\n}\n/**\n * Allocate memory on the heap of the WebAssembly instance.\n *\n * Be sure to call `free` on the byteOffset when you are done!\n *\n * @param length length of data to allocate\n * @param exports WASM module instance's exports\n */\nexport function allocateBuffer(length, exports) {\n    const memory = exports.memory;\n    const ptr = exports.malloc(length);\n    if (ptr === 0) {\n        throw new Error(\"malloc failed to allocate memory for string\");\n    }\n    try {\n        return new Uint8Array(memory.buffer, ptr, length);\n    }\n    catch (e) {\n        exports.free(ptr);\n        throw e;\n    }\n}\n/**\n * Wrapper to be passed to a WebAssembly function.\n *\n * The contents of the array will be updated when the function finishes.\n */\nexport class MutableUint8Array {\n    uint8ArrayInputOutput;\n    constructor(uint8ArrayInputOutput) {\n        this.uint8ArrayInputOutput = uint8ArrayInputOutput;\n    }\n}\n/**\n * Wrapper to be passed to a WebAssembly function.\n *\n * The copy allocated on the VM will be filled with zero bytes. This is slower, but it will ensure that its contents won't linger after being freed.\n *\n * Note that the buffer pointed to by uint8ArrayInput is *not* zeroed out automatically, as it is not a deep copy, so remember to zero out the original buffer\n * when you are done with it, too!\n */\nexport class SecureFreeUint8Array {\n    uint8ArrayInput;\n    constructor(uint8ArrayInput) {\n        this.uint8ArrayInput = uint8ArrayInput;\n    }\n}\n/**\n * Convenience function for wrapping an array as a MutableUint8Array.\n *\n * Data from the WASM module will be copied back to the array once finished.\n * @param array array to wrap\n * @return wrapper\n */\nexport function mutable(array) {\n    return new MutableUint8Array(array);\n}\n/**\n * Convenience function for wrapping an array as a MutableUint8Array and SecureFreeUint8Array.\n *\n * Data from the WASM module will be copied back to the array once finished, and then it will be erased from the module.\n * @param array array to wrap\n * @return wrapper\n */\nexport function mutableSecureFree(array) {\n    return new MutableUint8Array(new SecureFreeUint8Array(array));\n}\n/**\n * Convenience function for wrapping an array as a MutableUint8Array and SecureFreeUint8Array.\n *\n * Data from the WASM module will be erased once finished.\n * @param array array to wrap\n * @return wrapper\n */\nexport function secureFree(array) {\n    return new SecureFreeUint8Array(array);\n}\nfunction allocateStringCopy(str, exports, toFree) {\n    const strBytes = stringToUtf8Uint8Array(str);\n    const allocationAmount = strBytes.length + 1;\n    let buf = allocateBuffer(allocationAmount, exports);\n    try {\n        buf.set(strBytes);\n        buf[buf.length - 1] = 0; // null terminate after string data\n        toFree.push(buf.byteOffset);\n        return buf;\n    }\n    catch (e) {\n        exports.free(buf.byteOffset);\n        throw e;\n    }\n}\nfunction allocateArrayCopy(arr, exports, toFree) {\n    const allocationAmount = arr.length;\n    let buf = allocateBuffer(allocationAmount, exports);\n    try {\n        buf.set(arr);\n        toFree.push(buf.byteOffset);\n        return buf;\n    }\n    catch (e) {\n        exports.free(buf.byteOffset);\n        throw e;\n    }\n}\nfunction allocateSecureArrayCopy(arr, exports, toFree, toClear) {\n    const arrayInWASM = allocateArrayCopy(arr, exports, toFree);\n    try {\n        toClear.push(arrayInWASM);\n    }\n    catch (e) {\n        // on the off chance that push fails, we don't want the buffer to linger in memory\n        arrayInWASM.fill(0);\n        throw e;\n    }\n    return arrayInWASM;\n}\n","export function mod(n, m) {\n    return ((n % m) + m) % m;\n}\n/**\n * Clamp value to between min and max (inclusive)\n */\nexport function clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n}\n","/**\n * return a list of words contained in a text, lowercased.\n * @param text\n */\nexport function tokenize(text) {\n    if (text == null)\n        return [];\n    let currentWord = [];\n    let words = [];\n    for (let i = 0; i < text.length; i++) {\n        let currentChar = text.charAt(i);\n        if (isEndOfWord(currentChar)) {\n            addCurrentWord(currentWord, words);\n            currentWord = [];\n        }\n        else {\n            currentWord.push(currentChar);\n        }\n    }\n    addCurrentWord(currentWord, words);\n    return words;\n}\nfunction addCurrentWord(currentWord, words) {\n    while (currentWord.length > 0 && currentWord[0] === \"'\") {\n        currentWord.shift();\n    }\n    while (currentWord.length > 0 && currentWord[currentWord.length - 1] === \"'\") {\n        currentWord.pop();\n    }\n    if (currentWord.length > 0) {\n        words.push(currentWord.join(\"\").toLowerCase());\n    }\n}\nfunction isEndOfWord(char) {\n    switch (char) {\n        case \" \":\n        case \"\\n\":\n        case \"\\r\":\n        case \"\\t\":\n        case \"\\x0B\":\n        case \"\\f\":\n        case \".\":\n        case \",\":\n        case \":\":\n        case \";\":\n        case \"!\":\n        case \"?\":\n        case \"&\":\n        case '\"':\n        case \"<\":\n        case \">\":\n        case \"-\":\n        case \"+\":\n        case \"=\":\n        case \"(\":\n        case \")\":\n        case \"[\":\n        case \"]\":\n        case \"{\":\n        case \"}\":\n        case \"/\":\n        case \"\\\\\":\n        case \"^\":\n        case \"_\":\n        case \"`\":\n        case \"~\":\n        case \"|\":\n        case \"@\":\n            return true;\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"}