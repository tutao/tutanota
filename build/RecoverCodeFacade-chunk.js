import "./dist-chunk.js";
import "./ProgrammingError-chunk.js";
import { assertWorkerOrNode } from "./Env-chunk.js";
import { assertNotNull, uint8ArrayToHex } from "./dist2-chunk.js";
import { asKdfType } from "./TutanotaConstants-chunk.js";
import "./EntityUtils-chunk.js";
import "./TypeModels2-chunk.js";
import { RecoverCodeTypeRef, createRecoverCode } from "./TypeRefs2-chunk.js";
import "./CryptoError-chunk.js";
import { aes256RandomKey, bitArrayToUint8Array, createAuthVerifier, createAuthVerifierAsBase64Url, decryptKey, encryptKey } from "./dist3-chunk.js";

//#region src/common/api/worker/facades/lazy/RecoverCodeFacade.ts
assertWorkerOrNode();
var RecoverCodeFacade = class {
	constructor(userFacade, entityClient, loginFacade, keyLoaderFacade) {
		this.userFacade = userFacade;
		this.entityClient = entityClient;
		this.loginFacade = loginFacade;
		this.keyLoaderFacade = keyLoaderFacade;
	}
	generateRecoveryCode(currentUserGroupKey) {
		const recoveryCode = aes256RandomKey();
		return this.encryptRecoveryCode(recoveryCode, currentUserGroupKey);
	}
	encryptRecoveryCode(recoveryCode, currentUserGroupKey) {
		const userEncRecoverCode = encryptKey(currentUserGroupKey.object, recoveryCode);
		const recoverCodeEncUserGroupKey = encryptKey(recoveryCode, currentUserGroupKey.object);
		const recoveryCodeVerifier = createAuthVerifier(recoveryCode);
		return {
			userEncRecoverCode,
			userKeyVersion: currentUserGroupKey.version,
			recoverCodeEncUserGroupKey,
			hexCode: uint8ArrayToHex(bitArrayToUint8Array(recoveryCode)),
			recoveryCodeVerifier
		};
	}
	async getRecoverCodeHex(passphrase) {
		const user = this.userFacade.getLoggedInUser();
		const passphraseKey = await this.getPassphraseKey(user, passphrase);
		const rawRecoverCode = await this.getRawRecoverCode(passphraseKey);
		return uint8ArrayToHex(bitArrayToUint8Array(rawRecoverCode));
	}
	async getRawRecoverCode(passphraseKey) {
		const user = this.userFacade.getLoggedInUser();
		const recoverCodeId = user.auth?.recoverCode;
		if (recoverCodeId == null) throw new Error("Auth is missing");
		const extraHeaders = { authVerifier: createAuthVerifierAsBase64Url(passphraseKey) };
		const recoveryCodeEntity = await this.entityClient.load(RecoverCodeTypeRef, recoverCodeId, { extraHeaders });
		const userGroupKey = await this.keyLoaderFacade.loadSymUserGroupKey(Number(recoveryCodeEntity.userKeyVersion));
		return decryptKey(userGroupKey, recoveryCodeEntity.userEncRecoverCode);
	}
	async getPassphraseKey(user, passphrase) {
		const passphraseKeyData = {
			kdfType: asKdfType(user.kdfVersion),
			passphrase,
			salt: assertNotNull(user.salt)
		};
		return await this.loginFacade.deriveUserPassphraseKey(passphraseKeyData);
	}
	async createRecoveryCode(passphrase) {
		const user = this.userFacade.getUser();
		if (user == null || user.auth == null) throw new Error("Invalid state: no user or no user.auth");
		const { userEncRecoverCode, userKeyVersion, recoverCodeEncUserGroupKey, hexCode, recoveryCodeVerifier } = this.generateRecoveryCode(this.userFacade.getCurrentUserGroupKey());
		const recoverPasswordEntity = createRecoverCode({
			userEncRecoverCode,
			userKeyVersion: String(userKeyVersion),
			recoverCodeEncUserGroupKey,
			_ownerGroup: this.userFacade.getUserGroupId(),
			verifier: recoveryCodeVerifier
		});
		const passphraseKeyData = {
			kdfType: asKdfType(user.kdfVersion),
			passphrase,
			salt: assertNotNull(user.salt)
		};
		const pwKey = await this.loginFacade.deriveUserPassphraseKey(passphraseKeyData);
		const authVerifier = createAuthVerifierAsBase64Url(pwKey);
		await this.entityClient.setup(null, recoverPasswordEntity, { authVerifier });
		return hexCode;
	}
};

//#endregion
export { RecoverCodeFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVjb3ZlckNvZGVGYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyRmFjYWRlOiBVc2VyRmFjYWRlIiwiZW50aXR5Q2xpZW50OiBFbnRpdHlDbGllbnQiLCJsb2dpbkZhY2FkZTogTG9naW5GYWNhZGUiLCJrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSIsImN1cnJlbnRVc2VyR3JvdXBLZXk6IFZlcnNpb25lZEtleSIsInJlY292ZXJ5Q29kZTogQWVzMjU2S2V5IiwicGFzc3BocmFzZTogc3RyaW5nIiwicGFzc3BocmFzZUtleTogQWVzS2V5IiwidXNlcjogVXNlciJdLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21tb24vYXBpL3dvcmtlci9mYWNhZGVzL2xhenkvUmVjb3ZlckNvZGVGYWNhZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNLZGZUeXBlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9UdXRhbm90YUNvbnN0YW50cy5qc1wiXG5pbXBvcnQgeyBjcmVhdGVSZWNvdmVyQ29kZSwgUmVjb3ZlckNvZGVUeXBlUmVmLCBVc2VyIH0gZnJvbSBcIi4uLy4uLy4uL2VudGl0aWVzL3N5cy9UeXBlUmVmcy5qc1wiXG5pbXBvcnQgeyBhc3NlcnROb3ROdWxsLCB0eXBlIEhleCwgdWludDhBcnJheVRvSGV4IH0gZnJvbSBcIkB0dXRhby90dXRhbm90YS11dGlsc1wiXG5pbXBvcnQgeyBMb2dpbkZhY2FkZSB9IGZyb20gXCIuLi9Mb2dpbkZhY2FkZS5qc1wiXG5pbXBvcnQgeyBhc3NlcnRXb3JrZXJPck5vZGUgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL0Vudi5qc1wiXG5pbXBvcnQge1xuXHRBZXMyNTZLZXksXG5cdGFlczI1NlJhbmRvbUtleSxcblx0QWVzS2V5LFxuXHRiaXRBcnJheVRvVWludDhBcnJheSxcblx0Y3JlYXRlQXV0aFZlcmlmaWVyLFxuXHRjcmVhdGVBdXRoVmVyaWZpZXJBc0Jhc2U2NFVybCxcblx0ZGVjcnlwdEtleSxcblx0ZW5jcnlwdEtleSxcbn0gZnJvbSBcIkB0dXRhby90dXRhbm90YS1jcnlwdG9cIlxuaW1wb3J0IHsgRW50aXR5Q2xpZW50IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9FbnRpdHlDbGllbnQuanNcIlxuaW1wb3J0IHsgVXNlckZhY2FkZSB9IGZyb20gXCIuLi9Vc2VyRmFjYWRlLmpzXCJcbmltcG9ydCB7IEtleUxvYWRlckZhY2FkZSB9IGZyb20gXCIuLi9LZXlMb2FkZXJGYWNhZGUuanNcIlxuaW1wb3J0IHsgVmVyc2lvbmVkS2V5IH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9XcmFwcGVyLmpzXCJcblxuYXNzZXJ0V29ya2VyT3JOb2RlKClcblxuZXhwb3J0IHR5cGUgUmVjb3ZlckRhdGEgPSB7XG5cdHVzZXJFbmNSZWNvdmVyQ29kZTogVWludDhBcnJheVxuXHR1c2VyS2V5VmVyc2lvbjogbnVtYmVyXG5cdHJlY292ZXJDb2RlRW5jVXNlckdyb3VwS2V5OiBVaW50OEFycmF5XG5cdGhleENvZGU6IEhleFxuXHRyZWNvdmVyeUNvZGVWZXJpZmllcjogVWludDhBcnJheVxufVxuXG4vKipcbiAqIEZhY2FkZSB0byBjcmVhdGUsIGVuY3J5cHQgYW5kIHNob3cgdGhlIHJlY292ZXJ5IGNvZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvdmVyQ29kZUZhY2FkZSB7XG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgdXNlckZhY2FkZTogVXNlckZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IGVudGl0eUNsaWVudDogRW50aXR5Q2xpZW50LFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgbG9naW5GYWNhZGU6IExvZ2luRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkga2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUsXG5cdCkge31cblxuXHRnZW5lcmF0ZVJlY292ZXJ5Q29kZShjdXJyZW50VXNlckdyb3VwS2V5OiBWZXJzaW9uZWRLZXkpOiBSZWNvdmVyRGF0YSB7XG5cdFx0Y29uc3QgcmVjb3ZlcnlDb2RlID0gYWVzMjU2UmFuZG9tS2V5KClcblx0XHRyZXR1cm4gdGhpcy5lbmNyeXB0UmVjb3ZlcnlDb2RlKHJlY292ZXJ5Q29kZSwgY3VycmVudFVzZXJHcm91cEtleSlcblx0fVxuXG5cdGVuY3J5cHRSZWNvdmVyeUNvZGUocmVjb3ZlcnlDb2RlOiBBZXMyNTZLZXksIGN1cnJlbnRVc2VyR3JvdXBLZXk6IFZlcnNpb25lZEtleSk6IFJlY292ZXJEYXRhIHtcblx0XHRjb25zdCB1c2VyRW5jUmVjb3ZlckNvZGUgPSBlbmNyeXB0S2V5KGN1cnJlbnRVc2VyR3JvdXBLZXkub2JqZWN0LCByZWNvdmVyeUNvZGUpXG5cdFx0Y29uc3QgcmVjb3ZlckNvZGVFbmNVc2VyR3JvdXBLZXkgPSBlbmNyeXB0S2V5KHJlY292ZXJ5Q29kZSwgY3VycmVudFVzZXJHcm91cEtleS5vYmplY3QpXG5cdFx0Y29uc3QgcmVjb3ZlcnlDb2RlVmVyaWZpZXIgPSBjcmVhdGVBdXRoVmVyaWZpZXIocmVjb3ZlcnlDb2RlKVxuXHRcdHJldHVybiB7XG5cdFx0XHR1c2VyRW5jUmVjb3ZlckNvZGUsXG5cdFx0XHR1c2VyS2V5VmVyc2lvbjogY3VycmVudFVzZXJHcm91cEtleS52ZXJzaW9uLFxuXHRcdFx0cmVjb3ZlckNvZGVFbmNVc2VyR3JvdXBLZXksXG5cdFx0XHRoZXhDb2RlOiB1aW50OEFycmF5VG9IZXgoYml0QXJyYXlUb1VpbnQ4QXJyYXkocmVjb3ZlcnlDb2RlKSksXG5cdFx0XHRyZWNvdmVyeUNvZGVWZXJpZmllcixcblx0XHR9XG5cdH1cblxuXHRhc3luYyBnZXRSZWNvdmVyQ29kZUhleChwYXNzcGhyYXNlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IHVzZXIgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0TG9nZ2VkSW5Vc2VyKClcblx0XHRjb25zdCBwYXNzcGhyYXNlS2V5ID0gYXdhaXQgdGhpcy5nZXRQYXNzcGhyYXNlS2V5KHVzZXIsIHBhc3NwaHJhc2UpXG5cdFx0Y29uc3QgcmF3UmVjb3ZlckNvZGUgPSBhd2FpdCB0aGlzLmdldFJhd1JlY292ZXJDb2RlKHBhc3NwaHJhc2VLZXkpXG5cdFx0cmV0dXJuIHVpbnQ4QXJyYXlUb0hleChiaXRBcnJheVRvVWludDhBcnJheShyYXdSZWNvdmVyQ29kZSkpXG5cdH1cblxuXHRhc3luYyBnZXRSYXdSZWNvdmVyQ29kZShwYXNzcGhyYXNlS2V5OiBBZXNLZXkpOiBQcm9taXNlPEFlc0tleT4ge1xuXHRcdGNvbnN0IHVzZXIgPSB0aGlzLnVzZXJGYWNhZGUuZ2V0TG9nZ2VkSW5Vc2VyKClcblx0XHRjb25zdCByZWNvdmVyQ29kZUlkID0gdXNlci5hdXRoPy5yZWNvdmVyQ29kZVxuXHRcdGlmIChyZWNvdmVyQ29kZUlkID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkF1dGggaXMgbWlzc2luZ1wiKVxuXHRcdH1cblxuXHRcdGNvbnN0IGV4dHJhSGVhZGVycyA9IHtcblx0XHRcdGF1dGhWZXJpZmllcjogY3JlYXRlQXV0aFZlcmlmaWVyQXNCYXNlNjRVcmwocGFzc3BocmFzZUtleSksXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVjb3ZlcnlDb2RlRW50aXR5ID0gYXdhaXQgdGhpcy5lbnRpdHlDbGllbnQubG9hZChSZWNvdmVyQ29kZVR5cGVSZWYsIHJlY292ZXJDb2RlSWQsIHsgZXh0cmFIZWFkZXJzIH0pXG5cdFx0Y29uc3QgdXNlckdyb3VwS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUubG9hZFN5bVVzZXJHcm91cEtleShOdW1iZXIocmVjb3ZlcnlDb2RlRW50aXR5LnVzZXJLZXlWZXJzaW9uKSlcblx0XHRyZXR1cm4gZGVjcnlwdEtleSh1c2VyR3JvdXBLZXksIHJlY292ZXJ5Q29kZUVudGl0eS51c2VyRW5jUmVjb3ZlckNvZGUpXG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGdldFBhc3NwaHJhc2VLZXkodXNlcjogVXNlciwgcGFzc3BocmFzZTogc3RyaW5nKSB7XG5cdFx0Y29uc3QgcGFzc3BocmFzZUtleURhdGEgPSB7XG5cdFx0XHRrZGZUeXBlOiBhc0tkZlR5cGUodXNlci5rZGZWZXJzaW9uKSxcblx0XHRcdHBhc3NwaHJhc2UsXG5cdFx0XHRzYWx0OiBhc3NlcnROb3ROdWxsKHVzZXIuc2FsdCksXG5cdFx0fVxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmxvZ2luRmFjYWRlLmRlcml2ZVVzZXJQYXNzcGhyYXNlS2V5KHBhc3NwaHJhc2VLZXlEYXRhKVxuXHR9XG5cblx0YXN5bmMgY3JlYXRlUmVjb3ZlcnlDb2RlKHBhc3NwaHJhc2U6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgdXNlciA9IHRoaXMudXNlckZhY2FkZS5nZXRVc2VyKClcblxuXHRcdGlmICh1c2VyID09IG51bGwgfHwgdXNlci5hdXRoID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGU6IG5vIHVzZXIgb3Igbm8gdXNlci5hdXRoXCIpXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyB1c2VyRW5jUmVjb3ZlckNvZGUsIHVzZXJLZXlWZXJzaW9uLCByZWNvdmVyQ29kZUVuY1VzZXJHcm91cEtleSwgaGV4Q29kZSwgcmVjb3ZlcnlDb2RlVmVyaWZpZXIgfSA9IHRoaXMuZ2VuZXJhdGVSZWNvdmVyeUNvZGUoXG5cdFx0XHR0aGlzLnVzZXJGYWNhZGUuZ2V0Q3VycmVudFVzZXJHcm91cEtleSgpLFxuXHRcdClcblx0XHRjb25zdCByZWNvdmVyUGFzc3dvcmRFbnRpdHkgPSBjcmVhdGVSZWNvdmVyQ29kZSh7XG5cdFx0XHR1c2VyRW5jUmVjb3ZlckNvZGU6IHVzZXJFbmNSZWNvdmVyQ29kZSxcblx0XHRcdHVzZXJLZXlWZXJzaW9uOiBTdHJpbmcodXNlcktleVZlcnNpb24pLFxuXHRcdFx0cmVjb3ZlckNvZGVFbmNVc2VyR3JvdXBLZXk6IHJlY292ZXJDb2RlRW5jVXNlckdyb3VwS2V5LFxuXHRcdFx0X293bmVyR3JvdXA6IHRoaXMudXNlckZhY2FkZS5nZXRVc2VyR3JvdXBJZCgpLFxuXHRcdFx0dmVyaWZpZXI6IHJlY292ZXJ5Q29kZVZlcmlmaWVyLFxuXHRcdH0pXG5cdFx0Y29uc3QgcGFzc3BocmFzZUtleURhdGEgPSB7XG5cdFx0XHRrZGZUeXBlOiBhc0tkZlR5cGUodXNlci5rZGZWZXJzaW9uKSxcblx0XHRcdHBhc3NwaHJhc2UsXG5cdFx0XHRzYWx0OiBhc3NlcnROb3ROdWxsKHVzZXIuc2FsdCksXG5cdFx0fVxuXHRcdGNvbnN0IHB3S2V5ID0gYXdhaXQgdGhpcy5sb2dpbkZhY2FkZS5kZXJpdmVVc2VyUGFzc3BocmFzZUtleShwYXNzcGhyYXNlS2V5RGF0YSlcblx0XHRjb25zdCBhdXRoVmVyaWZpZXIgPSBjcmVhdGVBdXRoVmVyaWZpZXJBc0Jhc2U2NFVybChwd0tleSlcblx0XHRhd2FpdCB0aGlzLmVudGl0eUNsaWVudC5zZXR1cChudWxsLCByZWNvdmVyUGFzc3dvcmRFbnRpdHksIHtcblx0XHRcdGF1dGhWZXJpZmllcixcblx0XHR9KVxuXHRcdHJldHVybiBoZXhDb2RlXG5cdH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBb0JBLG9CQUFvQjtJQWFQLG9CQUFOLE1BQXdCO0NBQzlCLFlBQ2tCQSxZQUNBQyxjQUNBQyxhQUNBQyxpQkFDaEI7RUFrRkYsS0F0RmtCO0VBc0ZqQixLQXJGaUI7RUFxRmhCLEtBcEZnQjtFQW9GZixLQW5GZTtDQUNkO0NBRUoscUJBQXFCQyxxQkFBZ0Q7RUFDcEUsTUFBTSxlQUFlLGlCQUFpQjtBQUN0QyxTQUFPLEtBQUssb0JBQW9CLGNBQWMsb0JBQW9CO0NBQ2xFO0NBRUQsb0JBQW9CQyxjQUF5QkQscUJBQWdEO0VBQzVGLE1BQU0scUJBQXFCLFdBQVcsb0JBQW9CLFFBQVEsYUFBYTtFQUMvRSxNQUFNLDZCQUE2QixXQUFXLGNBQWMsb0JBQW9CLE9BQU87RUFDdkYsTUFBTSx1QkFBdUIsbUJBQW1CLGFBQWE7QUFDN0QsU0FBTztHQUNOO0dBQ0EsZ0JBQWdCLG9CQUFvQjtHQUNwQztHQUNBLFNBQVMsZ0JBQWdCLHFCQUFxQixhQUFhLENBQUM7R0FDNUQ7RUFDQTtDQUNEO0NBRUQsTUFBTSxrQkFBa0JFLFlBQXFDO0VBQzVELE1BQU0sT0FBTyxLQUFLLFdBQVcsaUJBQWlCO0VBQzlDLE1BQU0sZ0JBQWdCLE1BQU0sS0FBSyxpQkFBaUIsTUFBTSxXQUFXO0VBQ25FLE1BQU0saUJBQWlCLE1BQU0sS0FBSyxrQkFBa0IsY0FBYztBQUNsRSxTQUFPLGdCQUFnQixxQkFBcUIsZUFBZSxDQUFDO0NBQzVEO0NBRUQsTUFBTSxrQkFBa0JDLGVBQXdDO0VBQy9ELE1BQU0sT0FBTyxLQUFLLFdBQVcsaUJBQWlCO0VBQzlDLE1BQU0sZ0JBQWdCLEtBQUssTUFBTTtBQUNqQyxNQUFJLGlCQUFpQixLQUNwQixPQUFNLElBQUksTUFBTTtFQUdqQixNQUFNLGVBQWUsRUFDcEIsY0FBYyw4QkFBOEIsY0FBYyxDQUMxRDtFQUVELE1BQU0scUJBQXFCLE1BQU0sS0FBSyxhQUFhLEtBQUssb0JBQW9CLGVBQWUsRUFBRSxhQUFjLEVBQUM7RUFDNUcsTUFBTSxlQUFlLE1BQU0sS0FBSyxnQkFBZ0Isb0JBQW9CLE9BQU8sbUJBQW1CLGVBQWUsQ0FBQztBQUM5RyxTQUFPLFdBQVcsY0FBYyxtQkFBbUIsbUJBQW1CO0NBQ3RFO0NBRUQsTUFBYyxpQkFBaUJDLE1BQVlGLFlBQW9CO0VBQzlELE1BQU0sb0JBQW9CO0dBQ3pCLFNBQVMsVUFBVSxLQUFLLFdBQVc7R0FDbkM7R0FDQSxNQUFNLGNBQWMsS0FBSyxLQUFLO0VBQzlCO0FBQ0QsU0FBTyxNQUFNLEtBQUssWUFBWSx3QkFBd0Isa0JBQWtCO0NBQ3hFO0NBRUQsTUFBTSxtQkFBbUJBLFlBQXFDO0VBQzdELE1BQU0sT0FBTyxLQUFLLFdBQVcsU0FBUztBQUV0QyxNQUFJLFFBQVEsUUFBUSxLQUFLLFFBQVEsS0FDaEMsT0FBTSxJQUFJLE1BQU07RUFHakIsTUFBTSxFQUFFLG9CQUFvQixnQkFBZ0IsNEJBQTRCLFNBQVMsc0JBQXNCLEdBQUcsS0FBSyxxQkFDOUcsS0FBSyxXQUFXLHdCQUF3QixDQUN4QztFQUNELE1BQU0sd0JBQXdCLGtCQUFrQjtHQUMzQjtHQUNwQixnQkFBZ0IsT0FBTyxlQUFlO0dBQ1Y7R0FDNUIsYUFBYSxLQUFLLFdBQVcsZ0JBQWdCO0dBQzdDLFVBQVU7RUFDVixFQUFDO0VBQ0YsTUFBTSxvQkFBb0I7R0FDekIsU0FBUyxVQUFVLEtBQUssV0FBVztHQUNuQztHQUNBLE1BQU0sY0FBYyxLQUFLLEtBQUs7RUFDOUI7RUFDRCxNQUFNLFFBQVEsTUFBTSxLQUFLLFlBQVksd0JBQXdCLGtCQUFrQjtFQUMvRSxNQUFNLGVBQWUsOEJBQThCLE1BQU07QUFDekQsUUFBTSxLQUFLLGFBQWEsTUFBTSxNQUFNLHVCQUF1QixFQUMxRCxhQUNBLEVBQUM7QUFDRixTQUFPO0NBQ1A7QUFDRCJ9