import "./dist-chunk.js";
import { ProgrammingError } from "./ProgrammingError-chunk.js";
import "./Env-chunk.js";
import { assertNotNull, base64ExtToBase64, base64ToBase64Ext, base64ToBase64Url, base64UrlToBase64, getFirstOrThrow, isEmpty, uint8ArrayToBase64 } from "./dist2-chunk.js";
import { GroupType } from "./TutanotaConstants-chunk.js";
import { GENERATED_MAX_ID, elementIdPart } from "./EntityUtils-chunk.js";
import "./TypeModels2-chunk.js";
import { createGiftCardCreateData, createGiftCardRedeemData } from "./TypeRefs2-chunk.js";
import "./CryptoError-chunk.js";
import { GiftCardRedeemService, GiftCardService } from "./Services-chunk.js";
import { aes256RandomKey, base64ToKey, bitArrayToUint8Array, sha256Hash } from "./dist3-chunk.js";
import { encryptKeyWithVersionedKey } from "./CryptoWrapper-chunk.js";

//#region src/common/api/worker/facades/lazy/GiftCardFacade.ts
const ID_LENGTH = GENERATED_MAX_ID.length;
const KEY_LENGTH_128_BIT_B64 = 24;
const KEY_LENGTH_256_BIT_B64 = 44;
var GiftCardFacade = class {
	constructor(user, customer, serviceExecutor, cryptoFacade, keyLoaderFacade) {
		this.user = user;
		this.customer = customer;
		this.serviceExecutor = serviceExecutor;
		this.cryptoFacade = cryptoFacade;
		this.keyLoaderFacade = keyLoaderFacade;
	}
	async generateGiftCard(message, value) {
		const adminGroupIds = this.user.getGroupIds(GroupType.Admin);
		if (isEmpty(adminGroupIds)) throw new Error("missing admin membership");
		const adminGroupId = getFirstOrThrow(adminGroupIds);
		const ownerKey = await this.keyLoaderFacade.getCurrentSymGroupKey(adminGroupId);
		const sessionKey = aes256RandomKey();
		const ownerEncSessionKey = encryptKeyWithVersionedKey(ownerKey, sessionKey);
		const { giftCard } = await this.serviceExecutor.post(GiftCardService, createGiftCardCreateData({
			message,
			keyHash: sha256Hash(bitArrayToUint8Array(sessionKey)),
			value,
			ownerEncSessionKey: ownerEncSessionKey.key,
			ownerKeyVersion: ownerEncSessionKey.encryptingKeyVersion.toString()
		}), { sessionKey });
		return giftCard;
	}
	getGiftCardInfo(id, key) {
		return this.serviceExecutor.get(GiftCardRedeemService, createGiftCardRedeemData({
			giftCardInfo: id,
			keyHash: sha256Hash(bitArrayToUint8Array(base64ToKey(key))),
			countryCode: ""
		}), { sessionKey: base64ToKey(key) });
	}
	async redeemGiftCard(giftCardInfoId, key, countryCode) {
		if ((await this.customer.loadAccountingInfo()).invoiceCountry == null && countryCode == null) throw new ProgrammingError("User must provide a country");
		await this.serviceExecutor.post(GiftCardRedeemService, createGiftCardRedeemData({
			giftCardInfo: giftCardInfoId,
			keyHash: sha256Hash(bitArrayToUint8Array(base64ToKey(key))),
			countryCode
		}));
	}
	async encodeGiftCardToken(giftCard) {
		const key = assertNotNull(await this.cryptoFacade.resolveSessionKeyForInstance(giftCard));
		return this.encodeToken(elementIdPart(giftCard._id), bitArrayToUint8Array(key));
	}
	async decodeGiftCardToken(token) {
		const id = base64ToBase64Ext(base64UrlToBase64(token.slice(0, ID_LENGTH)));
		const key = base64UrlToBase64(token.slice(ID_LENGTH, token.length));
		if (id.length !== ID_LENGTH || key.length !== KEY_LENGTH_128_BIT_B64 && key.length !== KEY_LENGTH_256_BIT_B64) throw new Error("invalid token");
		return {
			id,
			key
		};
	}
	encodeToken(id, key) {
		if (id.length !== ID_LENGTH) throw new Error("Invalid gift card params");
		const keyBase64 = uint8ArrayToBase64(key);
		if (keyBase64.length !== KEY_LENGTH_128_BIT_B64 && keyBase64.length !== KEY_LENGTH_256_BIT_B64) throw new Error("Invalid gift card key");
		const idPart = base64ToBase64Url(base64ExtToBase64(id));
		const keyPart = base64ToBase64Url(keyBase64);
		return idPart + keyPart;
	}
};

//#endregion
export { GiftCardFacade };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2lmdENhcmRGYWNhZGUtY2h1bmsuanMiLCJuYW1lcyI6WyJ1c2VyOiBVc2VyRmFjYWRlIiwiY3VzdG9tZXI6IEN1c3RvbWVyRmFjYWRlIiwic2VydmljZUV4ZWN1dG9yOiBJU2VydmljZUV4ZWN1dG9yIiwiY3J5cHRvRmFjYWRlOiBDcnlwdG9GYWNhZGUiLCJrZXlMb2FkZXJGYWNhZGU6IEtleUxvYWRlckZhY2FkZSIsIm1lc3NhZ2U6IHN0cmluZyIsInZhbHVlOiBOdW1iZXJTdHJpbmciLCJpZDogSWQiLCJrZXk6IHN0cmluZyIsImdpZnRDYXJkSW5mb0lkOiBJZCIsImNvdW50cnlDb2RlOiBzdHJpbmciLCJnaWZ0Q2FyZDogR2lmdENhcmQiLCJ0b2tlbjogc3RyaW5nIiwia2V5OiBVaW50OEFycmF5Il0sInNvdXJjZXMiOlsiLi4vc3JjL2NvbW1vbi9hcGkvd29ya2VyL2ZhY2FkZXMvbGF6eS9HaWZ0Q2FyZEZhY2FkZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHcm91cFR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL1R1dGFub3RhQ29uc3RhbnRzLmpzXCJcbmltcG9ydCB7XG5cdGFzc2VydE5vdE51bGwsXG5cdEJhc2U2NCxcblx0YmFzZTY0RXh0VG9CYXNlNjQsXG5cdGJhc2U2NFRvQmFzZTY0RXh0LFxuXHRiYXNlNjRUb0Jhc2U2NFVybCxcblx0YmFzZTY0VXJsVG9CYXNlNjQsXG5cdGdldEZpcnN0T3JUaHJvdyxcblx0aXNFbXB0eSxcblx0dWludDhBcnJheVRvQmFzZTY0LFxufSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLXV0aWxzXCJcbmltcG9ydCB0eXBlIHsgR2lmdENhcmRSZWRlZW1HZXRSZXR1cm4gfSBmcm9tIFwiLi4vLi4vLi4vZW50aXRpZXMvc3lzL1R5cGVSZWZzLmpzXCJcbmltcG9ydCB7IGNyZWF0ZUdpZnRDYXJkQ3JlYXRlRGF0YSwgY3JlYXRlR2lmdENhcmRSZWRlZW1EYXRhLCBHaWZ0Q2FyZCB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvVHlwZVJlZnMuanNcIlxuaW1wb3J0IHsgYWVzMjU2UmFuZG9tS2V5LCBiYXNlNjRUb0tleSwgYml0QXJyYXlUb1VpbnQ4QXJyYXksIHNoYTI1Nkhhc2ggfSBmcm9tIFwiQHR1dGFvL3R1dGFub3RhLWNyeXB0b1wiXG5pbXBvcnQgeyBJU2VydmljZUV4ZWN1dG9yIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9TZXJ2aWNlUmVxdWVzdC5qc1wiXG5pbXBvcnQgeyBHaWZ0Q2FyZFJlZGVlbVNlcnZpY2UsIEdpZnRDYXJkU2VydmljZSB9IGZyb20gXCIuLi8uLi8uLi9lbnRpdGllcy9zeXMvU2VydmljZXMuanNcIlxuaW1wb3J0IHsgZWxlbWVudElkUGFydCwgR0VORVJBVEVEX01BWF9JRCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbHMvRW50aXR5VXRpbHMuanNcIlxuaW1wb3J0IHsgQ3J5cHRvRmFjYWRlIH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9GYWNhZGUuanNcIlxuaW1wb3J0IHsgVXNlckZhY2FkZSB9IGZyb20gXCIuLi9Vc2VyRmFjYWRlLmpzXCJcbmltcG9ydCB7IFByb2dyYW1taW5nRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL2Vycm9yL1Byb2dyYW1taW5nRXJyb3IuanNcIlxuaW1wb3J0IHsgQ3VzdG9tZXJGYWNhZGUgfSBmcm9tIFwiLi9DdXN0b21lckZhY2FkZS5qc1wiXG5pbXBvcnQgeyBLZXlMb2FkZXJGYWNhZGUgfSBmcm9tIFwiLi4vS2V5TG9hZGVyRmFjYWRlLmpzXCJcbmltcG9ydCB7IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5IH0gZnJvbSBcIi4uLy4uL2NyeXB0by9DcnlwdG9XcmFwcGVyLmpzXCJcblxuY29uc3QgSURfTEVOR1RIID0gR0VORVJBVEVEX01BWF9JRC5sZW5ndGhcbmNvbnN0IEtFWV9MRU5HVEhfMTI4X0JJVF9CNjQgPSAyNFxuY29uc3QgS0VZX0xFTkdUSF8yNTZfQklUX0I2NCA9IDQ0XG5cbmV4cG9ydCBjbGFzcyBHaWZ0Q2FyZEZhY2FkZSB7XG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgcmVhZG9ubHkgdXNlcjogVXNlckZhY2FkZSxcblx0XHRwcml2YXRlIGN1c3RvbWVyOiBDdXN0b21lckZhY2FkZSxcblx0XHRwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VFeGVjdXRvcjogSVNlcnZpY2VFeGVjdXRvcixcblx0XHRwcml2YXRlIHJlYWRvbmx5IGNyeXB0b0ZhY2FkZTogQ3J5cHRvRmFjYWRlLFxuXHRcdHByaXZhdGUgcmVhZG9ubHkga2V5TG9hZGVyRmFjYWRlOiBLZXlMb2FkZXJGYWNhZGUsXG5cdCkge31cblxuXHRhc3luYyBnZW5lcmF0ZUdpZnRDYXJkKG1lc3NhZ2U6IHN0cmluZywgdmFsdWU6IE51bWJlclN0cmluZyk6IFByb21pc2U8SWRUdXBsZT4ge1xuXHRcdGNvbnN0IGFkbWluR3JvdXBJZHMgPSB0aGlzLnVzZXIuZ2V0R3JvdXBJZHMoR3JvdXBUeXBlLkFkbWluKVxuXG5cdFx0aWYgKGlzRW1wdHkoYWRtaW5Hcm91cElkcykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYWRtaW4gbWVtYmVyc2hpcFwiKVxuXHRcdH1cblxuXHRcdGNvbnN0IGFkbWluR3JvdXBJZCA9IGdldEZpcnN0T3JUaHJvdyhhZG1pbkdyb3VwSWRzKVxuXHRcdGNvbnN0IG93bmVyS2V5ID0gYXdhaXQgdGhpcy5rZXlMb2FkZXJGYWNhZGUuZ2V0Q3VycmVudFN5bUdyb3VwS2V5KGFkbWluR3JvdXBJZClcblxuXHRcdGNvbnN0IHNlc3Npb25LZXkgPSBhZXMyNTZSYW5kb21LZXkoKVxuXHRcdGNvbnN0IG93bmVyRW5jU2Vzc2lvbktleSA9IGVuY3J5cHRLZXlXaXRoVmVyc2lvbmVkS2V5KG93bmVyS2V5LCBzZXNzaW9uS2V5KVxuXHRcdGNvbnN0IHsgZ2lmdENhcmQgfSA9IGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoXG5cdFx0XHRHaWZ0Q2FyZFNlcnZpY2UsXG5cdFx0XHRjcmVhdGVHaWZ0Q2FyZENyZWF0ZURhdGEoe1xuXHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRrZXlIYXNoOiBzaGEyNTZIYXNoKGJpdEFycmF5VG9VaW50OEFycmF5KHNlc3Npb25LZXkpKSxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdG93bmVyRW5jU2Vzc2lvbktleTogb3duZXJFbmNTZXNzaW9uS2V5LmtleSxcblx0XHRcdFx0b3duZXJLZXlWZXJzaW9uOiBvd25lckVuY1Nlc3Npb25LZXkuZW5jcnlwdGluZ0tleVZlcnNpb24udG9TdHJpbmcoKSxcblx0XHRcdH0pLFxuXHRcdFx0eyBzZXNzaW9uS2V5IH0sXG5cdFx0KVxuXG5cdFx0cmV0dXJuIGdpZnRDYXJkXG5cdH1cblxuXHRnZXRHaWZ0Q2FyZEluZm8oaWQ6IElkLCBrZXk6IHN0cmluZyk6IFByb21pc2U8R2lmdENhcmRSZWRlZW1HZXRSZXR1cm4+IHtcblx0XHRyZXR1cm4gdGhpcy5zZXJ2aWNlRXhlY3V0b3IuZ2V0KFxuXHRcdFx0R2lmdENhcmRSZWRlZW1TZXJ2aWNlLFxuXHRcdFx0Y3JlYXRlR2lmdENhcmRSZWRlZW1EYXRhKHtcblx0XHRcdFx0Z2lmdENhcmRJbmZvOiBpZCxcblx0XHRcdFx0a2V5SGFzaDogc2hhMjU2SGFzaChiaXRBcnJheVRvVWludDhBcnJheShiYXNlNjRUb0tleShrZXkpKSksXG5cdFx0XHRcdGNvdW50cnlDb2RlOiBcIlwiLFxuXHRcdFx0fSksXG5cdFx0XHR7XG5cdFx0XHRcdHNlc3Npb25LZXk6IGJhc2U2NFRvS2V5KGtleSksXG5cdFx0XHR9LFxuXHRcdClcblx0fVxuXG5cdGFzeW5jIHJlZGVlbUdpZnRDYXJkKFxuXHRcdGdpZnRDYXJkSW5mb0lkOiBJZCxcblx0XHRrZXk6IHN0cmluZyxcblx0XHQvKiogQ291bnRyeSBjb2RlIHRvIHVzZSBpZiBhIGZyZWUgdXNlciBpcyBiZWluZyB1cGdyYWRlZCB0byBwcmVtaXVtIChyZXF1aXJlZCBpZiBhY2NvdW50VHlwZSBpcyBmcmVlKSAqL1xuXHRcdGNvdW50cnlDb2RlOiBzdHJpbmcsXG5cdCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICgoYXdhaXQgdGhpcy5jdXN0b21lci5sb2FkQWNjb3VudGluZ0luZm8oKSkuaW52b2ljZUNvdW50cnkgPT0gbnVsbCAmJiBjb3VudHJ5Q29kZSA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgUHJvZ3JhbW1pbmdFcnJvcihcIlVzZXIgbXVzdCBwcm92aWRlIGEgY291bnRyeVwiKVxuXHRcdH1cblxuXHRcdGF3YWl0IHRoaXMuc2VydmljZUV4ZWN1dG9yLnBvc3QoXG5cdFx0XHRHaWZ0Q2FyZFJlZGVlbVNlcnZpY2UsXG5cdFx0XHRjcmVhdGVHaWZ0Q2FyZFJlZGVlbURhdGEoe1xuXHRcdFx0XHRnaWZ0Q2FyZEluZm86IGdpZnRDYXJkSW5mb0lkLFxuXHRcdFx0XHRrZXlIYXNoOiBzaGEyNTZIYXNoKGJpdEFycmF5VG9VaW50OEFycmF5KGJhc2U2NFRvS2V5KGtleSkpKSxcblx0XHRcdFx0Y291bnRyeUNvZGUsXG5cdFx0XHR9KSxcblx0XHQpXG5cdH1cblxuXHRhc3luYyBlbmNvZGVHaWZ0Q2FyZFRva2VuKGdpZnRDYXJkOiBHaWZ0Q2FyZCk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3Qga2V5ID0gYXNzZXJ0Tm90TnVsbChhd2FpdCB0aGlzLmNyeXB0b0ZhY2FkZS5yZXNvbHZlU2Vzc2lvbktleUZvckluc3RhbmNlKGdpZnRDYXJkKSlcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGVUb2tlbihlbGVtZW50SWRQYXJ0KGdpZnRDYXJkLl9pZCksIGJpdEFycmF5VG9VaW50OEFycmF5KGtleSkpXG5cdH1cblxuXHRhc3luYyBkZWNvZGVHaWZ0Q2FyZFRva2VuKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgaWQ6IElkOyBrZXk6IEJhc2U2NCB9PiB7XG5cdFx0Y29uc3QgaWQgPSBiYXNlNjRUb0Jhc2U2NEV4dChiYXNlNjRVcmxUb0Jhc2U2NCh0b2tlbi5zbGljZSgwLCBJRF9MRU5HVEgpKSlcblx0XHRjb25zdCBrZXkgPSBiYXNlNjRVcmxUb0Jhc2U2NCh0b2tlbi5zbGljZShJRF9MRU5HVEgsIHRva2VuLmxlbmd0aCkpXG5cblx0XHRpZiAoaWQubGVuZ3RoICE9PSBJRF9MRU5HVEggfHwgKGtleS5sZW5ndGggIT09IEtFWV9MRU5HVEhfMTI4X0JJVF9CNjQgJiYga2V5Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSF8yNTZfQklUX0I2NCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdG9rZW5cIilcblx0XHR9XG5cblx0XHRyZXR1cm4geyBpZCwga2V5IH1cblx0fVxuXG5cdHByaXZhdGUgZW5jb2RlVG9rZW4oaWQ6IElkLCBrZXk6IFVpbnQ4QXJyYXkpOiBCYXNlNjQge1xuXHRcdGlmIChpZC5sZW5ndGggIT09IElEX0xFTkdUSCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBnaWZ0IGNhcmQgcGFyYW1zXCIpXG5cdFx0fVxuXHRcdGNvbnN0IGtleUJhc2U2NCA9IHVpbnQ4QXJyYXlUb0Jhc2U2NChrZXkpXG5cdFx0aWYgKGtleUJhc2U2NC5sZW5ndGggIT09IEtFWV9MRU5HVEhfMTI4X0JJVF9CNjQgJiYga2V5QmFzZTY0Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSF8yNTZfQklUX0I2NCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBnaWZ0IGNhcmQga2V5XCIpXG5cdFx0fVxuXG5cdFx0Y29uc3QgaWRQYXJ0ID0gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0RXh0VG9CYXNlNjQoaWQpKVxuXHRcdGNvbnN0IGtleVBhcnQgPSBiYXNlNjRUb0Jhc2U2NFVybChrZXlCYXNlNjQpXG5cdFx0cmV0dXJuIGlkUGFydCArIGtleVBhcnRcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQXlCQSxNQUFNLFlBQVksaUJBQWlCO0FBQ25DLE1BQU0seUJBQXlCO0FBQy9CLE1BQU0seUJBQXlCO0lBRWxCLGlCQUFOLE1BQXFCO0NB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